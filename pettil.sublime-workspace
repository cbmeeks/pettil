{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "; pettil-core.a65\n#echo .       pettil-core.a65\n#echo .       PETTIL - Personal Electronics Transactor\n#echo .                Threaded Interpretive Language\n#echo .\n; PETTIL core dictionary\n\n#include \"options.def\"\n#include \"inc/cbm.def\"\n#include \"inc/pettil.def\"\n\n;==============================================================\n;====                     BASIC bootstrap                  ====\n#define basic $0401\n*=basic-2\n#print basic\n;--------------------------------------------------------------\n#if 0\nname=BASIC2PETTIL\ntags=system,nosymbol\n! BASIC bootstrap `$0401`\n\nPETTIL loads as a BASIC program consisting of the line,\n\n`10 SYS1037`\n\nPETTIL is designed with the idea of having a clear separation between\n`pettil-core` (which is this file) and any application code running\non top of core.\n\nThe bonus of doing this is to release about 10K of RAM when `pettil-studio`\nand the symbol table are not resident.  PETTIL Studio behaves like any other\napplications coded to run on top of `pettil-core`.\n#endif\nbasic2pettil\n    .word basic                 ; PRG file load address `$0401`\n    .word basend\n    .word 10\n    .byt $9E                    ; SYS token\n    .asc \"1037\",0               ; restart #1 (of 3) `liftoff`\nbasend\n    .word 0\n\n;--------------------------------------------------------------\n#if 0\nname=RESTART\nstack=( -- )\ntags=system,startup,default\nPerforms the `startup` action.  Usually results in a `warm` boot,\nwhen reentering PETTIL from BASIC.\n\nDuring startup, `restart` executes four times\n1. when called from BASIC to `liftoff`\n2. to start the upper dictionary\n3. at the end of `cold`\n4. finally, at the end of `mackinac` to get to the first `warm` boot\n\n\n\n```\n: restart   ( -- )\n    startup @  execute ;\n```\n#endif\nrestart\n    jmp (userstartup)\n\n; check for build at proper point in memory\n#if (* <> $0410)\n#echo PETTIL Build Error - Program counter is not at $0410!\n#echo You moved something, didn't you?  PETTIL expected BASIC\n#echo to transfer control here to kick things off.  This is a problem.\n#endif (pettil address check)\n#print *\n;====                     BASIC bootstrap                  ====\n;==============================================================\n\n;--------------------------------------------------------------\n#if 0\nname=ZPBUF\ntags=system,nosymbol,startup,self-modifying\n!Zero page buffer and NEXT routine `$0410`\n\n|ROM_PET_4|$00-$8C|\n|ROM_PET_UPGRADE|$00-$8C|\n|ROM_PET_ORIGINAL||\n|ROM_VIC20||\n|ROM_C64|$02-$8C|\n\nzero page swap region, first 141 bytes\n\n`aloha` swaps this region with a little over half of zero page when\ncoming from or going back to BASIC\n\n* Sweet16 stack pointer initialized to `$0100` here\n* copy of NEXT routine is here\n#endif\nzpbuf\n;$0000\n    .word $0000,$1001,$2002,$3003   ; overlapping\n    .word $4004,$5005,$6006,$7007   ; PETTIL registers\n    .word $8008,$9009,$A00A,$B00B   ; and\n    .word $0100,$D00D,$E00E,$F00F   ; Sweet16 registers ()\n;$0020\n    .dsb bos,$aa                ; low stack\n;$0050\n    .dsb bos,$bb                ; high stack\n;$0080\n    .word 0, 0, uarea           ; zi, zlim, up\n;\n;       NEXT\n;               +IP\n;               [IP] -> PC\n;\n; PETTIL's minimalist NEXT.\n;\n; PETTIL's NEXT routine puts responsibility for page alignment on the compiler,\n; greatly improving execution speed vs. a more conventional indirect-threaded\n; design.\n;\n;$0086\nzpnext\n    inc ip              ;[5]    ; (next)\n    inc ip              ;[5]    ; (next1)\n;ip = *+1\n    jmp ($cafe)         ;[5]    ; (nexto)\n\n                        ;[15]   ; clock cycles total!!!\n;$008D TIME                     ; end of zero page buffer, Jiffy clock is here\n\n;==============================================================\n; powers of 2 in a lookup table\npower2\n    .byt $80,$40,$20,$10,$08,$04,$02,$01\n\n;--------------------------------------------------------------\n#if 0\nname=PLUGH\ntags=nosymbol\nAn isolated RTS instruction, used only as a VICE xpet debugger breakpoint,\nset in the `pettil.dbg` config file. [[XYZZY]] is the high-level Forth\nvariant of this.\n\n```\n    .byt ld | N0\n    .byt std | N2\n    .byt ext                    ; invoking VICE debugger from Sweet16\n    .word plugh\n    .byt ld | N3\n    .byt nxt\n\n    jsr something\n    jsr somethingelse\n    sta anyplace\n    jsr plugh                   ; invoking VICE debugger from 6502 assembler\n    ldx anyplace\n```\n#endif\nplugh\n    rts\n;   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .\n; .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .\n\n\n;==============================================================\n;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====\n;\n; Before this point there should be exactly 156($9C) bytes of code\n; and data, beginning at $0401 (BASIC), with the last byte at $04A5.\n; This is where `pettil-core` page-aligns Sweet-16.\n; <$0401> | BASIC | $9C bytes of padding |\n; <$04A6> | Sweet16 prequel |\n; <$0500> | Sweet16 opcode handler page |\n; <$0600> | Sweet16 sequel |\n; <$0660> | User variables init/storage |\n; check for build at proper point in memory\n#if (* <> $04A6)\n#echo PETTIL Build Error - Program counter is not at $04A6!\n#echo You moved something, didn't you?  Sweet16 expected to\n#echo load at $04A6 (1190).  This is a problem.\n#echo .       program counter is now:\n#print *\n#endif\n;\n;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====\n;==============================================================\n#include \"inc/sweet16.def\"\n#include \"sweet16.a65\"\n\n;--------------------------------------------------------------\n#if 0\nname=USERAREA\nstack=( -- )\ntags=system,uservar,nosymbol\n!User Area\nInitialization values & storage for User Variables\n\n#endif\nuserarea\n; ---- initialization values per each `cold`\nuser0base       .word 10\nuser0filename   .word currname  ;1 counted string, default \"PETTILPACKETS\"\nuser0sanum      .word 0         ;2 default secondary address is 0, (PRG file)\nuser0drvnum     .word 1         ;3 default drive (datasette #1),\n\n; ---- UP points to here, all live user variables\nuarea\n; ---- not re-initialized or initialized another way\nusermemsiz      .word 0         ; 0 here means use BASIC MEMTOP($34)\nusersp0         .word bos+1     ; `abort` does `sp!`\nuserrp0         .word $01FE     ; `quit` does `rp!`\nuserirqtoggle   .word 0\nuserbrktoggle   .word SW16^TIMBRK\nuserstartup     .word liftoff\nuserwarning     .word _doterr   ; `studio` replaces this with `error.msg`\nuserdp          .word there\nuserfence       .word fencepost\nusersymtab      .word 0\n\nucore\n    .dsb uarea-userarea+60,$cc  ; predefined values plus 60 bytes\n\n; ---- re-initialized by `cold`\nuserbase        = ucore+0\nuserfilename    = ucore+2\nusersanum       = ucore+4\nuserdrvnum      = ucore+6\n\nustart = ucore+8\nuservmbuf       = ustart+0\nusernumblk      = ustart+2\nuserscr         = ustart+4\nuserblk         = ustart+6      ;1 `refill?` needs these four in #userorder\nuserin          = ustart+8      ;2                                         8-bit\nuserspan        = ustart+10     ;3                                         8-bit\nusernumout      = ustart+12     ;4/ CR relies on #LINE being\nusernumline     = ustart+14     ;5\\ adjacent to #OUT in uarea\nuserediting     = ustart+16     ; `pettil-studio` flag, indicates edit mode\nuserdpl         = ustart+18     ;                                          8-bit\nuserhld         = ustart+20     ;\nuserscrpkt      = ustart+22     ; ~wut? eliminate\nuendcore = ustart+24            ; mark our place for TDICT uservar base\n\n;--------------------------------------------------------------\n#if 0\nname=ZPMODE\nstack=( -- )\ntags=system,uservar,nosymbol,data\n!User Area\n\nThis one's like a meta-User variable, in that it has to function properly\neven when PETTIL is switched out (reasons: BASIC; TIM monitor; cassette I/O)\n\nIt's only one byte, which makes it a convenient thing to move around to\nword-align something like `userarea`\n\nA byte used as a semaphore by `aloha` to test/indicate whether BASIC (0)\nor PETTIL (1) occupies (a bit more than half of) zero page\n\n#endif\nzpmode\n    .byt 0\n\n;==============================================================\n#if 0\nname=COREBASE\ntags=nosymbol\nWhen changing these files, also modify `xap.rb`\n\n#endif\ncorebase\n#print *\n#include \"core-locals.a65\"\n#print *\n#include \"core-user.a65\"\n#print *\n#include \"core-nucleus.a65\"\n#print *\n#include \"core-extra.a65\"\n#print *\n#include \"core-inner.a65\"\n#print *\n#include \"core-double.a65\"\n#print *\n#include \"core-vm.a65\"\n#print *\n#include \"core-io.a65\"\n#print *\n\n;lower location for `fencepost` for turnkey apps (without `cold`)\n;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n;==============================================================\n; If your app will never `restart` again, it would be okay to\n; move FENCE to ` ' restart ` before invoking `restart`\n; * No in and out of BASIC/TIM\n; * tape I/O will still work\n; * no restart with COLD\n; * no editor (needs IRQ switching)\n;==============================================================\n\n;--------------------------------------------------------------\n#if 0\nname=AUFWIEDERSEHEN\ntags=startup,nosymbol\nExit Forth, restoring BASIC z.p.\n#endif\naufwiedersehen\n    lsr zpmode                  ; lights off!\n    beq aloha2                  ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=ALOHARD\ntags=startup,nosymbol\n`aloha` invoked by `cold` and `liftoff` also closes files\n#endif\nalohard\n    cld                         ; clear decimal mode\n    jsr CLRCHN                  ; restore default I/O channels\n    jsr CLALL                   ; close all open files\n\n;--------------------------------------------------------------\n#if 0\nname=ALOHA\ntags=startup,nosymbol\nFlips back and forth between BASIC and PETTIL modes.\n\n* Swap part of zero page with zpbuf\n* required by tape I/O\n\n* used to access TIM monitor\n* toggle Sweet16 BRK vector at ($0090)\n* `pettil-studio` does not use the IRQ vector except in the Editor\n* performs swapzp, toggleirq and togglesw16\n#endif\naloha\n    lsr zpmode                  ; check lights\n    inc zpmode                  ; lights on!\n    bcs aloha4                  ; were the lights already on?\naloha2                          ; entry point for tape I/O\n    jsr toggleirqbrk\n    stx z                       ; preserve Forth data stack pointer\n    ldx #TIME                   ; loop from ACC $00 up to the jiffy clock $8D\naloha3\n    lda <(ACC-1),x\n    ldy zpbuf-1,x\n    sty <(ACC-1),x\n    sta zpbuf-1,x\n    dex\n    bne aloha3\n    ldx z                       ; restore Forth data stack pointer\naloha4\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=COLD\nstack=( -- )\ntags=system,startup\nCOLD starts up the system and when invoked as a command will attempt\nto restore the system to as pristine a condition as possible.\n#endif\n#include \"align.i65\"\n_cold\n    jsr alohard\n    ldx usersp0\n    dex\n#include \"align.i65\"\n    jsr toforth                 ; transition from 6502 Assembly to Forth\n#include \"pass.i65\"\n    .word plits\n    .byt 5\n    .word ustart                ; erase\n    .word uendcore-ustart\n    .word userarea              ; cmove\n    .word ucore\n    .word uarea-userarea\n#include \"page.i65\"\n    .word cmove\n#include \"page.i65\"\n    .word _erase\n#include \"page.i65\"\ncoldpatch\n    .word next                  ; later transformed into `rehash`\n#include \"pass.i65\"\n    .word restart               ; restart #2 (of 3) `studio`\n\n;upper location for `fencepost` for development (includes `cold`)\n;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n;==============================================================\n; move the `fencepost` label to either lower or upper location\n;==============================================================\n;--------------------------------------------------------------\n#if 0\nname=FENCEPOST\ntags=system,startup,nosymbol\nThis is where [[FENCE]] points, and also [[DP]] after initial\nbuild of the symbol table.  First-run startup code beyond\nthis point (`fencepost` to `there`) may not have symbol table\nentries pointing to it.\n#endif\nfencepost\n; beyond lies the Abyss...\n;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n;==============================================================\n;==============================================================\n;===-===-===-===-===-===-===-===-===-===-===-===-===-===-===-==\n;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==\n;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n;=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-\n;---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=--\n;--------------------------------------------------------------\n;---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.--\n;--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--\n;-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n;..............................................................\n;... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ..\n;.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..\n;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n; .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .\n;   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .\n;.     .     .     .     .     .     .     .     .     .     .\n;   .        .        .        .        .        .        .\n;   .     .        .             .              .     .\n;                        .             .                   .\n;         .     .              .            .\n;\n;\n;\n;\n;\n;\n\n;--------------------------------------------------------------\n#if 0\nname=LIFTOFF\ntags=system,startup,throwaway,nosymbol\nA primitive relocator to move already-linked code to upper memory\nGets us from `pettil-core` to module LAUNCH\n\n* CMOVE transient dictionary to upper memory\n* EXECUTE first word in transient dictionary\n\nSetting the `size` of the transient dictionary to 0 will prevent\nmoving anything; control still transfers to `loadaddr+2`.\n\n```\n: liftoff   ( -- )\n    ['] there @+ tuck over @ 2+ cmove 2+ execute\n```\n#endif\n#include \"align.i65\"\nliftoff\n    lda usermemsiz\n    ldy usermemsiz+1\n    bne fs01                    ; something there already? leave it alone\n    lda MEMSIZ                  ; nothing there?  get it from BASIC MEMSIZ($34)\n    ldy MEMSIZ+1\nfs01\n    sta usermemsiz\n    sty usermemsiz+1\n    jsr alohard\n    ldx usersp0\n    dex\n#include \"align.i65\"\n    jsr toforth                 ; transition from 6502 Assembly to Forth\n#include \"pass.i65\"\n    .word plit\n    .word there\n#include \"page.i65\"\n    .word fetchplus             ; link to upper dictionary\n#include \"page.i65\"\n    .word tuck\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word twoplus\n#include \"page.i65\"\n    .word cmove                 ; but first, make an upper dictionary\n#include \"page.i65\"\n    .word twoplus\n#include \"page.i65\"\n    .word startup\n#include \"page.i65\"\n    .word store                 ; `studio` -> `startup` for 2nd `restart`\n#include \"page.i65\"\n    .word _cold\n\n;--------------------------------------------------------------\n#if 0\nname=SPLASHIRQ\nstack=( -- )\ntags=system,startup,nosymbol\nsplash screen irq handler\nchoose a random location\ncheck character on either page\n    4D?  replace it with 4E\n    4E?  replace it with 4D\n    else? leave it alone\n\n#endif\n#include \"align.i65\"\nsplashirq\n    dec sploosh\n    bne splashirq03\n    lda #80\n    sta sploosh                 ; jiffies between letters\n    lda #1\n    sta splotch+3               ; set the mainline `doletter` flag\n\nsplashirq03\n    lda splushh+3\n    sta splush\nsplashirq01\n    jsr randu\n    tax\n    lda VIDRAM,x\n    jsr splish\n    sta VIDRAM,x\n    lda VIDRAM+$100,x\n    jsr splish\n    sta VIDRAM+$100,x\n    dec splush\n    bne splashirq01\n;    inc $83E7\n    jmp MAINIRQ\n\nsplish\n    tay\n    eor #$4C                    ; swap \\ <--> / else leave it alone\n    and #$7C\n    bne splish01\n    tya\n    eor #3\n    tay\nsplish01\n    tya\n    rts\n\nsplush\n    .byt 1\nsplushh\n    jsr docreate\n    .byt 15\nsploosh\n    .byt 120\nsplotch                         ; flag for mainline routine\n    jsr docreate\n    .byt 0\nsplash\n    .byt 0\norigr11l\n    .byt 0\norigr11h\n    .byt 0\ncurrletter\n    jsr docreate\n    .word pettillogo\n\n;--------------------------------------------------------------\n#if 0\nname=?TRIGGER\nstack=( -- )\ntags=system,startup,nosymbol\n\n```\n: qtrigger   ( -- )\n    splotch c@\n    if\n        splotch coff\n    then\n;\n```\n#endif\n#include \"align.i65\"\n_qtrigger\n    jsr enter\n#include \"page.i65\"\n    .word splotch\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(qtrigger01-*+1)\n#include \"page.i65\"\n    .word splotch\n#include \"page.i65\"\n    .word coff\n;#include \"pass.i65\"\n;    .word plit\n;    .word splashirq+1\n;#include \"page.i65\"\n;    .word oneminusstore\n#include \"page.i65\"\n    .word _doletter\n#include \"pass.i65\"\nqtrigger01\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=BARF\nstack=( -- false )\ntags=system,startup,nosymbol\nprimitive to fill the screen with a rapidly changing diagonal\nmaze effect\n\n#endif\nbarf\n    stx z\n    lda #$93\n    jsr $FFD2\n    ldx #0\n    lda #$4d\nbarf01\n    sta $8000,x\n    sta $8100,x\n    sta $8200,x\n    sta $8300,x\n    dex\n    bne barf01\nbarf02\n    jsr randu\n    tax\n    lda VIDRAM,x\n    jsr splish\n    sta VIDRAM,x\n    lda VIDRAM+$100,x\n    jsr splish\n    sta VIDRAM+$100,x\n    lda VIDRAM+$200,x\n    jsr splish\n    sta VIDRAM+$200,x\n    lda VIDRAM+$300,x\n    jsr splish\n    sta VIDRAM+$300,x\n    dec barfctr\n    bne barf02\n    dec barfctr+1\n    bne barf02\n    ldx z\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=BARF.CTR\nstack=( -- false )\ntags=system,startup,nosymbol\ncounter used by `barf`, number of times to twiddle the maze\n#endif\nbarfctr\n    .word 5000\n\n;--------------------------------------------------------------\n#if 0\nname=FLIPPER\nstack=( -- false )\ntags=system,startup,nosymbol\n\n```\n: flipper  2-\n    9 40* vidram dup +under\n    do\n        i c@ c>s 0<\n        if $66 i c! then\n    loop ;\n```\n#endif\n#include \"align.i65\"\n_flipper\n    jsr enter\n#include \"page.i65\"\n    .word vidram\n#include \"page.i65\"\n    .word nine\n#include \"page.i65\"\n    .word fortytimes\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word vidram\n#include \"pass.i65\"\n    .word pdo\n    .byt <(flipper03-*+1)\n#include \"page.i65\"\nflipper01\n    .word i\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word duptor\n#include \"pass.i65\"\n    .word clit\n    .byt $E9\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word ctos\n#include \"page.i65\"\n    .word zlt\n#include \"page.i65\"\n    .word xor\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(flipper02-*+1)\n#include \"pass.i65\"\n    .word clit\n;    .byt $66  ; shift-&\n;    .byt $BA  ; rvs-:\n    .byt $A0\n#include \"page.i65\"\n    .word i\n#include \"page.i65\"\n    .word cstore\n#include \"pass.i65\"\nflipper02\n    .word ploop\n    .byt <(flipper01-*+1)\n#include \"pass.i65\"\nflipper03\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=DOLETTER\nstack=( -- false )\ntags=system,startup,nosymbol\ninstalled by `splashirq` to get in there and display something during FORGET\n\nReplaces either (forget).pass1 or (forget).pass2 for one call\nreturns \"false\" to iterate t\nsplash screen irq handler\nchoose a random location\ncheck character on either page\n    4D?  replace it with 4E\n    4E?  replace it with 4D\n    else? leave it alone\n\n```\n: doletter\n    'origr11 @ >r11 drop\n    'currletter dup @ @+ dup\n    ?: $. drop\n    swap ! ;\n\n: doletter\n    'currletter dup @ @+ ?dup\n    if\n        $. over !\n    then  drop ;\n```\n#endif\n#include \"align.i65\"\n_doletter\n    jsr enter\n;#include \"pass.i65\"\n;    .word plit\n;    .word $83E7\n;#include \"page.i65\"\n;    .word oneplusstore\n#include \"page.i65\"\n    .word currletter\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word fetchplus\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word currletter\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word execute\n#include \"pass.i65\"\n    .word exit\n\n#include \"page.i65\"\n    .word splushh\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word clit\n    .byt 5\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word eq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(doletter01x-*+1)\n#include \"page.i65\"\ndoletter01x\n    .word twominus\n#include \"page.i65\"\n    .word one\n#include \"page.i65\"\n    .word max\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word cstore\ndoletter02\n    .word drop\n#include \"pass.i65\"\n    .word exit\n\npettillogo\n    .word pl0,pl1,pl2,pl3,pl4,pl5,pl6,pl7,pl8,pl9,pl10\n\n#include \"align.i65\"\npl0\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl0x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc CRSRDOWN,RVSON,\"SORTING SYMBOLS... 30 SECONDS\",RVSOFF\npl0x\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl1\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl1x-*-1)\n    .asc    HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc    CRSRDOWN,CRSRDOWN,RVSON,$CE,RVSOFF,$E9,RVSON\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$CE,$CE\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$EB,$CE\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$CE,$CE\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$CE,$CE\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$CE,$CE\n    .asc    CRSRUP,CRSRLEFT,CRSRLEFT,$E9,$F2,$CE,$CE,$CE,$DF\n    .asc    CRSRDOWN,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,$CE,$CE,$CE,$CE\n    .asc    CRSRDOWN,CRSRLEFT,CRSRLEFT,$EB,$CE\n    .asc    CRSRDOWN,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,$CE,$CE,$CE,RVSOFF,$E9\npl1x\n#include \"page.i65\"\n    .word one\n#include \"page.i65\"\n    .word splushh\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n\n#include \"align.i65\"\npl2\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl2x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc RVSON,$E9,$CE,$CE,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$F1,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $EB,$CE,$CE,$CE,RVSOFF,$E9,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$CE,$CE,$F2,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F1,$CE,$CE,$CE,RVSOFF,$E9,RVSON\npl2x\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl3\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl3x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc RVSON,$E9,$F2,$CE,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$CE,$CE,$F1,RVSOFF,$E9,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F3,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,RVSOFF,$E9,RVSON\npl3x\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl4\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl4x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,RVSOFF,$D6,RVSON,CR,CR,CR,CR,CR,CR,CR,CR\n    .asc RVSON,\"PERSONAL ELECTRONIC TRANSACTOR\"\npl4x\n#include \"page.i65\"\n    .word nine\n#include \"page.i65\"\n    .word splushh\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl5\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl5x-*-1)\n    .asc CR,RVSON,\"THREADED INTERPRETIVE LANGUAGE\",CR\npl5x\n#include \"page.i65\"\n    .word _flipper\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl6\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl6x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc RVSON,$E9,$CE,$CE,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F1,$CE,$CE,$CE,RVSOFF,$E9,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F3,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,RVSOFF,$E9,RVSON\npl6x\n#include \"page.i65\"\n    .word one\n#include \"page.i65\"\n    .word splushh\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl7\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl7x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc RVSON,$E9,$CE,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$CE,$F1,RVSOFF,$E9,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc RVSOFF,$AA,RVSON,$CE,RVSOFF,$B4,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc RVSOFF,$AA,RVSON,$CE,RVSOFF,$B4,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc RVSOFF,$AA,RVSON,$CE,RVSOFF,$B4,RVSON,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $E9,$CE,$CE,$CE,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F1,$CE,$CE,RVSOFF,$E9,RVSON\npl7x\n#include \"pass.i65\"\n    .word exit\n\n\n#include \"align.i65\"\npl8\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (pl8x-*-1)\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT,CRSRRIGHT\n    .asc RVSON,$E9,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$F3,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $EB,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$CE,$CE,$F2,$CE,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRDOWN\n    .asc $CE,$CE,$CE,$CE,$CE,RVSOFF,$E9\npl8x\n#include \"pass.i65\"\n    .word exit\n\n#include \"align.i65\"\npl9\n    jsr enter\n#include \"page.i65\"\n    .word _flipper\n#include \"page.i65\"\n    .word exit\n\n#include \"align.i65\"\npl10\n    jsr enter\n#include \"pass.i65\"\n    .word plit\n    .word pettillogo+2*10\n#include \"pass.i65\"\n    .word currletter\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SPLASH\nstack=( -- )\ntags=system,startup,nosymbol\nSet up the loader splash screen entertainment\n#endif\n#include \"align.i65\"\n_splash\n    jsr enter\n#include \"page.i65\"\n    .word barf\n#include \"pass.i65\"\n    .word plits\n    .byt 3\n    .word splashirq\n    .word VIDRAM+11*40\n    .word 14*40\n#include \"page.i65\"\n    .word _blank\n#include \"page.i65\"\n    .word _banner\n#include \"page.i65\"\n    .word irqstore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=BANNER\nstack=( -- )\ntags=system,startup,nosymbol\nsplash screen irq handler\nchoose a random location\ncheck character on either page\n    4D?  replace it with 4E\n    4E?  replace it with 4D\n    else? leave it alone\n\n#endif\n#include \"align.i65\"\n_banner\n    jsr enter\n#include \"pass.i65\"\n    .word _pdq\n    .byt (setupmsg01-*-1)\n    .asc    HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc    CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc    RVSON,\"FORTH FOR THE COMMODORE PET 2001!\",CR\n    .asc    \"HTTP:\",\"/\",\"/GITHUB.COM/CHITSELB/PETTIL\",CR,CR,CR,CR\nsetupmsg01\n#include \"pass.i65\"\n    .word _pdq\n    .byt (bannermsg01-*-1)      ; length of bannermsg\n    .asc    \"VERSION: 2017-11-05\",CR\n    .asc    \"2017 WHEN I PROGRAM, I LIKE TO LISTEN\",CR\n    .asc    \"     TO WCBN-FM, RADIO FREE ANN ARBOR\",CR\n            ;123456789.123456789.123456789.123456789.\nbannermsg01\n#include \"pass.i65\"\n    .word exit\n\nthere\n#print *\n#echo . you are there\n\n; concatenate pettil-studio (or some other) object module here\n; first word is starting address for indirect `jmp (there)`\n;==============================================================\n;   .word load address          ; e.g. `$68FE`\n;$<68FE>\n;   .word size                  ; there+2 contains (there+4)\n;<$6900>\n;                               ; <-- cfa of module initialization\n",
			"file": "core/src/pettil-core.a65",
			"file_size": 29465,
			"file_write_time": 131544269393999332,
			"settings":
			{
				"buffer_size": 29465,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; pettil-studio.a65\n#echo .       pettil-studio.a65\n#echo .       PETTIL Developer Studio (intepreter, compiler, editor, assembler)\n\n#include \"../../core/src/options.def\"\n#include \"../../core/src/inc/sweet16.def\"\n#include \"../../core/src/inc/cbm.def\"\n#include \"../../tmp/pettil-core.def\"\n#include \"inc/pettil-studio.def\"\n\n; see core/src/options.def\n\nhitop=VIDRAM-$1600              ; <--- #ResizeTdict here, also lower down\n\n    .word hitop-2               ; load address\n    .word tdictend-hitop        ; size of the transient dictionary in bytes\n                                ; startup CFA (LIFTOFF) from `pettil-core` COLD\n*=hitop\n#echo Transient Dictionary\n#print *\n\n;--------------------------------------------------------------\n#if 0\nname=STUDIO\nstack=( -- )\ntags=system,startup,throwaway,nosymbol\nFirst time startup code\n\n```\n<0400> core\n<1B68> fence\n{ disappearing banner startup code }\n<1F6F> there\nhitop-2\ntdict.size\n<\n{ deadbeef }\n<56FE> vmbuf\n\n<00> zeropage\n<01> stack\n<0200> buffers\n<0400> core\n<1B80> here\n{ disappearing banner startup code }\n{ deadbeef }\n<56FE> vmbuf\n<5700> blkbuf\n<5B00> symtab\n<6900> init & deadbeef\n<6A00> studio\n<8000> VIDRAM\n\n: studio\n    ['] there+2 @+ + 32 - symtab !\n    chilly cmove\n    .\" banner message\"\n    cold\n```\n#endif\n_studio\n    jsr enter\n#include \"pass.i65\"\n    .word plit\n    .word there+2\n#include \"page.i65\"\n    .word fetchplus\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word symtab                ; points to unindexed symbol list\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _splash\n#include \"pass.i65\"\n    .word plits\n    .byt 9\n    .word _warm                 ; !\n    .word userstartup\n    .word _mackinac             ; !\n    .word userwarning\n    .word _rehash               ; !\n    .word coldpatch\n    .word user0tdict            ; cmove\n    .word usertdict\n    .word utdict-user0tdict\n#include \"page.i65\"\n    .word cmove                 ; reset `tdict` `tdp` `#voc`\n#include \"page.i65\"\n    .word store                 ; patch `cold` to invoke `rehash`\n#include \"page.i65\"\n    .word store                 ; set `warning` to `mackinac`\n#include \"page.i65\"\n    .word store                 ; set `startup` to `warm`\n#include \"pass.i65\"\n    .word restart               ; and bounce it (#3) (fake)`warm`\n\n;--------------------------------------------------------------\n#if 0\nname=MACKINAC\nstack=( -- )\ntags=system,startup,nosymbol\nfinal bridge between lower `core` and upper `tdict` dictionaries\n\n6976\n5C20\nd56\n\n41CF\n347A\nd55\n\ngross trick: the error path out of `warm` gets us here.  Once here,\nfix the error handler (`warning`) and `warm` now kicks out to `abort`\n\nother gross trick:  `(forget)`\n#endif\n#include \"align.i65\"\n_mackinac\n    jsr enter\n#include \"page.i65\"\n    .word drop                  ; `warm` sent us an error #\n#include \"page.i65\"\n    .word here                  ; `here` now points to `there`\n#include \"page.i65\"\n    .word _pforget\n#include \"pass.i65\"\n    .word plits\n    .byt 9\n    .word userdp\n    .word userfence             ; @ swap !\n    .word pforgetpass2\n    .word pfpatchb              ; !\n    .word pforgetpass1\n    .word pfpatcha              ; !\n    .word _errormsg\n    .word userwarning           ; !\n    .word MAINIRQ               ; irq!\n#include \"page.i65\"\n    .word irqstore              ; restore default IRQ handler\n#include \"page.i65\"\n    .word store                 ; set `warning` to `error.msg`\n#include \"page.i65\"\n    .word store                 ; patch `(forget)` pass1\n#include \"page.i65\"\n    .word store                 ; patch `(forget)` pass2\n#include \"page.i65\"\n    .word fetch                 ; fix DP to reclaim startup code area\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _deadbeef\n#include \"pass.i65\"\n    .word restart               ; restart #4 -> `warm`\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET).PASS\nstack=( -- )\ntags=system,startup,nosymbol\n\n```\n    .word splotch\n    .word cfetch\n    .word qbranch\n    .byt <(pfpass01-*+1)\n    .word splotch\n    .word coff\n    .word _doletter\n```\n#endif\n#include \"align.i65\"\n_pfpass\n    jsr enter\n#include \"page.i65\"\n    .word _qtrigger\n#include \"pass.i65\"\npfpass01\n    .word zpfrom\n    .byt ACC+2*N4\n#include \"pass.i65\"\n    .word pquerycolon\n    .word pforgetpass1\n    .word pforgetpass2\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=DEADBEEF\nstack=( -- )\ntags=startup,nosymbol\nFill available memory with the 32-bit value `$DEADBEEF` . Discarded after\nrunning once at startup.  Used to assist in debugging.\n\n#endif\n#include \"align.i65\"\n_deadbeef\n    jsr enter\n;#include \"pass.i65\"\n;    .word clit\n;    .byt <(next-1)\n;#include \"page.i65\"\n;    .word tor\n#include \"pass.i65\"\n    .word _pdq\n    .byt deadbeef00-*-1\n    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n    .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRLEFT,CRSRLEFT,CRSRLEFT\n    .asc CRSRLEFT,CRSRLEFT,RVSON,\"DEAD\",CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT\ndeadbeef00\n#include \"page.i65\"\n    .word symtab\n#include \"page.i65\"\n    .word fetch\n#include \"pass.i65\"\ndeadbeef01\n    .word dlit\n    .word $dead,$beef\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word four\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word lt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(deadbeef02-*+1)\n#include \"page.i65\"\n    .word dashrot\n#include \"page.i65\"\n    .word third\n#include \"page.i65\"\n    .word twostore\n#include \"pass.i65\"\n    .word branch\n    .byt <(deadbeef01-*+1)\n#include \"page.i65\"\ndeadbeef02\n    .word drop\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word twostore\n#include \"pass.i65\"\n    .word _pdq\n    .byt deadbeef03-*-1\n    .asc    RVSOFF,\"BEEF\",CR,CR,CR,CR\ndeadbeef03\n#include \"pass.i65\"\n    .word exit\n\n#print *\n    .dsb hitop+$100-*,$EA       ; #ResizeTdict\n#print *\n\n;\n;\n;\n;\n;\n;\n;         .     .              .            .\n;                        .             .                   .\n;   .     .        .             .              .     .\n;   .        .        .        .        .        .        .\n;.     .     .     .     .     .     .     .     .     .     .\n;   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .\n; .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .\n;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n;.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..\n;... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ..\n;..............................................................\n;-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n;--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--\n;---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.--\n;--------------------------------------------------------------\n;---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=--\n;=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-\n;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==\n;===-===-===-===-===-===-===-===-===-===-===-===-===-===-===-==\n;==============================================================\n;==============================================================\n;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n;==============================================================\n; code above this point is void memory after startup\n#print *\n\n#if 0\nname=TDICTBASE\nstack=( -- )\ntags=nosymbol\nBottom edge of PETTIL Studio.  [[TDICT]] contains this address.\n#endif\ntdictbase\n\n;--------------------------------------------------------------\nuser0tdict      .word tdictbase\nuser0tdp        .word tdictend\nuser0numvoc     .word 2         ; `editor` & `assembler`\nutdict\n\n; ---- copy from initialization values\nusertdict       = uendcore+0    ;1\nusertdp         = uendcore+2    ;2\nusernumvoc      = uendcore+4    ;3\n\n; ---- WARM will set to 0\nusercsp         = uendcore+6\nusercurrent     = uendcore+8\nuserredefined   = uendcore+10   ; ~wut? eliminate\nusernewest      = uendcore+12\nuserstate       = uendcore+14\nuservocabs      = uendcore+16   ; 10 bytes\n\n; ---- RESTART does not mess with these\nusersymnew      = uendcore+26   ;1  keep.\nusersymtail     = uendcore+28   ;2  adjacent. [[SYMTAIL!]]\nuserbloom       = uendcore+30   ; 8 bytes (64 bits)\nuserpassbits    = uendcore+38   ; 4 bytes (32 bits)\n                                ;+42\nutend = uendcore+42\n\n;--------------------------------------------------------------\n#if 0\nname=WARM\nstack=( -- )\ntags=startup\n\n#endif\n#include \"align.i65\"\n_warm\n    jsr enter\n#include \"pass.i65\"\n    .word plits\n    .byt 5\n    .word usercsp               ; erase\n    .word usersymnew-usercsp\n    .word user0tdict            ; cmove\n    .word usertdict\n    .word utdict-tdictbase\n#include \"page.i65\"\n    .word cmove                 ; reset `tdict` `tdp` `#voc`\n#include \"page.i65\"\n    .word _erase                ; reset\n#include \"page.i65\"             ; so it only happens one time, at startup.\n    .word zero\n#include \"pass.i65\"\n    .word fail\n\n;==============================================================\n#include \"pettil-user.a65\"\n#print *\n#include \"pettil-dictionary.a65\"\n#print *\n#include \"pettil-interpreter.a65\"\n#print *\n#include \"pettil-compiler.a65\"\n#print *\n#include \"pettil-utils.a65\"\n#print *\n#include \"pettil-editor.a65\"\n#print *\n#include \"pettil-assembler.a65\"\n#print *\n\n;--------------------------------------------------------------\n#if 0\nname=TDICTEND\nstack=( -- )\ntags=nosymbol,nosymbol\nThis label marks the upper boundary of the transient dictionary ([[TDP]])\n#endif\ntdictend\n;==============================================================\n\n",
			"file": "studio/src/pettil-studio.a65",
			"file_size": 9978,
			"file_write_time": 131545604694900368,
			"settings":
			{
				"buffer_size": 9978,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; Set up some breakpoints to enable/disable.\n; `make pettil` appends this file to `./tmp/pettil.mon`\n; `make launch` executes this at startup with `xpet -moncommands pettil.mon`\n;\n; `enable` or `en` turns them all on\n; `disable` or `dis` turns them all off\n; `en 1;en 2;en 3` turns on Sweet16\nbk .disp1  ;dis 1\nbk .disp2  ;dis 2\nbk .disp3  ;dis 3\nbk .nexto  ;dis 4\nbk .exit   ;dis 5\nbk .restart;dis 6\nbk .plugh\nbk .xyzzy\n; this helps (sometimes, it's dicey) when stack sentinel value is overwritten\nwatch store 7f if a != 10\nwatch store 4f if a != 01\nbk ._interpret\n",
			"file": "pettil.dbg",
			"file_size": 566,
			"file_write_time": 131545692544930411,
			"settings":
			{
				"buffer_size": 566,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; pettil-dictionary.a65\n#echo .       pettil-dictionary.a65     Dictionary\n\n;--------------------------------------------------------------\n#if 0\nname=FORTH\nstack=( -- )\ntags=vocabulary,forth-83\nReset the vocabulary search order to just CORE.  Equivalent to\n`ONLY FORTH` in ANS Forth\n\n```\n: forth   ( -- )\n    vocabs coff ;\n```\n#endif\n#include \"align.i65\"\nforth\n    lda #0\n    sta uservocabs\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=DEFINITIONS\nstack=( -- )\ntags=forth-83\nSets the compilation vocabulary by copying the first vocabulary in\nthe [[VOCABS]] search order to [[CURRENT]].\n\n```\n: definitions   ( -- )\n    vocabs c@  current c! ;     \\ [13]\n```\n\nThis is the most bare-metal approach, fastest, [9] bytes. Also here is some\ncode golf notation.\n#endif\n#include \"align.i65\"\ndefinitions\n    lda uservocabs              ;[9]{4 {=26}}    [bytes]{clocks {=total}}\n    sta usercurrent             ;{4}\n    ;jsr plugh                  ;{*}     _closedefinition\n                                ; external code, unknown score\n    ;jsr slide                  ;{22}           ; external code, known score\n                                ;  code as a constant when comparing\n                                ;  different versions of the code.\n    jmp next                    ;{18}           ; Golfer gets tail code\n\n;--------------------------------------------------------------\n#if 0\nname=>SYMS\nstack=( -- nfa )\ntags=interpreter,ext,nosymbol\nReturns `nfa` of first symbol in the `symbol table`\n\nsymtab @+ drop bl +\n: symtab @ 34 + ;\n\n[14]\n_tosyms\n    jsr enter\n    .word symtab\n    .word fetch\n    .word clit\n    .byt 34\n    .word plus\n    .word exit\n[12]\ntosyms\n    brk\n    .byt push\n    .byt set | TOS\n    .word usersymtab\n    .byt ldd | N0\n    .byt set | TOS\n    .word 34\n    .byt add | TOS\n    .byt st | TOS\n    .byt nxt\n\n#endif\n#include \"align.i65\"\ntosyms\n    lda usersymtab\n    ldy usersymtab+1\n    clc\n    adc #34\n    bcc tosyms01\n    iny\ntosyms01\n    jmp pushya\n;[15]\n\n;--------------------------------------------------------------\n#if 0\nname=SYM.LEN\nstack=( -- len )\ntags=nfa,nosymbol\nReturn length information about the `nfa` in `n3`\n\n`visible length` means the length of the name when you type it.\nThe carry flag indicates whether a `vocabid` follows the `name`\n\nC = vocabid?\nA,N8L = visible length\nY = 0\n#endif\nsymlen\n    lda #>(pushya-1)\n    pha\n    lda #<(pushya-1)\n    pha\n;--------------------------------------------------------------\n#if 0\nname=SYMLENS\neffects=A:len;Y:0;C:vocab?\ntags=nfa,nosymbol\n\n#endif\nsymlens\n    ldy #0              ;{2 {=23}}\n    lda (ACC+2*N3),y    ;{5}\n    pha                 ;{3}    ; not using tay/tya preserves Y=0\n    asl                 ;{2}\n    asl                 ;{2}    ; Vocab bit to C flag\n    pla                 ;{4}\n    and #$1F            ;{2}    ; length\n    sta ACC+2*N8        ;{3}    ; N8L = visible length (omit vocab +1)\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=SYMCOPY\nstack=( -- )\ntags=ext,primitive,nfa,nosymbol\n\n* N3 (curr) symbol to N7 (targ) symbol\n* copy vocab byte\n* copy text\n* copy length/flags\n* does not move N7, does not move N3 either\n\n#endif\nsymcopy\n    jsr symlens\n    adc #0\n    tay\nsymcopy01\n    lda (ACC+2*N3),y\n    sta (ACC+2*N7),y\n    dey\n    bpl symcopy01\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=SYM+\nstack=( -- )\ntags=ext,primitive,nfa,nosymbol\n* move N3 to the next symbol\ncompiled with an inline value following the CFA\nto specify a constant per-symbol offset\n\ncodegolf=\n\n[24]\nsymplus\n    ldy #2\n    lda (ip),y\n    inc ip                      ; ~wut? dangerous? probably\n    pha\n    jsr symlens\n    pla                         ; + length/flags + cfa\n    adc ACC+2*N8\n    adc ACC+2*N3\n    sta ACC+2*N3\n    bcc symplus01\n    inc ACC+2*N3+1\nsymplus01\n    jmp next\n[28] played around with this approach, which works but [28] was bigger\n    stx z\n    ldx #ACC+2*N3\n    jsr ADD\n    jsr ST\n    ldx z\n[19]                            2017-09-17 chitselb *5* bytes\n\n```\n     3 sym+                     compiles to\n    .word symplus\n    .byt 3                      ; skip symbol + cfa word + flag/len byte\n\n    .word symplus\n    .byt 0                      ;skip just the symbol\n```\n\nsymplus\n    jsr symlens         ;{*}\n    ldy #2              ;{2}\n    adc (ip),y          ;{5}    ; + length/flags + cfa\n    adc ACC+2*N3        ;{3}\n    sta ACC+2*N3        ;{3}\n    bcc symplus02       ;{3}\n    inc ACC+2*N3+1\nsymplus02\n    ldy #2              ;{2}\n    jmp pad             ;{3 {=21}}\n\n#endif\nsymplus\n    ldy #2\n    lda (ip),y\n    jsr sympluss\n    lda #2\n    jmp pad\n\nsympluss\n    sta ACC\n    jsr symlens\n    adc ACC\n    adc ACC+2*N3\n    sta ACC+2*N3\n    bcc symplus01\n    inc ACC+2*N3+1\nsymplus01\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=SYM.COMP\ntags=nosymbol\nCompares two symbols at N3 and N4\n#endif\nsymcomps\n    jsr symlens\n    bne symcomp01\nsymcomp00\n    jmp true\nsymcomp01\n    tay\n    bcc symcomp03\n    iny\n    lda (ACC+2*N3),y\n    dey\n    eor ACC+2*N4                ; compare to context\n    beq symcomp03\nsymcomp02\n    jmp false\nsymcomp03\n    lda (ACC+2*N3),y\n    eor (ACC+2*N7),y\n    bne symcomp00\n    dey\n    bne symcomp01\n\n    lda (ACC+2*N3),y\n    bne symcomp01\n    dey\n    rts\n    eor (n),y\n    and #%11011111\n    bne strcomp02               ; length, vocab bit or smudge?\n    jsr symlens\n    adc #0\n    ;clc\n    tay\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=STRCOMP\ntags=nosymbol\nCompares two strings known to be the same length pointed to by\n`TOS` and `N0`.\n\n|<br><i>inputs</i>|<|\n|<b>TOS</b>|NFA|\n|<b>N0</b>|NFA being sought|\n|<b>Y</b>|length|\n|<br><i>returns</i>|<|\n|<b>TOS</b>|unchanged|\n|<b>N0</b>|unchanged|\n|^<b>Y</b>|index of mismatch<br><b>0</b> if success|\n|<b>Z</b>|strings match?|\n|<b>C</b>|unchanged|\n#endif\nstrcomp\n    lda (tos),y\n    eor (n),y\n    bne strcomp02\n    dey\n    bne strcomp\nstrcomp02\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=BLOOM#\nstack=( -- n )\ntags=ext,nosymbol\nAlways returns a value between 0 and 63, which is used as an index into a\n(hopefully) sparsely populated bit field\n\nthe sum of all the digits within the word\n(each digit is incremented before it is summed, so 0 --> +1, 9 --> +10\n\n\nThe dictionary Bloom filter tries to answer the question,\n'is this word a number or does it contain numbers?'\nreturning zero (no digits present) or the sum (mod64)\nof each digits in this word plus how many digits.  If\nany digit is present, BLOOMHASH will not return zero.\n\nThis is expected to sparsely populate the 64-bit wide\nbloom filter field, allowing FIND to bypass the symbol\ntable search if the bit is turned off.\n\nCalculate the bloom filter hash between 0..63.\n#endif\nbloomhash\n    ldy ACC+2*N8                ; length\n    lda #0\n    sta z\nbloomhash01\n    lda (ACC+2*N3),y\n    eor #$30\n    cmp #9\n    bcs bloomhash02\n    adc z\n    sta z\nbloomhash02\n    dey\n    bne bloomhash01\n    lda z\n    and #$3F                    ; width of the filter is 64 bits\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=BLOOMFILTER\nstack=( -- mask addr )\ntags=nfa,dictionary,nosymbol\n\nReturns a `mask`/`addr` pair suitable for `cbit!` or `cbit@`\n\n```\n: bloom!   ( -- mask addr )\n    bloom# bloom >bit ;\n```\n#endif\n#include \"align.i65\"\n_bloomfilter\n    jsr enter\n#include \"page.i65\"\n    .word bloomhash\n#include \"page.i65\"\n    .word bloom\n#include \"page.i65\"\n    .word tobit\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PEARSON#\nstack=( -- pearsonhash )\ntags=ext,nosymbol,nfa\nReturn the hash value for name field address at N3\n`pearson#` is the 4-bit thread index (0..F)\n\nThis hash is used to divide the entire symbol table into\n16 roughly equal-sized lists called \"threads\".  The Ruby\nscript `pearson.rb` is used to generate 8 initial values\nfrom the base dictionary, so if you feel a need to come\nup with your own numbers after adding to the common wordlist,\nthere's the tool.\n\nthe Pearson hash should return an evenly distributed\nvalue between $00-$0F based on the values generated from\nthe core dictionary.  In other words, all 16 threads\nare initially balanced with the same number of words,\nto reduce searches to (on average) 1/16th of the\ndictionary.\n\n```\nsymbol table entry\n+---------------+\n|    CFA[low]   |  -2      Code field address\n|    CFA[high]  |\n+-+-+-+-+-+-+-+-+\n|     [   len   ]  NFA     Length field\n[S]             |          Smudge bit\n| [V]           |          Vocabulary bit\n|   [I]         |          Immediate bit\n+-+-+-+-+-+-+-+-+\n|   name[1]     |  +1      Name field\n|           ... |\n|   name[len]   |  +len\n+---------------+\n?  vocab ident  ?  +len+1  Vocabulary token (if V bit set)\n+---------------+\n```\n\n2017-09-20 this is just AND #$0F, not Pearson hash anymore, so vestigial label.\n#endif\npearsonhash\n    ldy #1\n    lda (ACC+2*N3),y    ; [5]\n    and #$0F\n    jmp push0a\n\n;--------------------------------------------------------------\n#if 0\nname=UNSMUDGE\nstack=( nfa -- )\ntags=compiler,nosymbol\nTurn off the smudge bit so it can be found by [[FIND]].  In\nPETTIL, the smudge bit does double duty, also deactivating any\nwords that have been [[REDEFINED]].\n\n```\nsymbol table entry\n+---------------+\n|   CFA[low]    |  -2      Code field address\n|   CFA[high]   |\n+-+-+-+-+-+-+-+-+\n[S]             |  NFA     Smudge bit\n| [V]           |          Vocabulary bit\n|   [I]         |          Immediate bit\n|     [   len   ]          Length field\n+-+-+-+-+-+-+-+-+\n|   name[1]     |  +1      Name field\n|           ... |\n|   name[len]   |  +len\n+---------------+\n?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)\n+---------------+\n```\n#endif\nunsmudge\n    clc\n    .byt $29            ; AND #\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=SMUDGE\nstack=( nfa -- )\ntags=compiler,nosymbol\nTurn on the smudge bit.  Smudged names won't be found by FIND.\nIn PETTIL, the smudge bit does double duty, also marking as\ninactive any names that have been [[REDEFINED]].\n#endif\nsmudge\n    sec\n    lda #>(drop-1)\n    pha\n    lda #<(drop-1)\n    pha\n    ;fall through\n;--------------------------------------------------------------\n#if 0\nname=?SMUDGE\nstack=( nfa -- nfa )\ntags=compiler,nosymbol\nSmudges or unsmudges the byte pointed to by `tos`\n\n|<br><i>inputs</i>|<|\n|<b>C</b>|<b>0</b> unsmudge<br/><b>1</b> smudge|\n|<b>TOS</b>|NFA address|\n|<br><i>returns</i>|<|\n|^<b>A</b>|altered byte|\n|^<b>Y</b>|<b>0</b>|\n#endif\nqsmudge\n    php\n    ldy #0\n    lda (tos),y\n    asl\n    plp\n    ror\n    sta (tos),y\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=UNSMUDGECLONE16\nstack=( nfa -- nfa )\ntags=interpreter,ext,nosymbol\nUnsmudge the last clone\n#endif\nunsmudgeclone16\n    clc\n    bcc qsmudge                 ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=SMUDGECLONE16\nstack=( nfa -- nfa )\ntags=interpreter,ext,nosymbol\nUnsmudge the last clone\n#endif\nsmudgeclone16\n    sec\n    bcs qsmudge                 ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=(>NAME)\nstack=( cfa -- xfa flag )\ntags=compiler,nosymbol\nThis is the IoC (inversion of control) design pattern in PETTIL.  R11 has the\nCFA of this word, called by `ext.until` (~wut? I dislike that name) until\neither the symbol table is exhausted or the lost CFA is found.  To continue\nour analogy (from the next word `>name`), this is like showing the milk carton\nto one person and asking them if they are the CFA we are looking for.\n\nCompare the provided CFA(N4) vs. CFA of current NFA in (N3)\nIf equal, return the NFA (twice)\nelse return 0\n\n```\n: (>name)   ( cfa -- xfa flag )\n    <n3 name>                   ( cfa currcfa )\n    2dup =                      ( cfa currcfa flag )\n\n    brk\n    .byt popd | N3\n    .byt cpr | N4\n    .byt bz , ptoname02\n    .byt sub | ACC\nptoname02\n    .byt push\n    .byt nxt\n```\n#endif\n#include \"align.i65\"\nptoname\n    jsr enter\n#include \"pass.i65\"\n    .word zpfrom\n    .byt ACC+2*N3\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word namefrom\n#include \"page.i65\"\n    .word ne\n#include \"page.i65\"\n    .word qbranch\n    .byt <(ptoname01-*+1)\n#include \"pass.i65\"\n    .word symplus\n    .byt 3\n#include \"pass.i65\"\n    .word exit\n#include \"page.i65\"\nptoname01\n    .word dup\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=>NAME\nstack=( cfa -- nfa|0 )\ntags=compiler\nReturns the Name Field Address (`nfa`) of a given word, or 0\nif the provided Code Field Address (`cfa`) wasn't found in the\nsymbol table.  This word honors the smudge bit\n\ncodegolf=\n[44]\n_toname\n    jsr enter\n    .word tosyms\ntoname01\n    .word duptor\n    .word namefrom\n    .word over\n    .word ne\n    .word rfetch\n    .word symlen\n    .word andx\n    .word qbranch\n    .byt <(toname02-*+1)\n    .word rfrom\n    .word symplus\n    .byt 3\n    .word branch\n    .byt <(toname01-*+1)\ntoname02\n    .word drop\n    .word rfetch\n    .word rfrom\n    .word symlen\n    .word zne\n    .word andx\n    .word exit\n\n```\n: >name   ( cfa -- nfa )\n     >syms                      ( cfa nfa )\n     begin                      ( cfa nfa )\n         dup>r                  ( cfa nfa ; nfa )\n         name>  over <>\n         r@ sym.len and          ( cfa flag ; nfa )\n     while\n        r> 3 sym+\n     until\n     drop r@ r> sym.len\n     0<> and ;\n```\n#endif\n#include \"align.i65\"\n_toname\n    jsr enter\n#include \"page.i65\"\n    .word tosyms\n#include \"pass.i65\"\n    .word tozp\n    .byt ACC+2*N3               ; symtab -> N3\n#include \"pass.i65\"\n    .word plit\n    .word ptoname\n#include \"page.i65\"\n    .word init411               ; '(>name) -> R11; junk -> N4\n#include \"page.i65\"\n    .word _extuntil\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=NAME>\nstack=( nfa -- cfa )\ntags=compiler\nReturns the Code Field Address (`cfa`) of the provided Name\nField Address (`nfa`)\n\n```\n: name>   ( nfa -- cfa )\n    2- @ ;\n```\n#endif\nnamefrom\n    jsr tos2minus\nnamefrom01\n    jmp fetch\n\n;--------------------------------------------------------------\n#if 0\nname=(FILTER).REWIND\nstack=( -- )\ntags=interpreter,nfa,nosymbol\nRewinds to beginning of symbol table on each loop iteration\n\n```\n: (filter).rewind   ( -- )\n    <n6 >n3 drop ;\n    <n4 0=\n    if  <n5 <n7 2+ !+ >n5 drop\n    then ;\n```\n\n\n#endif\npfilterrewind\n    brk\n    .byt ld | N6                ; get `sym0`\n    .byt st | N3                ; rewind the symbol list\n    .byt ld | N4                ; contains either `newdp`(pass1) or `0`(pass2)\n    .byt bnz , <(pfilterrewind02-*-2) ; check 'pass' flag\n    .byt ld | N7\n    .byt inr | ACC\n    .byt inr | ACC              ; thread points to 1st NFA of each thread\n    .byt std | N5               ; write thread start addresses on pass2\npfilterrewind02\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=SWAP.73\nstack=( -- )\ntags=interpreter,nfa,nosymbol\nSwitches contents of N7 <--> N3\n\n```\n[9]\n    brk\n    ld | N3\n    push\n    ld | N7\n    st | N3\n    ld | TOS\n    st | N7\n    pull\n    nxt\n\n\n    stx z\n    ldx #ACC+2*N7\n    jsr LD\n    ldx #ACC+2*N3\n    jsr swapxs\n    ldx #ACC+2*N7\n    jsr swapxs\n    ldx z\n\n    sta ACC+2*N7\n    ldx #ACC+2*N7\n    jsr swapxs\n    ldx #ACC+2*N3\n    jsr swapxs\n    ldx #ACC+2*N7\n    jsr swapxs\n\n\n    lda ACC+2*N3\n    ldy ACC+2*N7\n    sta ACC+2*N7\n    sty ACC+2*N3\n    lda ACC+2*N3+1\n    ldy ACC+2*N7+1\n    sta ACC+2*N7+1\n    sty ACC+2*N3+1\n\n[22+17]\nswap73\n    stx z\n    ldx #ACC+2*N7\n    jsr LD\n    ldx #ACC+2*N3\n    jsr swapxs                  ; swaps ACC with register indicated by X\n    ldx #ACC+2*N7\n    jsr ST\n    ldx z\n    jmp next\nswapxs\n    lda ACC,x\n    ldy ACC\n    sta ACC\n    sty ACC,x\n    lda ACC+1,x\n    ldy ACC+1\n    sta ACC+1\n    sty ACC+1,x\n    rts\n```\n#endif\n#include \"align.i65\"\nswap73\n    lda ACC+2*N7\n    ldy ACC+2*N3\n    sta ACC+2*N3\n    sty ACC+2*N7\n    lda ACC+2*N7+1\n    ldy ACC+2*N3+1\n    sta ACC+2*N3+1\n    sty ACC+2*N7+1\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=EXT-UNTIL\nstack=( -- )\ntags=ext,immediate,compiler\nThis (poorly named) word wraps a BEGIN-UNTIL loop around a `cfa` called\nvia the `r11` register, like PETTIL Sweet16's `ext` instruction.  The\ninjected function needs a stack signature of ( -- flag ) that is\n`true` when finished.\n\n1. write your filter function to do what it needs to do to each of the things\n2. set up registers the filter function needs\n3. set R11 to point to your filter function\n4. `ext-until`\n5. profit!\n\n#endif\n#include \"align.i65\"\n_extuntil\n    jsr enter\n#include \"page.i65\"\nextuntil01                      ; begin\n    .word extuntil02\n#include \"pass.i65\"             ;  ( flag )\n    .word qbranch               ; until\n    .byt <(extuntil01-*+1)\n#include \"pass.i65\"\n    .word exit\nextuntil02\n    jmp (ACC+2*R11)             ;[3]{5 {=5}}\n\n;--------------------------------------------------------------\n#if 0\nname=(SEEK)\nstack=( thread -- flag )\ntags=interpreter,primitive,nosymbol\nSearch a segment of the dictionary\n\nend of list\n    nfa 0 true\nfound\n    cfa -1|1 true\nnot found\n    vocabs+ false\n\n#endif\npseek\n    lda ACC+2*N4+1              ; toggle sorted/unsorted flag in `n4h`\n    eor #$FF\n    sta ACC+2*N4+1              ; sorted = 0; unsorted = $FF\n    ldy #0\n    lda (tos),y\n    sta ACC+2*N3                ; try to shorten this\n    iny\n    lda (tos),y\n    sta ACC+2*N3+1              ; start of thread `n3`\npseek00\n    jsr symlens\n    beq pseek08                 ; not found!\n    tay\n    ror                         ; save the carry flag for later\n    cpy ACC+2*N4                ; compare curr vs seek lengths\n    beq pseek02                 ; same length? check it\n    bcc pseek01                 ; curr length is shorter, keep try\n    bit ACC+2*N4+1              ; is this list sorted?\n    bpl pseek08\npseek01\n    lda #3\n    jsr sympluss\n    bne pseek00                 ; bra\npseek02\n    asl\n    bpl pseek03\n    lda ACC+2*N5                ; vocab we are looking for\n    iny\n    .byt $2C\npseek03\n    lda (ACC+2*N7),y\npseek04\n    eor (ACC+2*N3),y\n    bne pseek01\n    dey\n    bne pseek03\npseek07\n    clc                         ; found, false (inverted flag)\n    .byt $29\npseek08\n    sec                         ; not found, true\npseek09\n    jmp putc\n\n;--------------------------------------------------------------\n#if 0\nname=NEXTVOCAB\nstack=( -- flag )\ntags=interpreter,forth-83,conspiracy,nosymbol\n\nnextvocab\n    brk\n    .byt ldi | N6\n    .byt st | N5                ; current vocab\n    .byt nxt\n\nnextvocab\n    ldy ACC+2*N5+1\n    lda (ACC+2*N6),y\n    sta ACC+2*N5\n    sty ACC+2*N5+1\n    jmp next\n\n#endif\nnextvocab\n    jsr slip                    ; leave room for the flag\n    ldy ACC+2*N5\n    beq pseek08                 ; true -- last vocab\n    ldy ACC+2*N5+1\n    lda (ACC+2*N6),y\n    sta ACC+2*N5\n    iny\n    sty ACC+2*N5+1\n    bne pseek07                 ; false -- another vocab here\n\n;--------------------------------------------------------------\n#if 0\nname=FOUND?\nstack=( nfa -- xfa -1|0|1 )\ntags=interpreter,forth-83,conspiracy,nosymbol\n\n`nfa` is the word we are looking for.  It will usually be found in `n7`\n`xfa` is the result,\n    either (unfound) `nfa` (always 0 flag)\n    or the `cfa` of (found) `nfa`.\n        Flag is +1 for immediate,\n        -1 for not so much\n\naddr1 is the address of a counted string, which is the word we are looking  for\nto look\nup in the dictionary.\n\nif not found, addr2 is the original addr1, and flag = 0\nif found, addr2 is the code field address of the word,\nand flag = -1 for normal words, +1 for immediate words\n\n! outer interpreter\n\nname is the address of a counted string we are searching for.\nfflag is the find mode.  False means NFAs are sorted, True means check them all\nnfa is the first nfa in the hash list\n\nvocabid identifies which vocabulary to search.  Vocabularies may be\nnested.  FIND walks up the CONTEXT tree and leaves a set of hashed\nNFAs (with the vocabid appended to the name before hashing) on the stack.\nThe final vocabulary searched will be core, and (FIND) will exit afterward.\n\n  0 = corelist\n\n  1 = assembler\n\n  2 = editor\n\n  3+ user vocabularies\n\n(FIND) first searches all unsorted names beginning at SYMTAIL, without regard\nto name length.  If it fails to find the word there,\nit tries the hash list, which is sorted in ascending size\norder.  Vocabularies are searched first, beginning with CONTEXT and chaining\nup until core (0) is reached.  The vocabid is appended to the word when\nsearching that vocabulary.  Only one symbol within a vocabulary may be\nactive (unsmudged) at a time.  Smudged words are ignored.  The same symbol\nmay be active within more than one vocabulary.\n\n returns\n       ( cfa -1 ) found normal word\n       ( cfa 1 ) found immediate word\n       ( name 0 ) not in dictionary\n\n```\n: found?   ( name -- xfa flag )\n\nstarting with the most recently added to `vocabs`\nfor each vocabulary\n    try searches in this order\n        word+trialvocabid `symnew`\n        word+trialvocabid `symtab`\nuntil vocabulary was (0)forth\nif still not found, 0\n\n        for the nfa(n7) in `symnew` list (ordered by age)\n    calculate pearson hash for word if it were in this vocabulary\n    get thread start\n    search for the nfa(n7) in `symtab` list (ordered by length)\n    search for the nfa(n7) in `sym\n\n: found?   ( nfa -- xfa flag )\n    '(seek) init.411\n    bloomfilter cbit@\n    if  vocabs c@+ symnew @\n        set.76 swap73\n        ext-until ?exit\n        1- c@+\n```\n#endif\n#include \"align.i65\"\n_foundq\n    jsr enter\n#include \"page.i65\"\n    .word vocabs\n#include \"page.i65\"\n    .word pfoundq               ; `found?` initialization\n#include \"page.i65\"\n    .word _bloomfilter          ; sum of decimal digits in name % 64\n#include \"page.i65\"\n    .word cbitfetch\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(found04-*+1)\n#include \"page.i65\"\nfoundq01                        ; begin\n    .word symnew\n#include \"page.i65\"\n    .word pseek                 ; returns inverted found? flag\n#include \"pass.i65\"\n    .word qbranch               ; not found? try the veal\n    .byt <(foundq03-*+1)\n#include \"page.i65\"\n    .word symtab\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word tothread\n#include \"page.i65\"\n    .word pseek\n#include \"pass.i65\"\n    .word qbranch               ; inverted flag, so branch if found\n    .byt <(foundq03-*+1)\n#include \"page.i65\"\n    .word nextvocab\n#include \"pass.i65\"\n    .word qbranch               ; loop if more vocabs\n    .byt <(foundq01-*+1)\n#include \"page.i65\"\nfound04\n    .word zpfrom\n    .byt ACC+2*N7\n#include \"page.i65\"\n    .word false\n#include \"pass.i65\"\n    .word exit\n#include \"pass.i65\"\nfoundq03                        ; found it\n    .word zpfrom\n    .byt ACC+2*N3               ; the CFA\n#include \"page.i65\"\n    .word namefrom\n#include \"page.i65\"\n    .word true                  ; assume it's a normie -1\n#include \"page.i65\"\n    .word immedornot            ; maybe add 2 if it's immediate\n#include \"page.i65\"\n    .word exit\n\npfoundq\n    brk\n    .byt ldi | TOS              ; get first vocab\n    .byt st | N5                ; 1st vocab `n5l` ; 0 vocabs offset `n5h`\n    .byt ld | TOS\n    .byt st | N6                ; vocabs+1 `n6`\n    .byt ld | N8\n    .byt st | N4                ; search length `n4l`; 0 sorted/unsorted `n4h`\n    .byt pull\n    .byt st | N7                ; search NFA\n    .byt st | N3                ; search NFA\n    .byt pull\n    .byt nxt\n\ntothread\n    ldy #1\n    lda (ACC+2*N7),y\n    and #$0F\n    asl\n    sta tos                     ; `symtab` is at a page boundary\n    jmp next\n\nimmedornot\n    ldy #0\n    lda (ACC+2*N3),y\n    and #$20                    ; immediate?\n    lsr\n    lsr\n    lsr\n    lsr                         ; $20 -> $02\n    jmp nplus\n\n;--------------------------------------------------------------\n#if 0\nname=(CREATE)\nstack=( cfa -- )\ntags=compiler,nosymbol\n* for duplicate names (same name & vocabulary)\n** issues \"//name// EXISTS\" warning message\n** sets [[REDEFINED]] user variable\n* new symbol table entry\n** symbol CFA links back to [[HERE]]\n** compiles page-aligned `JSR cfa` at [[HERE]]\n\n~wut? rewrite\n\n\nget next token from the input stream\nnada? bye.  maybe error DEFINITION UNFINISHED\n\nsearch current vocabulary first, if nonzero\nsearch symnew\nsearch Forth vocabulary thread\ndon't search other vocabularies in VOCABS\n\n\n* Frame out the word with BL NAME\n* Check length = 0? exit\n* Search current (where definitions are added) vocabulary first\n* found it?\n** It's a duplicate.\n** Tell the user RVS {word} OFF EXISTS\n** REDEFINED !\n** remember to deactivate (smudge) the active clone at the very end during close-definition\n* turn on bloom bit\n* set NEWEST\n\nappend to symtail\ncfa\nlength & name\nvocabulary byte\nupdate symtail\nsymtail symtail (forget).teardown   cheesy trick to use this from (CREATE)\ntriple null\n\n```\n: (create)   ( cfa -- )\n    >r  bl word                 ( cfa addr size )\n    dup 0=  4 ?error            \\ DEFINITION UNFINISHED\n    current c@                  ( addr size voabcid ; cfa )\n    (vfind)\n\n\n    set N7 = symnew\n    r> cfa++\n\n    current c@ (vfind) nip\n    if\n        [ RVSON ] cliteral emit\n        dup id.\n        redefined !\n        .\" [RVSOFF] EXISTS\"\n        here\n    then\n    ( cfa here )\n    dup bloom# >bit bloom + cbit!       \\ add to bloom filter\n    ( cfa here )\n    symtail @  dup>r  2+ dup newest !   \\ set NEWEST\n    ( cfa here symtail+2 ; symtail )\n    over sym.len 1+\n    ( cfa here symtail+2 sym.len+1 ; symtail )\n\n    current @ ?dup                      \\ are we adding to a vocabulary?\n    if\n    ( cfa here symtail+2 sym.len+1 current ; symtail )\n        >r  here c@ $40 or here c!      \\ set vocabulary bit\n    ( cfa here symtail+2 sym.len+1+1 ; current symtail )\n        r> over here + c!  1+\n    ( cfa here symtail+2 sym.len+1+1 ; symtail )\n    then\n    ( cfa here symtail+2 sym.len+1+voc ; symtail )\n\n    2dup +\n    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )\n    dup symtail ! 3erase              \\ mark new symtail\n    ( cfa here symtail+2 len+1 ; symtail )\n    cmove cfa,\n    ( cfa ; symtail )\n    here 3- r> ! ;\n```\n#endif\n#include \"align.i65\"\n_pcreate\n    jsr enter\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _name ; _word            ; ~~1\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word zeq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pcreate03-*+1)\n#include \"page.i65\"\n    .word twodrop\n    .word exit\n#include \"page.i65\"\npcreate03\n    .word current\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n;    .word _pvfind\n#include \"page.i65\"\n    .word nip\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pcreate02-*+1)\n#include \"page.i65\"\n    .word clit\n    .byt RVSON\n#include \"page.i65\"\n    .word emit\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word _iddot\n#include \"page.i65\"\n    .word redefined\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word _pdq\n    .byt pcreate01-*-1\n    .byt RVSOFF\n    .asc    \" EXISTS \"\npcreate01\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\npcreate02\n    .word dup\n#include \"page.i65\"\n    .word _bloomfilter\n#include \"page.i65\"\n    .word cbitstore\n#include \"page.i65\"\n    .word symtail\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word twoplus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word newest\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word symlen\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word current\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word qdup\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pcreate04-*+1)\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word clit\n    .byt $40\n#include \"page.i65\"\n    .word orx\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\npcreate04\n    .word twodup\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word symtail\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word threeoff\n#include \"page.i65\"\n    .word cmove\n#include \"page.i65\"\n    .word _cfacomma\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word threeminus\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(?VMMOVE).MAGIC\nstack=( )\ntags=ext,nosymbol\n\n```\n: ?vmmove   ( newsymtab -- )\n    #blk @\n    if  symtab @                \\ old SYMTAB\n                                ( newsymtab oldsymtab )\n        2dup -                  \\ newsymtab oldsymtab delta ) set up for +MOVE\n        vmbuf @\n        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )\n        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )\n        rot +move\n\n        vmbuf under +!          \\ update vmbuf pointer while we're at it\n        rot +move               ( newsymtab )\n    else\n        dup b/buf - 2-\n        dup off\n    then\n     vmbuf !\n    symtab ! ;\n```\n#endif\nqvmmovemagic\n    jsr harvests4               ; grab just b/buf & vmbuf, leave newsymtab next\n    brk\n    .byt ldd | TOS              ; #blk@\n    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything\n    .byt bz , <(qvmmovemagic01-*-2)\n    .byt pull                   ; newsymtab\n    .byt st | N2                ; put it somewhere safe, for now\n    .byt sub | N6               ; old `symtab`\n\n    ;~wut? more to do here, to support moving `vmbuf`\n\n                                ; no blocks in VM buffer to worry about here\n                                ; not much to do either, really\nqvmmovemagic01\n    .byt rtn\nplant4\n    ldy #4\n    jmp plant\n\n;--------------------------------------------------------------\n#if 0\nname=?VMMOVE\nstack=( newsymtab -- )\ntags=ext,nosymbol\n\n* if `#blk` nonzero, move `vmbuf` area\n\n```\n: ?vmmove   ( newsymtab -- )\n    #blk @\n    if  symtab @                \\ old SYMTAB\n                                ( newsymtab oldsymtab )\n        2dup -                  \\ newsymtab oldsymtab delta ) set up for +MOVE\n        vmbuf @\n        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )\n        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )\n        rot +move\n\n        vmbuf under +!          \\ update vmbuf pointer while we're at it\n        rot +move               ( newsymtab )\n    else\n        dup b/buf - 2-\n        dup off\n    then\n     vmbuf !\n    symtab ! ;\n\n\n: ?vmmove   ( newsymtab -- )\n    vmbuf\n    b/buf\n    #blk\n    (?vmmove).magic             ( newsymtab newvmbuf from to delta flag )\n    ?: +move 3drop\n    vmbuf !\n    symtab ! ;\n\n;(?vmmove).magic   ( newsymtab vmbuf b/buf #blk -- newvmbuf newsymtab )\nqvmmovemagic\n    jsr locals4                 ; grab just b/buf & vmbuf, leave newsymtab next\n    brk\n    .byt ldd | TOS              ; #blk@\n    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything\n    .byt bz , <(qvmmovemagic01-*-2)\n    .byt pull                   ; newsymtab\n    .byt st | N2                ; put it somewhere safe, for now\n    .byt sub | N6               ; old `symtab`\n\n\n                                ; no blocks in VM buffer to worry about here\n                                ; not much to do either, really\nqvmmovemagic01\n    .byt rtn\n    ldy #4\n    jsr restack\n    jmp next\n\n\n\n    if  symtab @                \\ old SYMTAB\n                                ( newsymtab oldsymtab )\n        2dup -                  \\ newsymtab oldsymtab delta ) set up for +MOVE\n        vmbuf @\n        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )\n        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )\n        rot +move\n\n        vmbuf under +!          \\ update vmbuf pointer while we're at it\n        rot +move               ( newsymtab )\n    else\n        dup b/buf - 2-\n        dup off\n    then\n```\n#endif\n#include \"align.i65\"\n_qvmmove\n    jsr enter\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(AUTOMEM)\nstack=( ~wut? )\ntags=ext,nosymbol\nFigure out where the new symbol table will be located, runs in between\nPASS1 and PASS2 of (FORGET)\n\n~wut? If VMBUF has buffers loaded, they are moved by (AUTOMEM)\n\nAutomatically move symbol table and vmbuf to someplace that\n\npad pass1end -                  negative size of symbol table\ntdict +                         new `symtab` is `size` bytes below tdict\nff00 and                        include remainder of the page\n256 -                           include one more page\n--------------\n'some room'                     `symtab`\n\n\n`n7` points to the null at the end of the sorted-by-size symbol\ntable copy at `pad`\n* calculate `n7` - `pad`\n** pass1 symbol table size\n** 1 byte larger per entry because PEARSON#\n\n```\n: (automem)   ( pad+3 -- pad+3 symtab )\n    (automem).init              \\ set `dp`, calculate new `symtab`\n    dup 32 +under\n    symtab #blk @\n    if ?movevmbuf then\n    ! (automem).phase2 ;\n\n(automem)\ntdict\ninline ; brk ; ldd tos ; st n5\npull ; sub n7 ; add n5 ; push\nsub acc ; std n7 ; sti n7 ; rtn\nlda #0 ; sta tos\ndec tos+1 ; jsr toforth\n>n5 dup bl +under symtab\n#blk @ if ?vmmove then\n! ;\n\n\n```\n#endif\n#include \"align.i65\"\n_automem\n    jsr enter\n#include \"page.i65\"\n    .word tdict\n#include \"pass.i65\"\n    .word *+2                   ; `[ assembler here 2+ xt,  brk, tos ldd, ...`\n    brk                         ;( 16 0 pad+3 tdict )\n    .byt ldd | TOS              ;( 16 0 pad+3 tdict+2 )\n    .byt st | N5\n    .byt pull\n    .byt sub | N7               ; negated size of interim symtab\n    .byt add | N5               ; new size subtracted from tdict, will round\n    .byt push                   ; down to $FF00 AND\n    .byt sub | ACC\n    .byt std | N7               ; append end-of-symbols marker\n    .byt sti | N7\n    .byt rtn\n    lda #0\n    sta tos                     ; &= $FF00\n    dec tos+1                   ; <-- #ResizeTdict startup code area here\n;    dec tos+1                   ; -= $0200 leave 'some room'\n#include \"align.i65\"\n    jsr toforth                 ; `>forth jsr, forth ] >n5 dup ...`\n#include \"pass.i65\"\n    .word tozp\n    .byt ACC+2*N5\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word bl                    ; 32\n#include \"page.i65\"\n    .word plusunder             ;( 16 0 pad+3 $5920 $5900 )\n#include \"page.i65\"\n    .word symtab\n#include \"page.i65\"\n    .word numblk\n#include \"page.i65\"\n    .word fetch                 ;( 16 0 pad+3 $5920 $5900 symtab #blk )\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(automem01-*+1)\n#include \"page.i65\"\n    .word _qvmmove              ; need to move vm buffer before symtab !\n#include \"page.i65\"\nautomem01\n    .word store                 ; set symtab\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=>PASSBIT\nstack=( index -- flag )\ntags=interpreter,nfa,nosymbol\n\n```\n: >passbit   ( index -- addr mask )\n    passbits >bit ;\n```\n#endif\n#include \"align.i65\"\ntopassbit\n    jsr enter\n#include \"page.i65\"\n    .word passbits\n#include \"page.i65\"\n    .word tobit\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PASSBITS?\nstack=( index -- flag )\ntags=interpreter,nfa,nosymbol\n\n```\n: passbits?   ( index -- flag )\n    passbits >bit cbit@ ;\n```\n#endif\n#include \"align.i65\"\npassbitsq\n    jsr enter\n#include \"page.i65\"\n    .word topassbit\n#include \"page.i65\"\n    .word cbitfetch\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PASSBITS!\nstack=( index -- )\ntags=interpreter,nfa,nosymbol\n\n```\n: passbits?   ( index -- flag )\n    passbits >bit cbit@ ;\n```\n#endif\n#include \"align.i65\"\npassbitsstore\n    jsr enter\n#include \"page.i65\"\n    .word topassbit\n#include \"page.i65\"\n    .word cbitstore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET).LOOPER\nstack=( b a from to -- )\ntags=interpreter,nfa,nosymbol\ninner word, `b a do rewind begin cfa execute while copy? repeat loop`\n\n#endif\n#include \"align.i65\"\npforgetlooper\n    jsr enter\n#include \"page.i65\"\n    .word set76                 ;( b a ) set `sym0 targ filter\n#include \"page.i65\"\n    .word zero\n#include \"pass.i65\"\n    .word pdo\n    .byt <(pforgetlooper03-*+1)\n#include \"page.i65\"\npforgetlooper01\n    .word i\n#include \"page.i65\"\n    .word passbitsq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pforgetlooper02-*+1)\n#include \"page.i65\"\n    .word pfilterrewind         ; rewind symbol list, copies N6 to N3\n#include \"page.i65\"\n    .word _extuntil             ; filterpass\n#include \"pass.i65\"\npforgetlooper02\n    .word ploop\n    .byt <(pforgetlooper01-*+1)\n#include \"pass.i65\"\npforgetlooper03\n    .word exit\n\nset76\n    brk\n    .byt ld | TOS\n    .byt st | N7                ; targ\n    .byt pull\n    .byt st | N6                ; sym0\n    .byt pull\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET).KEEP\nstack=( cfa -- flag )\ntags=interpreter,nfa,nosymbol\n\n#endif\n#include \"align.i65\"\n_pforgetkeep\n    jsr enter\n#include \"page.i65\"\n    .word pforgetpostcfa\n#include \"page.i65\"\n    .word symcopy\n#include \"page.i65\"\n    .word swap73\n#include \"pass.i65\"\n    .word symplus\n    .byt 1                      ; only include flag/len byte + symbol + vocabid\n#include \"page.i65\"\n    .word swap73\n#include \"pass.i65\"\n    .word exit\n\npforgetpostcfa\n    brk\n    .byt ld | TOS\n    .byt std | N7\n    .byt pull\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=SYM.NEXT\nstack=( -- flag )\ntags=interpreter,nfa,nosymbol\n\n#endif\n#include \"align.i65\"\n_symnext\n    jsr enter\n#include \"pass.i65\"\nsymnext01\n    .word symplus\n    .byt 3\n#include \"page.i65\"\n    .word symlen\n#include \"page.i65\"             ; ( i )\n    .word zeq\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET).PASS1\nstack=( -- )\ntags=interpreter,nfa,nosymbol\n\n* This is the first pass filter.\n* It copies the symbol table from SYMTAB @ to PAD,\n**    sorted by (visible) length of symbol\n**    ignoring words above a given address (NEWDP)\n**    ignoring smudged words\n**    keeping all words in TDICT\n\nIt assumes that the programmer won't attempt `forget` while creating\na definition.\n\n    `: newdefinition [ forget newdefinition ] ;   \\ doh!`\n\nIn the origin dictionary at cold start, there are no clones.  There are no\nsmudged words.\n\nThis means that any smudged words have been redefined.  How do we figure out\nthe most recently redefined word, that is still inside NEWDP?  The active\nword is the clone with the highest (in-bounds) CFA.  It would be unlikely\nfor an unsmudged clone with code at a lower address to exist, as (CREATE)\ndoes not allow it.\n\nOnce the system is up, the dictionary remains sorted and indexed.\nClones have the same name, PEARSON# value, and length, and will be\nadjacent in a sorted symbol table, in ascending CFA order, with all\nof them smudged but the one with the highest CFA.  These existing\nwell-established clones from Philadelphia will be encountered first.\n\nNewly arrived clones from SYMNEW on up will also be sorted ascending\nby CFA but may not be adjacent. All will certainly have higher CFAs\nthan their clone(s) in Philadelphia.\n\nWhen encountering a smudged word\n    store CFA in N2\n    search upward in current thread (Philadelphians) for clones\n    search upward in SYMNEW (Noobs) for clones\n    is the CFA of the clone in-bounds?\n    As soon as we find the first newer clone with an in-bounds CFA, we are done.\n    We this is NOT the active clone.\n    yes:    we are done.  Copy this older clone with smudge bit set\n    no: we got to the end of the list without finding a twin\n    regardless of whether that newer clone is smudged or not\n    if we didn't find any juniors, this is the most recent.\n        Unsmudge it.  Welcome to Philadelphia, brother.\n    append CFA to PAD (N7++)\n\nwhen a smudged word is found,\n    compare its CFA to NEWDP.  If >= NEWDP, it is skipped (out of bounds)\n    compare its CFA to N2.  If >N2, it replaces N2\n\nThe rule here is that the highest CFA that is less than NEWDP is saved, and\nthe word is copied to PAD as is, smudged.\n\n```\n: (forget).pass1\n    sym.len i 2dup 1-\n    ?: drop passbits!\n    =\n    if  cfacheck\n        ?dup ?: (forget).pass1.keep (forget).pass1.discard\n        if  bloomfilter cbit!\n            pearson# (forget)1pearson\n            symcopy\n            swap73\n            1 sym+\n            swap73\n        then\n    then\n    3 sym+  sym.len 0= ;\n\n: (forget).pass1   ( cfa -- )\n    i if\n        i symlen =\n        if\n            <n3 name>           ( cfa curr )\n            2dup tdict @ swap   ( cfa curr cfa tdict curr )\n            between? 0=         ( cfa curr flag )\n            ?: (forget).keep drop\n        then\n    else\n        passbits! bloomfilter cbit!\n    then\n    sym.next ;\n```\n#endif\n#include \"align.i65\"\npforgetpass1\n    jsr enter\n#include \"page.i65\"\n    .word i\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pforgetpass1b-*+1)\n#include \"page.i65\"\n    .word i\n#include \"page.i65\"\n    .word symlen\n#include \"page.i65\"\n    .word eq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(symnext01-*+1)       ; next!\n;#refactor\n#include \"pass.i65\"\n    .word zpfrom                ; nfa\n    .byt ACC+2*N3\n#include \"page.i65\"\n    .word namefrom              ; nfa>cfa\n;\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word tdict\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word betweenq\n#include \"pass.i65\"\npforgetpass1a\n    .word pquerycolon\n    .word drop\n    .word _pforgetkeep\n#include \"pass.i65\"\n    .word branch\n    .byt <(symnext01-*+1)       ; next!\n\n#include \"page.i65\"\npforgetpass1b                   ; pass 0 only, set passbits and bloomfilter\n    .word symlen\n#include \"page.i65\"\n    .word passbitsstore         ; if ((i-1) = 0) set `passbits` for all lengths\n#include \"page.i65\"\n    .word _bloomfilter          ; doing this here speeds things up (slightly)\n#include \"page.i65\"             ; with a low risk of setting inconsequential\n    .word cbitstore             ; false positives in bloom#\n#include \"pass.i65\"\n    .word branch\n    .byt <(symnext01-*+1)       ; next!\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET).PASS2\nstack=( -- )\ntags=interpreter,nfa,nosymbol\n* This is the second pass filter.\n* It copies the symbol t\nable from PAD to the new SYMTAB\n**    sorted by pearson hash\n\nRetrieves the pearson hash value for this word, stored on pass 1\n\n```\n: (forget)pass2   ( -- )\n    pearson# i =\n    ?: (forget).keep next\n    sym.next ;\n```\n#endif\n#include \"align.i65\"\npforgetpass2\n    jsr enter\n#include \"pass.i65\"\n    .word zpfrom                ; nfa\n    .byt ACC+2*N3\n#include \"page.i65\"\n    .word namefrom              ; nfa>cfa\n#include \"page.i65\"\n    .word pearsonhash\n#include \"page.i65\"\n    .word i\n#include \"page.i65\"\n    .word ne\n#include \"pass.i65\"\n    .word branch\n    .byt <(pforgetpass1a-*+1)\n\n;--------------------------------------------------------------\n#if 0\nname=INIT.411\nstack=( ? )\ntags=interpreter,nfa,nosymbol\nSweet16 primitive, sets R4 & R11\n\n```\n: init.411    ( flag(r4) `filter(r11) -- )\n    >r11 drop >n4 drop ;\n```\n#endif\ninit411\n    brk\n    .byt ld | TOS\n    .byt st | R11\n    .byt pull\n    .byt st | N4\n    .byt pull\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=(FORGET)\nstack=( cfa -- )\ntags=nfa,ext,nosymbol\n(FORGET) rebuilds and reindexes the entire dictionary, balancing it\ninto 16 roughly equal-sized 'threads'.  (FORGET) merges symbols\ncreated at SYMNEW since the last (FORGET) into their thread. Then\nSYMNEW is set to SYMTAIL, emptying the 'noob' list\n\n!!!Symbol table entry\n|field| size| offset|h\n|cfa| 2| -2|\n|flags+length| 1| `NFA` 0|\n|name| length| +1|\n|voabcid| 1| +length+1|\nA ''//clone//'' is a symbol which has the same name (and length) as well as\nboth belonging to the same vocabulary (or both [[FORTH]], no vocabulary).  The\ndistinction is that each `clone` has a different `cfa`.  When (CREATE) adds\na `clone`, this new definition replaces the original and smudges the lower,\nearlier definition.  It is up to [[(FORGET)]] to reverse that process.\n\nSmudge is set between ''[[:]]'' and ''[[;]]'' during a word's\ncreation. If there is an error during compilation, [[UNDEFINE]]\ncleans up the partial (smudged) definition in the symbol table\nand also moves [[DP]] back to where it started.  There should\nonly ever be one symbol at a time that is smudged during word\ncreation.\n\nThe other reason a word is smudged is when it is redefined.\nWhen ''[[;]]'' closes the definition, if there is a previous\nactive definition ([[REDEFINED]] is non-zero) then it will be\nsmudged, and the new definition becomes active.  There should\nonly ever be one active `clone` (the most recent) at a time.\n\nAs [[FORGET]] sorts through the symbol table, when it finds a\nsmudged symbol, that is how it knows it found a `clone`.  Since\nPASS1 processes Pearson-hashed symbols in [[SYMTAB]] first,\nthen [[SYMNEW]] symbols, the first clone found will also be\nthe original definition of the word.  This order corresponds\nto the chronological order in which symbols are added.  At this\npoint, PASS1 collects all the other clones and smudges them.\nWhen no more clones can be found, the last `clone` is unsmudged,\nmaking it the active one.\n\n[SYMTAB ... SYMTAIL] is also a long continuous chain of symbols, beginning at\nSYMTAB+32 and ending at the triple null where SYMTAIL points.\n\n```\n: (forget)   ( cfa -- )\n    passbits 4 erase            \\ wipe them clean at dawn of time\n    (forget).pass1              ( cfa cfa1 cfa2 cfa3 )\n    (forget).setup              \\ pass 3 cfas to the setup routine\n        32 1\n        >syms 2+ pad\n    (forget).looper\n    (forget).pass2              ( cfa1 cfa2 cfa3 )\n    (forget).setup\n        16 0\n        pad 3+ (automem)\n        ['] (forget).pass2 >r11 drop\n               ( 16 0 sym0 targ filter )\n    (forget)looper\n        symnew symtail! ;\n```\n\n* pass2 filter\n* going up\n** bloom# <> i\nbuild index as we go\nso we need an index pointer register\nor we could add I to symtab @\n```\n: (forget)   ( cfa -- )\n    bloom 8 erase\n\n    passbits $80 !+ off\n    (forget).pass1 (filter)!\n    32 0  >syms pad\n    (forget).looper             \\ does `ext-until` 32x, completing pass1\n\n    passbits on\n    (forget).pass2 (filter)!\n    16 0  pad 3+ (automem)\n    (forget).looper             \\ does `ext-until` 16x, completing pass2\n```\n#endif\n#include \"align.i65\"\n_pforget\n    jsr enter\n#include \"page.i65\"\n    .word bloom                 ; cfa bloom )\n#include \"page.i65\"\n    .word eight                 ; cfa bloom 8 )\n#include \"page.i65\"\n    .word _erase                ; reset the Bloom filter\n#include \"page.i65\"\n    .word passbits              ; cfa passbits )\n#include \"pass.i65\"\n    .word clit                  ; cfa passbits %1000_0000 )\n    .byt $80\n#include \"page.i65\"\n    .word storeplus             ; cfa passbits+2 )\n#include \"page.i65\"\n    .word off                   ; passbits = %1000 0000 0000 0000\n#include \"pass.i65\"\n    .word dlit\npfpatcha\n    .word _pfpass               ; >r11\n;    .word pforgetpass1          ; >r11\n    .word $FFFF\n#include \"page.i65\"\n    .word init411\n#include \"page.i65\"\n    .word bl                    ; 32 )\n;#include \"page.i65\"\n;    .word zero                 ; 32 0 ) \\ factored into `(forget).looper`\n#include \"page.i65\"\n    .word tosyms\n#include \"page.i65\"\n    .word _pad\n#include \"page.i65\"\n    .word pforgetlooper         ; this is it. performs all of pass1\n#include \"page.i65\"\n    .word passbits\n#include \"page.i65\"\n    .word on                    ; passbits = %1111 1111 1111 1111\n#include \"pass.i65\"\n    .word dlit\npfpatchb\n    .word _pfpass               ; >r11\n;    .word pforgetpass2          ; >r11\n    .word 0                     ; pass2 flag\n#include \"page.i65\"\n    .word init411\n#include \"pass.i65\"\n    .word clit\n    .byt 16\n;#include \"page.i65\"\n;    .word zero\n#include \"page.i65\"\n    .word _pad                  ; the new sym0\n#include \"page.i65\"\n    .word twoplus\n#include \"page.i65\"\n    .word _automem              ; does things, returns the new targ\n#include \"page.i65\"\n    .word pforgetlooper         ;( do eet! again! )\n#include \"page.i65\"\n    .word dp\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word symtail\n#include \"page.i65\"\n    .word symtailstore\n#include \"page.i65\"\n    .word symnew\n#include \"page.i65\"\n    .word symtailstore\n#include \"pass.i65\"\n    .word exit\n\n\n;--------------------------------------------------------------\n#if 0\nname=SYMTAIL!\nstack=( symx -- )\ntags=dictionary,nosymbol\n* Append a triple null end marker to symbol table\n* Set SYMTAIL/SYMNEW after (FORGET) and (CREATE)\n* Ordering of the input addresses is important.\n* 2nd value of `n7` stored is +2 more than 1st `n7` value\n\n`symnew` is where the indexed symbol table ends and the sequential list begins.\n`symnew` doesn't change until the next `rehash`.  This is the word that changes\nit.   It always points to the 3rd byte in the symbol, the `nfa`\n\n`symtail` is where new symbols are appended.  Like the 6502 stack pointer, it\npoints to where the next byte (the `lsb` of a `cfa`) is to be written when the\nnext symbol is created.\n\n\n```\n: (forget)    ...  symtail symnew symtail! ;     \\ reset symnew & symtail\n: (create)    ... symtail symtail symtail! ;    \\ only move symtail\n```\n(FORGET) sends `symnew` `symtail` to reset `symnew` & `symtail`\n(CREATE) sends `symtail` `symtail` to append a new symbol\n\n```\n: symtail!   (  symtail symnew -- )\n    <n7 dup dup 3off 2+ rot ! swap ! ;\n\n; same size, even runs faster\n[12]\nsymtailstore\n    brk\n    .byt ld | N7\n    .byt std | TOS\n    .byt pull\n    .byt sub | ACC\n    .byt std | N7\n    .byt ld | N7\n    .byt std | TOS\n    .byt pull\n    .byt sub | ACC\n    .byt sti | N7\n    .byt nxt\n;\n; slightly slower, uses BS/RS opcodes\n[12]\nsymtailstore\n    brk\n    .byt bs , <(symtailstores-*-2)\n    .byt nxt\nsymtailstores\n    .byt bs , <(symtailstores1-*-2)\n    ;fall through\nsymtailstores1\n    .byt ld | N7\n    .byt std | TOS\n    .byt pull\n    .byt sub | ACC\n    .byt std | N7\n    .byt rs\n```\n#endif\n#include \"align.i65\"\nsymtailstore\n    brk                         ;[7+2] (+2 for extra call from `(forget)`\n    .byt ld | N7\n    .byt std | TOS\n    .byt pull\n    .byt sub | ACC\n    .byt std | N7\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=REHASH\nstack=( -- )\ntags=interpreter,extension\nRebuilds the PETTIL [[symbol table ~]].\n\n```\n: rehash  ( -- )\n    here (forget) ;   \\ effectively a FORGET nil\n```\n#endif\n#include \"align.i65\"\n_rehash\n    jsr enter\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word _pforget\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=FORGET\nstack=( \"name\" -- )\ntags=interpreter,dictionary,forth-83,forth-79,fig\nchecks FENCE, sorts symbol table, keeping only words below the CFA of the named word\n\n```\n: forget   ( \"name\" -- )\n    '  dup  fence @  u<  7 ?error\n    (forget) ;\n\n~wut?  maybe new and improved 2017-09-04\n: forget   ( \"name\" -- )\n    '  dup  fence @ tdict @ between 0=\n    7 ?error (forget) ;\n```\n#endif\n#include \"align.i65\"\n_forget\n    jsr enter\n#include \"page.i65\"\n    .word _tick\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word fence\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word ult\n#include \"pass.i65\"\n    .word qerror\n    .byt 7                      ; CAN'T FORGET BELOW FENCE\n#include \"page.i65\"\n    .word _pforget\n#include \"pass.i65\"\n    .word exit\n\n#print (*-forth)\n",
			"file": "studio/src/pettil-dictionary.a65",
			"file_size": 52423,
			"file_write_time": 131545526996321538,
			"settings":
			{
				"buffer_size": 52423,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-interpreter.a65",
			"settings":
			{
				"buffer_size": 20899,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; core-io.a65\n#echo .       core-io.a65               I/O\n\n;--------------------------------------------------------------\n#if 0\nname=EMIT\nstack=( c -- )\ntags=forth-83,i/o\n#endif\nemit\n    inc usernumout\n    bne emit01\n    inc usernumout+1\nemit01\n    lda tos\n    jsr CHROUT\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=?KEY\nstack=( -- c )\ntags=i/o\nGet a character from the keyboard, or 0 if no key pressed\n#endif\nqkey\n    clc\n    .byt $29                    ; AND # opcode to skip SEC\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=KEY\nstack=( -- c )\ntags=forth-83,i/o\nWait for a keypress by the user\n#endif\nkey\n    sec\n    stx z\nkey01\n    php\n    jsr GETIN\n    bne key02\n    plp\n    bcs key01\n    php\nkey02\n    plp\n    ldx z\n    jmp push0a\n\n;--------------------------------------------------------------\n#if 0\nname=CR\nstack=( -- )\ntags=forth-83,i/o\nOutput a carriage return, uses machine-specific ROM address\n\n```\ncr\n    [ CROUT ] literal jsr\n    #out off #line 1+! ;  ( 17 )\n\ncr\n    jsr CROUT                   ; $D534\n    lda #0\n    sta usernumout\n    sta usernumout+1\n    inc usernumline\n    bne cr01\n    inc usernumline+1\ncr01\n    jmp next\n\n(docall)\nlets us call 6502 subroutines as forth primitives terminating in [[NEXT]]\nwhen RTS executes\n\n: jsr ( -- ; pronounced: \"j-s-r\" )\n    r> 2+ @ ['] next >r execute ;\n```\n#endif\ncr\n    brk\n    .byt ext\n    .word CROUT                 ; ROM routine prints a carriage return\n    .byt set | N0\n    .word usernumline+2\n    .byt popd | N0\n    .byt inr | ACC\n    .byt std | N0\n;    .byt set | N0\n;    .word usernumout\n    .byt sub | ACC\n    .byt std | N0\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=EXPECT\nstack=( addr +n -- )\ntags=forth-83,i/o\n''Forth-83:''//  EXPECT       addr +n --                    M,83\n       Receive characters and store each into memory.  The transfer\n       begins at addr proceeding towards higher addresses one byte\n       per character until either a \"return\" is received or until\n       +n characters have been transferred.  No more than +n\n       characters will be stored.  The \"return\" is not stored into\n       memory.  No characters are received or transferred if +n is\n       zero.  All characters actually received and stored into\n       memory will be displayed, with the \"return\" displaying as a\n       space.  See:  SPAN  \"9.5.2 EXPECT\"//\n\n|Receive characters and store each into memory.|check.|\n|The transfer begins at `addr` proceeding towards higher addresses|check.|\n|one byte per character|check.|\n|until either a \"return\" is received|check.|\n|or until +n characters have been transferred.|and double check.|\n|No more than +n characters will be stored.|check.|\n|The \"return\" is not stored into memory.|check.|\n|No characters are received or transferred if +n is zero.|uhhhh... I didn't check that, sorry|\n|All characters actually received and stored into memory will be displayed|check.|\n|with the \"return\" displaying as a space.|check.|\n\n#endif\nexpect\n    jsr harvests2               ; `addr` to `n0`\n;   sty userspan+1              ; always off\n    stx z\n;   ldy #0                      ; thanks, `harvests`\nexpect01\n    jsr CHRIN\n    cmp #$0d\n    beq expect02\n    sta (n),y\n    iny\n    cpy tos\n    bcc expect01\nexpect02\n    ldx z\n    jsr dashtrailings\n    ;lda tos                    ; thanks, `-trailing`\n    sta userspan                ; set `span`\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname='STREAM\nstack=( -- buf siz )\ntags=extra,todo\nflags=immediate,locals\nProvide the line buffer address and buffer size of the input stream\n\n```\n: 'stream\nblk@  ?: SIB TIB  80 ;\n```\n#endif\n#include \"align.i65\"\n_tickstream\n    jsr enter\n#include \"page.i65\"\n    .word tib\n#include \"page.i65\"\n    .word eighty\n#include \"page.i65\"\n    .word blkfetch\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(tickstream01-*+1)\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word plusunder\n;#include \"page.i65\"\n;    .word mumbojumbo           ; redirect input from `blkbuf`\n#include \"pass.i65\"\ntickstream01\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=QUERY\nstack=( -- )\ntags=forth-83,interpreter\nQUERY        --                            M,83\n   Characters are received and transferred into the memory area\n   addressed by TIB .  The transfer terminates when either a\n   \"return\" is received or the number of characters transferred\n   reaches the size of the area addressed by TIB .  The values\n   of >IN and BLK are set to zero and the value of #TIB is set\n   to the value of SPAN .  WORD may be used to accept text from\n   this buffer.  See:  EXPECT  \"input stream\"\n\nPETTIL differs from the Forth-83 standard here, because it uses\na lazy loading scheme with all kinds of goodies sprinkled around\non the zero page. This version is provided in core so programs can\ninvoke `query` to acquire keyboard input from the user.\n\n* Simply does `tib 80 expect`\n* No `#tib`\n* Does not reset `blk` or `in`\n* `expect` will set `span`\n```\n: query   ( buf len -- )\n    tib 80 expect ;\n```\n#endif\n#include \"align.i65\"\n_query\n    jsr enter\n#include \"page.i65\"\n    .word _tickstream\n#include \"page.i65\"\n    .word expect\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SPACE\nstack=( -- )\ntags=forth-83,i/o\nEmits a space character\n\n```\n: space   ( -- )\n   bl emit ;\n```\n#endif\n#include \"align.i65\"\n_space\n    jsr enter\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word emit\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SPACES\nstack=( n -- )\ntags=forth-83,i/o\nEmits \"n\" spaces\n\n```\n: spaces   ( n -- )\n    0 max 0\n    ?do\n        space\n    loop ;\n```\n#endif\n#include \"align.i65\"\n_spaces\n    jsr enter\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word max\n#include \"page.i65\"\n    .word zero\n#include \"pass.i65\"\n    .word pqdo\n    .byt <(spaces02-*+1)\n#include \"page.i65\"\nspaces01\n    .word _space\n#include \"pass.i65\"\n    .word ploop\n    .byt <(spaces01-*+1)\nspaces02\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=TYPE\nstack=( addr count -- )\ntags=forth-83,i/o\n#endif\ntype\n    jsr harvests2\n    clc\n    lda tos\n    adc usernumout\n    sta usernumout\n    lda tos+1\n    adc usernumout+1\n    sta usernumout+1\n    ;ldy #0\ntype01\n    cpy tos\n    bne type02\n    dec tos+1\n    bpl type02\n    jmp drop\ntype02\n    lda (n),y\n    jsr CHROUT\n    iny\n    bne type01\n    inc n+1\n    bne type01                  ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=$.\nstack=( addr -- )\ntags=string\nOutputs a string\n\n#endif\n#include \"align.i65\"\n_stringdot\n    jsr enter\n#include \"page.i65\"\n    .word count\n#include \"page.i65\"\n    .word type\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=DIGIT\nstack=( char base -- digit true | false )\ntags=numword\n\n Converts a single character to a digit using the current number\n base.  A flag on TOS indicates whether the conversion succeeded.\ntodo: possible to code golf this down with BCD tricks?\n\"http://www.6502.org/tutorials/decimal_mode.html\n#endif\ndigit\n    ldy #$ff                    ; assume success\n    lda stackl,x                ; get the character\n    sec\n    sbc #'0'\n    bcc digit02                 ; char was < '0'? not a digit, fail\n    cmp #10\n    bcc digit01                 ; digit is in the range 00-09\n    sbc #7                      ; no? alphabet adjust 'A' --> $0a\ndigit01\n    cmp tos                     ; compare to current number base\n    bcs digit02                 ; not in current number base? fail\n    sta stackl,x                ; digit in the current number base\n    .byt $2c                    ; BIT xxyy, skip the next two bytes\ndigit02\n    iny                         ; fail, set flag to 0\n    inx                         ; drop the stack\n    tya                         ; ya = flag word $0000 or $ffff\n    jmp put                     ; next!\n\n;--------------------------------------------------------------\n#if 0\nname=HOLD\nstack=( char -- )\ntags=numword,forth-83\n\n\n Inserts  character into a pictured numeric out-\n put string.\n char is inserted into a pictured numeric output\n string.  Typically used between  [[<#]] and [[#>]] .\n\n```\n: hold   ( char -- )\n    hld 1-!  hld @  c! ;\n```\n#endif\n#include \"align.i65\"\n_hold\n    jsr enter\n#include \"page.i65\"\n    .word hld\n#include \"page.i65\"\n    .word oneminusstore\n#include \"page.i65\"\n    .word hld\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word cstore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=NUMBER\nstack=( addr -- d )\ntags=numword,forth-83\n\n Convert the counted string at addr, to a signed\n 32-bit integer, using the value of BASE .  If numeric\n conversion is not possible, an error condition exists.  The\n string may contain a preceding minus sign.\n\n```\n \\ There is a string that is probably a number stored from addrlow..addrhigh\n \\ convert a counted string to a signed double, keeping track of the decimal\n: number  ( addr -- d )\n  ( addr )\n     0 0 rot count\n  ( 0 0 addr+1 len )\n     over c@ [ ascii - ] literal  =\n  ( 0 0 addr+1 len negative? )\n     dup>r\n  ( 0 0 addr+1 len negative? ) ( R; -- negative? )\n     +\n  ( 0 0 addr+1 lenadj ; adjust length for sign char )\n     over + r@ -\n  ( 0 0 addr+1 addrhigh+1 )\n     swap  r@ -\n  ( 0 0 addrhigh+1 addrlow )\n     dpl on\n     ?do\n  ( d )\n         base @ >r\n  ( d ) ( R; base negative? )\n         i c@  r@  digit\n  ( -- d currdigit~?~ flag )\n         if\n             swap r@ um*\n             drop rot\n             r@ um* d+\n             dpl @ 1+  0= negate dpl +!\n         else\n             i c@ [ ascii . ] literal  =\n             dpl @ 0<  and\n             if\n                 dpl off\n             else\n                 3 fail ( abort\" not found\" )\n             then\n         then\n         r> drop\n  ( R; negative? ; discard base )\n     loop\n     r>  if  dnegate  then ;\n\n```\n#endif\n#include \"align.i65\"\n_number\n    jsr enter\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word count\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word clit\n    .byt '-'\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word on\n#include \"pass.i65\"\n    .word pqdo\n    .byt <(number05-*+1)\n#include \"page.i65\"\nnumber01\n    .word base\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word i\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word digit\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(number02-*+1)\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word umstar\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word umstar\n#include \"page.i65\"\n    .word dplus\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zlt\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word plusstore\n#include \"pass.i65\"\n    .word branch\n    .byt <(number04-*+1)\n#include \"page.i65\"\nnumber02\n    .word i\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word clit\n    .byt '.'\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zlt\n#include \"page.i65\"\n    .word andx\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(number03-*+1)\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word off\n#include \"pass.i65\"\n    .word branch\n    .byt <(number04-*+1)\n#include \"page.i65\"\nnumber03\n    .word three\n#include \"page.i65\"\n;    .word _fail\n#include \"page.i65\"\nnumber04                        ; then then\n    .word rfrom\n#include \"page.i65\"\n    .word drop\n#include \"pass.i65\"\n    .word ploop\n    .byt <(number01-*+1)\n#include \"page.i65\"\nnumber05\n    .word rfrom\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(number07-*+1)\n#include \"page.i65\"\n    .word dnegate\n#include \"pass.i65\"\nnumber07\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=<#\nstack=( -- )\ntags=numword,forth-83\n\nsee also: [[HOLD]] [[HLD]]\n\npronounced: 'less-than-sharp'\n\n```\n: <#   ( -- )\n    pad hld ! ;\n```\n#endif\n#include \"align.i65\"\n_ltsharp\n    jsr enter\n#include \"page.i65\"\n    .word _pad                  ; ( pad )\n#include \"page.i65\"\n    .word hld                   ; ( pad hld )\n#include \"page.i65\"\n    .word store                 ; ( )\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=#>\nstack=( d -- hld size )\ntags=numword,forth-83\nTerminates pictured numeric output, discarding the double `d` and returning\nthe starting address and size of the output string.\n\nsee also: [[<#]] [[#]] [[#S]] [[HOLD]] [[HLD]] [[SIGN]]\n\npronounced: 'sharp-greater'\n\n```\n: #>   ( d -- hld size )\n    2drop hld @ pad over - ;\n```\n#endif\n#include \"align.i65\"\n_sharpgt\n    jsr enter\n#include \"page.i65\"\n    .word twodrop\n#include \"page.i65\"\n    .word hld\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word _pad\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word minus\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SIGN\nstack=( n -- )\ntags=numword,forth-83\n\n If n is negative, an ASCII \"-\" (minus sign) is appended to the\n pictured numeric output string.  Typically used between <# and #> .\n\n```\n: sign   ( n -- )\n    0< if '-' hold then ;\n```\n#endif\n#include \"align.i65\"\n_sign\n    jsr enter\n#include \"page.i65\"\n    .word zlt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(sign01-*+1)\n#include \"pass.i65\"\n    .word clit\n    .byt '-'\n#include \"page.i65\"\n    .word _hold\n#include \"pass.i65\"\nsign01\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(#)\nstack=( +d1 -- +d2 )\ntags=numword,nosymbol\nbase is the current system number base, which must be between 2 and 36.\nThis helper primitive divides d1 by BASE, returning the quotient d2\nand the remainder (as an ascii digit).  Called by '#'\n\npronounced: 'paren-sharp'\n#endif\npsharp\n        lda  #0                 ; partial remainder\n        ldy  #32                ; loop counter\npsharp2\n        asl  stackl,x           ; Dividend\n        rol  stackh,x           ; is gradually replaced\n        rol  tos                ; with the quotient\n        rol  tos+1              ; A is gradually replaced\n        rol                     ; with the remainder\n        cmp  userbase           ; partial remainder < BASE?\n        bcc  psharp3            ; no: update the partial\n        sbc  userbase           ; remainder and partial\n        inc  stackl,x           ;  quotient\npsharp3\n        dey\n        bne  psharp2            ; loop 32 times\n        cmp  #10\n        sed\n        adc  #'0'               ; adjust remainder to ASCII\n        cld\n        jmp  pushya             ; actually need to do a HOLD\n\n;--------------------------------------------------------------\n#if 0\nname=(DIGIT)\nstack=( n -- c )\ntags=numword,nosymbol\n\npronounced: 'paren-digit'\n#endif\npdigit\n    lda tos\n    sed\n    cmp #10\n    adc #'0'\n    cld\n    sta tos\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=#\nstack=( +d1 -- +d2 )\ntags=numword,forth-83\n\n +d1 is divided by BASE and the quotient is\n placed onto the stack.  The remainder is con-\n verted to an ASCII character and appended to\n the output string toward lower memory ad-\n dresses.\n The remainder of +d1 divided by the value of\n BASE is converted to an ASCII character and ap-\n pended to the output string toward lower memory\n addresses.  +d2 is the quotient and is main-\n tained for further processing.  Typically used\n between <# and #> .\n\npronounced: 'sharp'\n#endif\n#include \"align.i65\"\n_sharp\n    jsr enter\n#include \"page.i65\"\n    .word base                  ; ( d base )\n#include \"page.i65\"\n    .word fetch                 ; ( d @base )\n#include \"page.i65\"\n\n; psharp will replace the following block of code\n;    .word psharp\n\n    .word udslashmod            ; ( rem d )\n#include \"page.i65\"\n    .word rot                   ; ( d rem )\n#include \"page.i65\"\n    .word pdigit\n#include \"page.i65\"\n    .word _hold                 ; ( d )\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=#S\nstack=( d -- )\ntags=numword,forth-83\n\npronounced: 'sharp-s'\n#endif\n#include \"align.i65\"\n_sharps\n    jsr enter\n#include \"page.i65\"\nsharps01\n    .word _sharp                ; ( d )\n#include \"page.i65\"\n    .word twodup                ; ( d d )\n#include \"page.i65\"\n    .word _dzeq                 ; ( d flag )\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(sharps01-*+1)\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(UD.)\nstack=( d -- )\ntags=numword,nosymbol\nPrint an unsigned double\n\npronounced: 'paren-u-d-dot'\n\n```\n: (ud.)\n    <# #s #> ;\n```\n#endif\n#include \"align.i65\"\n_puddot\n    jsr enter\n#include \"page.i65\"\n    .word _ltsharp\n#include \"page.i65\"\n    .word _sharps\n#include \"page.i65\"\n    .word _sharpgt\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(D.)\nstack=( d -- )\ntags=numword,nosymbol\nPrint a signed double\n\n```\n: (d.)\n    dup>r  dabs  <# #s r> sign #> ;\n```\n#endif\n#include \"align.i65\"\n_pddot\n    jsr enter\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word dabs\n#include \"page.i65\"\n    .word _ltsharp\n#include \"page.i65\"\n    .word _sharps\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word _sign\n#include \"page.i65\"\n    .word _sharpgt\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(U.)\nstack=( u -- )\ntags=numword,nosymbol\nPrint an unsigned number\n\n```\n: (u.)\n    0 (ud.) ;\n```\n#endif\n#include \"align.i65\"\n_pudot\n    jsr enter\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word _puddot\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(.)\nstack=( n -- )\ntags=nosymbol,i/o,inner\nPrint a signed number\n\n```\n: (.)\n    s->d (d.) ;\n```\n#endif\n#include \"align.i65\"\n_pdot\n    jsr enter\n#include \"page.i65\"\n    .word _stod\n#include \"page.i65\"\n    .word _pddot\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=UD.\nstack=( ud -- )\ntags=numword\n\n#endif\n#include \"align.i65\"\n_uddot\n    jsr enter\n#include \"page.i65\"\n    .word _puddot\n#include \"pass.i65\"\n    .word branch\n    .byt <(tse-*+1)\n;--------------------------------------------------------------\n#if 0\nname=D.\nstack=( d -- )\ntags=numword\n\n#endif\n#include \"align.i65\"\n_ddot\n    jsr enter\n#include \"page.i65\"\n    .word _pddot\n#include \"pass.i65\"\n    .word branch\n    .byt <(tse-*+1)\n;--------------------------------------------------------------\n#if 0\nname=U.\nstack=( n -- )\ntags=numword,forth-83\n\n#endif\n#include \"align.i65\"\n_udot\n    jsr enter\n#include \"page.i65\"\n    .word _pudot\n#include \"pass.i65\"\n    .word branch\n    .byt <(tse-*+1)\n;--------------------------------------------------------------\n#if 0\nname=.\nstack=( n -- )\ntags=numword,forth-83\n\n\n The value of n is displayed in a free field for-\n mat with a leading minus sign if n is negative.\n#endif\n#include \"align.i65\"\n_dot\n    jsr enter\n#include \"page.i65\"\n    .word _pdot                 ; ( addr count )\n#include \"page.i65\"\ntse                             ; type, space, exit\n    .word type                  ; ( )\n#include \"page.i65\"\n    .word _space                ; ( )\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=U.R\nstack=( u w -- )\ntags=numword\n\n u is converted using the value of BASE and then\n displayed as an unsigned number right-aligned\n in a field +n characters wide.  If the number\n of characters required to display u is greater\n than +n, an error condition exists.\n\n#endif\n#include \"align.i65\"\n_udotr\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _pudot\n#include \"pass.i65\"\n    .word branch\n    .byt <(rjustify-*+1)\n;--------------------------------------------------------------\n#if 0\nname=.R\nstack=( n1 w -- )\ntags=numword\n\n#endif\n#include \"align.i65\"\n_dotr\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _pdot\n#include \"pass.i65\"\n    .word branch\n    .byt <(rjustify-*+1)\n;--------------------------------------------------------------\n#if 0\nname=UD.R\nstack=( d w -- )\ntags=numword\n\n#endif\n#include \"align.i65\"\n_uddotr\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _puddot\n#include \"pass.i65\"\n    .word branch\n    .byt <(rjustify-*+1)\n;--------------------------------------------------------------\n#if 0\nname=D.R\nstack=( d n -- )\ntags=numword\n\n#endif\n#include \"align.i65\"\n_ddotr\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _pddot\n#include \"page.i65\"\nrjustify\n    .word rfrom\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word _spaces\n#include \"page.i65\"\n    .word type\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=?\nstack=( addr -- )\ntags=i/o,memory\nFetches the value at `addr` and outputs it via [[.]]\n\n#endif\n#include \"align.i65\"\n_question\n    jsr enter\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word _dot\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=IRQ!\nstack=( irqhandler -- )\ntags=device\nCalled by the editor (and anything else) to flip the IRQ vector\non and off between two different values\n#endif\nirqstore\n    lda tos\n    ldy tos+1\n    sei\n    sta CINV\n    sty CINV+1\n    cli\n    jmp drop\n\nirqoff\n    sei\n    jmp next\n\nirqon\n    cli\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=^IRQS\ntags=nosymbol,subroutine\nToggle the BRK vector between Sweet16 <--> TIM\n\nY=2; replace just IRQ\nY=4; replace BRK and IRQ\n\n#endif\ntoggleirqs\n    ldy #2\n    .byt $2C\n    ;fall through\n;--------------------------------------------------------------\n#if 0\nname=^IRQBRK\ntags=startup,nosymbol\n* toggle Sweet16 BRK vector at ($0090)\n\n#endif\ntoggleirqbrk\n    ldy #4                      ; set both IRQ and BRK vectors\n    ;\n    sei\ntoggleib01\n    lda userirqtoggle-1,y\n    eor CINV-1,y\n    sta CINV-1,y\n    dey\n    bne toggleib01\n    cli\n    rts\n\n#print (*-emit)\n",
			"file": "core/src/core-io.a65",
			"file_size": 23403,
			"file_write_time": 131545558825736556,
			"settings":
			{
				"buffer_size": 23403,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 31 files for \"dashtrailings\" (regex)\n\n/home/chitselb/dev/commodore/pettil/core/src/core-io.a65:\n  139  expect02\n  140      ldx z\n  141:     jsr dashtrailings\n  142      ;lda tos                    ; thanks, `-trailing`\n  143      sta userspan                ; set `span`\n\n/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65:\n 2065      lda #<(put-1)\n 2066      pha\n 2067: dashtrailings\n 2068      lda #$20\n 2069      sta n+2\n\n2 matches across 2 files\n\n\nSearching 31 files for \"_qrefill\" (regex)\n\n/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  563  #endif\n  564  #include \"align.i65\"\n  565: _qrefill\n  566      jsr enter\n  567  #include \"page.i65\"\n  ...\n  685      .word qstack\n  686  #include \"page.i65\"             ; interpret init\n  687:     .word _qrefill\n  688  #include \"page.i65\"\n  689      .word bl\n\n2 matches in 1 file\n\n\nSearching 31 files for \"deadbeef\" (regex)\n\n/home/chitselb/dev/commodore/pettil/studio/src/pettil-studio.a65:\n   35  tdict.size\n   36  <\n   37: { deadbeef }\n   38  <56FE> vmbuf\n   39  \n   ..\n   44  <1B80> here\n   45  { disappearing banner startup code }\n   46: { deadbeef }\n   47  <56FE> vmbuf\n   48  <5700> blkbuf\n   49  <5B00> symtab\n   50: <6900> init & deadbeef\n   51  <6A00> studio\n   52  <8000> VIDRAM\n   ..\n  157      .word store\n  158  #include \"page.i65\"\n  159:     .word _deadbeef\n  160  #include \"pass.i65\"\n  161      .word restart               ; restart #4 -> `warm`\n  ...\n  195  ;--------------------------------------------------------------\n  196  #if 0\n  197: name=DEADBEEF\n  198  stack=( -- )\n  199  tags=startup,nosymbol\n  200: Fill available memory with the 32-bit value `$DEADBEEF` . Discarded after\n  201  running once at startup.  Used to assist in debugging.\n  202  \n  203  #endif\n  204  #include \"align.i65\"\n  205: _deadbeef\n  206      jsr enter\n  207  ;#include \"pass.i65\"\n  ...\n  212  #include \"pass.i65\"\n  213      .word _pdq\n  214:     .byt deadbeef00-*-1\n  215      .asc HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n  216      .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN\n  217      .asc CRSRDOWN,CRSRDOWN,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT\n  218      .asc RVSON,\"DEAD\",CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT\n  219: deadbeef00\n  220  #include \"page.i65\"\n  221      .word symtab\n  ...\n  223      .word fetch\n  224  #include \"pass.i65\"\n  225: deadbeef01\n  226      .word dlit\n  227      .word $dead,$beef\n  ...\n  240  #include \"pass.i65\"\n  241      .word qbranch\n  242:     .byt <(deadbeef02-*+1)\n  243  #include \"page.i65\"\n  244      .word dashrot\n  ...\n  249  #include \"pass.i65\"\n  250      .word branch\n  251:     .byt <(deadbeef01-*+1)\n  252  #include \"page.i65\"\n  253: deadbeef02\n  254      .word drop\n  255  #include \"page.i65\"\n  ...\n  259  #include \"pass.i65\"\n  260      .word _pdq\n  261:     .byt deadbeef03-*-1\n  262      .asc    RVSOFF,\"BEEF\",CR,CR,CR,CR,CR,CR,CR\n  263: deadbeef03\n  264  #include \"pass.i65\"\n  265      .word exit\n\n15 matches in 1 file\n\n\nSearching 31 files for \"_choose\" (regex)\n\n/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65:\n 2490  #endif\n 2491  #include \"align.i65\"\n 2492: _choose\n 2493      jsr enter\n 2494  #include \"pass.i65\"\n ....\n 2526      .word execute\n 2527  #include \"page.i65\"\n 2528:     .word _choose\n 2529  #include \"pass.i65\"\n 2530      .word exit\n\n/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  399      .word blkfetch\n  400  #include \"page.i65\"\n  401:     .word _choose               ; true=sib false=tib, buffer to EXPECT it in\n  402  #include \"page.i65\"\n  403      .word qrefillsetup          ;( flag )\n\n3 matches across 2 files\n\n\nSearching 31 files for \"name=3\"\n\n/home/chitselb/dev/commodore/pettil/core/src/core-inner.a65:\n   93  ;--------------------------------------------------------------\n   94  #if 0\n   95: name=3DROP\n   96  stack=( a b c -- )\n   97  tags=stack,ext\n\n/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65:\n  473  ;--------------------------------------------------------------\n  474  #if 0\n  475: name=3OFF\n  476  stack=( addr -- )\n  477  tags=nucleus,memory\n  ...\n 1056  ;--------------------------------------------------------------\n 1057  #if 0\n 1058: name=3\n 1059  stack=( -- 3 )\n 1060  tags=nucleus\n ....\n 1595  ;--------------------------------------------------------------\n 1596  #if 0\n 1597: name=3-\n 1598  stack=( n -- n-3 )\n 1599  tags=nucleus\n ....\n 1637  ;--------------------------------------------------------------\n 1638  #if 0\n 1639: name=3+\n 1640  stack=( n -- n+3 )\n 1641  tags=nucleus\n ....\n 1715  ;--------------------------------------------------------------\n 1716  #if 0\n 1717: name=3DUP\n 1718  stack=( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )\n 1719  tags=nucleus\n ....\n 1857  ;--------------------------------------------------------------\n 1858  #if 0\n 1859: name=3C@\n 1860  stack=( addr -- d )\n 1861  tags=nucleus\n ....\n 1893  ;--------------------------------------------------------------\n 1894  #if 0\n 1895: name=3C!\n 1896  stack=( d addr -- )\n 1897  tags=nucleus\n\n8 matches across 2 files\n\n\nSearching 31 files for \"tickstream\"\n\n/home/chitselb/dev/commodore/pettil/core/src/core-io.a65:\n  158  #endif\n  159  #include \"align.i65\"\n  160: _tickstream\n  161      jsr enter\n  162  #include \"page.i65\"\n  ...\n  168  #include \"pass.i65\"\n  169      .word qbranch\n  170:     .byt <(tickstream01-*+1)\n  171  #include \"page.i65\"\n  172      .word dup\n  ...\n  176  ;    .word mumbojumbo           ; redirect input from `blkbuf`\n  177  #include \"pass.i65\"\n  178: tickstream01\n  179      .word exit\n  180  \n  ...\n  211      jsr enter\n  212  #include \"page.i65\"\n  213:     .word _tickstream\n  214  #include \"page.i65\"\n  215      .word expect\n\n/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  547      jsr enter\n  548  #include \"page.i65\"\n  549:     .word _tickstream\n  550  #include \"pass.i65\"\n  551      .word clit\n\n5 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 5922,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "; core-nucleus.a65\n#echo .       core-nucleus.a65          Nucleus\n\n;--------------------------------------------------------------\n#if 0\nname=UM*\nstack=( u1 u2 -- ud )\ntags=nucleus,math,forth-83\n\"ud\" is the unsigned product of \"u1\" times \"u2\".  All values and\narithmetic are unsigned.\n\nA proper 6502 assembly solution.\n\nFeatures\n\n* multiplies two 8-bit numbers with 16 bit result\n* inner loop of only 17 clock cycles per iteration\n* worst case behaviour of 40 clock cycles per iteration\n* minimizes number of iterations\n* total execution time 25 - 320 cycles\n\n(i.e. only 3x slower (worst case) than MUL on Intel 8088)\n\n* 43 bytes size\n* relocatable to about anywhere in address space\n* uses C64-friendly memory locations\n\n INPUT  = op1 in A, op2 in X\n\n OUTPUT = low byte in X, high byte in Y\n\n memory locations used as temp space = $fb, $fc, $fd\n\n```\n;You beat me to the punch, but there is some unnecessary code in there\n;(you don't need to clear the carry before a LSR). And trashing X is\n;unnecessary since you can test for zero just as fast with LDA $02.\n;Or with some crazy jujitsu to save a byte...\n;\n;Here's my version, handles 8-bit operands:\n;--$00 holds operand 1\n;--$01 (low byte) and $02 (high byte) hold operand 2\n;--$03 (low byte) and $04 (high byte) hold product\n;       cld\n;Loop\n;    lsr $00\n;    bcc NoAdd\n;    clc\n;    lda $03\n;    adc $01\n;    sta $03\n;    lda $04\n;    adc $02\n;    sta $04\n;    .byte $2C\n;NoAdd\n;    beq Done\n;    asl $01\n;    rol $02\n;    bcc Loop                   ; this assumes that operand 2 is 8-bit\n;Done\n;\n;A proper 6502 assembly solution.\n;\n;Features\n;- multiplies two 8-bit numbers with 16 bit result\n;- inner loop of only 17 clock cycles per iteration\n;- worst case behaviour of 40 clock cycles per iteration\n;- minimizes number of iterations\n;- total execution time 25 - 320 cycles\n;(i.e. only 3x slower (worst case) than MUL on Intel 8088)\n;- 43 bytes size\n;- relocatable to about anywhere in address space\n;- uses C64-friendly memory locations\n; INPUT  = op1 in A, op2 in X\n; OUTPUT = low byte in X, high byte in Y\n; memory locations used as temp space = $fb, $fc, $fd\n;    stx $fc    ; save op2\n;    cmp $fc    ; compare both operands\n;    bcc noswap ; swap them unless op1 < op2\n;    sta $fc    ; save op1 instead of op2\n;    txa        ; swap op2 for op1\n;noswap\n;    ldx #$00   ; prepare result low byte\n;    stx $fd    ; clear high byte of op2\n;    ldy #$00   ; prepare result high byte\n;    beq begin  ; skip shift of op2 for first iteration\n;loop\n;    asl $fc    ; multiply op2 by 2, low byte\n;    rol $fd    ; multiply op2 by 2, high byte\n;begin\n;    lsr        ; divide op1 by 2\n;    bcs add    ; if op1 was odd before division, add op2\n;    bne loop   ; if op1 is not zero repeat loop\n;    rts        ; otherwise return result\n;add\n;    sta $fb    ; save current value of op1\n;    clc        ; prepare addition\n;    txa        ; fetch low byte\n;    adc $fc    ; add op2, low byte\n;    tax        ; store low byte\n;    tya        ; fetch high byte\n;    adc $fd    ; add op2, high byte\n;    tay        ; store high byte\n;    lda $fb    ; restore op1\n;    bne loop   ; if op1 is not zero repeat loop\n;    rts        ; otherwise return result\n;\n\n    stx $fc    ; save op2\n    cmp $fc    ; compare both operands\n    bcc noswap ; swap them unless op1 < op2\n    sta $fc    ; save op1 instead of op2\n    txa        ; swap op2 for op1\nnoswap\n    ldx #$00   ; prepare result low byte\n    stx $fd    ; clear high byte of op2\n    ldy #$00   ; prepare result high byte\n    beq begin  ; skip shift of op2 for first iteration\nloop\n    asl $fc    ; multiply op2 by 2, low byte\n    rol $fd    ; multiply op2 by 2, high byte\nbegin\n    lsr        ; divide op1 by 2\n    bcs add    ; if op1 was odd before division, add op2\n    bne loop   ; if op1 is not zero repeat loop\n    rts        ; otherwise return result\nadd\n    sta $fb    ; save current value of op1\n    clc        ; prepare addition\n    txa        ; fetch low byte\n    adc $fc    ; add op2, low byte\n    tax        ; store low byte\n    tya        ; fetch high byte\n    adc $fd    ; add op2, high byte\n    tay        ; store high byte\n    lda $fb    ; restore op1\n    bne loop   ; if op1 is not zero repeat loop\n    rts        ; otherwise return result\n\n```\ncheck http://6502.org/source/ for multiply and divide and stuff\n#endif\numstar\n    lda stackl,x\n    sta n+4\n    lda stackh,x                ; multiplicand in tos\n    sta n+5                     ; multiplier in N2\n    jsr multiply                ; 16 bit unsigned multiply\n    lda n\n    sta stackl,x\n    lda n+1\n    sta stackh,x\n    lda n+2\n    ldy n+3\n    jmp put\n\nmultiply\n    lda #0                      ; unsigned multiply tos*N2 destroys tos\n    sta n+2                     ; clear upper half of product\n    sta n+3\n    ldy #16\nrshift\n    lsr tos+1\n    ror tos\n    bcc rrot                    ; Go rotate right if c = 0\n    clc\n    lda n+2                     ; Get upper half of product\n    adc n+4                     ; and add multiplicand toit\n    sta n+2\n    lda n+3\n    adc n+5\nrrot\n    ror                         ; shift partial product right\n    sta n+3\n    ror n+2\n    ror n+1\n    ror n\n    dey                         ; Decrement bit count and\n    bne rshift                  ; loop\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=UD/MOD\nstack=( ud1 u2 -- u3 ud4 )\ntags=numword\n\nhttp://www.bradrodriguez.com/papers/camel09.txt\n\\   High level: numeric output                   (c) 31mar95 bjr\n: UD/MOD      \\ ud1 u2 -- u3 ud4     32/16->32 divide\n    >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT ;\n\n#endif\nudslashmod\n        stx z                   ; saves a dex;dex later\n        ;ldy #4\n        jsr harvests4           ; dividend to n0..n3\n        clc\n        ;ldy #0                 ; harvests does this for us\n        ldx #33\n        tya\n        beq udslashmodb         ; bra to initialization code\nudslashmoda\n        rol n+4         ; [5]   ; I don't know what this 2-bytes is called\n        rol n+5         ; [5]   ; trial minuend or something like that\n        sec             ; [2]\n        lda n+4         ; [3]\n        sbc tos         ; [3]\n        tay             ; [2]\n        lda n+5         ; [3]\n        sbc tos+1       ; [3]\n        bcc udslashmodc         ; save or abandon the trial subtraction\nudslashmodb\n        sty n+4         ; [2+3+3] or [3]?\n        sta n+5         ; treating this as [~6] clocks on average\nudslashmodc\n        rol n+0         ; [5]\n        rol n+1         ; [5]\n        rol n+2         ; [5]\n        rol n+3         ; [5]\n        dex             ; [2]\n        bne udslashmoda ; [3]\n                        ; [54] or [59] clocks for 33x main loop = [1839]\n        ldx z\n        lda n+5\n        sta stackh+1,x\n        lda n+4\n        sta stackl+1,x\n        lda n+1\n        sta stackh,x\n        lda n\n        sta stackl,x\n        ldy n+3\n        lda n+2\n        jmp put                 ; push quotient(hi) on stack\n\n;--------------------------------------------------------------\n#if 0\nname=UM/MOD\nstack=( ud u -- rem quot )\ntags=forth-83,nucleus\nPerform an unsigned division of the 16-bit \"u\" into the double\n\"ud\", leaving the 16-bit unsigned remainder and quotient on\nthe stack\n\n      http://6502.org/source/integers/ummodfix/ummodfix.htm\n\n!!! pronounced: \"u-m slash mod\"\n#endif\numslashmod\n    lda stackl,x\n    cmp tos\n    lda stackh,x\n    sbc tos+1\n    bcs umslashmodx\numslashmoda\n    lda #17\n    sta n                       ; counter\numslashmodb\n    rol stackl+1,x\n    rol stackh+1,x\n    dec n\n    beq umslashmodz\n    rol stackl,x\n    rol stackh,x\n    lda #$80\n    rol\n    sta n+1                     ; carry\n    ;sec\n    lda stackl,x\n    sbc tos\n    sta n+2\n    lda stackh,x\n    sbc tos+1\n    tay\n    lda n+1\n    sbc #0\n    bcc umslashmodb\n\n    lda n+2\n    sta stackl,x\n    sty stackh,x\n    bcs umslashmodb\n\numslashmodx\n    lda #$ff\n    sta stackl,x\n    sta stackh,x\n    sta stackh+1,x\n    sta stackl+1,x\numslashmodz\n    jsr slide                   ; ~\n    jmp swap\n\n;--------------------------------------------------------------\n#if 0\nname=AND\nstack=( n1 n2 -- n1&n2 )\ntags=forth-83,nucleus,boolean\n#endif\nandx\n    lda tos+1\n    and stackh,x\n    tay\n    lda tos\n    and stackl,x\n    inx\n    bne not01       ; [3]       ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=OR\nstack=( n1 n2 -- n1|n2 )\ntags=forth-83,nucleus,boolean\n#endif\norx\n    lda tos+1\n    ora stackh,x\n    tay\n    lda tos\n    ora stackl,x\n    inx\n    bne not01       ; [3]       ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=XOR\nstack=( n1 n2 -- n1^n2 )\ntags=forth-83,nucleus,boolean\n#endif\nxor\n    lda tos+1       ; [3]\n    eor stackh,x    ; [4]\n    tay             ; [2]\n    lda tos         ; [3]\n    eor stackl,x    ; [4]\n    inx             ; [2]\n    bne not01       ; [3]       ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=NOT\nstack=( n -- !n )\ntags=forth-83,nucleus,boolean\n#endif\nnot\n    lda tos+1\n    eor #$ff\n    tay\n    lda tos\n    eor #$ff\nnot01\n    jmp put\n\n;--------------------------------------------------------------\n#if 0\nname=2>R\nstack=( x1 x2 -- ) ( R; -- x1 x2 )\ntags=double,stack,ext\n\nTransfer cell pair x1 x2 to the return stack. Semantically equivalent to `SWAP >R >R` .\n#endif\ntwotor\n    lda stackh,x\n    pha\n    lda stackl,x\n    pha\n    inx\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=>R\nstack=( n -- ) ( R; -- n )\ntags=forth-83,nucleus,stack\nMove the top element of the data stack to the return stack\n\n!!! pronounced: \"to-r\"\n#endif\ntor\n    sec\n    .byt $29                    ; AND #\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=DUP>R\nstack=( n -- n ) ( R; -- n )\ntags=nucleus,stack\nCopy the top of the data stack to the return stack\n\n!!! pronounced: \"dupe to-r\"\n#endif\nduptor\n    clc\n    lda tos+1\n    pha\n    lda tos\n    pha\n    bcc rdrop01\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=RDUP\nstack=( -- ) ( R; n -- n n )\ntags=nucleus,stack\nDuplicate the top of the return stack\n\nI can't think of any use for this yet\n\n!!! pronounced: \"r-dupe\"\n```\nrdup\n    pla\n    sta z\n    pla\n    tay\nrtwoput\n    lda z\n    pha\n    tya\n    pha\n    lda z\n    pha\n    tya\n    pha\n    jmp next\n```\n#endif\nrdup\n\n;--------------------------------------------------------------\n#if 0\nname=RSWAP\nstack=( -- ) ( R; a b -- b a )\ntags=nucleus,stack\nSwap the top two items on the return stack\n\n!!! pronounced: \"r-swap\"\n\n```\n: rswap   ( ; r1 r2 -- ; r2 r1)\n   2r> >r >r ;\n```\n#endif\n#include \"align.i65\"\n_rswap\n    jsr enter\n#include \"page.i65\"\n    .word tworfrom\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word tor\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=RDROP\nstack=( -- ) ( R; a -- )\ntags=nucleus,stack\nDrop the top item on the return stack\n\n!!! pronounced: \"r-drop\"\n#endif\nrdrop\n    pla\n    pla\nrdrop01\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=3OFF\nstack=( addr -- )\ntags=nucleus,memory\nErase three bytes starting at `addr`\n#endif\nthreeoff\n    ldy #3\n    .byt $2C                    ; BIT abs opcode skips `ldy #1`\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=COFF\nstack=( addr -- )\ntags=nucleus,memory\nStore 0 char at `addr`\n#endif\ncoff\n    ldy #1\n    sec\n    bcs twooff01                ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=ON\nstack=( addr -- )\ntags=nucleus,memory\nStore -1 at `addr`\n#endif\non\n    clc\n    .byt $29                    ; AND # opcode skips sec\n;--------------------------------------------------------------\n#if 0\nname=OFF\nstack=( addr -- )\ntags=nucleus,memory\nStore 0 word at `addr`\n#endif\noff\n    sec\n    ldy #2\n    .byt $2C                    ; BIT abs opcode skips `ldy #4`\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=2OFF\nstack=( addr -- )\ntags=nucleus,memory\nStore 0 word at `addr`\n#endif\ntwooff\n    ldy #4\ntwooff01\n    lda #>(drop-1)\n    pha\n    lda #<(drop-1)\n    pha\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=ERASES\nstack=( addr -- )\ntags=nucleus,memory\nStore 0 word at `addr`\n#endif\nerases\n    jsr dectos                  ; alters A, not C\n    lda #0\n    sbc #0\nerases02\n    sta (tos),y\n    dey\n    bne erases02\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=-\nstack=( n1 n2 -- difference )\ntags=forth-83,nucleus\nSubtract `n2` from `n1`\n\n#endif\nminus\n    jsr donegate\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=+\nstack=( n1 n2 -- sum )\ntags=forth-83,nucleus,math,fig,forth-79\nregisters=A:X:C:TOS=sum\nCalculate the sum of n1 plus n2\n\n```\n          +            w1 w2 -- w3                   79             \"plus\"\n               w3 is the arithmetic sum of w1 plus w2.\n```\n!!! pronounced: \"plus\"\n#endif\nplus\n    lda stackl,x\nplus01                          ; entry point from >BIT\n    clc\n    adc tos\n    sta tos\n    lda stackh,x\n    adc tos+1\n    sta tos+1\n    inx\nplus02\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=ABS\nstack=( n -- u )\ntags=forth-83,nucleus,math,fig,forth-79\nLeave the absolute value of n as u.\n#endif\nabs\n    bit tos+1\n    bpl plus02\n    ;fall through\n;--------------------------------------------------------------\n#if 0\nname=NEGATE\nstack=( n -- -n )\ntags=forth-83,nucleus,math\n\n#endif\nnegate\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\ndonegate\n    sec\nneg2\n    lda #0\n    sbc tos\n    sta tos\n    lda #0\n    sbc tos+1\n    sta tos+1\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=OVER\nstack=( n1 n2 -- n1 n2 n1 )\ntags=forth-83,nucleus,stack\n\n#endif\nover\n    ldy stackh,x\n    lda stackl,x\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=SWAP\nstack=( n1 n2 -- n2 n1 )\ntags=forth-83,nucleus,stack,fig,forth-79\nExchange the top two values on the stack.\n#endif\nswap\n    ldy tos+1\n    lda stackh,x\n    sta tos+1\n    sty stackh,x\n    ldy tos\n    lda stackl,x\n    sta tos\n    sty stackl,x\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=TUCK\nstack=( n1 n2 -- n2 n1 n2 )\ntags=nucleus,stack\nInsert the top item on the stack beneath the second.\n#endif\ntuck\n    dex\n    jsr tuckdashrot\n    jmp next\n\ntuckdashrot\n    lda stackh+1,x\n    sta stackh,x\n    lda stackl+1,x\n    sta stackl,x\n    lda tos+1\n    sta stackh+1,x\n    lda tos\n    sta stackl+1,x\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=-ROT\nstack=( a b c -- c a b )\ntags=nucleus,stack\n\n#endif\ndashrot\n    ldy stackh,x\n    lda stackl,x                ; b\n    pha\n    jsr tuckdashrot\n    pla\n    jmp put                     ; b -> c\n\n;--------------------------------------------------------------\n#if 0\nname=NIP\nstack=( n1 n2 -- n2 )\ntags=nucleus,stack\nRemove the second item from the stack\n#endif\nnip\n    inx\nqdup01\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=?DUP\nstack=( 0 -- 0 | n -- n n )\ntags=forth-83,nucleus\n DUP if top of stack is nonzero\n#endif\nqdup\n    lda tos\n    ora tos+1\n    beq qdup01\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=DUP\nstack=( n -- n n )\ntags=forth-83,nucleus,stack,forth-79,fig\nDuplicate the value on the stack.\n\n!!! pronounced: \"dupe\"\n#endif\ndup\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=SLIP\nstack=( n -- n n )\ntags=nosymbol,subroutine\nPush TOS to the stack (DUP)\n#endif\nslip\n    dex                         ; slip something onto the stack\nslip01\n    lda tos+1\n    sta stackh,x\n    lda tos\n    sta stackl,x\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=+!\nstack=( n addr -- )\ntags=forth-83,nucleus,fig,forth-79\nAdd \"n\" to the value at \"addr\"\n\n!!! pronounced: \"plus-store\"\n#endif\nplusstore\n    ldy #0\n    clc\n    lda stackl,x\n    adc (tos),y\n    sta (tos),y\n    iny\n    lda stackh,x\n    adc (tos),y\n    sta (tos),y\n    jmp twodrop\n\n;--------------------------------------------------------------\n#if 0\nname=TOGGLE\nstack=( addr bitmask -- )\ntags=nucleus,boolean,fig\nComplement the contents of addr by the bit pattern b.\n#endif\ntoggle\n    lda stackl,x\n    sta n\n    lda stackh,x\n    sta n+1\n    ldy #0\n    lda (n),y\n    eor tos\n    sta (n),y\n    jmp twodrop\n\n;--------------------------------------------------------------\n#if 0\nname=COUNT\nstack=( addr1 -- addr2 n1 )\ntags=forth-83\nLeaves the address, addr2 and the character count +n of text\nbeginning at addr1.  addr2 is addr1+1 and n1 is the length of\nthe counted string at addr1.  The byte at addr1 contains the\nbyte count +n.  Range of +n is {0...255}.\n#endif\ncount\n    ; synonym for C@+, fall through\n;--------------------------------------------------------------\n#if 0\nname=C@+\nstack=( addr -- addr+1 c )\ntags=nucleus,memory,primitive\nFetches the byte at addr, increments addr\n\n!!!pronounced: \"c-fetch-plus\"\n#endif\ncfetchplus\n    ldy #0\n    lda (tos),y\n    jsr inctos\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=@+\nstack=( addr -- addr+2 w )\ntags=nucleus,memory,primitive\nFetches word `w` at `addr`, increments addr by 2\n\n!!!pronounced: \"c-fetch-plus\"\n#endif\nfetchplus\n    ldy #1\nfetchplus01\n    lda (tos),y\n    pha\n    dey\n    bpl fetchplus01\n    jsr inctos\n    jsr inctos\n    jmp rfrom\n\n;--------------------------------------------------------------\n#if 0\nname=CBIT!\nstack=( mask addr -- )\ntags=nucleus,boolean,memory\n\n turn on the mask bits in the byte at address\n\n~wut? shouldn't I call this 'cbiton'?  what does 'c' mean here?\n\n!!! pronounced: \"c-bit-store\"\n#endif\ncbitstore\n    ldy #0\n    lda (tos),y\n    ora stackl,x\n    sta (tos),y\n    jmp twodrop\n\n;--------------------------------------------------------------\n#if 0\nname=CBIT@\nstack=( mask addr -- flag )\ntags=nucleus\n\n test the mask bits in the byte at address\n\n#endif\ncbitfetch\n    ldy #0\n    lda (tos),y\n    and stackl,x\n    inx\n    jmp put\n\n;--------------------------------------------------------------\n#if 0\nname=TIB\nstack=( -- addr )\ntags=nucleus,const,forth-83\nThe address of the text input buffer.  This buffer is used\nto hold characters when the input stream is coming from the\ncurrent input device.  The minimum capacity of TIB is 80\ncharacters.\n\n!!!pronounced: \"t-i-b\"\n#endif\ntib\n    jsr doconst\n    .word BUF                   ; $0200\n\n;--------------------------------------------------------------\n#if 0\nname=SIB\nstack=( -- addr )\ntags=nucleus,const,forth-83\nThe address of the screen input buffer.  This buffer is used\nto hold each logical line on a screen while interpreting it.\n\nCREATE puts the count in the buffer just before the\ntoken and also the vocab just after the token.\n\nThis could overwrite $01FF, $0250, $0251 and 02A2\n\n!!!pronounced: \"s-i-b\"\n#endif\nsib\n    jsr doconst\n    .word BUF+82                ; $0252\n\n;--------------------------------------------------------------\n#if 0\nname=-5\nstack=( -- -5 )\ntags=nucleus,const\n\n#endif\nminusfive\n    jsr doconst\n    .word -5\n\n;--------------------------------------------------------------\n#if 0\nname=-4\nstack=( -- -4 )\ntags=nucleus,const\n\n#endif\nminusfour\n    jsr doconst\n    .word -4\n\n;--------------------------------------------------------------\n#if 0\nname=-3\nstack=( -- -3 )\ntags=nucleus,const\n\n#endif\nminusthree\n    jsr doconst\n    .word -3\n\n;--------------------------------------------------------------\n#if 0\nname=-2\nstack=( -- -2 )\ntags=nucleus,const\n\n#endif\nminustwo\n    jsr doconst\n    .word -2\n\n;--------------------------------------------------------------\n#if 0\nname=BLK@\nstack=( -- blk )\ntags=numword\nReturns the contents of [[BLK]]\n#endif\nblkfetch\n    lda userblk\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=9\nstack=( -- 9 )\ntags=nucleus\nConstant: `9`\n#endif\nnine\n    lda #9\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=8\nstack=( -- 8 )\ntags=nucleus\nConstant: `8`\n#endif\neight\n    lda #8\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=7\nstack=( -- 7 )\ntags=nucleus\nConstant: `7`\n#endif\nseven\n    lda #7\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=6\nstack=( -- 6 )\ntags=nucleus\nConstant: `6`\n#endif\nsix\n    lda #6\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=EIGHTY\nstack=( -- 80 )\ntags=nucleus,const\nConstant: `80`\n#endif\neighty\n    lda #80\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=FORTY\nstack=( -- 40 )\ntags=nucleus,const\nConstant: `40`\n#endif\nforty\n    lda #40\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=BL\nstack=( -- n )\ntags=nucleus,const\nConstant: `32`\n#endif\nbl\n    lda #' '\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=L/SCR\nstack=( -- n )\ntags=nucleus,const\nLines per screen, 25\nConstant: `25`\n#endif\nlperscr\n    lda #25\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=5\nstack=( -- 5 )\ntags=nucleus\nConstant: `5`\n#endif\nfive\n    lda #5\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=4\nstack=( -- 4 )\ntags=nucleus\nConstant: `4`\n#endif\nfour\n    lda #4\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=3\nstack=( -- 3 )\ntags=nucleus\nConstant: `3`\n#endif\nthree\n    lda #3\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=2\nstack=( -- 2 )\ntags=nucleus\nConstant: `2`\n#endif\ntwo\n    lda #2\n    .byt $2c                    ; BIT abs opcode\n;--------------------------------------------------------------\n#if 0\nname=1\nstack=( -- 1 )\ntags=nucleus,const\nConstant: `1`\n#endif\none\n    lda #1\n    jmp push0a\n\n;--------------------------------------------------------------\n#if 0\nname=?TERMINAL\nstack=( -- flag )\ntags=forth-83\nLeaves a flag indicating whether the [[STOP]] key was pressed by the user\n#endif\nqterminal\n    lda STKEY                   ; $9B\n    cmp #$EF                    ; check STOP key\n    beq true\n\n;--------------------------------------------------------------\n#if 0\nname=ACC\nstack=( -- $00 )\ntags=assembler,vocabulary,extension\n!!!Assembler constant\nzero page scratch location\n\n```\n$00 cconstant acc\n```\n#endif\nasmacc\n\n;--------------------------------------------------------------\n#if 0\nname=0\nstack=( -- 0 )\ntags=nucleus\nPut a 0 on the stack\n#endif\nzero\n\n;--------------------------------------------------------------\n#if 0\nname=FALSE\nstack=( -- 0 )\ntags=nucleus\nPut a 0 (false flag) on the stack\n#endif\nfalse\n    clc\n    .byt $29                    ; AND # opcode\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=-1\nstack=( -- -1 )\ntags=nucleus\n\n#endif\nminusone\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=TRUE\nstack=( -- -1 )\ntags=nucleus,forth-83\n#endif\ntrue\n    sec\npushc\n    lda #>(pushya-1)\n    ldy #<(pushya-1)\nrightchere\n    pha\n    tya\n    pha\nctoyarts\n    ldy #0\n    bcc yyrts\n    dey                         ; you load 16 ones, and whaddya get?\nyyrts\n    tya\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=BETWEEN?\nstack=( low high test -- flag )\ntags=nucleus,thinking-forth,forth200x\nReturns TRUE when `high > test >= low`\n\n\n```\n: WITHIN   ( n lo hi+1 -- ?)\n    >r 1- over < swap r> < and ;\n```\nreturns true iff a < x < b, unsigned\n\n6.2.2440 WITHIN\nCORE EXT\n    ( n1|u1 n2|u2 n3|u3 -- flag )\nPerform a comparison of a test value n1|u1 with a lower limit n2|u2 and an upper limit n3|u3, returning true if either (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 < n3|u3)) or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 < n3|u3)) is true, returning false otherwise. An ambiguous condition exists if n1|u1, n2|u2, and n3|u3 are not all the same type.\n\nSee: A.6.2.2440 WITHIN, where after much monkeying about with ways that\nare broken, they finally get to it:\n\n```\n: WITHIN ( test low high -- flag )  OVER - >R - R> U< ;\n\nwithin\n    brk\n    .byt ld | TOS\n    .byt st | N0\n    .byt pull\n    .byt\n```\nsub16\n    sec                         ; 16-bit signed subtract/compare\n    lda stackl,x                ; returns AY = (2OS-TOS)\n    sbc tos                     ; (N^V) = result was negative\n    tay                         ; !(N^V) = result was positive\n    lda stackh,x\n    inx                         ; nip 2OS\n    sbc tos+1\n    rts\nparallels the syntax of do loops\nn lo hi within   ( n lo hi -- flag )\nwithin\n    jsr sub16\n\n\n\n\"Thinking Forth\" pp. 171,283\nAn often-used word is `within`, which determines wheteher a given value lies within two other values.  The syntax is:\nn  lo hi within\nwhere `n` is the value to be tested and `lo` and `hi` represent the range.\n`within` returns true if `n` is greater-than or equal-to `lo` and //less-than//\n`hi`.  This use of the non-incluseive upper limit parallels the syntax\nof `do loop`s.\n\np.283\n`within` can be defined in high level like this\n: within ( n lo hi+1 -- ?)\n>r 1- over < swap r> < and ;\n#endif\nbetweenq\n    jsr sub16                   ;hi-n\n    inx\n    bcc putc\n    dex\n    jsr sub16                   ;lo-n\nbetwq01\n    jmp putnotc\n\n;--------------------------------------------------------------\n#if 0\nname=0=\nstack=( n -- flag )\ntags=forth-83,nucleus\nLeaves [[TRUE]] if the top of stack is zero, otherwise [[FALSE]].\nLogical [[NOT]], turns nonzero values to `$FFFF`\n#endif\nzeq\n    clc\n    .byt $29                    ; AND # opcode, 1-byte branch trick\n\n;--------------------------------------------------------------\n#if 0\nname=0<>\nstack=( n -- flag )\ntags=nucleus\nLeave `FALSE` if `n` is 0, `TRUE` otherwise.  Normalizes nonzero\nvalues to $FFFF .   Could this word be removed? ~~\n#endif\nzne\n    sec\n    lda tos\n    ora tos+1\n    bne putc\n    bcs zlt                     ; 0<> puts FALSE\n    dec tos+1                   ; 0= puts TRUE\n                                ; fall through\n;--------------------------------------------------------------\n#if 0\nname=0<\nstack=( n -- flag )\ntags=forth-83,nucleus\n#endif\nzlt\n    asl tos+1                   ; copy N to C\nputc\n    lda #>(put-1)               ; more 'bra' than a Hawaiian surf party here\n    ldy #<(put-1)\n    bne rightchere              ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=SUB16\nstack=( n1 n2 -- flag )\ntags=nucleus,subroutine,nosymbol\nPerforms a 16-bit subtraction of `2OS - TOS`\n\n\"V is the exclusive or of the carrys out of bits 6 and 7\" - Bogax\n\n|AY|result A (high)  Y (low)|\n|N|sign of result|\n|C|borrow of result|\n|Z||\n#endif\nsub16\n    sec                         ; 16-bit signed subtract/compare\n    lda stackl,x                ; returns AY = (2OS-TOS)\n    sbc tos                     ; (N^V) = result was negative\n    tay                         ; !(N^V) = result was positive\n    lda stackh,x\n    inx                         ; nip 2OS\n    sbc tos+1\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=<\nstack=( n1 n2 -- flag )\ntags=forth-83,nucleus\nPerform a signed comparison and return `true` if `n1` is less\nthan `n2`\n#endif\nlt\n    jsr sub16                   ; 2OS - TOS, return (N^V)\n    bvs putnotn\n    eor #$80\nputnotn\n    asl\nputnotc\n    bcc puttrue                 ; 8 bytes for put{notc,false,true}... not bad\nputfalse\n    clc\n    bcc putc                    ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=0>\nstack=( n -- flag )\ntags=forth-83,nucleus,relational\n\n#endif\nzgt\n    asl tos+1\n    bcs putfalse\nputtrue\n    sec\n    bcs putc                    ; bra\n;--\n;                       U<\n#if 0\nname=U<\nstack=( n1 n2 -- flag )\ntags=forth-83,nucleus\n#endif\nult\n    jsr sub16\n    bne putnotc                 ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=DCMP\nstack=( d1 d2 -- d1 d2 )\ntags=forth-83,double,primitive,nosymbol,subroutine\nEvaluate `d1 - d2` without changing either value\n\nreturns C flag\n\n* TRUE when `d1` ''>='' `d2`\n* FALSE when  `d1` ''<'' `d2`\n\nreturns Z flag\n\n* TRUE when `d1` ''='' `d2`\n* FALSE when  `d1` ''<>'' `d2`\n\nhttp://6502.org/tutorials/compare_beyond.html\n4.2 AN EQUALITY AND UNSIGNED COMPARISON\n#endif\ndcmp\n    lda stackh+1,x              ; high byte first\n    cmp tos+1\n    bne dcmp01\n    lda stackl+1,x\n    sbc tos\n    bne dcmp01\n    lda stackh+2,x\n    sbc stackh,x\n    bne dcmp01\n    lda stackl+2,x\n    sbc stackl,x                ; low byte last\ndcmp01\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=DU<\nstack=( d1 d2 -- flag )\ntags=forth-83,double,primitive,logical\nPerforms an unsigned compare of two doubles and leaves true if \"d1\" < \"d2\"\n\n#endif\ndult\n    jsr dcmp\n    inx\n    inx\n    inx\n    bne putnotc                 ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=D=\ntags=double,primitive,logical\nstack=( hi2 lo2 hi1 lo1 -- flag )\nLeaves true if the two doubles are equal\n#endif\ndeq\n    sec\n    lda tos\n    eor stackl+1,x\n    bne deq01\n    lda tos+1\n    eor stackh+1,x\n    bne deq01\n    lda stackl,x\n    eor stackl+2,x\n    bne deq01\n    lda stackh,x\n    eor stackh+2,x\n    bne deq01\n    .byt $29                    ; AND # opcode, skip CLC\ndeq01\n    clc\n    inx\n    inx\ndeq02\n    inx\n    bne putc                    ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=(=)\nstack=( n1 n2 -- n1 n2 ; returns Z flag )\ntags=nucleus,relational,nosymbol\nsubroutine evaluates TOS==2OS\n\n* Compares the TOS with 2OS\n* returns the Z flag\n* doesn't alter the stack\n\n|^A|^''*'' |^N|^''-'' |\n|^X||^V||\n|^Y||^Z|^''*'' |\n|>||^C||\n#endif\npeq\n    lda stackh,x    ; [4]\n    eor tos+1       ; [3]\n    sta z           ; [3]\n    lda stackl,x    ; [4]\n    eor tos         ; [3]\n    ora z           ; [3]\n    rts             ; [6]       ; Z flag is (TOS = 2OS)\n\n;--------------------------------------------------------------\n#if 0\nname=<>\nstack=( n1 n2 -- flag )\ntags=nucleus,relational\nLeave a true flag if \"n1\" does not equal \"n2\".\n#endif\nne\n    sec\n    .byt $29                    ; AND # opcode, skip CLC\n\n;--------------------------------------------------------------\n#if 0\nname==\nstack=( n1 n2 -- flag )\ntags=forth-83,nucleus,relational\nLeave a true flag if \"n1\" does is equal to \"n2\".\n#endif\neq\n    clc\n    jsr peq\n    php\n    pla\n    bcc eq01\n    eor #2                      ; toggle Z flag\neq01\n    lsr                         ; ignore C flag...\n    lsr                         ; Z flag!\n    bpl deq02                   ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=D<\nstack=( d1 d2 -- flag )\ntags=forth-83,double,primitive\nCompare two doubles.  True if d1 < d2\n#endif\ndlt\n    ldy #$00                    ; false\n    jsr dcmp\n    bvc dlt01\n    eor #$80\ndlt01\n    bpl dlt02\n    dey                         ; true\ndlt02\n    sty tos\n    sty tos+1\n    inx\n    inx\n    inx\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=>\nstack=( d1 d2 -- flag )\ntags=forth-83,double,primitive\nCompare two doubles.  True if d1 < d2\n#endif\n#include \"align.i65\"\n_gt\n    jsr enter\n#include \"page.i65\"\n    .word lt\n#include \"page.i65\"\n    .word not\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=D>\nstack=( d1 d2 -- flag )\ntags=double\n\n```\n: d>\n    d< not ;\n```\n#endif\n#include \"align.i65\"\n_dgt\n    jsr enter\n#include \"page.i65\"\n    .word dlt\n#include \"page.i65\"\n    .word not\n#include \"pass.i65\"\n    .word exit\n;                       D0=\n;--------------------------------------------------------------\n#if 0\nname=D0=\nstack=( d -- flag )\ntags=double,primitive,logical\nLeave true if the double `d` is zero\n\n`D0<>` is not in PETTIL, nor the Forth-83 standard.  Use `or 0<>`.\n#endif\n#include \"align.i65\"\n_dzeq\n    jsr enter\n#include \"page.i65\"\n    .word orx\n#include \"page.i65\"\n    .word zeq\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=TOS2MINUS\nstack=( n -- n-2 )\ntags=nosymbol\n!!!Subroutine\ndecrements the top of stack twice\n#endif\ntos2minus\n    jsr dectos\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=DECTOS\ntags=nosymbol\ndecrement TOS\n#endif\ndectos\n    lda tos\n    bne dectos01\n    dec tos+1\ndectos01\n    dec tos\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=1-\nstack=( n -- n-1 )\ntags=forth-83,nucleus\nSubtract 1 from top of stack\n#endif\noneminus\n    lda #$ff\n    bne oneminus01\n\n;--------------------------------------------------------------\n#if 0\nname=3-\nstack=( n -- n-3 )\ntags=nucleus\n\n#endif\nthreeminus\n    lda #$fd\n    .byt $2c ; BIT abs opcode, fall through to twominus\n;--------------------------------------------------------------\n#if 0\nname=2-\nstack=( n -- n-2 )\ntags=nucleus,forth-83\n\n#endif\ntwominus\n    lda #$fe\noneminus01\n    dec tos+1\n    .byt $2c ; BIT abs opcode, fall through to twoplus\n;--------------------------------------------------------------\n#if 0\nname=2+\nstack=( n -- n+2 )\ntags=nucleus,math,forth-83\nIncrement top of stack by 2\n\ntodo: code golf this together with slower tos2plus subroutine?\n#endif\ntwoplus\n    lda #2\nnplus\n    clc\n    adc tos\n    sta tos\n    bcc twoplus01\n    inc tos+1\ntwoplus01\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=3+\nstack=( n -- n+3 )\ntags=nucleus\n\n#endif\nthreeplus\n    lda #3\n    bne nplus                   ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=2/\nstack=( n -- n/2 )\ntags=forth-83,nucleus\n\n\n#endif\ntwoslash\n    lsr tos+1\n    ror tos\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=2*\nstack=( n -- n*2 )\ntags=nucleus\n\n#endif\ntwostar\n    asl tos\n    rol tos+1\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=ROT\nstack=( a b c -- b c a )\ntags=forth-83,nucleus\n\n\n#endif\nrot\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\n    ; fall through\nrots\n    ldy stackh+1,x\n    lda stackh,x\n    sta stackh+1,x\n    lda tos+1\n    sta stackh,x\n    sty tos+1\n    ldy stackl+1,x\n    lda stackl,x\n    sta stackl+1,x\n    lda tos\n    sta stackl,x\n    sty tos\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=THIRD\nstack=( n1 n2 n3 -- n1 n2 n3 n1 )\ntags=nucleus\n\n\n#endif\nthird\n    lda stackl+1,x\n    ldy stackh+1,x\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=3DUP\nstack=( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )\ntags=nucleus\nDuplicate the top three elements on the stack\n\n```\n: 3dup\n    2dup 4 pick -rot ;\n```\ncode version runs in about half the time for more than\ntwice the memory\n\n```\nthreedup\n    dex\n    dex\n    dex\n    lda tos+1\n    sta stackh+2,x\n    lda tos\n    sta stackl+2,x\n    lda stackh+4,x\n    sta stackh+1,x\n    lda stackl+4,x\n    sta stackl+1,x\n    lda stackh+3,x\n    sta stackh,x\n    lda stackl+3,x\n    sta stackl,x\n    jmp next\n```\n#endif\n#include \"align.i65\"\n_threedup\n    jsr enter\n#include \"page.i65\"\n    .word third\n#include \"page.i65\"\n    .word third\n#include \"page.i65\"\n    .word third\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=UNDER\nstack=( n1 n2 -- n1 n1 n2 )\ntags=nucleus\n\n Make a duplicate of the second stack element beneath `TOS`\n\n#endif\nunder\n    dex\n    lda stackh+1,x\n    sta stackh,x\n    lda stackl+1,x\n    sta stackl,x\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=+UNDER\nstack=( n1 n2 n3 -- n1+n3 n2 )\ntags=nucleus\n\n Add the top of stack to item underneath the second on stack\n\n#endif\nplusunder\n    lda #>(drop-1)\n    pha\n    lda #<(drop-1)\n    pha\n    clc\nplusunders\n    lda tos\n    adc stackl+1,x\n    sta stackl+1,x\n    lda tos+1\n    adc stackh+1,x\n    sta stackh+1,x\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=1+UNDER\nstack=( n1 n2 -- n1+1 n2 )\ntags=nucleus,extra\n\nIncrement second on stack.  Equivalent to `1 +under`\n\n#endif\noneplusunder\n    clc\n    ;\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\n    bcs oneminders\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=ONEPLUNDERS\nstack=( a b c d -- a b+1 c d )\ntags=nucleus,extra,subroutine,nosymbol\nIncrement stack at `x`.\n#endif\noneplunders\n    inc stackl,x\n    bne oneplunders01\n    inc stackh,x\noneplunders01\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=1-UNDER\nstack=( n1 n2 -- n1-1 n2 )\ntags=nucleus,extra\n\nDecrement second on stack.  Equivalent to `-1 +under`\n\n#endif\noneminusunder\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\n    ; fall through\noneminders\n    lda stackl,x\n    bne oneminders01\n    dec stackh,x\noneminders01\n    dec stackl,x\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=3C@\nstack=( addr -- d )\ntags=nucleus\n\n fetches three bytes as a double.  Useful for retrieving screen\n linewrap bits from the beginning of the block buffer or the jiffy\n clock\n\n msb addr+0\n\n 2sb addr+1\n\n lsb addr+2\n\n```\n: 3c@   ( addr -- d )\n     dup 1+ @ swap c@ ;\n\n```\n#endif\nthreecfetch\n    jsr slip\n    ldy #2\n    jsr fetchunders\n    jmp cfetch\n\nfetchunders\n    lda (tos),y         ; msb\n    sta stackl,x\n    dey\n    lda (tos),y\n    sta stackh,x\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=3C!\nstack=( d addr -- )\ntags=nucleus\n store low 3 bytes of d at addr in jiffy clock order\n\n|msb|addr|\n|2sb|addr+1|\n|lsb|addr+2|\n\nOrder inverted to write timer last for EVENTS\n\n```\n: 3c!    ( d addr -- )\n    2dup c!  nip 1+ ! ;\n\n```\n#endif\nthreecstore\n    ldy #2\n    lda stackl+1,x              ; lsb\n    sta (tos),y\n    dey\n    lda stackh+1,x              ; 2sb\n    sta (tos),y\n    dey\n    lda stackl,x                ; msb\n    sta (tos),y\n    jmp threedrop               ; discard 3 cells\n\n;    ldy #0\n;    lda stackl,x                ; msb\n;    sta (tos),y\n;    iny\n;    lda stackh+1,x              ; 2sb\n;    sta (tos),y\n;    iny\n;    lda stackl+1,x              ; lsb\n;    sta (tos),y\n;    inx                         ; discard 3 cells\n;    jmp twodrop\n\n;--------------------------------------------------------------\n#if 0\nname=FILL\nstack=( addr +howmany value -- )\ntags=forth-83,nucleus\n\n\n howmany has an upper limit of 32K bytes\n\n#endif\nfill\n    jsr harvests4               ; addr -> N0; howmany -> N1\n    lda #>(drop-1)\n    pha\n    lda #<(drop-1)\n    pha\nfills\n    clc\n    ;ldy #0\n    lda tos\nfill01\n    dec n+3\n    bpl fill02\n    sec             ; fill a partial page then exit\n    ldy n+2\n    beq fill03      ; nothing to do?\nfill02\n    dey\n    sta (n),y\n    bne fill02\n    inc n+1\n    bcc fill01\nfill03\n    rts\n    ;jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=ERASE\nstack=( addr howmany -- )\ntags=nucleus\n\n#endif\n#include \"align.i65\"\n_erase\n    jsr enter\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word fill\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=BLANK\nstack=( addr howmany -- )\ntags=nucleus\n\n#endif\n#include \"align.i65\"\n_blank\n    jsr enter\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word fill\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=-NULLS\nstack=( addr +n1 -- addr +n2 )\ntags=nucleus\n\n The character count +n1 of a text string beginning at addr\n is adjusted to exclude trailing nulls.  If +n1 is zero,\n then +n2 is also zero.  If the entire string consists of\n nulls, then +n2 is zero.\n\n```\n: -nulls   ( addr n1 -- addr n2 )\n     dup 0\n     ?do\n         2dup + 1- c@\n         0 <>\n     ?leave\n         1-\n     loop ;\n```\n#endif\ndashnulls\n    lda #$00\n    .byt $2c        ; BIT xxxx\n                    ; fall through\n\n;--------------------------------------------------------------\n#if 0\nname=-TRAILING\nstack=( addr +n1 -- addr +n2 )\ntags=nucleus,forth-83\n\n The character count +n1 of a text string beginning at addr\n is adjusted to exclude trailing spaces.  If +n1 is zero,\n then +n2 is also zero.  If the entire string consists of\n spaces, then +n2 is zero.\n\n```\n: -trailing   ( addr n1 -- addr n2 )\n     dup 0\n     ?do\n         2dup + 1- c@\n         bl <>\n     ?leave\n         1-\n     loop ;\n```\n#endif\ndashtrailing\n    lda stackl,x\n    sta n\n    clc\n    lda stackh,x\n    adc tos+1\n    sta n+1\n    ldy tos\n    lda #>(put-1)\n    pha\n    lda #<(put-1)\n    pha\ndashtrailings\n    lda #$20\n    sta n+2\ndashtrailing01\n    dey\n    cpy #$ff\n    bne dashtrailing02\n    dec tos+1\n    bmi dashtrailing03          ; `-trailing` will not work with 32K+ strings\ndashtrailing02\n    lda (n),y\n    eor n+2\n    beq dashtrailing01\ndashtrailing03\n    iny\n    tya\n    ldy tos+1\n    iny\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=CMOVE\nstack=( from to howmany -- )\ntags=forth-83,nucleus,memory\n\n\n\"~ see http://6502.org/source/general/memory_move.html\n#endif\ncmove\n    sec\n    .byt $29\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=CMOVE>\nstack=( from to howmany -- )\ntags=forth-83,nucleus,memory\n Move the u bytes beginning at address addr1 to\n addr2.  The move begins by moving the byte at\n (addr1 plus u minus 1) to (addr2 plus u minus 1)\n and proceeds to successively lower addresses\n for u bytes.  If u is zero nothing is moved.\n Useful for sliding a string towards higher addresses.\n\n#endif\ncmovegt\n    clc\n    jsr harvests4\n    stx z                       ; stash the data stack pointer\n    lda #>(drop-1)\n    pha\n    lda #<(drop-1)\n    pha\n    bcs cmoves+2\ncmovegts\n    ldx tos+1\n    clc\n    txa\n    adc n+1\n    sta n+1\n    clc\n    txa\n    adc n+3\n    sta n+3\n    inx\n    ldy tos\n    beq cmovegt03\n    dey\n    beq cmovegt02\ncmovegt01\n    lda (n),y\n    sta (n+2),y\n    dey\n    bne cmovegt01\ncmovegt02\n    lda (n),y\n    sta (n+2),y\ncmovegt03\n    dey\n    dec n+1\n    dec n+3\n    dex\n    bne cmovegt01\n    beq cmove03     ; bra\n\n;cmove, callable as a subroutine\n; Caller may clear Carry flag to copy < 256 bytes\ncmoves\n    bcc cmove02\n    ;sec            ; assume more pagers.\n    ldx #0\ncmove01\n    dec tos+1\n    bpl cmove02     ; do a whole page\n    ldx tos         ; last page\n    beq cmove03     ; none at all?\n; move X bytes from (N0) to (N1), restore X and return\n    clc             ; exit after this iteration\n; alternative cmove entry point, come here for shortest fastest bursts\n; caller be sure to `clc   stx z   ldy #0` first\ncmove02\n    lda (n),y\n    sta (n+2),y\n    iny\n    dex\n    bne cmove02\n    inc n+1\n    inc n+3\n    bcs cmove01\ncmove03\n    ldx z       ; revive the data stack pointer\n    rts\n    ;jmp drop    ; [37]\n\n;--------------------------------------------------------------\n#if 0\nname=MOVE\nstack=( from to howmany -- )\ntags=nucleus,memory\n Move the `howmany` bytes beginning at `from` to\n `to`.  Designed to prevent clobber if both memory regions\n overlap.\n\n```\n: move   ( from to howmany -- )\n     >r 2dup u< r> swap\n     ?: cmove> cmove ;\n\n\n     dup 2over u< nip  ?: cmove> cmove ;\n```\n#endif\n#include \"align.i65\"\n_move\n    jsr enter\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word twoover\n#include \"page.i65\"\n    .word ult\n#include \"page.i65\"\n    .word nip\n#include \"pass.i65\"\n    .word pquerycolon\n    .word cmovegt\n    .word cmove\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=+MOVE\nstack=( start end delta -- )\ntags=nucleus\n\n Move a block of memory between start and end (inclusive) to\n a new address calculated by adding the signed delta to start\n\n```\n for example, x = (5 of each letter)     AAAAABBBBBCCCCCDDDDD\n after  x 8 + x 11 + -7 +move, x becomes ABBCCBBBBBCCCCCDDDDD\n vidram dup 3+ 3+ 12 +move\n\n: +move   ( start end delta -- )\n    ?dup\n    if\n        >r over - 1+\n        over r> + swap move\n    else\n        2drop\n    then ;\n```\n#endif\n#include \"align.i65\"\n_plusmove\n    jsr enter\n#include \"page.i65\"\n    .word qdup\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(plusmove01-*+1)\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word oneplus               ; ( from howmany ) ( R; delta )\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word swap                  ; ( from to howmany )\n#include \"page.i65\"\n    .word _move\n#include \"pass.i65\"\n    .word branch\n    .byt <(plusmove02-*+1)\n#include \"page.i65\"\nplusmove01\n    .word twodrop\n#include \"pass.i65\"\nplusmove02\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=HERE\nstack=( -- addr )\ntags=nucleus,forth-83\n\n#endif\nhere\n    lda userdp\n    ldy userdp+1\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=PAD\nstack=( -- addr )\ntags=nucleus,forth-83\n\n The lower address of a scratch area used to hold data for\n intermediate processing.  The address or contents of PAD may\n change and the data lost if the address of the next\n available dictionary location is changed.  The minimum\n capacity of PAD is 84 characters.\n\n#endif\n#include \"align.i65\"\n_pad\n    jsr enter\n#include \"page.i65\"\n    .word here\n#include \"pass.i65\"\n    .word clit\n    .byt 80\n#include \"page.i65\"\n    .word plus\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=S>D\nstack=( s -- d )\ntags=nucleus\nsign-extends a single into a double\n#endif\n#include \"align.i65\"\n_stod\n    jsr enter\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word zlt\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=C>S\nstack=( c -- s )\ntags=nucleus\nsign-extends a character into a single\n#endif\nctos\n    ldy #0\n    lda tos\n    bpl ctos01\n    dey\nctos01\n    jmp put\n\n;--------------------------------------------------------------\n#if 0\nname=SGN\nstack=( n -- -1|0|1 )\ntags=nucleus\n\n return the sign of n\n\n#endif\nsgn\n    ldy #$ff\n    lda tos+1\n    bmi sgn01       ; negative\n    iny\n    ora tos\n    beq sgn01       ; zero\n    lda #1          ; positive\n    .byt $24        ; BIT zp to skip over tya\nsgn01\n    tya\n    jmp put\n\n;--------------------------------------------------------------\n#if 0\nname=RANDU\nstack=( -- r )\ntags=nucleus\n\n return a random byte in the range 0..255\n from the [[First Book of KIM-1|http://users.telenet.be/kim1-6502/6502/fbok.html]]. Also see [[RND]] and [[RANDOM]]\n\n#endif\nrandu\n    txa                         ; replaced `stx z` so this can be used in IRQ\n    pha\n    sec\n    lda randbuff+1\n    adc randbuff+4\n    adc randbuff+5\n    sta randbuff\n    ldx #4\nrpl\n    lda randbuff,x\n    sta randbuff+1,x\n    dex\n    bpl rpl\n    pla\n    tax\n    lda randbuff+1\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=RND\nstack=( -- r )\ntags=nucleus\n\n return a random number in the range 0..65535\n from the [[First Book of KIM-1|http://users.telenet.be/kim1-6502/6502/fbok.html]]\n\n#endif\nrnd\n    jsr randu\n    tay\n    .byt $2C\nranduc\n    ldy #0\nrandu2\n    jsr randu\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=RANDOM\nstack=( -- a )\ntags=nucleus\n\n Returns the address of the 6-byte random number buffer\n\n#endif\nrandom\n    jsr docreate\nrandbuff\n    .byt $08,$12,$b3,$16,$29,$62        ; random number seed\n\n;--------------------------------------------------------------\n#if 0\nname=1+!\nstack=( n -- )\ntags=nucleus\n\n increments the word addressed by n\n\n#endif\noneplusstore\n    ldy #$FF\n    lda #0\n    sec\noneplusstore01\n    iny\n    adc (tos),y\n    sta (tos),y\n    tya\n    beq oneplusstore01\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=1-!\nstack=( n -- )\ntags=nucleus\n\nDecrement the word of memory at address `n`\n\n#endif\noneminusstore\n    ldy #$ff\n    clc\nonemin01\n    iny\n    lda (tos),y\n    sbc #0\n    sta (tos),y\n    tya\n    beq onemin01\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=CHOOSE\nstack=( n1 n2 flag -- n )\ntags=nucleus,nosymbol\nReturns `n2` if `flag` is true, `n1` if false\n\nThis word is only here because I was using it in a few places,\n`choose` seemed like a good thing to name it.  Feel free to undo\nany of that.\n\n```\n: choose   ( n1 n2 flag -- n )\n    ?: nip drop ;\n```\n#endif\n#include \"align.i65\"\n_choose\n    jsr enter\n#include \"pass.i65\"\n    .word pquerycolon\n    .word nip\n    .word drop\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=>MINMAX\nstack=( n1 n2 -- n )\ntags=nucleus,nosymbol\nleverage similarities of [[MIN]] and [[MAX]]\n\n```\n: minmax   ( cfa == ; n1 n2 addr1 -- n )\n    <builds , does>             \\ defining word not built into asm source\n    3dup rot @ execute choose ;\n```\n#endif\n#include \"align.i65\"\ndominmax\n    jsr dodoes\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word third\n#include \"page.i65\"\n    .word third\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word execute\n#include \"page.i65\"\n    .word _choose\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=MIN\nstack=( n1 n2 -- n )\ntags=forth-83,nucleus\nReturns the lower of the two signed arguments\n\n```\n' >  minmax min\n```\n#endif\n#include \"align.i65\"\nmin\n    jsr dominmax\n    .word _gt\n\n;--------------------------------------------------------------\n#if 0\nname=MAX\nstack=( n1 n2 -- n )\ntags=forth-83,nucleus\nReturns the higher of the two signed arguments\n\n```\n' <  minmax max\n```\n#endif\n#include \"align.i65\"\nmax\n    jsr dominmax\n    .word lt\n\n;--------------------------------------------------------------\n#if 0\nname=M*\nstack=( n1 n2 -- d )\ntags=nucleus\n\n multiply two signed words, leaving the double product on the stack\n#endif\nmstar\n    jsr mult\n    jmp next\nmult\n    lda stackl,x\n    sta n+4\n    lda stackh,x\n    sta n+5\n    eor tos+1\n    php                     ; we only care about the sign bit\n    bit tos+1\n    bpl mult01\n    jsr donegate\nmult01\n    bit n+5\n    bpl mult02\n    sec\n    lda #0\n    sbc n+4\n    sta n+4\n    lda #0\n    sbc n+5\n    sta n+5\nmult02\n    jsr multiply\n    lda n+1\n    sta stackh,x\n    lda n\n    sta stackl,x\n    lda n+3\n    sta tos+1\n    lda n+2\n    sta tos\n    plp\n    bpl mult03\n    jmp dodnegate\nmult03\n    rts\n\n;--------------------------------------------------------------\n#if 0\nname=M*/\nstack=( n1 n2 n3 -- d )\ntags=nucleus\n\n multiplies n1*n2 giving an intermediate 16-bit value, and divides\n that by n3 yielding a 16-bit quotient.  Remainder is ignored,\n all values are signed.\n\n#endif\nmstarslash\n\n;--------------------------------------------------------------\n#if 0\nname=*\nstack=( n1 n2 -- n1*n2 )\ntags=forth-83,nucleus\n\n multiply two signed words\n#endif\nstar\n    jsr mult\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=/MOD\nstack=( n1 n2 -- n3 n4 )\ntags=forth-83,nucleus,todo\n\n n3 is the remainder and n4 the floor of the\n quotient of n1 divided by the divisor n2.  n3\n has the same sign as n2 or is zero.  An error\n condition results if the divisor is zero or if\n the quotient falls outside the range {-32,768\n ... 32,676}.\n~todo: should probably use ud/mod and then set signs\n~todo: division/modulo/multiplication words are kind of a mess\n\n```\n          division, floored\n               Integer division in which the remainder carries the sign of\n               the divisor or is zero, and the quotient is rounded to its\n               arithmetic floor.  Note that, except for error conditions,\n               n1 n2 SWAP OVER /MOD ROT * + is identical to n1.\n               See: \"floor, arithmetic\"\n               Examples:\n                    dividend  divisor  remainder  quotient\n                      10        7        3          1\n                     -10        7        4         -2\n                      10       -7       -4         -2\n                     -10       -7       -3          1\n```\n#endif\nslashmod\n    jsr doslashmod\n    jmp next\ndoslashmod\n    ;       lda stack+1,x\n    pha\n    ;       lda stack,x\n    pha\n    ;       lda stack+3,x\n    bpl doslashmod01\n    dey\ndoslashmod01\n    ;       sty stack,x\n    ;       sty stack+1,x\n    dex\n    dex\n    pla\n    ;       sta stack,x\n    pla\n    ;       sta stack+1,x\n    ldy #0\n;    jmp domslash\n\n;--------------------------------------------------------------\n#if 0\nname=/\nstack=( n1 n2 -- n3 )\ntags=forth-83,nucleus\n\n n3 is the floor of the quotient of n1 divided\n by the divisor n2.  An error condition results\n if the divisor is zero or if the quotient falls\n outside the range {-32,768 ... 32,767}.\n#endif\nslash\n    jsr doslashmod\n    ;       lda stack,x\n    ;       sta stack+2,x\n    ;       lda stack+1,x\n    ;       sta stack+3,x\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=MOD\nstack=( n1 n2 -- n3 )\ntags=forth-83,nucleus\n\n n3 is the remainder after dividing n1 by the\n divisor n2.  n3 has the same sign as n2 or is\n zero.  An error condition results if the\n divisor is zero or if the quotient falls out-\n side the range {32,768...32,768}.\n\n#endif\nmod\n    jsr doslashmod\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=*/MOD\nstack=( n1 n2 n3 -- n4 n5 )\ntags=forth-83,nucleus\n\n n1 is first multiplied by n2 producing an inter-\n mediate 32 bit result.  n4 is the remainder and\n n5 is the floor of the quotient of the inter-\n mediate 32-bit result divided by the divisor\n n3.  A 32-bit intermediate product is used for\n */ .  n4 has the same sign as n3 or is zero.\n An error condition results if the divisor is\n zero or if the quotient falls outside of the\n range {-32,768...32,767}.\n\n#endif\nstarslashmod\n    jsr dostarslashmod\n    jmp next\ndostarslashmod\n    ;       lda stack+1,x\n    pha\n    ;       lda stack,x\n    pha\n    inx\n    inx\n    jsr mult\n    dex\n    dex\n    pla\n    ;       sta stack,x\n    pla\n    ;       sta stack+1,x\n;    jmp domslash\n\n;--------------------------------------------------------------\n#if 0\nname=*/\nstack=( n1 n2 n3 -- n4 )\ntags=forth-83,nucleus\n\n n1 is first multiplied by n2 producing an inter-\n mediate 32-bit result.  n4 is the floor of the\n quotient of the intermediate 32-bit result\n divided by the divisor n3.  The product of n1\n times n2 is maintained as an intermediate 32-\n bit result for greater precision than the other-\n wise equivalent sequence n1 n2 * n3 / .  An\n error condition results if the divisor is zero\n or if the quotient falls outside the range\n {-32,768...32,767}.\n\n#endif\nstarslash\n    jsr dostarslashmod\n    ;       lda stack,x\n    ;       sta stack+2,x\n    ;       lda stack+1,x\n    ;       sta stack+3,x\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=PICK\nstack=( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )\ntags=forth-83,nucleus\n\n\n 0 pick = same as dup\n 1 pick = same as over\n#endif\npick\n    txa\n    clc\n    adc tos\n    tay\n    lda stackh,y\n    sta tos+1\n    lda stackl,y\n    sta tos\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=ROLL\nstack=( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )\ntags=forth-83,nucleus\nRemove the nth stack element (excluding n itself) to TOS, dropping n\n\n 2 roll = rot\n 1 roll = swap\n 0 roll has no effect\n\n\n```\nalternative code:\nr2d2\n    stx z\n    txa\n    clc\n    adc tos\n    tax\n    lda stackh,x\n    sta tos+1\n    lda stackl,x\n    sta tos\nr2d201\n    cpx z\n    beq r2d202\n    lda stackh-1,x\n    sta stackh,x\n    lda stackl-1,x\n    sta stackl,x\n    dex\n    bne r2d201\nr2d202\n    inx\n    jmp next\n```\n#endif\nroll\n    txa\n    clc\n    adc tos\n    tax\n    lda stackh,x\n    pha\n    lda stackl,x\n    pha\nroll01\n    inx\n    dec tos\n    bmi rput\n    dex\n    lda stackh-1,x\n    sta stackh,x\n    lda stackl-1,x\n    sta stackl,x\n    dex\n    bne roll01          ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=R>\nstack=( -- n ) ( R; n -- )\ntags=forth-83,nucleus,stack\nRemove the top value from the return stack and leave it on the\n        computation stack. See >R and R@\n\n!!! pronounced: \"r-from\"\n\n#endif\nrfrom\n    jsr slip\nrput\n    pla\n    sta tos\n    pla\n    sta tos+1\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=DEPTH\nstack=( -- n )\ntags=forth-83,nucleus\nReturns the depth of the data stack\n#endif\ndepth\n    txa\n    eor #$ff\n    sec\n    adc #<bos\n    jmp push0a\n\n;--------------------------------------------------------------\n#if 0\nname=>BIT\nstack=( bit# base -- mask addr )\ntags=nucleus,ext\nIndexes `bit#` bits into a bit array starting at `base`, returns a `mask` and\n`addr` for [[CBIT!]] or [[CBIT@]]\n\naddressing a bit field\n\nmask = 2^(n%8)\n\noffset = n/8\n\ne.g.\n\n```\n0 8192 >bit . . 8192 128  ok\n7 8192 >bit . . 8192 1  ok\n19 8192 >bit . . 8194 16  ok\n```\n\n\n```\n: >bit   ( bit# base -- mask offset )\n        over 7 and power2 + c@ -rot\n        swap 2/ 2/ 2/ + ;\n\n```\n#endif\ntobit\n    dex\n    lda stackh+1,x\n    lsr\n    sta stackh,x\n    lda stackl+1,x\n    pha\n    and #7\n    tay\n    lda power2,y\n    sta stackl+1,x\n    pla\n    ror\n    lsr stackh,x\n    ror\n    lsr stackh,x\n    ror\n    sta stackl,x\n    jmp plus01\n\n\n;--------------------------------------------------------------\n#if 0\nname=$!\nstack=( addr1 size addr2 -- )\ntags=string,nucleus,ext\nCopies `size` bytes from `addr1` to `addr2+1` as a counted string, storing\n`size` at `addr2`\n\ne.g. `2000 COUNT 2008 $!`\n\n|addr|before|after|h\n|2000|3|3|\n|2001|'F'|'F'|\n|2002|'O'|'O'|\n|2003|'O'|'O'|\n|2004|-|-|\n|2005|-|-|\n|2006|-|-|\n|2007|-|-|\n|2008|-|3|\n|2009|-|'F'|\n|200A|-|'O'|\n|200B|-|'O'|\n|200C|-|-|\n\n```\n: $!   ( addr1 size addr2 -- )\n    over c!+ swap move ;\n```\n#endif\n#include \"align.i65\"\n_dolstore\n    jsr enter\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word cstoreplus\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word _move\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=!+\nstack=( addr n -- addr+2 )\ntags=nucleus\n\nStores n at addr, returns the following address\n\nnote: Does an inverted store operation!\n\n!!! pronounced: \"store-plus\"\n\n`PAD 4096 0 DO I !+ LOOP DROP`\n\n* 109 jiffies, 11 bytes (Forth)\n* 245 jiffies, 7 bytes (Sweet16)\n* 65 jiffies, 25 bytes (6502)\n\n```\n_storeplus\n    jsr enter\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word twoplus\n#include \"pass.i65\"\n    .word exit\n\nstoreplus\n    brk\n    .byt ld | TOS\n    .byt st | N0\n    .byt pull\n    .byt ld | N0\n    .byt std | TOS\n    .byt nxt\n```\n#endif\nstoreplus\n    lda tos+1\n    pha\n    lda tos\n    pha\n    jsr slide\n    ldy #0\n    pla\n    sta (tos),y\n    iny\n    pla\n    sta (tos),y\n    jmp twoplus  ;[21]\n\n;--------------------------------------------------------------\n#if 0\nname=C!+\nstack=( addr c -- addr+1 )\ntags=nucleus,memory,primitive\nThe least-significant 8 bits of c are stored into the byte\nat addr, and addr is incremented by one\n\n!!!pronounced: \"c-store-plus\"\n#endif\ncstoreplus\n    ldy tos\n    jsr slide\n    tya\n    ldy #0\n    sta (tos),y\n    ; fall through\n;--------------------------------------------------------------\n#if 0\nname=1+\nstack=( n -- n+1 )\ntags=forth-83,nucleus\nAdd 1 to top of stack\n#endif\noneplus\n    lda #>(next-1)\n    pha\n    lda #<(next-1)\n    pha\n    ;fall through\n;--------------------------------------------------------------\n#if 0\nname=inctos\nstack=( n -- n+1 )\ntags=nosymbol\nincrement TOS; sets the Z flag\n#endif\ninctos\n    inc tos\n    bne inctos01\n    inc tos+1\ninctos01\n    rts\n\n#print (*-umstar)\n",
			"file": "core/src/core-nucleus.a65",
			"file_size": 60935,
			"file_write_time": 131545558533623803,
			"settings":
			{
				"buffer_size": 60935,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; core-vm.a65\n#echo .       core-vm.a65               Virtual Memory\n\n;--------------------------------------------------------------\n#if 0\nname=B/BUF\nstack=( -- 1024 )\ntags=const,forth-83\n!!!Constant\nbytes per buffer = 1024\n#endif\nbperbuf\n    jsr doconst\n    .word 1024\n\n;--------------------------------------------------------------\n#if 0\nname=B/SCR\nstack=( -- 1000 )\ntags=const,vm\n!!!Constant\nbytes per screen.  Not what it usually means in other Forths,\n(not blocks per screen = 1)\n#endif\nbperscr\n    jsr doconst\n    .word 1000\n\n;--------------------------------------------------------------\n#if 0\nname=CAS1BUF\nstack=( -- $027A )\ntags=const,vm\n!!!Constant\nAddress of the first tape buffer (device #1)\n#endif\ncas1buf\n    jsr doconst\n    .word CAS1BUF\n\n;--------------------------------------------------------------\n#if 0\nname=CAS2BUF\nstack=( -- $033A )\ntags=const,vm\n!!!Constant\nAddress of the second tape buffer (device #1)\nbase address of cassette buffer #2, used (for now) as a line buffer\nto unpack screens and blocks into lines\n#endif\ncas2buf\n    jsr doconst\n    .word CAS2BUF\n\n;--------------------------------------------------------------\n#if 0\nname=BLKBUF\nstack=( -- addr )\ntags=vm\nReturns the address of the 1K virtual memory block buffer.\n\nThere is only a single 1K fixed block buffer on the system, and\nall data and screen packets are retrieved from the packet buffer\nthrough it.\n\nCopying a block to a different block can be achieved by using [[PAD]] as\ntemporary storage.  When [[REHASH]] rebuilds the symbol\ntable, it performs [[automatic memory allocation|AUTOMEM]]\nand may move `BLKBUF` (and its contents) to a new location.\n\n!!! pronounced: \"b-l-k-buff\"\n\n```\n: blkbuf   ( -- addr )\n    symtab @  ?: symtab memsiz  @ b/buf - ;\n```\n#endif\n#include \"align.i65\"\n_blkbuf\n    jsr enter\n#include \"page.i65\"\n    .word symtab\n#include \"page.i65\"\n    .word fetch\n#include \"pass.i65\"\n    .word pquerycolon\n    .word symtab\n    .word memsiz\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word bperbuf\n#include \"page.i65\"\n    .word minus\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=WRAP^\nstack=( logline -- d )\ntags=editor,primitive\n\n Reads a portion of the linewrap table above the requested\n `logline`, up to but not including `logline`.\n\n Returns a right-aligned double with a copy of those high bit values\n\n!!!pronounced: \"wrap-above\"\n#endif\nwrapabove\n    stx z                       ; preserve Forth data stack pointer\n    ldx #0\n    stx n+1\n    stx n\n    stx tos+1\n    ldy tos                     ; first physical line of this logical line\n    stx tos\n    tya\n    beq wrapabove03\n    sty n+2\n    dex\nwrapabove02\n    inx\n    cpx n+2                     ; are we there yet?\n    beq wrapabove03             ; leave if done\n    lda $e0,x\n    asl                         ; nondestructively\n    rol tos\n    rol tos+1\n    rol n\n    rol n+1                     ; append the next high bit to the double\n    beq wrapabove02             ; this should always take the branch\nwrapabove03\n    lda n\n    ldy n+1                     ; high half of the double is going on the stack\n    ldx z                       ; restore Forth data stack pointer\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=RLENCODE\nstack=( from to size -- targend uncompressed? )\ntags=vm,sweet16\nThis works a lot like `cmove` with its `from to howmany` stack signature, but\nthe target is a `packet` of `virtual memory` that can be permanently stored\nto cassette tape.  The other difference is the two return values provided by\n`rlencode`.\n\n* `targend` End of the compressed|stored output\n* `uncompressed?` Flag reveals whether RLE compression was used.\n\nencode length {srclen} bytes from source address {srcaddr} to\ntarget address {targaddr}.  Return target end address {targend}\n#endif\nrlencode\n    ; tos   src (pristine)\n    ; n0    src (in)\n    ; n1    size (in)\n    ; n2    targ (out)\n    ; n3    size (out)\n    ; n4    repeat\n    ; n5    prev\n    ; n6    $100\n    ; n7    targ (pristine)\n    ; n8    size (pristine)\n    brk\n    .byt ld | TOS               ; size\n    .byt st | N1                ; size (in)\n    .byt st | N3                ; size (out)\n    .byt st | N8                ; size (pristine)\n    .byt pull                   ; to\n    .byt st | N2                ; targ (out)\n    .byt st | N7                ; targ (pristine)\n    .byt pull                   ; from -- TOS = src (pristine)\n    .byt st | N0                ; src (pristine)\n    .byt set | N6               ; constant to initialize repeat counter\n    .word $100\nrlencode01\n    .byt ld | N6                ; also unfindable character\nrlencode02\n    .byt st | N5                ; prev character\n    .byt ld | N3\n    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?\n    .byt ld | N1\n    .byt bz , <(rlencode06-*-2) ; done with input?\n    .byt ldi | N0               ; read input stream\n    .byt dcr | N1\n    .byt sti | N2               ; write output stream\n    .byt dcr | N3\n    .byt cpr | N5               ; compare to prev\n    .byt bnz , <(rlencode02-*-2) ; different? go get more\n    .byt ld | N6\n    .byt st | N4                ; count backwards from 256\n    .byt dcr | N4               ; count the one already in output stream\nrlencode03\n    .byt dcr | N4\n    .byt bz , <(rlencode04-*-2) ; overflow?\n    .byt ld | N1\n    .byt bz , <(rlencode04-*-2) ; end of input?\n    .byt ldi | N0               ; get from input stream\n    .byt dcr | N1\n    .byt cpr | N5\n    .byt bz , <(rlencode03-*-2) ; same char? loop\n\n    .byt dcr | N0               ; different char?\n    .byt inr | N1               ; un-get from input stream\nrlencode04                      ; overflow/end of input\n    .byt ld | N6\n    .byt sub | N4\n    .byt sti | N2               ; write count to output stream\n    .byt dcr | N3\n    .byt br , <(rlencode01-*-2)\n\nrlencode06                      ; win\n    .byt ld | N2                ; targ (out)\n    .byt st | TOS\n    .byt sub | ACC\n    .byt push\n    .byt nxt\n;    rlencode\n;( targend uncompressed?        ; floor  pkt )\n\nrlencode07                      ; lose - copy\n    .byt ld | TOS\n    .byt st | N0                ; keep pristine TOS\n    .byt ld | N8                ; size\n    .byt add | N7               ; +pristine targ\n    .byt st | TOS\n    .byt set | ACC\n    .word $4000\n    .byt push\n    .byt ld | N0\n    .byt push\n    .byt ld | N7\n    .byt push\n    .byt ld | N8\n    .byt push\n    .byt rtn\n    jmp cmove\n\n;--------------------------------------------------------------\n#if 0\nname=RLDECODE\nstack=( from to size -- )\ntags=vm,sweet16\ndecode length {srclen} bytes beginning at source address\n{srcaddr} to the target address (targaddr).\n#endif\nrldecode\n    jsr harvests4\n    brk\n    .byt set | N4\n    .word $100\nrldecode01\n    .byt ld | N4\n    .byt st | N2                ; set prev to unmatchable value\nrldecode02\n    .byt ld | TOS\n    .byt bz , <(rldecode06-*-2)\n    .byt dcr | TOS              ; decrement source counter\n    .byt ldi | N0               ; read source stream\n    .byt sti | N1               ; write target stream\n    .byt cpr | N2\n    .byt st | N2\n    .byt ld | R13\n    .byt bnz , <(rldecode02-*-2) ; different? go get more\nrldecode03\n    .byt dcr | TOS              ; decrement source counter\n    .byt ldi | N0               ; get the repeat count\n    .byt bnz, <(rldecode04-*-2)\n    .byt ld | N4\nrldecode04\n    .byt st | N3\n    .byt dcr | N3\n    .byt bz , <(rldecode01-*-2)\nrldecode05\n    .byt dcr | N3\n    .byt bz , <(rldecode01-*-2)\n    .byt ld | N2\n    .byt sti | N1               ; write target stream\n    .byt br , <(rldecode05-*-2)\nrldecode06\n    .byt pull                   ; drop srclen\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=NEXT>R\nstack=( -- R; next-1 )\ntags=inner\nPushes the address `next-1` to the return stack so invoking\na subroutine afterward will `rts` to `next`.  Effectively\nconverts a subroutine to a Forth primitive.\n\npronounced: \"next to R\"\"\n\n```\n: next>r   ( -- R; next-1 )\n    [ 'next 1- ] cliteral r> 2>r ;\n```\n#endif\n#include \"align.i65\"\n_nexttor\n    jsr enter\n#include \"pass.i65\"\n    .word clit\n    .byt <(next-1)\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word twotor\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PKT.SIZE\nstack=( packet -- packet size )\ntags=vm\nReturns the packet length from a packet header.  The term `size` includes the 2\nbyte packet header, where a packet's `length` is just the contents (`size-2`).  The subroutine mode replaces the packet address at\n`tos` with the length.  When called as a Forth word, `PKT.SIZE`\npushes the length to `tos` leaving the packet address unchanged\nat `2os`.\n\npronounced: \"packet-size\"\n\n```\n: pkt.size   ( packet -- packet size )\n    dup @ $7ff and ;\n```\n#endif\n#include \"align.i65\"\n_pktsize\n    jsr enter\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word fetch\n#include \"pass.i65\"\n    .word plit\n    .word $07ff\n#include \"page.i65\"\n    .word andx\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=>PKT\nstack=( n -- packet )\ntags=vm,ext\nReturn the packet address of block N\n\n```\n: >pkt   ( n -- packet )\n    blkbuf 2-\n    begin\n        over\n    while\n        pkt.size\n        - -1 +under\n    repeat\n    nip ;\n```\n#endif\n#include \"align.i65\"\n_topkt\n    jsr enter\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word twominus\n#include \"page.i65\"\ntopktb01\n    .word over\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(topktb02-*+1)\n#include \"page.i65\"\n    .word _pktsize\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word minusone\n#include \"page.i65\"\n    .word plusunder\n#include \"pass.i65\"\n    .word branch\n    .byt <(topktb01-*+1)\n#include \"page.i65\"\ntopktb02\n    .word nip\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PKT.INFO\nstack=( packet -- floor length uncompressed? isscr? )\ntags=vm,nosymbol\nReturns the floor, length and flags from a packet header.  [[SCRPKT]]\nis $8000 for screen packets, 0 for data packets.  the `uncompressed?`\nvalue is $4000 for uncompressed packets, 0 for [[RLENCODE]]d packets.\nThe term `size` also includes the 2 byte packet header, while a\npacket's `length` is just the contents (`size-2`)\n\npronounced: \"packet-info\"\n\n```\n: pkt.info   ( block -- floor length uncompressed? isscr? )\n    >pkt dup>r pkt.size 2- dup>r -\n    r> r> @ dup>r $4000 and r> vidram and scrpkt ! ;\n```\n#endif\n#include \"align.i65\"\npktinfo\n    jsr enter\n#include \"page.i65\"\n    .word _topkt\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word _pktsize\n#include \"page.i65\"\n    .word twominus\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word duptor\n#include \"pass.i65\"\n    .word plit\n    .word $4000\n#include \"page.i65\"\n    .word andx\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word vidram\n#include \"page.i65\"\n    .word andx\n#include \"page.i65\"\n    .word scrpkt\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=EDITING?\nstack=( -- flag )\ntags=vm,ext\nRetrieves the EDITING user variable\n\n```\n: editing?\n    editing @ ;\n```\n#endif\neditingq\n    lda userediting\n    ldy userediting+1\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=ISSCR?\nstack=( -- flag )\ntags=vm,ext\nRetrieves the [[SCRPKT]] user variable, which describes whether the current\npacket type is screen (true) or data (false)   ~wut? calculate this instead\n\n```\n: isscr?   ( -- flag )\n    scrpkt @ ;\n```\n#endif\nisscrq\n    lda userscrpkt\n    ldy userscrpkt+1\n    jmp pushya\n\n;--------------------------------------------------------------\n#if 0\nname=PKT+\nstack=( addr size -- floor )\ntags=vm,ext,nosymbol\ninserts a new packet at address.\n\n```\n: pkt+   ( addr size -- floor )\n    >r vmbuf @ over 1+\n    r@ negate  dup vmbuf +!  +move\n    r@ over !\n    r> - 2+ ;\n```\n#endif\n#include \"align.i65\"\n_pktplus\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word vmbuf\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word negate\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word vmbuf\n#include \"page.i65\"\n    .word plusstore\n#include \"page.i65\"\n    .word _plusmove\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word twoplus\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=RLE+\nstack=( pkt -- floor )\ntags=vm,ext,nosymbol\nConverts the given packet into a maximum-sized packet so it may be used\nas a temporary buffer by [[RLENCODE]]. This is a design-around to avoid\nadding a second [[BLKBUF]] block buffer to the system.  Returns the\naddress of the beginning of the 1K temporary buffer.\n\n```\n: rle+   ( pkt -- floor )\n    dup>r  b/buf dup 2+ r@ pkt.len\n    >r 2- over r> - pkt+ drop\n    r> ! - ;\n```\n#endif\n#include \"align.i65\"\n_rleplus\n    jsr enter\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word bperbuf\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word twoplus\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word _pktsize\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word twominus\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word _pktplus\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word minus\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=MKPKTS\nstack=( n -- )\ntags=vm,ext,nosymbol\nconcatenates `n+1` new packets at the tail of the [[VMBUF]] area\n\n```\n: mkpkts   ( n -- )\n    begin\n        #blk 1+!  vmbuf @  editing?\n        if\n            dup>r 5 pkt+ dup on 1+ on vidram r> +!\n        else\n            2 pkt+ drop\n        then\n        1- 0<\n    until drop ;\n```\n#endif\n#include \"align.i65\"\n_mkpkts\n    jsr enter\n#include \"page.i65\"\nmkpkts01\n    .word numblk\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word vmbuf\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word editingq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(mkpkts02-*+1)\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word five\n#include \"page.i65\"\n    .word _pktplus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word on\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word on\n#include \"page.i65\"\n    .word vidram\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word plusstore\n#include \"pass.i65\"\n    .word branch\n    .byt <(mkpkts03-*+1)\n#include \"page.i65\"\nmkpkts02\n    .word two\n#include \"page.i65\"\n    .word _pktplus\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\nmkpkts03\n    .word oneminus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word zlt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(mkpkts01-*+1)\n#include \"page.i65\"\n    .word drop\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=?MKPKTS\nstack=( blk -- )\ntags=vm,ext,nosymbol\nUsed by [[BLOCK]] to create empty packets.  If `blk` references a packet\nhigher than  [[#BLK]], generates new packets at the tail of the buffer\n(screen or data, based on [[EDITING]])\n\n```\n: ?mkpkts   ( blk -- )\n    #blk @ - dup 0<\n    ?: drop mkpkts ;\n```\n#endif\n#include \"align.i65\"\n_qmkpkts\n    jsr enter\n#include \"page.i65\"\n    .word numblk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word zlt\n#include \"pass.i65\"\n    .word pquerycolon\n    .word drop\n    .word _mkpkts\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=WRAP!\nstack=( wrapd -- )\ntags=nosymbol\n\nUpdates the linewrap table at $E1-F8 to reflect the low 24 bits\nin double `wrapd`.  Since line 0 ($E0) is never a continuation\nline, (always $80) it is not written to.  Only 24 bits are\nwritten to $E1-$F8, not 25.  Although unused, the most\nsignificant (2^24) bit may be set, as a framing bit, used\nto detect when the wrap double is full.\n\n#endif\nwrapstore\n    jsr harvests2\n    stx z\n    ldx #24\nwrapstore01\n    asl $e0,x\n    lsr tos+1\n    ror tos\n    ror n+1\n    ror n\n    ror $e0,x\n    dex\n    bne wrapstore01\n    ldx z\n    jmp drop\n\n;--------------------------------------------------------------\n#if 0\nname=SCR0\nstack=( -- )\ntags=vm,nosymbol\nReset [[SCR]] and [[BLK]] to screen/block 0.\n\n```\n: scr0   ( -- )\n    blk off  scr off ;\n```\n#endif\n#include \"align.i65\"\n_scr0\n    jsr enter\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word storeplus\n#include \"page.i65\"\n    .word off\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=#BLK!\nstack=( -- )\ntags=vm\nReset virtual memory user variables for `LOAD-BUFFERS` or `EMPTY-BUFFERS`\n\n~ It should also validate flags and max-lengths, error out on corrupt VMBUF\n\n```\n: #blk!   ( -- )\n    #blk off  blkbuf 2-\n    begin\n        pkt.size ?dup\n    while\n        #blk 1+!\n        -\n    repeat\n    vmbuf ! ;\n\n```\n#endif\n#include \"align.i65\"\n_numblkstore\n    jsr enter\n#include \"page.i65\"\n    .word numblk\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word twominus\n#include \"page.i65\"\nnumblkstore01\n    .word _pktsize\n#include \"page.i65\"\n    .word qdup\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(numblkstore02-*+1)\n#include \"page.i65\"\n    .word numblk\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word minus\n#include \"pass.i65\"\n    .word branch\n    .byt <(numblkstore01-*+1)\n#include \"page.i65\"\nnumblkstore02\n    .word vmbuf\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=EMPTY-BUFFERS\nstack=( -- )\ntags=i/o,forth-83\nUnassign all virtual memory.  UPDATEed blocks are not written\nto mass storage.\n\n```\n: empty-buffers   ( -- )\n    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;\n```\n#endif\n#include \"align.i65\"\n_emptybuffers\n    jsr enter\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word twominus\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _scr0\n#include \"page.i65\"\n    .word _numblkstore\n#include \"pass.i65\"\n    .word exit\n\n\nstashforth01 .byt 0             ; temp storage for X register during tape I/O\n\n;--------------------------------------------------------------\n#if 0\nname=STASH-FORTH\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol,magic-number\nSubroutine to preserve the data stack pointer, stack, Sweet16 and\nother Forth zero page during a BASIC system call\n\n#endif\nstashforth\n    stx 2                       ; $FF (z) gets messed up by save!  Use $02\n    jsr aloha2\n    lda #2                      ; set direct mode in CHRGET routine\n    sta $78                     ; so we get prompts during i/o\n    rts\n;--------------------------------------------------------------\n#if 0\nname=RESTORE-FORTH\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\nRestore Forth stack after BASIC system call\n\n#endif\nrestoreforth\n    jsr aloha2\n    ldx 2                       ; this messes up BASIC's USR() function\n    jmp exit\n\n;--------------------------------------------------------------\n#if 0\nname=DOTAPEIO\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\nPerform a ROM call framed between calls to [[Aloha]]. This is\nneeded in particular for tape I/O, which might error out to a\nCommodore BASIC `ready.` prompt.\n\nLike [[EXECUTE]] and the Sweet-16 interpreter, this word\nuses the machine stack ($0100-$01ff) and RTS trick to transfer\ncontrol from one subroutine to the next, so that code executes\nin this order:\n\ntodo: this is a little crashy returning from hitting the [[STOP]] key\n\n```\nstashforth\nRTS\ncaller's ROM routine\nRTS\nrestoreforth\nEXIT\n```\n#endif\n#include \"align.i65\"\n_dotapeio\n    jsr enter\n#include \"pass.i65\"\n    .word plit\n    .word restoreforth-1\n#include \"page.i65\"\n    .word caller\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word oneminus\n#include \"page.i65\"\n    .word twotor\n#include \"pass.i65\"\n    .word stashforth\n\n;--------------------------------------------------------------\n#if 0\nname=(SAVEPRG)\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\n#endif\npsaveprg\n    jsr _dotapeio\n    .word SAVEPRG\n\n;--------------------------------------------------------------\n#if 0\nname=(READHEAD)\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\n#endif\npreadhead\n    jsr _dotapeio\n    .word READHEAD\n\n;--------------------------------------------------------------\n#if 0\nname=(READDATA)\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\n#endif\npreaddata\n    jsr _dotapeio\n    .word READDATA\n\n;--------------------------------------------------------------\n#if 0\nname=CURRNAME\nstack=( -- addr )\ntags=vm,i/o\nCurrent filename\n\ntodo: All parameter and no code, maybe a string variable?\n#endif\ncurrname\n    .byt (currname01-*-1)\n    .asc \"PETTILPACKETS\",\ncurrname01\n    .asc              \"           \"\n        ;\"@0:full16characters,s,w \"\n        ; 123456789.123456789.1234\n\n;--------------------------------------------------------------\n#if 0\nname=FILE\nstack=( filename device secondary -- )\ntags=vm,i/o\nSet up parameters for file i/o\n\n```\n: file\n    sa# ! drv# ! filename ! ;\n```\n#endif\n#include \"align.i65\"\n_file\n    jsr enter\n#include \"page.i65\"\n    .word sanum\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word drvnum\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word filename\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(FILE)\nstack=( -- )\ntags=vm,i/o,nosymbol\nCalled at start of tape or disk i/o, sets up zero page variables.\nRetrieves DRV# SA# and FILENAME uservariables and stores them\nin zero page locations FA SA FNLEN FNADR.\n\nRelies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea\n\n|zero page|<|value|set by|description|h\n|^STATUS|^96|^0|rom|^i/o status byte|\n|^VERCK|^9d|^0|(file)|^0=load; 1=verify|\n|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|\n|^SAL|^c7-c8|^||^start address|\n|^EAL|^c9-ca|^||^end address|\n|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|\n|^LA|^d2|^0|(file)|^logical file #|\n|^SA|^d3|^SA#|(prg-file)|Secondary address|\n|^FA|^d4|^DRV#|(file)|Device number|\n|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|\n|^STAL|^fb-fc|^||^start address|\n\n|save|load|verify|open|name|address|description|h\n|^?|^?|^?|^?|^FNLEN|^d1|^Length of current file name|\n|^?|^?|^?|^?|^FNADR|^da-db|^File name address|\n|^&nbsp;|<|<|<|<|<|<|\n|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|\n|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|\n|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|\n|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|\n|^?|^?|^?|^?|^LA|^d2|^Current logical file number|\n|^?|^?|^?|^?|^SA|^d3|^Current secondary address|\n|^?|^?|^?|^?|^FA|^d4|^First address (device number)|\n|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|\n|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|\n|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|\n|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f\n\n#endif\npfile\n    brk\n    .byt set | N0\n    .word userfilename\n    .byt ldd | N0               ; FILENAME\n    .byt st | N2                ; pointer to FILENAME[0] or 0\n    .byt bz , <(pfile01-*-2)\n    .byt ldi | N2\npfile01\n    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET\n    .word FNLEN\n    .byt sti | N1               ; set FNLEN ($d1)\n\n;    .byt set | N1\n;    .word LA\n    .byt sub | ACC              ; 0\n    .byt sti | N1               ; set LA ($d2)\n\n;    .byt set | N1\n;    .word SA\n    .byt ldd | N0               ; get SA#\n    .byt sti | N1               ; set SA ($d3)\n\n;    .byt set | N1\n;    .word FA\n    .byt ldd | N0               ; DRV#\n    .byt sti | N1               ; set FA ($d4)\n\n    .byt set | N1\n    .word FNADR\n    .byt ld | N2\n    .byt std | N1               ; set FNADR ($da)\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=(PRG-FILE)\nstack=( -- )\ntags=vm,i/o,nosymbol\nTurn off SA# and set up for PRG file tape i/o\n\n* sets SA# = 0\n* sets TAPEID = 1\n* invoke [[(FILE)]]\n** copy `SA#` to SA\n** copy `DRV#` to FA\n** copy `FILENAME` to FNADR, FNLEN\n** set TAPEID to $01 (PRG)\n** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)\n\n```\n: (prg-file)   ( -- )\n    sa# off  1 TAPEID c!  (file) ;\n```\n#endif\n#include \"align.i65\"\n_pprgfile\n    jsr enter\n#include \"page.i65\"\n    .word sanum\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word one\n#include \"pass.i65\"\n    .word clit                  ; ~ can remove this if using $f619\n    .byt TAPEID\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word pfile\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(VMBUF)\nstack=( -- from to )\ntags=vm,kernel,nosymbol\nReturns the end and start of the virtual memory buffer\n\n```\n: (vmbuf)   ( -- vmbuf blkbuf )\n    vmbuf @  blkbuf ;\n```\n#endif\n#include \"align.i65\"\n_pvmbuf\n    jsr enter\n#include \"page.i65\"\n    .word vmbuf\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word _blkbuf\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(CASBUF)\nstack=( -- 027a|033a )\ntags=vm,kernel,nosymbol\nReturns the tape buffer address for most recently accessed\ndevice `FA ($d4)`\n\n```\n: (casbuf)   ( -- 027a|033a )\n    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;\n```\n#endif\ncasbuf\n    brk\n    .byt ext\n    .word SETCASBUF\n    .byt set | N0\n    .word TAPE1\n    .byt ldd | N0\n    .byt push\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=SAVE-BUFFERS\nstack=( -- )\ntags=vm,forth-83,i/o,kernel\nWrites the virtual memory area between [[VMBUF]] and [[BLKBUF]] out\nto a PRG file on cassette or disk\n\nAlso called by STOP-S in the editor\n\n```\n: save-buffers   ( -- )\n    (prg-file)\n    (vmbuf) next-1\n    >r 2>r\n    [ SETEALSTAL , ]\n    (saveprg) ;\n```\n#endif\n#include \"align.i65\"\n_savebuffers\n    jsr enter\n#include \"page.i65\"\n    .word _pprgfile             ; set up z.p. device, secondary, filename\n#include \"page.i65\"\n    .word _pvmbuf\n#include \"pass.i65\"\n    .word clit\n    .byt <(next-1)              ; stupid stack tricks\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word twotor\n#include \"page.i65\"\n    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT\n#include \"page.i65\"\n    .word psaveprg\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(LOADVERIFY)\nstack=( -- )\ntags=vm,i/o,kernel,nosymbol\nLoad or compare a batch of packets from tape to [[VMBUF]]\n\n```\n: (loadverify)   ( flag -- )\n    [ VERCK ] literal c!\n    (prg-file) (readhead)\n    blkbuf dup (casbuf) 1+ dup>r\n    2@ - - r> 2! ;\n```\n#endif\n#include \"align.i65\"\n_ploadverify\n    jsr enter\n#include \"pass.i65\"\n    .word clit\n    .byt VERCK\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word _pprgfile\n#include \"page.i65\"\n    .word preadhead\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word casbuf\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word twofetch\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word twostore\n#include \"page.i65\"\n    .word preaddata\n#include \"page.i65\"\n    .word _scr0\n#include \"page.i65\"\n    .word _numblkstore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=LOAD-BUFFERS\nstack=( -- )\ntags=vm,i/o,kernel\nLoad a batch of packets from the file to [[VMBUF]]\n\ncalled by STOP-L in the editor\n\n```\n: load-buffers   ( -- )\n    0 (loadverify) ;\n```\n#endif\n#include \"align.i65\"\n_loadbuffers\n    jsr enter\n#include \"page.i65\"\n    .word zero                  ; LOAD\n#include \"page.i65\"\n    .word _ploadverify\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=VERIFY-BUFFERS\nstack=( -- )\ntags=vm\nVerifies the [[VMBUF]] area following a write\n\ncalled by STOP-V in the editor\n\n```\n: verify-buffers   ( -- )\n    1 (loadverify)\n    ST c@  if  .\" error\"  then ;\n```\n#endif\n#include \"align.i65\"\n_verifybuffers\n    jsr enter\n#include \"page.i65\"\n    .word one                   ; VERIFY\n#include \"page.i65\"\n    .word _ploadverify\n#include \"pass.i65\"\n    .word clit\n    .byt STATUS\n#include \"page.i65\"\n    .word cfetch\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(verifybuffers05-*+1)\n#include \"pass.i65\"\n    .word _pdq\n    .byt (verifybuffers06-*-1)\n    .asc \"ERROR\"\nverifybuffers06\n#include \"pass.i65\"\nverifybuffers05\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SRCTARG\nstack=( -- var buffer size char  )\ntags=vm,ext,nosymbol\n[[BLOCK]] packs from or unpacks to [[VIDRAM]] or [[BLKBUF]], based on [[EDITING?]] and [[SCRPKT?]]\n\n~ horrible name\n\n```\n: srctarg   ( -- scr|blk vidram|blkbuf b/scr|b/buf bl|0 )\n    editing?\n    dup  ?: scr blk\n    swap ?: vidram blkbuf\n    scrpkt?\n    dup  ?: b/scr b/buf\n    swap ?: bl 0 ;\n```\n#endif\n#include \"align.i65\"\n_srctarg\n    jsr enter\n#include \"page.i65\"\n    .word editingq\n#include \"page.i65\"\n    .word dup\n#include \"pass.i65\"\n    .word pquerycolon\n    .word scr\n    .word blk\n#include \"page.i65\"\n    .word swap\n#include \"pass.i65\"\n    .word pquerycolon\n    .word vidram\n    .word _blkbuf\n#include \"page.i65\"\n    .word isscrq\n#include \"page.i65\"\n    .word dup\n#include \"pass.i65\"\n    .word pquerycolon\n    .word bperscr\n    .word bperbuf\n#include \"page.i65\"\n    .word swap\n#include \"pass.i65\"\n    .word pquerycolon\n    .word bl\n    .word zero\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=BLOCK\nstack=( blk -- buf )\ntags=vm,fig,forth-79,forth-83\nRetrieves and decompresses a screen or data block from the [[VMBUF]]\n[[region|PETTIL system memory map]]. This is PETTIL's top of the food\nchain for reading packets, the antonym of [[UPDATE]] (which writes\npackets).\n\nThe table below summarizes how `BLOCK` functions based on whether the\nuser is in the editor or not, and whether the packet is screen or data.\n\n|^[[EDITING?]] |<|packet# sets [[SCR]]<br>returns [[VIDRAM]]|\n|>|^ [[SCRPKT?]]|[[VIDRAM]] initialized to spaces<br>linewrap stored to zero page<br>write 1000-byte packet to [[VIDRAM]]|\n|>|^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not [[SCRPKT?]]|[[VIDRAM]] initialized to nulls<br>zero page linewrap table set to all 40-column<br>displays first 1000 characters of data block|\n||<|<|\n|^not [[EDITING?]] |<|packet# sets [[BLK]]<br>returns [[BLKBUF]]|\n|>|^ [[SCRPKT?]]|[[BLKBUF]] initialized to spaces<br>linewrap stored in first three bytes of [[BLKBUF]]<br>followed by 1000-bytes of screencodes|\n|>|^ not [[SCRPKT?]]|[[BLKBUF]] initialized to nulls<br>1024 bytes of data expanded to [[BLKBUF]]|\n\n```\n: block\n    dup ?mkpkts     \\ create packets if they don't exist yet\n    dup pkt.info    \\ ( blk floor len uncompressed? )\n    rot srctarg 3dup nip\n    b/buf swap fill 2drop 2>r r@ scrpkt?\n    if              \\ ( blk len uncompressed? floor\n                    \\ vidram|blkbuf scrpkt?\n                    \\ R; vidram|blkbuf scr|blk )\n        drop rot 3- -rot 3+ dup 3- 3c@ editing?\n        if\n            wrap! r@\n        else\n            r@ 3c! r@ 3+\n        then\n    then\n    2swap  ?: cmove rldecode\n    2r> -rot ! ;\n```\n#endif\n#include \"align.i65\"\n_block\n    jsr enter\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n   .word _qmkpkts\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word pktinfo\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word _srctarg\n#include \"page.i65\"\n    .word _threedup\n#include \"page.i65\"\n    .word nip\n#include \"page.i65\"\n    .word bperbuf\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word fill\n#include \"page.i65\"\n    .word twodrop\n#include \"page.i65\"\n    .word twotor\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word isscrq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(block02-*+1)\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word threeminus\n#include \"page.i65\"\n    .word dashrot\n#include \"page.i65\"\n    .word threeplus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word threeminus\n#include \"page.i65\"\n    .word threecfetch\n#include \"page.i65\"\n    .word editingq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(block01-*+1)\n#include \"page.i65\"\n    .word wrapstore\n#include \"page.i65\"\n    .word rfetch\n#include \"pass.i65\"\n    .word branch\n    .byt <(block02-*+1)\n#include \"page.i65\"\nblock01\n    .word rfetch\n#include \"page.i65\"\n    .word threecstore\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word threeplus\n#include \"page.i65\"\nblock02\n    .word twoswap\n#include \"pass.i65\"\n    .word pquerycolon\n    .word cmove\n    .word rldecode\n#include \"page.i65\"\n    .word tworfrom\n#include \"page.i65\"\n    .word dashrot\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(UPD1)\nstack=( from to howmany char -- )\ntags=vm,nosymbol\nReorganize the stack from some raw, disorganized pointers and\nvalues.  Returns enough to open up a 1024 byte hole in the\nVM buffer and trim trailing blanks/nulls from the source buffer,\nalong with a couple values that are required later.\n\n( src srcbufsiz pkt vmbuf maxbufsiz 0 )\n\n||^data|^editing<br/>screen|<|h\n|TOS|0|<|<|\n|N0|blkbuf|vidram|src|\n|N1|b/buf|b/scr|srcbufsiz|\n|N2|pkt|<|dst|\n|N3|pktsize|<||\n|N4|vmbuf|<|bottom|\n|N5|b/buf|<|maxbufsiz|\n( bottom pkt floor / src dest src srcbufsiz / vmbuf vmbuf-b/buf pkt-vmbuf )\n\n#endif\n#include \"align.i65\"\npupd1\n    jsr harvests10\n    brk\n    .byt ldd | N1               ; vmbuf @\n    .byt st | N5                ; save for later\n    .byt sub | N2               ; vmbuf-1024\n    .byt add | TOS              ; vmbuf-1024+size\n    .byt dcr | ACC\n    .byt dcr | ACC              ; vmbuf-1024+size-2\n    .byt st | N6                ; save for later\n    ; things we'll need for CMOVE+\n    .byt st | TOS               ; =bottom\n    .byt ld | N4                ; pkt\n    .byt push                   ; =pkt\n    .byt sub | N2               ; pkt-1024\n    .byt st | N7                ; save for later\n    .byt push                   ; =floor\n    ; things we'll need for RLENCODE\n    .byt push                   ; =dest\n    .byt ld | N0                ; blkbuf|vidram\n    .byt push                   ; =src\n    .byt ld | N3                ; b/buf|b/scr\n    .byt push                   ; =srcbufsiz\n    ; things we'll need for CMOVE\n    .byt ld | N5\n    .byt push                   ; =from\n    .byt ld | N6\n    .byt push                   ; =bottom\n    .byt ld | N7\n    .byt sub | N6\n    .byt push                   ; =howmany\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=(UPD2)\nstack=( source floor actualsize wrapd 'scrpkt -- )\ntags=vm,nosymbol\nSets up the linewrap bits in the output buffer (if needed) and\ngets ready for RLENCODE and squeezing out unused space\n\n||^data|^editing<br/>screen|<|h\n|TOS|'scrpkt|<|<|\n|N0|floor|<|<|\n|N1|blkbuf|vidram|src|\n|N2|b/buf|b/scr|srcbufsiz|\n|N3|wrapdlo|<|<|\n|N4|wrapdhi|<|<|\n\nneed 3C@ and 3C! for linewrap\n\n#endif\npupd2\n    jsr harvests10\n    lda n+7                     ; N3+1\n    sta n+12                    ; N6\n    brk\n    .byt ldd | TOS              ; isscr?\n    .byt st | N5                ; save for later\n    .byt bz , <(pupd2b-*-2)\n    .byt ldd | TOS              ; editing?\n    .byt bnz , <(pupd2a-*-2)\n    .byt ldd | N1\n    .byt std | N0\n    .byt ldi | N1\n    .byt sti | N0               ; use linewrap from blkbuf\n    .byt br , <(pupd2b-*-2)\npupd2a\n    .byt ld | N4\n    .byt sti | N0\n    .byt ld | N6\n    .byt sti | N0\n    .byt ld | N3\n    .byt sti | N0\n;    .byt ld | N3\n;    .byt sti | N0\n;    .byt ld | N6\n;    .byt sti | N0\n;    .byt ld | N4\n;    .byt sti | N0              ; write linewrap to output\npupd2b\n    ; setup for RLENCODE\n    .byt ld | N1                ; from\n    .byt st | TOS\n    .byt ld | N0                ; to\n    .byt push\n    ; setup for -TRAILING or -NULLS\n    .byt ld | N1                ; source\n    .byt push\n    .byt ld | N2                ; actual size\n    .byt push\n    .byt ld | N5                ; isscr?\n    .byt push\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=(UPD3)\nstack=( )\ntags=vm,nosymbol\n\n||^data|^editing<br/>screen|<|h\n|TOS|0|<|<|\n|N0|blkbuf|vidram|src|\n|N1|b/buf|b/scr|srcbufsiz|\n|N2|pkt|<|dst|\n|N3|vmbuf|<|bottom|\n|N4|b/buf|<|maxbufsiz|\n\n( bottom targend-1 pkt-targend )\n+move #blk! ;\n\n#endif\npupd3\n    lda tos+1                   ; SCRPKT flag bit to Carry\n    ora stackh,x                ; UNCOMPRESSED? flag\n    and #$c0\n    sta tos+1\n    jsr harvests8\n    sty tos                     ; low byte of packet flags\n    brk\n    .byt ld | N2\n    .byt sub | N1\n    .byt add | TOS\n    .byt st | N3                ; packet header\n    .byt ldd | N3               ; +2\n    .byt ld | N2\n    .byt st | TOS\n    .byt ld | N0\n    .byt sub | TOS\n    .byt dcr | TOS              ; =targend-1\n    .byt push                   ; =pkt-targend\n    .byt ld | N3\n    .byt std | N0\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname=UPDATE\nstack=( -- )\ntags=forth-83,vm\nCopies and compresses the current block buffer to the [[virtual memory\npacket buffer|PETTIL system memory map]].  Analogous to [[BLOCK]] which\nreads packets, this is PETTIL's single point of responsibility for\nwriting packets in the [[VMBUF]] region.\n\n```\n: update   ( -- )\n    #blk @ 0= ?exit                   \\ early exit if buffer empty\n    blkbuf  editing? if\n        drop  isscr? ?: vidram exit     \\ early exit if editing data\n    then\n    vmbuf b/buf\n    b/buf blk  isscr? if\n        2drop  b/scr scr\n    then\n    @ >pkt\n    (upd1)\n    cmove\n    25 wrap^ scrpkt\n    (upd2)\n    ?: -trailing -nulls  nip rlencode isscr?\n    (upd3)\n    +move #blk! ;\n```\n#endif\n#include \"align.i65\"\n_update\n    jsr enter\n#include \"page.i65\"\n    .word numblk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zeq\n#include \"page.i65\"\n    .word _qexit\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word editingq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(update01-*+1)\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word isscrq\n#include \"pass.i65\"\n    .word pquerycolon\n    .word vidram\n    .word exit\n#include \"page.i65\"\nupdate01\n    .word vmbuf\n#include \"page.i65\"\n    .word bperbuf\n#include \"page.i65\"\n    .word bperbuf\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word isscrq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(update02-*+1)\n#include \"page.i65\"\n    .word twodrop\n#include \"page.i65\"\n    .word bperscr\n#include \"page.i65\"\n    .word scr\n#include \"page.i65\"\nupdate02\n    .word fetch\n#include \"page.i65\"\n    .word _topkt\n#include \"page.i65\"\n    .word _pktsize\n#include \"page.i65\"\n    .word pupd1\n#include \"page.i65\"\n    .word cmove\n#include \"page.i65\"\n    .word lperscr               ; 25\n#include \"page.i65\"\n    .word wrapabove\n#include \"page.i65\"\n    .word scrpkt\n#include \"page.i65\"\n    .word pupd2\n#include \"pass.i65\"\n    .word pquerycolon\n    .word dashtrailing\n    .word dashnulls\n#include \"page.i65\"\n    .word nip\n#include \"page.i65\"\n    .word rlencode\n#include \"page.i65\"\n    .word isscrq\n#include \"page.i65\"\n    .word pupd3\n#include \"page.i65\"\n    .word _plusmove\n#include \"page.i65\"\n    .word _numblkstore\n#include \"pass.i65\"\n    .word exit\n\n#print (*-bperbuf)\n",
			"file": "core/src/core-vm.a65",
			"file_size": 40672,
			"file_write_time": 131545512353503967,
			"settings":
			{
				"buffer_size": 40672,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/chitselb/dev/commodore/activity.log",
			"settings":
			{
				"buffer_size": 111592,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/chitselb/dev/commodore/pettil"
	],
	"file_history":
	[
		"/home/chitselb/dev/commodore/pettil/core/src/core-inner.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-assembler.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-utils.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-compiler.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-vm.a65",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/F83 Appendix B. Uncontrolled Reference Words.tid",
		"/home/chitselb/.vice/sdl-vicerc",
		"/home/chitselb/dev/commodore/pettil/core/src/core-extra.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65",
		"/home/chitselb/dev/commodore/pettil/t.t"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 99.0,
		"where_history":
		[
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"tickstream",
			"name=3",
			"N2",
			"name=\\",
			"span",
			"query",
			"stream",
			"'stream",
			"_choose",
			"deadbeef",
			"_qrefill",
			"dashtrailings",
			"sty tos[^\\+]",
			"sty tos[^+]",
			"sty tos",
			"^put",
			"name=PUT",
			"name=-TRAILING",
			"PETSCII",
			"  ",
			"\\n",
			"name=MKPKTS",
			"name=(FILE)",
			"  ",
			"VOCAB",
			"name=UNSMUDGE",
			"name=VDROP",
			"^\\ *\\d*\\:\\ name\\=",
			"(^name=|nosymbol)",
			"stash-forth",
			"(^name=|nosymbol)",
			"^name=",
			"plits",
			"_rehash",
			"^(#if 0|#endif)",
			"lits",
			"name=lits",
			"name=plits"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			" ",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "core/src/pettil-core.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29465,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 466.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "studio/src/pettil-studio.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9978,
						"regions":
						{
						},
						"selection":
						[
							[
								4480,
								4480
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2565.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "pettil.dbg",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 566,
						"regions":
						{
						},
						"selection":
						[
							[
								566,
								566
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "studio/src/pettil-dictionary.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 52423,
						"regions":
						{
						},
						"selection":
						[
							[
								11368,
								11368
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7343.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "studio/src/pettil-interpreter.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20899,
						"regions":
						{
						},
						"selection":
						[
							[
								3241,
								3241
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2244.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "core/src/core-io.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23403,
						"regions":
						{
							"bookmarks":
							{
								"flags": 144,
								"icon": "bookmark",
								"regions":
								[
									[
										3258,
										3258
									]
								],
								"scope": "bookmarks"
							}
						},
						"selection":
						[
							[
								3258,
								3258
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1804.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 6,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5922,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										154,
										167
									],
									[
										392,
										405
									],
									[
										636,
										644
									],
									[
										796,
										804
									],
									[
										1020,
										1028
									],
									[
										1137,
										1145
									],
									[
										1231,
										1239
									],
									[
										1356,
										1364
									],
									[
										1556,
										1564
									],
									[
										1667,
										1675
									],
									[
										1815,
										1823
									],
									[
										1944,
										1952
									],
									[
										2246,
										2254
									],
									[
										2371,
										2379
									],
									[
										2509,
										2517
									],
									[
										2652,
										2660
									],
									[
										2702,
										2710
									],
									[
										2833,
										2841
									],
									[
										2909,
										2917
									],
									[
										3147,
										3154
									],
									[
										3278,
										3285
									],
									[
										3477,
										3484
									],
									[
										3833,
										3839
									],
									[
										4047,
										4053
									],
									[
										4206,
										4212
									],
									[
										4352,
										4358
									],
									[
										4503,
										4509
									],
									[
										4654,
										4660
									],
									[
										4828,
										4834
									],
									[
										4981,
										4987
									],
									[
										5210,
										5220
									],
									[
										5345,
										5355
									],
									[
										5521,
										5531
									],
									[
										5636,
										5646
									],
									[
										5836,
										5846
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								5841,
								5841
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 6,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 2955.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "core/src/core-nucleus.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 60935,
						"regions":
						{
						},
						"selection":
						[
							[
								22358,
								22358
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14091.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "core/src/core-vm.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40672,
						"regions":
						{
						},
						"selection":
						[
							[
								40355,
								40360
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 26164.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/chitselb/dev/commodore/activity.log",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 111592,
						"regions":
						{
						},
						"selection":
						[
							[
								109806,
								109806
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 64369.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 103.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "pettil.sublime-project",
	"replace":
	{
		"height": 69.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 244.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}

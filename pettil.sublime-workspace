{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "[Return to Main Page] NMOS 6502 Opcodes by John Pickens, Updated by Bruce Clark and by Ed Spittles \n[Up to Tutorials and Aids] \nINDEX\nBranches\tDecimal Mode\tInterrupt Flag\tOverflow Flag\tProgram Counter\tStack\tTimes\tWrap-around\nADC\tAND\tASL\tBCC\tBCS\tBEQ\tBIT\tBMI\tBNE\tBPL\tBRK\tBVC\tBVS\tCLC\nCLD\tCLI\tCLV\tCMP\tCPX\tCPY\tDEC\tDEX\tDEY\tEOR\tINC\tINX\tINY\tJMP\nJSR\tLDA\tLDX\tLDY\tLSR\tNOP\tORA\tPHA\tPHP\tPLA\tPLP\tROL\tROR\tRTI\nRTS\tSBC\tSEC\tSED\tSEI\tSTA\tSTX\tSTY\tTAX\tTAY\tTSX\tTXA\tTXS\tTYA\n \n\nADC (ADd with Carry)\nAffects Flags: S V Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     ADC #$44      $69  2   2\nZero Page     ADC $44       $65  2   3\nZero Page,X   ADC $44,X     $75  2   4\nAbsolute      ADC $4400     $6D  3   4\nAbsolute,X    ADC $4400,X   $7D  3   4+\nAbsolute,Y    ADC $4400,Y   $79  3   4+\nIndirect,X    ADC ($44,X)   $61  2   6\nIndirect,Y    ADC ($44),Y   $71  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nADC results are dependant on the setting of the decimal flag. In decimal mode, addition is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal).\nThere is no way to add without carry.\n\n \n\nAND (bitwise AND with accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     AND #$44      $29  2   2\nZero Page     AND $44       $25  2   3\nZero Page,X   AND $44,X     $35  2   4\nAbsolute      AND $4400     $2D  3   4\nAbsolute,X    AND $4400,X   $3D  3   4+\nAbsolute,Y    AND $4400,Y   $39  3   4+\nIndirect,X    AND ($44,X)   $21  2   6\nIndirect,Y    AND ($44),Y   $31  2   5+\n\n+ add 1 cycle if page boundary crossed\n \n\nASL (Arithmetic Shift Left)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ASL A         $0A  1   2\nZero Page     ASL $44       $06  2   5\nZero Page,X   ASL $44,X     $16  2   6\nAbsolute      ASL $4400     $0E  3   6\nAbsolute,X    ASL $4400,X   $1E  3   7\n\nASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.\n \n\nBIT (test BITs)\nAffects Flags: N V Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     BIT $44       $24  2   3\nAbsolute      BIT $4400     $2C  3   4\n\nBIT sets the Z flag as though the value in the address tested were ANDed with the accumulator. The S and V flags are set to match bits 7 and 6 respectively in the value stored at the tested address.\nBIT is often used to skip one or two following bytes as in:\n\nCLOSE1 LDX #$10   If entered here, we\n       .BYTE $2C  effectively perform\nCLOSE2 LDX #$20   a BIT test on $20A2,\n       .BYTE $2C  another one on $30A2,\nCLOSE3 LDX #$30   and end up with the X\nCLOSEX LDA #12    register still at $10\n       STA ICCOM,X upon arrival here.\n\nBeware: a BIT instruction used in this way as a NOP does have effects: the flags may be modified, and the read of the absolute address, if it happens to access an I/O device, may cause an unwanted action.\n                 \n\nBranch Instructions\nAffect Flags: none\n\nAll branches are relative mode and have a length of two bytes. Syntax is \"Bxx Displacement\" or (better) \"Bxx Label\". See the notes on the Program Counter for more on displacements.\n\nBranches are dependant on the status of the flag bits when the op code is encountered. A branch not taken requires two machine cycles. Add one if the branch is taken and add one more if the branch crosses a page boundary.\n\nMNEMONIC                       HEX\nBPL (Branch on PLus)           $10\nBMI (Branch on MInus)          $30\nBVC (Branch on oVerflow Clear) $50\nBVS (Branch on oVerflow Set)   $70\nBCC (Branch on Carry Clear)    $90\nBCS (Branch on Carry Set)      $B0\nBNE (Branch on Not Equal)      $D0\nBEQ (Branch on EQual)          $F0\n\nThere is no BRA (BRanch Always) instruction but it can be easily emulated by branching on the basis of a known condition. One of the best flags to use for this purpose is the oVerflow which is unchanged by all but addition and subtraction operations.\nA page boundary crossing occurs when the branch destination is on a different page than the instruction AFTER the branch instruction. For example:\n\n  SEC\n  BCS LABEL\n  NOP\nA page boundary crossing occurs (i.e. the BCS takes 4 cycles) when (the address of) LABEL and the NOP are on different pages. This means that\n        CLV\n        BVC LABEL\n  LABEL NOP\nthe BVC instruction will take 3 cycles no matter what address it is located at.\n \n\nBRK (BReaK)\nAffects Flags: B\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       BRK           $00  1   7\n\nBRK causes a non-maskable interrupt and increments the program counter by one. Therefore an RTI will go to the address of the BRK +2 so that BRK may be used to replace a two-byte instruction for debugging and the subsequent RTI will be correct.\n \n\nCMP (CoMPare accumulator)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CMP #$44      $C9  2   2\nZero Page     CMP $44       $C5  2   3\nZero Page,X   CMP $44,X     $D5  2   4\nAbsolute      CMP $4400     $CD  3   4\nAbsolute,X    CMP $4400,X   $DD  3   4+\nAbsolute,Y    CMP $4400,Y   $D9  3   4+\nIndirect,X    CMP ($44,X)   $C1  2   6\nIndirect,Y    CMP ($44),Y   $D1  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nCompare sets flags as if a subtraction had been carried out. If the value in the accumulator is equal or greater than the compared value, the Carry will be set. The equal (Z) and sign (S) flags will be set based on equality or lack thereof and the sign (i.e. A>=$80) of the accumulator.\n \n\nCPX (ComPare X register)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CPX #$44      $E0  2   2\nZero Page     CPX $44       $E4  2   3\nAbsolute      CPX $4400     $EC  3   4\n\nOperation and flag results are identical to equivalent mode accumulator CMP ops.\n \n\nCPY (ComPare Y register)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CPY #$44      $C0  2   2\nZero Page     CPY $44       $C4  2   3\nAbsolute      CPY $4400     $CC  3   4\n\nOperation and flag results are identical to equivalent mode accumulator CMP ops.\n \n\nDEC (DECrement memory)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     DEC $44       $C6  2   5\nZero Page,X   DEC $44,X     $D6  2   6\nAbsolute      DEC $4400     $CE  3   6\nAbsolute,X    DEC $4400,X   $DE  3   7\n\n \n\nEOR (bitwise Exclusive OR)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     EOR #$44      $49  2   2\nZero Page     EOR $44       $45  2   3\nZero Page,X   EOR $44,X     $55  2   4\nAbsolute      EOR $4400     $4D  3   4\nAbsolute,X    EOR $4400,X   $5D  3   4+\nAbsolute,Y    EOR $4400,Y   $59  3   4+\nIndirect,X    EOR ($44,X)   $41  2   6\nIndirect,Y    EOR ($44),Y   $51  2   5+\n\n+ add 1 cycle if page boundary crossed\n             \n\nFlag (Processor Status) Instructions\nAffect Flags: as noted\n\nThese instructions are implied mode, have a length of one byte and require two machine cycles.\n\nMNEMONIC                       HEX\nCLC (CLear Carry)              $18\nSEC (SEt Carry)                $38\nCLI (CLear Interrupt)          $58\nSEI (SEt Interrupt)            $78\nCLV (CLear oVerflow)           $B8\nCLD (CLear Decimal)            $D8\nSED (SEt Decimal)              $F8\n\nNotes:\n  The Interrupt flag is used to prevent (SEI) or enable (CLI) maskable interrupts (aka IRQ's). It does not signal the presence or absence of an interrupt condition. The 6502 will set this flag automatically in response to an interrupt and restore it to its prior status on completion of the interrupt service routine. If you want your interrupt service routine to permit other maskable interrupts, you must clear the I flag in your code.\n\n  The Decimal flag controls how the 6502 adds and subtracts. If set, arithmetic is carried out in packed binary coded decimal. This flag is unchanged by interrupts and is unknown on power-up. The implication is that a CLD should be included in boot or interrupt coding.\n\n  The Overflow flag is generally misunderstood and therefore under-utilised. After an ADC or SBC instruction, the overflow flag will be set if the twos complement result is less than -128 or greater than +127, and it will cleared otherwise. In twos complement, $80 through $FF represents -128 through -1, and $00 through $7F represents 0 through +127. Thus, after:\n\n  CLC\n  LDA #$7F ;   +127\n  ADC #$01 ; +   +1\nthe overflow flag is 1 (+127 + +1 = +128), and after:\n  CLC\n  LDA #$81 ;   -127\n  ADC #$FF ; +   -1\nthe overflow flag is 0 (-127 + -1 = -128). The overflow flag is not affected by increments, decrements, shifts and logical operations i.e. only ADC, BIT, CLV, PLP, RTI and SBC affect it. There is no op code to set the overflow but a BIT test on an RTS instruction will do the trick.\n \n\nINC (INCrement memory)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     INC $44       $E6  2   5\nZero Page,X   INC $44,X     $F6  2   6\nAbsolute      INC $4400     $EE  3   6\nAbsolute,X    INC $4400,X   $FE  3   7\n \n\nJMP (JuMP)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nAbsolute      JMP $5597     $4C  3   3\nIndirect      JMP ($5597)   $6C  3   5\n\nJMP transfers program execution to the following address (absolute) or to the location contained in the following address (indirect). Note that there is no carry associated with the indirect jump so:\nAN INDIRECT JUMP MUST NEVER USE A\nVECTOR BEGINNING ON THE LAST BYTE\nOF A PAGE\nFor example if address $3000 contains $40, $30FF contains $80, and $3100 contains $50, the result of JMP ($30FF) will be a transfer of control to $4080 rather than $5080 as you intended i.e. the 6502 took the low byte of the address from $30FF and the high byte from $3000.\n \n\nJSR (Jump to SubRoutine)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nAbsolute      JSR $5597     $20  3   6\n\nJSR pushes the address-1 of the next operation on to the stack before transferring program control to the following address. Subroutines are normally terminated by a RTS op code.\n \n\nLDA (LoaD Accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDA #$44      $A9  2   2\nZero Page     LDA $44       $A5  2   3\nZero Page,X   LDA $44,X     $B5  2   4\nAbsolute      LDA $4400     $AD  3   4\nAbsolute,X    LDA $4400,X   $BD  3   4+\nAbsolute,Y    LDA $4400,Y   $B9  3   4+\nIndirect,X    LDA ($44,X)   $A1  2   6\nIndirect,Y    LDA ($44),Y   $B1  2   5+\n\n+ add 1 cycle if page boundary crossed\n \n\nLDX (LoaD X register)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDX #$44      $A2  2   2\nZero Page     LDX $44       $A6  2   3\nZero Page,Y   LDX $44,Y     $B6  2   4\nAbsolute      LDX $4400     $AE  3   4\nAbsolute,Y    LDX $4400,Y   $BE  3   4+\n\n+ add 1 cycle if page boundary crossed\n \n\nLDY (LoaD Y register)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDY #$44      $A0  2   2\nZero Page     LDY $44       $A4  2   3\nZero Page,X   LDY $44,X     $B4  2   4\nAbsolute      LDY $4400     $AC  3   4\nAbsolute,X    LDY $4400,X   $BC  3   4+\n\n+ add 1 cycle if page boundary crossed\n \n\nLSR (Logical Shift Right)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   LSR A         $4A  1   2\nZero Page     LSR $44       $46  2   5\nZero Page,X   LSR $44,X     $56  2   6\nAbsolute      LSR $4400     $4E  3   6\nAbsolute,X    LSR $4400,X   $5E  3   7\n\nLSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.\n \n\nWrap-Around\nUse caution with indexed zero page operations as they are subject to wrap-around. For example, if the X register holds $FF and you execute LDA $80,X you will not access $017F as you might expect; instead you access $7F i.e. $80-1. This characteristic can be used to advantage but make sure your code is well commented.\n\nIt is possible, however, to access $017F when X = $FF by using the Absolute,X addressing mode of LDA $80,X. That is, instead of:\n\n  LDA $80,X    ; ZeroPage,X - the resulting object code is: B5 80\nwhich accesses $007F when X=$FF, use:\n  LDA $0080,X  ; Absolute,X - the resulting object code is: BD 80 00\nwhich accesses $017F when X = $FF (a at cost of one additional byte and one additional cycle). All of the ZeroPage,X and ZeroPage,Y instructions except STX ZeroPage,Y and STY ZeroPage,X have a corresponding Absolute,X and Absolute,Y instruction. Unfortunately, a lot of 6502 assemblers don't have an easy way to force Absolute addressing, i.e. most will assemble a LDA $0080,X as B5 80. One way to overcome this is to insert the bytes using the .BYTE pseudo-op (on some 6502 assemblers this pseudo-op is called DB or DFB, consult the assembler documentation) as follows:\n  .BYTE $BD,$80,$00  ; LDA $0080,X (absolute,X addressing mode)\nThe comment is optional, but highly recommended for clarity.\nIn cases where you are writing code that will be relocated you must consider wrap-around when assigning dummy values for addresses that will be adjusted. Both zero and the semi-standard $FFFF should be avoided for dummy labels. The use of zero or zero page values will result in assembled code with zero page opcodes when you wanted absolute codes. With $FFFF, the problem is in addresses+1 as you wrap around to page 0.\n\n \n\nProgram Counter\nWhen the 6502 is ready for the next instruction it increments the program counter before fetching the instruction. Once it has the op code, it increments the program counter by the length of the operand, if any. This must be accounted for when calculating branches or when pushing bytes to create a false return address (i.e. jump table addresses are made up of addresses-1 when it is intended to use an RTS rather than a JMP).\n\nThe program counter is loaded least signifigant byte first. Therefore the most signifigant byte must be pushed first when creating a false return address.\n\nWhen calculating branches a forward branch of 6 skips the following 6 bytes so, effectively the program counter points to the address that is 8 bytes beyond the address of the branch opcode; and a backward branch of $FA (256-6) goes to an address 4 bytes before the branch instruction.\n\n \n\nExecution Times\nOp code execution times are measured in machine cycles; one machine cycle equals one clock cycle. Many instructions require one extra cycle for execution if a page boundary is crossed; these are indicated by a + following the time values shown.\n\n \n\nNOP (No OPeration)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       NOP           $EA  1   2\n\nNOP is used to reserve space for future modifications or effectively REM out existing code.\n \n\nORA (bitwise OR with Accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     ORA #$44      $09  2   2\nZero Page     ORA $44       $05  2   3\nZero Page,X   ORA $44,X     $15  2   4\nAbsolute      ORA $4400     $0D  3   4\nAbsolute,X    ORA $4400,X   $1D  3   4+\nAbsolute,Y    ORA $4400,Y   $19  3   4+\nIndirect,X    ORA ($44,X)   $01  2   6\nIndirect,Y    ORA ($44),Y   $11  2   5+\n\n+ add 1 cycle if page boundary crossed\n               \n\nRegister Instructions\nAffect Flags: S Z\n\nThese instructions are implied mode, have a length of one byte and require two machine cycles.\n\nMNEMONIC                 HEX\nTAX (Transfer A to X)    $AA\nTXA (Transfer X to A)    $8A\nDEX (DEcrement X)        $CA\nINX (INcrement X)        $E8\nTAY (Transfer A to Y)    $A8\nTYA (Transfer Y to A)    $98\nDEY (DEcrement Y)        $88\nINY (INcrement Y)        $C8\n \n\nROL (ROtate Left)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ROL A         $2A  1   2\nZero Page     ROL $44       $26  2   5\nZero Page,X   ROL $44,X     $36  2   6\nAbsolute      ROL $4400     $2E  3   6\nAbsolute,X    ROL $4400,X   $3E  3   7\n\nROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.\n \n\nROR (ROtate Right)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ROR A         $6A  1   2\nZero Page     ROR $44       $66  2   5\nZero Page,X   ROR $44,X     $76  2   6\nAbsolute      ROR $4400     $6E  3   6\nAbsolute,X    ROR $4400,X   $7E  3   7\n\nROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.\n \n\nRTI (ReTurn from Interrupt)\nAffects Flags: all\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       RTI           $40  1   6\n\nRTI retrieves the Processor Status Word (flags) and the Program Counter from the stack in that order (interrupts push the PC first and then the PSW).\nNote that unlike RTS, the return address on the stack is the actual address rather than the address-1.\n\n \n\nRTS (ReTurn from Subroutine)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       RTS           $60  1   6\n\nRTS pulls the top two bytes off the stack (low byte first) and transfers program control to that address+1. It is used, as expected, to exit a subroutine invoked via JSR which pushed the address-1.\nRTS is frequently used to implement a jump table where addresses-1 are pushed onto the stack and accessed via RTS eg. to access the second of four routines:\n\n LDX #1\n JSR EXEC\n JMP SOMEWHERE\n\nLOBYTE\n .BYTE <ROUTINE0-1,<ROUTINE1-1\n .BYTE <ROUTINE2-1,<ROUTINE3-1\n\nHIBYTE\n .BYTE >ROUTINE0-1,>ROUTINE1-1\n .BYTE >ROUTINE2-1,>ROUTINE3-1\n\nEXEC\n LDA HIBYTE,X\n PHA\n LDA LOBYTE,X\n PHA\n RTS\n \n\nSBC (SuBtract with Carry)\nAffects Flags: S V Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     SBC #$44      $E9  2   2\nZero Page     SBC $44       $E5  2   3\nZero Page,X   SBC $44,X     $F5  2   4\nAbsolute      SBC $4400     $ED  3   4\nAbsolute,X    SBC $4400,X   $FD  3   4+\nAbsolute,Y    SBC $4400,Y   $F9  3   4+\nIndirect,X    SBC ($44,X)   $E1  2   6\nIndirect,Y    SBC ($44),Y   $F1  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nSBC results are dependant on the setting of the decimal flag. In decimal mode, subtraction is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal).\nThere is no way to subtract without the carry which works as an inverse borrow. i.e, to subtract you set the carry before the operation. If the carry is cleared by the operation, it indicates a borrow occurred.\n\n \n\nSTA (STore Accumulator)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STA $44       $85  2   3\nZero Page,X   STA $44,X     $95  2   4\nAbsolute      STA $4400     $8D  3   4\nAbsolute,X    STA $4400,X   $9D  3   5\nAbsolute,Y    STA $4400,Y   $99  3   5\nIndirect,X    STA ($44,X)   $81  2   6\nIndirect,Y    STA ($44),Y   $91  2   6\n             \n\nStack Instructions\nThese instructions are implied mode, have a length of one byte and require machine cycles as indicated. The \"PuLl\" operations are known as \"POP\" on most other microprocessors. With the 6502, the stack is always on page one ($100-$1FF) and works top down.\n\nMNEMONIC                        HEX TIM\nTXS (Transfer X to Stack ptr)   $9A  2\nTSX (Transfer Stack ptr to X)   $BA  2\nPHA (PusH Accumulator)          $48  3\nPLA (PuLl Accumulator)          $68  4\nPHP (PusH Processor status)     $08  3\nPLP (PuLl Processor status)     $28  4\n \n\nSTX (STore X register)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STX $44       $86  2   3\nZero Page,Y   STX $44,Y     $96  2   4\nAbsolute      STX $4400     $8E  3   4\n \n\nSTY (STore Y register)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STY $44       $84  2   3\nZero Page,X   STY $44,X     $94  2   4\nAbsolute      STY $4400     $8C  3   4\nLast Updated May 5, 2017.",
			"settings":
			{
				"buffer_size": 19500,
				"line_ending": "Unix",
				"name": "[Return to Main Page] NMOS 6502 Opcodes by John Pi"
			}
		},
		{
			"file": "tmp/pettil.mon",
			"settings":
			{
				"buffer_size": 24807,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-name.a65",
			"settings":
			{
				"buffer_size": 11322,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 32 files for \"ult\" (regex)\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-double.a65:\n   35  stack=( d1 d2 -- d1-d2 )\n   36  tags=forth-83,double,math\n   37: Subtract \"d2\" from \"d1\" leaving the result on the stack\n   38  \n   39  #endif\n   ..\n  288  stack=( d -- d*2 )\n  289  tags=double,primitive,math\n  290: Multiply the double \"d\" by 2\n  291  #endif\n  292  dtwostar\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-extra.a65:\n   85  tags=i/o,kernel\n   86  stack=( -- )\n   87: Restore default I/O channels\n   88  #endif\n   89  cmdoff\n   ..\n  280      .word twodup\n  281  #include \"page.i65\"\n  282:     .word ult\n  283  #include \"pass.i65\"\n  284      .word qbranch\n  ...\n  401  stack=( u -- u*40 )\n  402  tags=math\n  403: Fast integer unsigned TOS multiply by 40, no overflow checking\n  404  \n  405  #endif\n  ...\n  540  ;stack=( addr1 u1 n -- addr2 u2 )\n  541  ;tags=string\n  542: ;Adjust the character string at c-addr1 by n characters. The resulting\n  543  ;character string, specified by c-addr2 u2, begins at c-addr1 plus n\n  544  ;characters and is u1 minus n characters long.\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-inner.a65:\n  318  tags=fig\n  319  Ordinarily the 6502 machine stack (aka PETTIL return stack) is\n  320: initialized to $01FF by BASIC, but the value stored at RP0 defaults\n  321  to $01fe instead.  This is because the PET ROM stores a line of\n  322  input at $0200 (where TIB points) and INTERPRET will be storing a\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-io.a65:\n  222  ptickstream\n  223      lda #3\n  224:     sta DFLTN                   ; $AF Default Input Device\n  225      lda tos\n  226      sta LNMX                    ; $D5 logical line length (39 or 79)\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-locals.a65:\n   61  tags=nosymbol,subroutine\n   62  Pops cells from the split stack to N area, working backwards.\n   63: Used for setting up primitives that consume multiple arguments\n   64  \n   65  Input\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-nucleus.a65:\n   10  arithmetic are unsigned.\n   11  \n   12: check http://6502.org/source/ for multiply and divide and stuff\n   13  \n   14  \n   ..\n   17      lda stackl,x\n   18      sta n+4\n   19:     lda stackh,x            ;multiplicand in tos\n   20:     sta n+5                 ;multiplier in N2\n   21:     jsr multiply            ;16 bit unsigned multiply\n   22      lda n\n   23      sta stackl,x\n   ..\n   28      jmp put ;[26]\n   29  \n   30: multiply\n   31:     lda #0                  ; unsigned multiply tos*N2 destroys tos\n   32      sta n+2                 ;clear upper half of product\n   33      sta n+3\n   ..\n   37      ror tos\n   38      bcc rrot                ;Go rotate right if c = 0\n   39:     clc                     ; and add multiplicand to\n   40      lda n+2                 ;Get upper half of product\n   41      adc n+4                 ; it\n   ..\n   78  #if 0\n   79  name=(UM*)\n   80: stack=( 0 multiplicand multiplier 0 0 -- product )\n   81  tags=nucleus,math,forth-83,nosymbol\n   82  \n   ..\n   84  set product to 0.\n   85  begin\n   86:     right shift multiplier\n   87  if\n   88:     add multiplicand to product\n   89  then\n   90:     double multiplicand\n   91:     multiplier 0=\n   92  until\n   93  ```\n   ..\n   95  pumstar\n   96      jsr harvests6               ;( N0              N1              N2 )\n   97:                                 ;( multiplicand.lo multiplicand.hi multiplier )\n   98      stx z                       ; stash stack pointer\n   99  pumstar01\n  100      lsr ACC+2*N2+1\n  101:     ror ACC+2*N2                ; shift off low bit of multiplier\n  102      bcc pumstar03\n  103      clc\n  104      ldx #<(-4) ;$FC\n  105: pumstar02                       ; add 32-bit multiplicand to 32-bit product\n  106      lda <(ACC+4),x\n  107      adc <(ACC+2*N0+4),x\n  ...\n  113      ldx #ACC+2*N0\n  114      jsr wraprolls\n  115:     lda ACC+2*N2                ; done when multiplier reaches 0\n  116      ora ACC+2*N2+1\n  117      bne pumstar01               ; keep go?\n  ...\n 1162  tags=forth-83,nucleus\n 1163  #endif\n 1164: ult\n 1165      jsr sub16                   ; also clears `z` flag\n 1166  betwq01\n ....\n 1214  \"V is the exclusive or of the carrys out of bits 6 and 7\" - Bogax\n 1215  \n 1216: |AY|result A (high)  Y (low)|\n 1217: |N|sign of result|\n 1218: |C|borrow of result|\n 1219  |Z|clear|\n 1220  #endif\n ....\n 1222      sec                         ; 16-bit signed subtract/compare\n 1223      lda stackl,x                ; returns AY = (2OS-TOS)\n 1224:     sbc tos                     ; (N^V) = result was negative\n 1225:     tay                         ; !(N^V) = result was positive\n 1226      lda stackh,x\n 1227      sbc tos+1\n ....\n 1248  \n 1249  #endif\n 1250: dult\n 1251      jsr dsub\n 1252      inx\n ....\n 2029      .word twoover\n 2030  #include \"page.i65\"\n 2031:     .word ult\n 2032  #include \"page.i65\"\n 2033      .word nip\n ....\n 2386  stack=( n1 n2 -- d )\n 2387  tags=nucleus\n 2388: Multiply two signed words, leaving the double product on the stack\n 2389  \n 2390  ```\n ....\n 2394  \n 2395  mstar\n 2396:     jsr mult\n 2397      jmp next\n 2398: mult\n 2399      lda stackl,x\n 2400      sta n+4\n ....\n 2404      php                     ; we only care about the sign bit\n 2405      bit tos+1\n 2406:     bpl mult01\n 2407      jsr donegate\n 2408: mult01\n 2409      bit n+5\n 2410:     bpl mult02\n 2411      sec\n 2412      lda #0\n ....\n 2416      sbc n+5\n 2417      sta n+5\n 2418: mult02\n 2419:     ;jsr multiply\n 2420      lda n+1\n 2421      sta stackh,x\n ....\n 2427      sta tos\n 2428      plp\n 2429:     bpl mult03\n 2430      jmp dodnegate\n 2431: mult03\n 2432      rts\n 2433  \n ....\n 2471  tags=nucleus\n 2472  \n 2473:  multiplies n1*n2 giving an intermediate 16-bit value, and divides\n 2474   that by n3 yielding a 16-bit quotient.  Remainder is ignored,\n 2475   all values are signed.\n ....\n 2502  tags=forth-83,nucleus\n 2503  \n 2504:  multiply two signed words\n 2505  #endif\n 2506  #include \"align.i65\"\n ....\n 2523   quotient of n1 divided by the divisor n2.  n3\n 2524   has the same sign as n2 or is zero.  An error\n 2525:  condition results if the divisor is zero or if\n 2526   the quotient falls outside the range {-32,768\n 2527   ... 32,676}.\n 2528  ~todo: should probably use ud/mod and then set signs\n 2529: ~todo: division/modulo/multiplication words are kind of a mess\n 2530  \n 2531  ```\n ....\n 2574  \n 2575   n3 is the floor of the quotient of n1 divided\n 2576:  by the divisor n2.  An error condition results\n 2577   if the divisor is zero or if the quotient falls\n 2578   outside the range {-32,768 ... 32,767}.\n ....\n 2589  \n 2590   n3 is the floor of the quotient of n1 divided\n 2591:  by the divisor n2.  An error condition results\n 2592   if the divisor is zero or if the quotient falls\n 2593   outside the range {-32,768 ... 32,767}.\n ....\n 2609   n3 is the remainder after dividing n1 by the\n 2610   divisor n2.  n3 has the same sign as n2 or is\n 2611:  zero.  An error condition results if the\n 2612   divisor is zero or if the quotient falls out-\n 2613   side the range {32,768...32,768}.\n ....\n 2624  tags=forth-83,nucleus\n 2625  \n 2626:  n1 is first multiplied by n2 producing an inter-\n 2627:  mediate 32 bit result.  n4 is the remainder and\n 2628   n5 is the floor of the quotient of the inter-\n 2629:  mediate 32-bit result divided by the divisor\n 2630   n3.  A 32-bit intermediate product is used for\n 2631   */ .  n4 has the same sign as n3 or is zero.\n 2632:  An error condition results if the divisor is\n 2633   zero or if the quotient falls outside of the\n 2634   range {-32,768...32,767}.\n ....\n 2643  tags=forth-83,nucleus\n 2644  \n 2645:  n1 is first multiplied by n2 producing an inter-\n 2646:  mediate 32-bit result.  n4 is the floor of the\n 2647:  quotient of the intermediate 32-bit result\n 2648   divided by the divisor n3.  The product of n1\n 2649   times n2 is maintained as an intermediate 32-\n 2650:  bit result for greater precision than the other-\n 2651   wise equivalent sequence n1 n2 * n3 / .  An\n 2652:  error condition results if the divisor is zero\n 2653   or if the quotient falls outside the range\n 2654   {-32,768...32,767}.\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-vm.a65:\n  572  wrapzap12\n  573      jsr slip                    ; dup, so this won't overwrite `tos`\n  574:     lda #12                     ; default # of bytes to clear\n  575      ;fall through\n  576  ;--------------------------------------------------------------\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/cbm.def:\n   48  ; No. of Open Files / Index to File Table\n   49  #define LDTND       $AE\n   50: ; Default Input Device (0)\n   51  #define DFLTN       $AF\n   52: ; Default Output Device (3)\n   53  #define DFLTO       $B0\n   54  ; Tape buffer leading character (eg 1=PRG 2=DATA 3= 4=SEQ 5=EOT)\n   ..\n  247  ; Set output device\n  248  #define CHKOUT      $FFC9\n  249: ; Restore default I/0 devices\n  250  #define CLRCHN      $FFCC\n  251  ; Input character\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/pettil-tdict.def:\n   14  #define CHRIN       $FFCF   ; Input character\n   15  #define CHROUT      $FFD2   ; Output character\n   16: #define CLRCHN      $FFCC   ; Restore default I/0 devices\n   17  #define CLALL       $FFE7\n   18  #define UDTIM       $FFEA\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/sweet16.def:\n   39  #define rtn   $00\n   40  \n   41: ; branch if plus            R15 <-- R15 +/- offset if prior result is positive\n   42  #define bp    $01\n   43  \n   44: ; branch if minus           R15 <-- R15 +/- offset if prior result is negative\n   45  #define bm    $02\n   46  \n   47: ; branch if zero            R15 <-- R15 +/- offset if prior result is 0\n   48  #define bz    $03\n   49  \n   50: ; branch if not zero        R15 <-- R15 +/- offset if prior result is not 0\n   51  #define bnz   $04\n   52  \n   53: ; branch if -1              R15 <-- R15 +/- offset if prior result is -1\n   54  #define bm1   $05\n   55  \n   56: ; branch if not -1          R15 <-- R15 +/- offset if prior result is not -1\n   57  #define bnm1  $06\n   58  \n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/pettil-core.a65:\n   46  name=RESTART\n   47  stack=( -- )\n   48: tags=system,startup,default\n   49: Performs the `startup` action.  Usually results in a `warm` boot,\n   50  when reentering PETTIL from BASIC.\n   51  \n   ..\n  200  ; ---- initialization values per each `cold`\n  201  user0base       .word 10\n  202: user0filename   .word currname+3 ;1 counted string, default \"PETTILPACKETS\"\n  203: user0sanum      .word 0         ;2 default secondary address is 0, (PRG file)\n  204: user0drvnum     .word 1         ;3 default drive (datasette #1),\n  205  \n  206  ; ---- UP points to here, all live user variables\n  ...\n  358  alohard\n  359      cld                         ; clear decimal mode\n  360:     jsr CLRCHN                  ; restore default I/O channels\n  361      jsr CLALL                   ; close all open files\n  362  \n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/sweet16.a65:\n   42  ;r11 = 2*R11         ; EXT address\n   43  ;r12 = 2*R12         ; BS/RS stack pointer\n   44: ;r13 = 2*R13         ; CPR result\n   45: ;r14 = 2*R14         ; prior result register(l) and carry flag(h)\n   46  ;r15 = 2*R15         ; Sweet16 PC\n   47  \n   ..\n   96      EOR (R15L),Y   ;NOW HAVE OPCODE\n   97      BEQ TOBR       ;IF ZERO THEN NON-REG OP\n   98:     STX R14L       ;INDICATE \"PRIOR RESULT REG\"\n   99      LSR\n  100      LSR            ;OPCODE*2 TO LSB'S\n  ...\n  132  \n  133      ; bp, bm, bz, bnz, bm1, bnm1\n  134:     ; A = prior result[high]\n  135      ; X = prior register*2\n  136      ; Y = 0\n  137:     ; N = sign? prior result[high]\n  138:     ; Z = zero? prior result[high]\n  139      ; C = 0\n  140  disp2\n  ...\n  150      ; N = 0\n  151      ; Z = ?\n  152:     ; C = from prior result\n  153  TOBR4\n  154  disp3\n  ...\n  174      LDY #0\n  175  STAT3\n  176:     STY R14L        ;INDICATE R0 IS PRIOR RESULT REG\n  177  INR\n  178      INC R0L,X\n  ...\n  200      STY R0H\n  201  POP3\n  202:     LDY #0         ;INDICATE R0 AS LAST RESULT REG\n  203      STY R14L\n  204      RTS\n  ...\n  282      LDA R0L\n  283      STA (R0L,X)     ;STORE R0 LOW BYTE @RX\n  284:     JMP POP3        ;INDICATE R0 AS LAST RESULT REG\n  285  DCR\n  286      LDA R0L,X\n  ...\n  291      RTS\n  292  SUB\n  293:     LDY #0          ;RESULT TO R0\n  294  CPR\n  295      ;LDY #R13*2\n  ...\n  302  SUB2\n  303      STA R0H,Y\n  304:     STY R14L        ;LAST RESULT REG*2\n  305      ROL R14H        ;CARRY TO LSB\n  306      RTS\n  ...\n  336      LDA R0H\n  337      ADC R0H,X\n  338:     LDY #0          ;R0 FOR RESULT\n  339      BEQ SUB2        ;FINISH ADD\n  340  SET\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-compiler.a65:\n  151  work around the NMOS jmp ($xxFF) bug.  The value of `margin`\n  152  is the highest usable address within a page, which is `$xxFC`\n  153: by default.  The `margin` is located in the code immediately\n  154  following the call to `PAGEMARGIN`.\n  155  #endif\n  ...\n 1366      .word benjamin\n 1367  #include \"page.i65\"\n 1368:     .word ult\n 1369  #include \"pass.i65\"\n 1370      .word qbranch\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-dictionary.a65:\n  932      .word store\n  933  #include \"page.i65\"\n  934:     .word false                 ; make room for `(seekb)` result\n  935  #include \"page.i65\"\n  936      .word pseekb\n  ...\n 1804      .word fetch\n 1805  #include \"page.i65\"\n 1806:     .word ult\n 1807  #include \"pass.i65\"\n 1808      .word qerror\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-editor.a65:\n  822  ```\n  823  ~wut? fix this\n  824: ~ still a little goofy when inserting multiple screens\n  825  #endif\n  826  #include \"page.i65\"\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  328      .word lperscr\n  329  #include \"page.i65\"\n  330:     .word ult\n  331  #include \"page.i65\"\n  332      .word span\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-name.a65:\n  168  \n  169  ;input a byte\n  170: F215  A5 AF       LDA $AF       ; input device (default = #0, keyboard)\n  171  F217  D0 0B       BNE $F224\n  172                                  ; it is keyboard #0.\n  ...\n  246  E143  85 AC       STA $AC       ; input from screen (#3) or from keyboard (#0) flag\n  247  E145  A9 0D       LDA #$0D\n  248: E147  A6 AF       LDX $AF       ; Input device (default = #0, keyboard)\n  249  E149  E0 03       CPX #$03      ; is it the screen?\n  250  E14B  F0 06       BEQ $E153\n  251: E14D  A6 B0       LDX $B0       ; Output device (default = #3, screen)\n  252  E14F  E0 03       CPX #$03\n  253  E151  F0 03       BEQ $E156\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-number.a65:\n  174      .byt sub | ACC\n  175      .byt st | TOS\n  176:     .byt push                   ; leave `0.` as initial result\n  177      .byt st | N3                ; zero `-` flag. -1 with a leading `-` sign\n  178      .byt st | N4                ; zero rundown cfa (normal number)\n  ...\n  424  #* //compilation only//\n  425  #* works with registers `>n3` `<r11`\n  426: #* uses default number base `decimal >142 hex =E820`\n  427  #* also works with explicit base operator `>#142` `=$E820`\n  428  #* may not be combined with `-` or `.`\n  ...\n  536  \n  537  :base\n  538:                                 \\ sets default number `base`\n  539      %11110001 prefix.flags      \\ -<N#-<N# disallow/set\n  540                                  \\ set prefix flag `#$%`\n  ...\n  645  #include \"page.i65\"\n  646  number01\n  647:     .word nextchar              ; ( result. char )\n  648  #include \"page.i65\"\n  649      .word dup\n  ...\n  756      .word qdpl                  ; what about the decimal point?\n  757  #include \"pass.i65\"\n  758:     .word branch                ; ( result. )\n  759      .byt <(number02-*+1)\n  760  \n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-studio.a65:\n  148      .word MAINIRQ               ; irq!\n  149  #include \"page.i65\"\n  150:     .word irqstore              ; restore default IRQ handler\n  151  #include \"page.i65\"\n  152      .word store                 ; set `warning` to `error.msg`\n\n108 matches across 19 files\n\n\nSearching 32 files for \"putnotc\" (regex)\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-io.a65:\n  232      inx\n  233      inx\n  234:     jmp putnotc\n  235  ptickstream01\n  236      sta TBLX                    ; $D8 cursor physical line number\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-nucleus.a65:\n 1095  putnotn\n 1096      asl\n 1097: putnotc\n 1098      bcc puttrue\n 1099      bcs putfalse                ; bra\n ....\n 1165      jsr sub16                   ; also clears `z` flag\n 1166  betwq01\n 1167:     bne putnotc                 ; bra\n 1168  \n 1169  ;--------------------------------------------------------------\n ....\n 1238  zgt\n 1239      asl tos+1\n 1240:     jmp putnotc\n 1241  \n 1242  ;--------------------------------------------------------------\n ....\n 1251      jsr dsub\n 1252      inx\n 1253:     bne putnotc                 ; bra\n 1254  \n 1255  ;--------------------------------------------------------------\n\n5 matches across 2 files\n\n\nSearching 32 files for \"xpushc\" (regex)\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-nucleus.a65:\n 1064      sec\n 1065      ;\n 1066: xpushc\n 1067      jsr slip\n 1068      jmp putc\n\n/home/chitselb/Documents/dev/commodore/pettil/core/src/core-vm.a65:\n  119  uncompressedq01\n  120      asl                         ; normalize `flag`\n  121:     jmp xpushc\n  122  \n  123  ;--------------------------------------------------------------\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  349      lda userin+1\n  350      cmp #LPERSCR\n  351:     jmp xpushc\n  352  \n  353  ;--------------------------------------------------------------\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-number.a65:\n   36      clc\n   37  morecharq01\n   38:     jmp xpushc\n   39  \n   40  ;--------------------------------------------------------------\n\n4 matches across 4 files\n\n\nSearching 32 files for \".word span\"\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-dictionary.a65:\n  889      jsr enter\n  890  #include \"page.i65\"\n  891:     .word span\n  892  #include \"page.i65\"\n  893      .word fetch\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-interpreter.a65:\n  326      .word eosq\n  327  #include \"page.i65\"\n  328:     .word span\n  329  #include \"page.i65\"\n  330      .word fetch\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-name.a65:\n  285      jsr enter\n  286  #include \"page.i65\"\n  287:     .word span\n  288  #include \"page.i65\"\n  289      .word fetch\n\n3 matches across 3 files\n\n\nSearching 32 files for \"_qrefill\"\n\n/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-name.a65:\n  282  #endif\n  283  #include \"align.i65\"\n  284: _qrefill\n  285      jsr enter\n  286  #include \"page.i65\"\n  ...\n  340      jsr enter\n  341  #include \"page.i65\"\n  342:     .word _qrefill\n  343  #include \"page.i65\"\n  344      .word _tickstream\n\n2 matches in 1 file\n",
			"settings":
			{
				"buffer_size": 19239,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "studio/src/pettil-assembler.a65",
			"settings":
			{
				"buffer_size": 31780,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-studio.a65",
			"settings":
			{
				"buffer_size": 10341,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/pettil-core.a65",
			"settings":
			{
				"buffer_size": 29143,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-nucleus.a65",
			"settings":
			{
				"buffer_size": 56416,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-vm.a65",
			"settings":
			{
				"buffer_size": 39984,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-compiler.a65",
			"settings":
			{
				"buffer_size": 42475,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-editor.a65",
			"settings":
			{
				"buffer_size": 27284,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-interpreter.a65",
			"settings":
			{
				"buffer_size": 13899,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; core-extra.a65\n#echo .       core-extra.a65            Extra stuff\n\n;--------------------------------------------------------------\n#if 0\nname=VIDRAM\nstack=( -- $8000 )\ntags=i/o,const\nConstant, address of PET video memory $8000\n#endif\nvidram\n    jsr doconst\n    .word VIDRAM\n\n;--------------------------------------------------------------\n#if 0\nname=EOSCR\nstack=( -- $83E8 )\ntags=i/o,const\nConstant, address of PET `vidram b/scr +`\n#endif\neoscr\n    jsr doconst\n    .word VIDRAM+BPERSCR\n\n;--------------------------------------------------------------\n#if 0\nname=BENJAMIN\nstack=( -- $100 )\ntags=i/o,const\nConstant, 256\n\n#endif\nbenjamin\n    jsr doconst\n    .word $100\n\n;--------------------------------------------------------------\n#if 0\nname=MON\nstack=( -- )\ntags=system,ext\nRestores BASIC zero page and exits to the TIM monitor\n\n~broken\n#endif\nmon\n    jsr aufwiedersehen          ; restore BASIC zpage\n    brk\n    jsr aloha                   ; restore PETTIL zpage\n\n;--------------------------------------------------------------\n#if 0\nname=XYZZY\nstack=( -- )\ntags=extra\nThis word doesn't do much (executes a [[NEXT]].  It is used as\na VICE xpet debugger breakpoint.\n\nSee [[PLUGH]] for low-level variant of this.\n\nForth breakpoint, used for debugging in VICE when `break .xyzzy`\nis enabled, as it is in the `pettil.dbg` configuration file\n\nusage:\n\n```\n: someword\n   begin\n       dup .\n       1-\n       dup bar 0=\n\n       xyzzy    \\ insert a breakpoint\n\n    until drop ;\n```\n#endif\nxyzzy\n    jmp next                    ; used as a VICE monitor breakpoint\n\n;--------------------------------------------------------------\n#if 0\nname=CMDOFF\ntags=i/o,kernel\nstack=( -- )\nRestore default I/O channels\n#endif\ncmdoff\n    stx z\n    jsr CLRCHN\ncmdoff01\n    ldx z\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=@SWAP!\nstack=( addr1 addr2 -- )\ntags=extra\nExchanges the 16-bit values at `addr1` and `addr2`\n\n```\n: @swap!   ( a b -- )\n    dup>r @\n    over @ r> !\n    swap ! ;\n```\n#endif\n#include \"align.i65\"\n_fetchswapstore\n    jsr enter\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word store\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=PAUSE\nstack=( flag -- )\ntags=nucleus,ext\nWaits for a keypress from the user before exiting\n\n```\n: pause   ( flag -- )\n    if\n        .\" \\nPRESS ANY KEY\\n\"\n    then\n    key drop ;\n```\n#endif\n#include \"align.i65\"\n_pause\n    jsr enter\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(pause02-*+1)\n#include \"pass.i65\"\n    .word _pdq\n    .byt <(pause01-*-1)\n    .asc CR,\"PRESS ANY KEY\",CR\npause01\n#include \"page.i65\"\npause02\n    .word key\n#include \"page.i65\"\n    .word drop\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=?PAUSE\nstack=( -- )\ntags=nucleus,ext\nScans keyboard and if 'space' was pressed, pauses until any key\nis pressed.\n\n```\n: ?pause   ( -- )\n    ?key bl =\n    if false pause then ;\n```\n#endif\n#include \"align.i65\"\n_qpause\n    jsr enter\n#include \"page.i65\"\n    .word qkey\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word eq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(qpause01-*+1)\n#include \"page.i65\"\n    .word false\n#include \"page.i65\"\n    .word _pause\n#include \"pass.i65\"\nqpause01\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=JIFFY@\nstack=( -- d )\ntags=device,system,ext\nThe number of jiffies since powerup or midnight as a double\n\n```\n: jiffy@   ( -- TIME.hi TIME.lo )\n    !irq [ TIME ] cliteral 3c@ !irq ;\n```\n#endif\n#include \"align.i65\"\njiffyfetch\n    sei\n    lda TIME+1\n    pha\n    lda TIME+2\n    pha\n    lda #0\n    pha\n    lda TIME\n    pha\n    cli\n    jmp tworfrom\n\n;--------------------------------------------------------------\n#if 0\nname=JIFFIES\nstack=( u -- )\ntags=events\n#endif\n#include \"align.i65\"\n_jiffies\n    jsr enter\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word jiffyfetch\n#include \"page.i65\"\n    .word dplus\n#include \"page.i65\"\njiffies01\n    .word jiffyfetch\n#include \"page.i65\"\n    .word twoover\n#include \"page.i65\"\n    .word _dgt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(jiffies01-*+1)\n#include \"page.i65\"\n    .word twodrop\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=RANDMASK\nstack=( n -- mask )\ntags=events\nreturns the next power of 2 mask >= n\n\n```\n: randmask   ( n -- mask )\n    1\n    begin\n        2* 2dup u<\n    until nip ;\n```\n#endif\n#include \"align.i65\"\n_randmask\n    jsr enter\n#include \"page.i65\"\n    .word one\n#include \"page.i65\"\nrandmask01\n    .word twostar\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word ult\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(randmask01-*+1)\n#include \"page.i65\"\n    .word oneminus\n#include \"page.i65\"\n    .word nip\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=RNDMAX\nstack=( max -- rnd )\ntags=events\ngenerate a random unsigned byte less than `max`\n\n```\n: rndmax   ( max -- )\n    dup 0= ?exit\n    1- dup randmask\n    begin\n        randu\n        3dup and >\n    while\n        drop\n    repeat\n    and nip ;\n```\n#endif\n#include \"align.i65\"\n_rndmax\n    jsr enter\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word zeq\n#include \"page.i65\"\n    .word _qexit\n#include \"page.i65\"\n    .word oneminus\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word _randmask\n#include \"page.i65\"\nrndmax01\n    .word randuc\n#include \"page.i65\"\n    .word _threedup\n#include \"page.i65\"\n    .word andx\n#include \"page.i65\"\n    .word lt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(rndmax02-*+1)\n#include \"page.i65\"\n    .word drop\n#include \"pass.i65\"\n    .word branch\n    .byt <(rndmax01-*+1)\n#include \"page.i65\"\nrndmax02\n    .word andx\n#include \"page.i65\"\n    .word nip\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=40/MOD\nstack=( u -- u%40 u/40 )\ntags=math\n[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]\nThank you sir!\n\nPerform a divide by 40 and a modulo 40, useful for screen positioning and\n[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]\n#endif\nslashmod40\n    jsr slip\n    lda #0\n    ldy #16\nslmod40b\n    cmp #20\n    bcc slmod40c\n    sbc #20\nslmod40c\n    rol tos\n    rol tos+1\n    rol\n    dey\n    bne slmod40b\nslmod40d                        ; also an exit for\n    sta stackl,x\n    sty stackh,x\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=2NIP\nstack=( d2 d1 -- d1 )\ntags=forth-83,double,primitive\ndiscards the 2nd double on the stack\n\n#endif\ntwonip\n    lda stackl,x\n    ldy stackh,x\n    inx\n    inx\n    bne slmod40d                ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=40*\nstack=( u -- u*40 )\ntags=math\nFast integer unsigned TOS multiply by 40, no overflow checking\n\n#endif\nfortytimes\n    lda tos+1\n    pha\n    lda tos\n    asl\n    rol tos+1\n    asl\n    rol tos+1\n    adc tos\n    sta tos\n    pla\n    adc tos+1\n    asl tos\n    rol\n    asl tos\n    rol\n    asl tos\n    rol\n    sta tos+1\n    jmp next\n\n;--------------------------------------------------------------\n#if 0\nname=(LITS)\nstack=( a b c d e f n == ; -- a b c d e f )\ntags=system,startup,nosymbol\nWorks like `(LIT)` but for a group, will pile several inline literal\nconstants onto the stack.  Think if `(lits)` as `list` (of literals),\nspelled sideways\n\n```\n: (lits)   ( 0 [args...] \"name\" == ; -- [args...] )\n    caller c@+ 0 do @+ swap loop drop ; [23]\n\nusage:\n    : foo  [ 64 41 17 12  4 ] literals ;\n    foo .s\n```\nplits02 exit is used by `(.\")` to skip past the inline string\nIt drops TOS, adds whatever is passed by Y to the IP and branches there\n#endif\nplits\n    jsr slip\n    ldy #2\n    lda (ip),y\n    sta n\nplits01\n    dex\n    iny\n    lda (ip),y\n    sta stackl,x\n    iny\n    lda (ip),y\n    sta stackh,x\n    dec n\n    bne plits01\nplits02                         ; useful entry point\n    jsr slide\n    tya\n    jmp pad\n\n;--------------------------------------------------------------\n#if 0\nname=CSWAP\nstack=( ab -- ba )\ntags=extra\nSwaps high and low byte of TOS\n#endif\ncswap\n    clc\n    .byt $24                    ; BIT zp opcode\n\n;--------------------------------------------------------------\n#if 0\nname=LSB\nstack=( u -- c )\ntags=extra\nReturns the low byte of a cell\n#endif\nlsb\n    sec\n    lda tos\n    bcs put0a\n    tay\n    .byt $24                    ; BIT zp opcode\n\n;--------------------------------------------------------------\n#if 0\nname=MSB\nstack=( u -- c )\ntags=extra\nReturns the most significant byte of a cell\n#endif\nmsb\n    sec\n    lda tos+1\n    bcc put\nput0a\n    ldy #0\nlsb01\n    beq put                     ; bra\n\n;--------------------------------------------------------------\n#if 0\nname=>DISPATCH\nstack=( idx -- )\ntags=extra\nIndexed branch to the jump table address following this word.  Like ON GOTO\nbut there's no GOTO in programming anymore.\n\n```\n: >dispatch   ( idx -- )\n    r> 2+ + @ >r ;\n```\n#endif\n#include \"align.i65\"\n_dodispatch\n    jsr enter\n#include \"page.i65\"\n    .word rfrom                 ; where am I?\n#include \"page.i65\"\n    .word twoplus               ; address of jump table\n#include \"page.i65\"\n    .word plus                  ; add the index\n#include \"page.i65\"\n    .word fetch                 ; branch address\n#include \"page.i65\"\n    .word tor                   ; off we go!\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n;#if 0\n;name=/STRING\n;stack=( addr1 u1 n -- addr2 u2 )\n;tags=string\n;Adjust the character string at c-addr1 by n characters. The resulting\n;character string, specified by c-addr2 u2, begins at c-addr1 plus n\n;characters and is u1 minus n characters long.\n;\n;!!!pronounced \"slash-string\"\n;#endif\n;#include \"align.i65\"\n;_slashstring\n;    jsr enter\n;#include \"page.i65\"\n;    .word duptor\n;#include \"page.i65\"\n;    .word minus\n;#include \"page.i65\"\n;    .word rfrom\n;#include \"page.i65\"\n;    .word plusunder\n;#include \"pass.i65\"\n;    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=$INDEX\nstack=( addr char -- +index|0 )\ntags=string,ext,primitive\nreturns the (1-based) index of char within the counted string at `addr`.\notherwise returns `0`\n\n#endif\ndolindex\n    jsr harvests2\n    lda (n),y\n    tay                         ; Y = length of string\ndolindex01\n    lda (n),y\n    eor tos\n    beq dolindex02\n    dey\n    bne dolindex01\ndolindex02\n    tya\n    jmp put0a\n\n#print (*-vidram)\n",
			"file": "core/src/core-extra.a65",
			"file_size": 10842,
			"file_write_time": 131742520226155863,
			"settings":
			{
				"buffer_size": 10842,
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-io.a65",
			"settings":
			{
				"buffer_size": 18112,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "; pettil-interpreter.a65\n#echo .       pettil-interpreter.a65    Outer Interpreter\n\n;--------------------------------------------------------------\n#if 0\nname=~ Error messages\ntags=general,nosymbol\nPETTIL system messages, output by [[FAIL]]\n#endif\nerrptr\n    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08\n    .word msg09,msg10,msg11\n\nmsg01\n    .byt msg02-*-1\n    .asc \"STACK UNDERFLOW\"\nmsg02\n    .byt msg03-*-1\n    .asc \"STACK OVERFLOW\"\nmsg03\n    .byt msg04-*-1\n    .asc \"NOT FOUND\"\nmsg04\n    .byt msg05-*-1\n    .asc \"DEFINITION UNFINISHED\"\nmsg05\n    .byt msg06-*-1\n    .asc \"COMPILATION ONLY\"\nmsg06\n    .byt msg07-*-1\n    .asc \"UNPAIRED CONDITIONALS\"\nmsg07\n    .byt msg08-*-1\n    .asc \"CAN'T FORGET BELOW FENCE\"\nmsg08\n    .byt msg09-*-1\n    .asc \"BLOCK OUT OF RANGE\"\nmsg09\n    .byt msg10-*-1\n    .asc \" MISSING\"\nmsg10\n    .byt msg11-*-1\n    .byt \"CORRUPT VIRTUAL MEMORY\"\nmsg11\n    .byt msg12-*-1\n    .byt \"BAD ADDRESSING MODE\"\nmsg12\n\n;--------------------------------------------------------------\n#if 0\nname=EXISTS?\nstack=( -- addr flag )\ntags=interpreter,ext,nosymbol\nparses the next token in the input stream.  Returns either the\naddress of the (unfound) token at HERE and a 0, or the code\nfield address of the word and -1 for normal, +1 for immediate\nwords\n\n```\n: exists?\n   bl word dup c@ ?: find 0 ;\n```\n#endif\n#include \"align.i65\"\n_existsq\n    jsr enter\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word pquerycolon\n    .word _find\n    .word zero\n#include \"page.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname='\nstack=( -- cfa )\ntags=forth-83\nParse the next token in the input stream and search for it,\nreturning the CFA if successful.  Otherwise aborts with the\nmessage \"NOT FOUND\"\n\n```\n: '   ( \"name\" -- cfa )\n    exists? 0=  3 ?error ;\n```\n#endif\n#include \"align.i65\"\n_tick\n    jsr enter\n#include \"page.i65\"\n    .word _existsq\n#include \"page.i65\"\n    .word zeq\n    .word qerror\n    .byt 3                      ; NOT FOUND\n#include \"page.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.TIB\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from the console.  Leaves\nan address\n\n```\n: source.tib   ( -- addr size )\n    tib #tib @ ;\n```\n#endif\n#include \"align.i65\"\n_sourcetib\n    jsr enter\n#include \"page.i65\"\n    .word tib\n#include \"page.i65\"\n    .word numtib\n#include \"page.i65\"\n    .word fetch\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.BLK\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from the console.  Leaves\nan address and size\n\n```\n: source.blk   ( -- addr size )\n    block b/buf ;\n```\n#endif\n#include \"align.i65\"\n_sourceblk\n    jsr enter\n#include \"page.i65\"\n    .word _block\n#include \"page.i65\"\n    .word bperbuf\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=REFILL.SCR\nstack=( -- flag )\ntags=interpreter,nosymbol\nLoads the next logical line from the virtual screen buffer into another\n80-character buffer, returning a flag indicating if there was a next line\n\n```\n: refill.scr   ( -- )\n    #lin off\n    >in off\n    lin dup 1+! @\n    25 <\n    if\n        lin @                   ( lin )\n        dup >bit blkbuf + cbit@ ( lin flag )\n        swap 24 = or            ( flag )\n        if\n            forty\n        else\n            lin 1+! eighty\n        then                    ( 40|80 )\n        dup    LNMX c!\n        3      DFLTN c!\n        @lin @ PNT dup dup>r 3c@ >r >r !\n        0      PNTR c!          ( 40|80 )\n        cas2buf over 2dup expect -trailing\n        r> r> r> 3c!            ( restore screen cursor )\n        @lin +!\n        span @  #lin !\n    then ;\n\n: refill.scr   ( -- )\n    in off\n    in benjamin +!  in @ msb\n    25 <\n    if\n        lin @                   ( lin )\n        dup >bit blkbuf + cbit@ ( lin flag )\n        swap 24 = or            ( flag )\n        if\n            forty\n        else\n            lin 1+! eighty\n        then                    ( 40|80 )\n        dup    LNMX c!\n        3      DFLTN c!\n        @lin @ PNT dup dup>r 3c@ >r >r !\n        0      PNTR c!          ( 40|80 )\n        cas2buf over 2dup expect -trailing\n        r> r> r> 3c!            ( restore screen cursor )\n        @lin +!\n        span @  #lin !\n    then ;\n```\n#endif\n#include \"align.i65\"\n_refillscr\n    jsr enter\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt 25\n#include \"page.i65\"\n    .word lt\n#include \"page.i65\"\n    .word qbranch\n    .byt <(refillscr03-*+1)\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word tobit\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word cbitfetch\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word clit\n    .byt 24\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word orx\n#include \"page.i65\"\n    .word qbranch\n    .byt <(refillscr01-*+1)\n#include \"page.i65\"\n    .word forty\n#include \"page.i65\"\n    .word branch\n    .byt <(refillscr02-*+1)\n#include \"page.i65\"\nrefillscr01\n    .word lin\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word eighty\n#include \"page.i65\"\nrefillscr02\n    .word dup\n#include \"page.i65\"\n    .word clit\n    .byt LNMX\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word three\n#include \"page.i65\"\n    .word clit\n    .byt DFLTN\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt PNT\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word threecfetch\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word clit\n    .byt PNTR\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word plusstore\n#include \"page.i65\"\n    .word cas2buf\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word expect\n#include \"page.i65\"\n    .word dashtrailing\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word span\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word threecstore\nrefillscr03\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=EOL?.SCR\nstack=( -- flag )\ntags=interpreter,nosymbol\nLeaves true when, while parsing a screen, the cursor is at the end of\na line.  This test triggers a refill event.\n\n```\n: eol?.scr   ( -- flag )\n    #lin @  >in @  over min  =\n    lin @ 25 < and ;\n```\n#endif\n#include \"align.i65\"\n_eolqscr\n    jsr enter\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word _min\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt 25\n#include \"page.i65\"\n    .word lt\n#include \"page.i65\"\n    .word andx\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.SCR\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from a screen.  Leaves\nan address pointing to the beginning of a line and line size 40|80\n\n```\n: source.scr   ( -- addr size )\n    begin\n        eol?.scr\n    while\n        refill.scr\n    repeat\n    cas2buf  #lin @ ;\n```\n#endif\n#include \"align.i65\"\n_sourcescr\n    jsr enter\n#include \"page.i65\"\nsourcescr01\n    .word _eolqscr\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcescr02-*+1)\n#include \"page.i65\"\n    .word _refillscr\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcescr01-*+1)\n#include \"page.i65\"\nsourcescr02\n    .word cas2buf\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word fetch\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE\nstack=( -- addr size )\ntags=interpret,nosymbol\nReturns the base address of the buffer that [[INTERPRET]] is\nreading from, and the buffer size.\n#endif\nsource\n    jmp (uarea+uservsource-userarea)\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE!\nstack=( -- )\ntags=vm,interpreter,nosymbol\nSets the input source to TIB, BLK, or SCR\n\n```\n: source!   ( -- )\n    blk @  ?dup\n    if\n        block  isscr?\n        if\n            3+ @lin !  lin on  #lin off  ['] source.scr\n        else\n            drop  ['] source.blk\n        then\n    else\n        ['] source.tib\n    then\n    (source) ! ;\n```\n~ something here so that LOAD can restore position on a screen #41\n#endif\n#include \"align.i65\"\n_sourcestore\n    jsr enter\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word qdup\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcestore02-*+1)\n#include \"page.i65\"\n    .word _block\n#include \"page.i65\"\n    .word isscrq\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcestore01-*+1)\n#include \"page.i65\"\n    .word threeplus\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word on\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word plit\n    .word _sourcescr\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcestore03-*+1)\n#include \"page.i65\"\nsourcestore01\n    .word drop\n#include \"page.i65\"\n    .word plit\n    .word _sourceblk\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcestore03-*+1)\n#include \"page.i65\"\nsourcestore02\n    .word zero\n#include \"page.i65\"\n    .word clit\n    .byt DFLTN\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word plit\n    .word _sourcetib\n#include \"page.i65\"\nsourcestore03\n    .word psource\n#include \"page.i65\"\n    .word store\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=-->\nstack=( -- )\ntags=interpreter\nflags=immediate\nAn immediate word which loads the next screen of Forth source\n\n!!! pronounced: \"next-block\"\n\n```\n: -->   ( -- )\n    blk 1+!  >in off  source! ; immediate\n```\n: -->\n    ?loading 0 in !\n    b/scr blk @ over mod -\n    blk +! ;\nL18be .byt 3 | bit7 | bit6\n .byt \"--\",\">\"|bit7\n .word L1885\nDASHDASHGT\n .word DOCOL\n .word QLOADING\n .word ZERO\n .word IN\n .word STORE\n .word BSCR\n .word BLK\n .word FETCH\n .word OVER\n .word MOD\n .word NEGATE\n .word BLK\n .word PSTORE\n .word SEMIS\n#endif\n#include \"align.i65\"\n_nextblock\n    jsr enter\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _sourcestore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SKIP\nstack=( addr1 size1 char -- addr2 count2 )\ntags=numword,nosymbol\n\n addr1 is the starting address in the input stream where up\n to size1 bytes are skipped *WHILE* they match char.  Returns\n addr2 as the address of the first non-matching character and\n count2 as the remaining number of bytes in the buffer.\n#endif\nskip\n    brk\n    .byt bs, <(skipscan01-*-2)      ; setup\nskip01\n    .byt bs, <(skipscan02-*-2)      ; next char\n    .byt bz, <(skip01-*-2)\n    .byt br, <(skipscan04-*-2)      ; exit\n;--------------------------------------------------------------\n#if 0\nname=SCAN\nstack=( addr count char -- addr count )\ntags=numword,nosymbol\n\n addr1 is the starting address in the input stream where up\n to count1 bytes are skipped *UNTIL* they match char.  Returns\n addr2 as the address of the first non-matching character and\n count2 as the remaining number of bytes in the buffer.\n\n#endif\nscan\n    brk\n    .byt bs, <(skipscan01-*-2)      ; setup\nscan01\n    .byt bs, <(skipscan02-*-2)      ; next char\n    .byt bnz, <(scan01-*-2)\n    .byt br, <(skipscan04-*-2)\n\nskipscan01\n    .byt ld | TOS   ; char\n    .byt st | N1\n    .byt pull\n    .byt st | N0\n    .byt pull       ; addr\n    .byt rs\nskipscan02\n    .byt ldi | TOS\n    .byt dcr | N0\n    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0\n    .byt sub | N1\n    .byt rs\nskipscan03\n    .byt popd | R12 ; drop the BS return\nskipscan04\n    .byt dcr | TOS\n    .byt inr | N0\n    .byt ld | N0\n    .byt push\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname='STREAM\nstack=( -- addr size )\ntags=numword,nosymbol\nCalculates SOURCE offset by >IN with respect to buffer size.\n\n```\n : 'stream   ( -- addr size )\n       source   ( baseaddr size )\n       dup >in @ min /string ;\n```\n#endif\n#include \"align.i65\"\n_tickstream\n    jsr enter\n#include \"page.i65\"\n    .word source\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word _min\n#include \"page.i65\"\n    .word _slashstring\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=WORD\nstack=( char -- addr )\ntags=interpreter\n Generates a counted string by non-destructively accepting\n characters from the input stream until the delimiting\n character char is encountered or the input stream is\n exhausted.  Leading delimiters are ignored.  The entire\n character string is stored in memory beginning at addr as a\n sequence of bytes.  The string is followed by a blank which\n is not included in the count.  The first byte of the string\n is the number of characters {0..255}.  If the string is\n longer than 255 characters, the count is unspecified.  If\n the input stream is already exhausted as WORD is called,\n then a zero length character string will result.\n\n If the delimiter is not found the value of >IN is the size\n of the input stream.  If the delimiter is found >IN is\n adjusted to indicate the offset to the character following\n the delimiter.  #TIB is unmodified.\n\n The counted string returned by WORD may reside in the \"free\"\n dictionary area at HERE or above.  Note that the text\n interpreter may also use this area.\nSee: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream\n\n```\n: word   ( char -- addr )\n    >r 'stream\n    under r@ skip  under r> scan  drop\n    2dup swap -  >r\n    rot - 1+ >in +!\n    r> here dup bl blank $!\n    here ;\n```\n#endif\n#include \"align.i65\"\n_word\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _tickstream\n#include \"page.i65\"\n    .word under\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word skip\n#include \"page.i65\"\n    .word under\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word scan\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word plusstore\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _blank\n#include \"page.i65\"\n    .word _dolstore\n#include \"page.i65\"\n    .word here\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=?CHAR\nstack=( char -- addr )\ntags=compiler,nosymbol\nScans ahead in the input stream until `char` is found.  Moves >IN beyond\nthat character.\n#endif\n#include \"align.i65\"\n_qchar\n    jsr enter\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word oneplusstore\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=INTERPRET\nstack=( -- )\ntags=fig,forth-83,interpreter\nThe Forth interpreter loop\n\nconsistent eager-loaded approach\nTIB source comes already loaded from QUIT\nBLK source comes already loaded from BLOCK\nSCR source will eager-load each line from the block buffer, already loaded by BLOCK\n\n```\ncreate jumptable  next ,   dlit ,  drop ,  droplit ,\n                \\ double  double,  single    single,\n: interpret   ( -- )\n    begin\n        ?stack                  \\ make sure things are okay\n        bl word   ( addr )      \\ eager-load for screens is done by SOURCE\n        dup c@    ( addr len )  \\ WORD returns zero-length when SOURCE is exhausted\n    while\n        find ?dup\n        if        ( cfa findflag )\n            \\               find -1    find +1\n            \\             ____________________\n            \\ state -1   | compile     execute\n            \\ state 0    | execute     execute\n            state @ <>  ?: execute ,xt\n        else      ( here )\n            number\n            jumptable  dpl @ 0< 2*  state @ + 2* -\n            @ execute\n        then\n    repeat\n    drop ;\n```\n#endif\n#include \"align.i65\"\n_interpret\n    jsr enter\n#include \"page.i65\"\ninterpret01\n    .word qstack\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word qbranch\n    .byt <(interpret04-*+1)\n#include \"page.i65\"\n    .word _find\n#include \"page.i65\"\n    .word qdup\n#include \"page.i65\"\n    .word qbranch\n    .byt <(interpret02-*+1)\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word ne\n#include \"page.i65\"\n    .word pquerycolon\n    .word execute\n    .word _xtcomma\n#include \"page.i65\"\n    .word branch\n    .byt <(interpret03-*+1)\n#include \"page.i65\"\ninterpret02\n    .word _number\n#include \"page.i65\"\n    .word plit\n    .word interpret06           ; case table\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zlt\n#include \"page.i65\"\n    .word twostar\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word twostar\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word execute\n#include \"page.i65\"\ninterpret03\n    .word branch\n    .byt <(interpret01-*+1)\n#include \"page.i65\"\ninterpret04\n    .word drop\n    .word exit\n\ninterpret06\n    .word next\n    .word _dlit\n    .word drop\n    .word _droplit\n\n;--------------------------------------------------------------\n#if 0\nname=QUERY\nstack=( -- )\ntags=forth-83,fig\nAccept a line of input from the user\n\n```\n: query   ( -- )\n    tib 80 expect\n    span @ #tib !\n    >in off ;\n```\n#endif\n#include \"align.i65\"\n_query\n    jsr enter\n#include \"page.i65\"\n    .word tib\n#include \"page.i65\"\n    .word clit\n    .byt 80\n#include \"page.i65\"\n    .word expect\n#include \"page.i65\"\n    .word span\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word numtib\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=QUIT\nstack=( -- )\ntags=forth-83,interpreter\nThis is the infinite outer interpreter loop:\n      - resets the return stack (RP!)\n      - outputs a carriage return (CR)\n      - waits for a line of input (QUERY)\n      - interprets that line\n\n```\n: quit\n    [ rp!\n    blk off  source!\n    begin\n        cr\n        query interpret\n        state @ 0=\n        if\n            .\" OK\"\n        then\n    again ;\n```\n#endif\n#include \"align.i65\"\n_quit\n    jsr enter\n#include \"page.i65\"\n    .word _lbracket             ; STATE OFF\n#include \"page.i65\"\n    .word rpstore\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _sourcestore          ; set input source\n#include \"page.i65\"\nquit01                          ; BEGIN\n    .word cr\n#include \"page.i65\"\n    .word _query\n#include \"page.i65\"\n    .word _interpret\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zeq\n#include \"page.i65\"\n    .word qbranch           ; IF\n    .byt <(quit03-*+1)\n#include \"page.i65\"\n    .word _pdq\n    .byt (quit02-*-1)\n    .asc    \" OK\"\nquit02\n#include \"page.i65\"\nquit03                                  ; THEN AGAIN\n    .word branch\n    .byt <(quit01-*+1)\n;#include \"page.i65\"\n;    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=ABORT\nstack=( -- )\ntags=fig,forth-79,forth-83,interpreter\n#endif\n#include \"align.i65\"\n_abort\n    jsr enter\n#include \"page.i65\"\n    .word spstore\n#include \"page.i65\"\n    .word _forth\n#include \"page.i65\"\n    .word _definitions\n#include \"page.i65\"\n    .word _quit\n\n;--------------------------------------------------------------\n#if 0\nname=LOAD\nstack=( u -- )\ntags=interpreter\n\n The contents of >IN and BLK , which locate the current input\n stream, are saved.  The input stream is then redirected to\n the beginning of screen u by setting >IN to zero and BLK to\n u.  The screen is then interpreted.  If interpretation from\n screen u is not terminated explicitly it will be terminated\n when the input stream is exhausted and then the contents of\n >IN and BLK will be restored.  An error condition exists if\n u is zero.  See  >IN  BLK  BLOCK\n\n```\n: load   ( scr -- )\n    ?dup\n    if\n        blk @  >in @ 2>r\n        blk !  source! interpret\n        r> >in !  r> blk !  source!\n    then ;\n```\n#endif\n#include \"align.i65\"\n_load\n    jsr enter\n#include \"page.i65\"\n    .word qdup\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(load01-*+1)\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word twotor\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _sourcestore\n#include \"page.i65\"\n    .word _interpret\n#include \"page.i65\"\n    .word tworfrom\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _sourcestore\n#include \"pass.i65\"\nload01\n    .word exit\n",
			"file": "src/pettil-interpreter.a65",
			"file_size": 22174,
			"file_write_time": 131742508122111140,
			"settings":
			{
				"buffer_size": 22771,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "_qrefill\n    jsr enter\n    .word span\n    .word fetch\n    .word _qexit\n    .word blkfetch\n    .word qbranch               ; keyboard? go directly to `query`\n    .byt <(qrefill01-*+1)\n    .word blkfetch\n    .word _block\n    \n    .word clit\n    .byt PNT                    ; ($C4) pointer current screen line address\n    .word store\n    .word in\n    .word cfetchplus            ; `in.l` cursor offset on logical line\n    .word clit\n    .byt PNTR                   ; $C6 Cursor Column on Current Line\n    .word cstore\n    .word cfetch                ; `in.h` cursor physical line number\n    .word clit\n    .byt TBLX                   ; $D8 Current Cursor Physical Line Number\n    .word cstore\n    .word three                 ; get input from screen device #3\n    .word clit\n    .byt DFLTN                  ; $AF Default Input Device (0)\n    .word cstore\n    .word pqrefill\nqrefill01\n    .word _query\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(?REFILL)\nstack=( -- )\ntags=interpreter,nosymbol\n|Three possible states coming in|<|<|h\n|1|span is 0||\n|2|||\n|3|||\n\n* 'force refill' check first -- exit to outer caller ( of INTERPRET )\n* 'end of line/buffer' check next\n\n    lda userin\n    sta PNTR                    ; $C6\n    lda userin+1\n    sta TBLX                    ; $D8\n    lda #39\n    sta LNMX                    ; $D5 39 or 79\n\n#endif\npqrefill\n    jmp next\n\n\n;--------------------------------------------------------------\n#if 0\nname=NAME\nstack=( char -- nfa | false )\ntags=outer,extra\nParse the next `word` from the `input stream`.  Return `false` if the\n`input stream` is exhausted, or the `nfa` of the found word, built\ndirectly within the input stream.  Advance `in` past the parsed `word`.\n\nLeading delimiters are ignored.   If the delimiter is not found the value of\nIN is the size of the input stream.  If the delimiter is found IN is\n adjusted to indicate the offset to the character following\n the delimiter.  `span` is unmodified.\n\nIn PETTIL `name` replaces the function of Forth-83 //required// reserved\nword `word`, which is //omitted//.\n\nAs much of the `ugly` as I could for the `blk` conspiracy goes in here.\nIsolating conspiracy support in as few words as possible will hopefully\nreduce overall system complexity and present clear transitions between the\nphases of the outer interpreter.\n\n```\n: name   ( nfa -- xfa flag )\n     ?refill 'stream swap >n6 2drop\n     dup skip dup>r 1- <n6 +\n     swap scan r> - >n8 dup\n     if  over c! in 1+!\n     dup \\ something for nip\n     then nip ;\n```\n#endif\n_name\n    jsr enter\n    .word _qrefill\n    .word _tickstream\n    .word swap\n    .word tozp\n    .byt ACC+2*N6               ; set up buffer pointer `n6`\n    .word twodrop\n    .word dup\n    .word skip                  ; start of name\n    .word duptor\n    .word oneminus\n    .word zpfrom\n    .byt ACC+2*N6               ; buf\n    .word plus\n    .word swap\n    .word scan                  ; end of name (and/or buffer)\n    .word rfrom\n    .word minus\n    .word tozp\n    .byt ACC+2*N8               ; name.len\n    .word dup\n    .word qbranch\n    .byt <(name01-*+1)\n    .word over\n    .word cstore                ; prepend name in buffer with name.len\n    .word in\n    .word oneplusstore          ; move `in` past the space that stopped us\n    .word dup                   ; something for `nip` to consume\nname01\n    .word nip\n    .word exit\n\n#print (*-skip)\n",
			"settings":
			{
				"buffer_size": 3411,
				"line_ending": "Unix",
				"name": "_qrefill"
			}
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"ui",
				"UI: Select Color Scheme"
			],
			[
				"pack",
				"Package Control: Install Package"
			]
		],
		"width": 497.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": true,
		"show_open_files": false,
		"show_tabs": true,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/chitselb/Documents/dev/commodore/pettil"
	],
	"file_history":
	[
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-vm.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-dictionary.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-extra.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-studio.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-interpreter.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-editor.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-io.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-name.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/cbm.def",
		"/home/chitselb/Documents/dev/commodore/pettil/tmp/pettil.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/Makefile",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-utils.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/t.t",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-inner.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-nucleus.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/pettil-core.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/pettil.dbg",
		"/home/chitselb/Documents/dev/commodore/pettil/Makefile",
		"/home/chitselb/Documents/dev/commodore/vice-3.2/src/arch/unix/x11/gnome/uimon.c",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/pettil.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/foo.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/mon1.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/enter.mon",
		"/home/chitselb/Documents/dev/commodore/pettil/wrapper.mon",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/pettil-tdict.def",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-compiler.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-user.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-user.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-double.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-locals.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/docs/statictiddlers/EditorDesign.tid",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-number.a65",
		"/home/chitselb/Documents/pettilmobile/resources/history/end.vsf",
		"/home/chitselb/Documents/pettilmobile/resources/history/start.vsf",
		"/home/chitselb/.config/sublime-text-3/Packages/DA UI/DA Color.sublime-settings",
		"/home/chitselb/.config/sublime-text-3/Packages/DA UI/DA Dark.tmTheme",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/; pettil-editor.old2",
		"/home/chitselb/Documents/dev/commodore/pettil/src/pettil-editor.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/src/core-vm.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-editor.old",
		"/home/chitselb/Documents/dev/commodore/pettil/tools/xap.rb",
		"/home/chitselb/.config/autokey/data/My Phrases/pds.txt",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-user.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-assembler.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-editor.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-user.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-utils.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-studio.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-dictionary.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-extra.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/pettil-core.a65",
		"/home/chitselb/core-vm.a65",
		"/home/chitselb/dev/commodore/pettil/tools/xap.rb",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/tiddlywiki.info",
		"/home/chitselb/dev/commodore/pettil/core/src/pettil-corewtf.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-locals.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/sweet16.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-compiler.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-inner.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-double.a65",
		"/mnt/sdc1/chitselb/dev/commodore/otherpet/kenross/download",
		"/home/chitselb/.local/share/applications/xpet.desktop",
		"/home/chitselb/.local/share/applications/xvic.desktop",
		"/home/chitselb/dev/commodore/pettil/core/src/inc/pettil.def",
		"/home/chitselb/dev/commodore/pettil/studio/src/inc/pettil-studio.def",
		"/home/chitselb/dev/commodore/pettil/core/src/inc/cbm.def",
		"/home/chitselb/dev/commodore/pettil/core/src/core-vm.a65",
		"/home/chitselb/dev/commodore/pettil/pettil.dbg",
		"/home/chitselb/dev/commodore/pettil/core/src/core-io.a65",
		"/home/chitselb/.vice/PET/chitselb.vpl",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure.ac",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure.proto",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.guess",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.log",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.rpath",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.status",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.sub",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/t.t",
		"/home/chitselb/dev/commodore/pettil/Makefile",
		"/home/chitselb/dev/commodore/vic20/vickeymap.txt",
		"/home/chitselb/vickeymap.txt",
		"/home/chitselb/dev/commodore/pettil/tmp/symtab.csv",
		"/home/chitselb/dev/commodore/activity.log",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/F83 05. Definitions of Terms.tid",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/AboutPETTIL.tid",
		"/home/chitselb/dev/commodore/pettil/README",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/F83 Appendix B. Uncontrolled Reference Words.tid",
		"/home/chitselb/.vice/sdl-vicerc",
		"/home/chitselb/dev/commodore/pettil/t.t"
	],
	"find":
	{
		"height": 56.0
	},
	"find_in_files":
	{
		"height": 135.0,
		"where_history":
		[
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/vice-3.2/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/.config/sublime-text-3/Packages/DA UI",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src,/home/chitselb/dev/commodore/pettil/docs/statictiddlers",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"_qrefill",
			".word span",
			"xpushc",
			"putnotc",
			"ult",
			"name=U",
			"^ult",
			"ult",
			".word lt",
			"name=>",
			"gt",
			"name=>$",
			"name=<",
			"name=>=",
			"^ge",
			"interpret03",
			"qlineplus",
			"_query",
			"_tickstream",
			"_ticksteam",
			"_name",
			"sib",
			"github",
			"personal ele",
			"for the commo",
			"LPERSCR",
			"^expect",
			"dashtrailing",
			"deadbeef",
			"github.com",
			"^expect",
			"dashtrailing",
			"github\\.com",
			"^_name",
			"^_interpret",
			"userspan",
			"query",
			"dashtrailing",
			"qlineplus",
			"_query",
			"_tickstream",
			"'stream",
			"sib",
			"tuck",
			"_bufwrap",
			"ptickstream",
			"ptick",
			"LNMX",
			"pqrefill",
			"d5",
			"A1",
			"f215",
			"ffcf",
			"e215",
			"_back",
			"erases02",
			"name=(UM*)",
			"threecfe",
			"storeplus",
			"cswap",
			"threecfet",
			"cstoreplus",
			"ptick",
			"threec",
			"threecfetch",
			"tickstream",
			"_query",
			"threecstore",
			"_bufwrap",
			"threecstore",
			"wrap",
			".word _block",
			"dashrot",
			"dwrapfetch",
			"twooff",
			"_load",
			"msb",
			"split",
			"csplit",
			"tickstream",
			"bloomfilter",
			"tobit",
			"tickstream",
			"threeminus",
			"blkbuf",
			"N8",
			"_tickstream",
			"_query",
			"_qrefill",
			"_tickstream",
			"_query",
			"PNT",
			"C4",
			"CR",
			"^expect",
			"userin",
			"DFLTN",
			"device",
			"wrapumax",
			"shims",
			"qrefill",
			"eighty",
			"plugh",
			"userspan",
			"userin",
			"userspan",
			".word span",
			"^_name",
			".word _name",
			".word skip",
			"skip",
			"eighty",
			"ACC+2*N7",
			"N7",
			"N7+1",
			"40|80",
			"tickstream",
			"wraprolls",
			"_block",
			"bufwrap",
			"dwrapfetch",
			"drwapfetch",
			"iddot",
			".word _block",
			"userpwrap",
			"forty",
			"^#include \".*$",
			"xyzzy"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"",
			" ",
			"",
			"^$",
			"$",
			"",
			";",
			"bk .",
			"^bk .",
			"crap",
			"wget https://web.archive.org/web/20051201020459/http://freespace.virgin.net:80/ken.ross1/\\1",
			"\\2",
			" ",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19500,
						"regions":
						{
						},
						"selection":
						[
							[
								10119,
								10119
							]
						],
						"settings":
						{
							"auto_name": "[Return to Main Page] NMOS 6502 Opcodes by John Pi",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4530.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "tmp/pettil.mon",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24807,
						"regions":
						{
						},
						"selection":
						[
							[
								18215,
								18215
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 16774.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "studio/src/pettil-name.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11322,
						"regions":
						{
						},
						"selection":
						[
							[
								10013,
								10013
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5798.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19239,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										221,
										224
									],
									[
										334,
										337
									],
									[
										526,
										529
									],
									[
										645,
										648
									],
									[
										785,
										788
									],
									[
										981,
										984
									],
									[
										1346,
										1349
									],
									[
										1650,
										1653
									],
									[
										1988,
										1991
									],
									[
										2183,
										2186
									],
									[
										2314,
										2317
									],
									[
										2370,
										2373
									],
									[
										2402,
										2405
									],
									[
										2439,
										2442
									],
									[
										2535,
										2538
									],
									[
										2590,
										2593
									],
									[
										2833,
										2836
									],
									[
										3005,
										3008
									],
									[
										3018,
										3021
									],
									[
										3164,
										3167
									],
									[
										3200,
										3203
									],
									[
										3254,
										3257
									],
									[
										3278,
										3281
									],
									[
										3458,
										3461
									],
									[
										3474,
										3477
									],
									[
										3490,
										3493
									],
									[
										3669,
										3672
									],
									[
										3799,
										3802
									],
									[
										3994,
										3997
									],
									[
										4146,
										4149
									],
									[
										4328,
										4331
									],
									[
										4372,
										4375
									],
									[
										4400,
										4403
									],
									[
										4630,
										4633
									],
									[
										4700,
										4703
									],
									[
										4798,
										4801
									],
									[
										4912,
										4915
									],
									[
										5026,
										5029
									],
									[
										5154,
										5157
									],
									[
										5186,
										5189
									],
									[
										5345,
										5348
									],
									[
										5383,
										5386
									],
									[
										5424,
										5427
									],
									[
										5515,
										5518
									],
									[
										5538,
										5541
									],
									[
										5645,
										5648
									],
									[
										5684,
										5687
									],
									[
										5756,
										5759
									],
									[
										5974,
										5977
									],
									[
										6176,
										6179
									],
									[
										6376,
										6379
									],
									[
										6552,
										6555
									],
									[
										6779,
										6782
									],
									[
										7038,
										7041
									],
									[
										7210,
										7213
									],
									[
										7272,
										7275
									],
									[
										7382,
										7385
									],
									[
										7547,
										7550
									],
									[
										7721,
										7724
									],
									[
										7783,
										7786
									],
									[
										7859,
										7862
									],
									[
										7986,
										7989
									],
									[
										8107,
										8110
									],
									[
										8421,
										8424
									],
									[
										8703,
										8706
									],
									[
										8768,
										8771
									],
									[
										8980,
										8983
									],
									[
										9288,
										9291
									],
									[
										9546,
										9549
									],
									[
										9665,
										9668
									],
									[
										9784,
										9787
									],
									[
										9896,
										9899
									],
									[
										10012,
										10015
									],
									[
										10125,
										10128
									],
									[
										10316,
										10319
									],
									[
										10370,
										10373
									],
									[
										10596,
										10599
									],
									[
										10662,
										10665
									],
									[
										10747,
										10750
									],
									[
										10972,
										10975
									],
									[
										11257,
										11260
									],
									[
										11300,
										11303
									],
									[
										11529,
										11532
									],
									[
										11678,
										11681
									],
									[
										11773,
										11776
									],
									[
										11815,
										11818
									],
									[
										11932,
										11935
									],
									[
										12051,
										12054
									],
									[
										12178,
										12181
									],
									[
										12347,
										12350
									],
									[
										12450,
										12453
									],
									[
										12569,
										12572
									],
									[
										12719,
										12722
									],
									[
										13003,
										13006
									],
									[
										13190,
										13193
									],
									[
										13445,
										13448
									],
									[
										13573,
										13576
									],
									[
										13784,
										13787
									],
									[
										13992,
										13995
									],
									[
										14208,
										14211
									],
									[
										14513,
										14516
									],
									[
										14687,
										14690
									],
									[
										14968,
										14971
									],
									[
										15229,
										15232
									],
									[
										15459,
										15462
									],
									[
										15698,
										15701
									],
									[
										15908,
										15911
									],
									[
										16158,
										16161
									],
									[
										16457,
										16464
									],
									[
										16670,
										16677
									],
									[
										16844,
										16851
									],
									[
										17006,
										17013
									],
									[
										17149,
										17156
									],
									[
										17435,
										17441
									],
									[
										17647,
										17653
									],
									[
										17878,
										17884
									],
									[
										18090,
										18096
									],
									[
										18380,
										18390
									],
									[
										18583,
										18593
									],
									[
										18778,
										18788
									],
									[
										19025,
										19033
									],
									[
										19153,
										19161
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								19153,
								19161
							]
						],
						"settings":
						{
							"color_scheme": "Packages/BetterFindBuffer/FindResults.hidden-tmTheme",
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 5,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 10692.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "studio/src/pettil-assembler.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31780,
						"regions":
						{
						},
						"selection":
						[
							[
								15453,
								15453
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14406.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "studio/src/pettil-studio.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10341,
						"regions":
						{
						},
						"selection":
						[
							[
								315,
								315
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 54.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "core/src/pettil-core.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29143,
						"regions":
						{
						},
						"selection":
						[
							[
								28677,
								28677
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 19075.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "core/src/core-nucleus.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 56416,
						"regions":
						{
						},
						"selection":
						[
							[
								21175,
								21175
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 18726.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "core/src/core-vm.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 39984,
						"regions":
						{
						},
						"selection":
						[
							[
								26919,
								26919
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 22303.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "studio/src/pettil-compiler.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 42475,
						"regions":
						{
						},
						"selection":
						[
							[
								10228,
								10228
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8461.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "studio/src/pettil-editor.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 27284,
						"regions":
						{
						},
						"selection":
						[
							[
								25596,
								25596
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 22375.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "studio/src/pettil-interpreter.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13899,
						"regions":
						{
						},
						"selection":
						[
							[
								7531,
								7531
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5546.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "core/src/core-extra.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10842,
						"regions":
						{
						},
						"selection":
						[
							[
								8482,
								8482
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8070.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "core/src/core-io.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18112,
						"regions":
						{
						},
						"selection":
						[
							[
								6448,
								6448
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4484.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "src/pettil-interpreter.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22771,
						"regions":
						{
						},
						"selection":
						[
							[
								3967,
								3967
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2838.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 15,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3411,
						"regions":
						{
						},
						"selection":
						[
							[
								223,
								223
							]
						],
						"settings":
						{
							"auto_name": "_qrefill",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 33.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 103.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "pettil.sublime-project",
	"replace":
	{
		"height": 95.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"tiddly",
				"docs/statictiddlers/tiddlywiki.info"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 199.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}

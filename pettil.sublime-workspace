{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "[Return to Main Page] NMOS 6502 Opcodes by John Pickens, Updated by Bruce Clark and by Ed Spittles \n[Up to Tutorials and Aids] \nINDEX\nBranches\tDecimal Mode\tInterrupt Flag\tOverflow Flag\tProgram Counter\tStack\tTimes\tWrap-around\nADC\tAND\tASL\tBCC\tBCS\tBEQ\tBIT\tBMI\tBNE\tBPL\tBRK\tBVC\tBVS\tCLC\nCLD\tCLI\tCLV\tCMP\tCPX\tCPY\tDEC\tDEX\tDEY\tEOR\tINC\tINX\tINY\tJMP\nJSR\tLDA\tLDX\tLDY\tLSR\tNOP\tORA\tPHA\tPHP\tPLA\tPLP\tROL\tROR\tRTI\nRTS\tSBC\tSEC\tSED\tSEI\tSTA\tSTX\tSTY\tTAX\tTAY\tTSX\tTXA\tTXS\tTYA\n \n\nADC (ADd with Carry)\nAffects Flags: S V Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     ADC #$44      $69  2   2\nZero Page     ADC $44       $65  2   3\nZero Page,X   ADC $44,X     $75  2   4\nAbsolute      ADC $4400     $6D  3   4\nAbsolute,X    ADC $4400,X   $7D  3   4+\nAbsolute,Y    ADC $4400,Y   $79  3   4+\nIndirect,X    ADC ($44,X)   $61  2   6\nIndirect,Y    ADC ($44),Y   $71  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nADC results are dependant on the setting of the decimal flag. In decimal mode, addition is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal).\nThere is no way to add without carry.\n\n \n\nAND (bitwise AND with accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     AND #$44      $29  2   2\nZero Page     AND $44       $25  2   3\nZero Page,X   AND $44,X     $35  2   4\nAbsolute      AND $4400     $2D  3   4\nAbsolute,X    AND $4400,X   $3D  3   4+\nAbsolute,Y    AND $4400,Y   $39  3   4+\nIndirect,X    AND ($44,X)   $21  2   6\nIndirect,Y    AND ($44),Y   $31  2   5+\n\n+ add 1 cycle if page boundary crossed\n \n\nASL (Arithmetic Shift Left)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ASL A         $0A  1   2\nZero Page     ASL $44       $06  2   5\nZero Page,X   ASL $44,X     $16  2   6\nAbsolute      ASL $4400     $0E  3   6\nAbsolute,X    ASL $4400,X   $1E  3   7\n\nASL shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.\n \n\nBIT (test BITs)\nAffects Flags: N V Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     BIT $44       $24  2   3\nAbsolute      BIT $4400     $2C  3   4\n\nBIT sets the Z flag as though the value in the address tested were ANDed with the accumulator. The S and V flags are set to match bits 7 and 6 respectively in the value stored at the tested address.\nBIT is often used to skip one or two following bytes as in:\n\nCLOSE1 LDX #$10   If entered here, we\n       .BYTE $2C  effectively perform\nCLOSE2 LDX #$20   a BIT test on $20A2,\n       .BYTE $2C  another one on $30A2,\nCLOSE3 LDX #$30   and end up with the X\nCLOSEX LDA #12    register still at $10\n       STA ICCOM,X upon arrival here.\n\nBeware: a BIT instruction used in this way as a NOP does have effects: the flags may be modified, and the read of the absolute address, if it happens to access an I/O device, may cause an unwanted action.\n                 \n\nBranch Instructions\nAffect Flags: none\n\nAll branches are relative mode and have a length of two bytes. Syntax is \"Bxx Displacement\" or (better) \"Bxx Label\". See the notes on the Program Counter for more on displacements.\n\nBranches are dependant on the status of the flag bits when the op code is encountered. A branch not taken requires two machine cycles. Add one if the branch is taken and add one more if the branch crosses a page boundary.\n\nMNEMONIC                       HEX\nBPL (Branch on PLus)           $10\nBMI (Branch on MInus)          $30\nBVC (Branch on oVerflow Clear) $50\nBVS (Branch on oVerflow Set)   $70\nBCC (Branch on Carry Clear)    $90\nBCS (Branch on Carry Set)      $B0\nBNE (Branch on Not Equal)      $D0\nBEQ (Branch on EQual)          $F0\n\nThere is no BRA (BRanch Always) instruction but it can be easily emulated by branching on the basis of a known condition. One of the best flags to use for this purpose is the oVerflow which is unchanged by all but addition and subtraction operations.\nA page boundary crossing occurs when the branch destination is on a different page than the instruction AFTER the branch instruction. For example:\n\n  SEC\n  BCS LABEL\n  NOP\nA page boundary crossing occurs (i.e. the BCS takes 4 cycles) when (the address of) LABEL and the NOP are on different pages. This means that\n        CLV\n        BVC LABEL\n  LABEL NOP\nthe BVC instruction will take 3 cycles no matter what address it is located at.\n \n\nBRK (BReaK)\nAffects Flags: B\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       BRK           $00  1   7\n\nBRK causes a non-maskable interrupt and increments the program counter by one. Therefore an RTI will go to the address of the BRK +2 so that BRK may be used to replace a two-byte instruction for debugging and the subsequent RTI will be correct.\n \n\nCMP (CoMPare accumulator)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CMP #$44      $C9  2   2\nZero Page     CMP $44       $C5  2   3\nZero Page,X   CMP $44,X     $D5  2   4\nAbsolute      CMP $4400     $CD  3   4\nAbsolute,X    CMP $4400,X   $DD  3   4+\nAbsolute,Y    CMP $4400,Y   $D9  3   4+\nIndirect,X    CMP ($44,X)   $C1  2   6\nIndirect,Y    CMP ($44),Y   $D1  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nCompare sets flags as if a subtraction had been carried out. If the value in the accumulator is equal or greater than the compared value, the Carry will be set. The equal (Z) and sign (S) flags will be set based on equality or lack thereof and the sign (i.e. A>=$80) of the accumulator.\n \n\nCPX (ComPare X register)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CPX #$44      $E0  2   2\nZero Page     CPX $44       $E4  2   3\nAbsolute      CPX $4400     $EC  3   4\n\nOperation and flag results are identical to equivalent mode accumulator CMP ops.\n \n\nCPY (ComPare Y register)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     CPY #$44      $C0  2   2\nZero Page     CPY $44       $C4  2   3\nAbsolute      CPY $4400     $CC  3   4\n\nOperation and flag results are identical to equivalent mode accumulator CMP ops.\n \n\nDEC (DECrement memory)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     DEC $44       $C6  2   5\nZero Page,X   DEC $44,X     $D6  2   6\nAbsolute      DEC $4400     $CE  3   6\nAbsolute,X    DEC $4400,X   $DE  3   7\n\n \n\nEOR (bitwise Exclusive OR)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     EOR #$44      $49  2   2\nZero Page     EOR $44       $45  2   3\nZero Page,X   EOR $44,X     $55  2   4\nAbsolute      EOR $4400     $4D  3   4\nAbsolute,X    EOR $4400,X   $5D  3   4+\nAbsolute,Y    EOR $4400,Y   $59  3   4+\nIndirect,X    EOR ($44,X)   $41  2   6\nIndirect,Y    EOR ($44),Y   $51  2   5+\n\n+ add 1 cycle if page boundary crossed\n             \n\nFlag (Processor Status) Instructions\nAffect Flags: as noted\n\nThese instructions are implied mode, have a length of one byte and require two machine cycles.\n\nMNEMONIC                       HEX\nCLC (CLear Carry)              $18\nSEC (SEt Carry)                $38\nCLI (CLear Interrupt)          $58\nSEI (SEt Interrupt)            $78\nCLV (CLear oVerflow)           $B8\nCLD (CLear Decimal)            $D8\nSED (SEt Decimal)              $F8\n\nNotes:\n  The Interrupt flag is used to prevent (SEI) or enable (CLI) maskable interrupts (aka IRQ's). It does not signal the presence or absence of an interrupt condition. The 6502 will set this flag automatically in response to an interrupt and restore it to its prior status on completion of the interrupt service routine. If you want your interrupt service routine to permit other maskable interrupts, you must clear the I flag in your code.\n\n  The Decimal flag controls how the 6502 adds and subtracts. If set, arithmetic is carried out in packed binary coded decimal. This flag is unchanged by interrupts and is unknown on power-up. The implication is that a CLD should be included in boot or interrupt coding.\n\n  The Overflow flag is generally misunderstood and therefore under-utilised. After an ADC or SBC instruction, the overflow flag will be set if the twos complement result is less than -128 or greater than +127, and it will cleared otherwise. In twos complement, $80 through $FF represents -128 through -1, and $00 through $7F represents 0 through +127. Thus, after:\n\n  CLC\n  LDA #$7F ;   +127\n  ADC #$01 ; +   +1\nthe overflow flag is 1 (+127 + +1 = +128), and after:\n  CLC\n  LDA #$81 ;   -127\n  ADC #$FF ; +   -1\nthe overflow flag is 0 (-127 + -1 = -128). The overflow flag is not affected by increments, decrements, shifts and logical operations i.e. only ADC, BIT, CLV, PLP, RTI and SBC affect it. There is no op code to set the overflow but a BIT test on an RTS instruction will do the trick.\n \n\nINC (INCrement memory)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     INC $44       $E6  2   5\nZero Page,X   INC $44,X     $F6  2   6\nAbsolute      INC $4400     $EE  3   6\nAbsolute,X    INC $4400,X   $FE  3   7\n \n\nJMP (JuMP)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nAbsolute      JMP $5597     $4C  3   3\nIndirect      JMP ($5597)   $6C  3   5\n\nJMP transfers program execution to the following address (absolute) or to the location contained in the following address (indirect). Note that there is no carry associated with the indirect jump so:\nAN INDIRECT JUMP MUST NEVER USE A\nVECTOR BEGINNING ON THE LAST BYTE\nOF A PAGE\nFor example if address $3000 contains $40, $30FF contains $80, and $3100 contains $50, the result of JMP ($30FF) will be a transfer of control to $4080 rather than $5080 as you intended i.e. the 6502 took the low byte of the address from $30FF and the high byte from $3000.\n \n\nJSR (Jump to SubRoutine)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nAbsolute      JSR $5597     $20  3   6\n\nJSR pushes the address-1 of the next operation on to the stack before transferring program control to the following address. Subroutines are normally terminated by a RTS op code.\n \n\nLDA (LoaD Accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDA #$44      $A9  2   2\nZero Page     LDA $44       $A5  2   3\nZero Page,X   LDA $44,X     $B5  2   4\nAbsolute      LDA $4400     $AD  3   4\nAbsolute,X    LDA $4400,X   $BD  3   4+\nAbsolute,Y    LDA $4400,Y   $B9  3   4+\nIndirect,X    LDA ($44,X)   $A1  2   6\nIndirect,Y    LDA ($44),Y   $B1  2   5+\n\n+ add 1 cycle if page boundary crossed\n \n\nLDX (LoaD X register)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDX #$44      $A2  2   2\nZero Page     LDX $44       $A6  2   3\nZero Page,Y   LDX $44,Y     $B6  2   4\nAbsolute      LDX $4400     $AE  3   4\nAbsolute,Y    LDX $4400,Y   $BE  3   4+\n\n+ add 1 cycle if page boundary crossed\n \n\nLDY (LoaD Y register)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     LDY #$44      $A0  2   2\nZero Page     LDY $44       $A4  2   3\nZero Page,X   LDY $44,X     $B4  2   4\nAbsolute      LDY $4400     $AC  3   4\nAbsolute,X    LDY $4400,X   $BC  3   4+\n\n+ add 1 cycle if page boundary crossed\n \n\nLSR (Logical Shift Right)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   LSR A         $4A  1   2\nZero Page     LSR $44       $46  2   5\nZero Page,X   LSR $44,X     $56  2   6\nAbsolute      LSR $4400     $4E  3   6\nAbsolute,X    LSR $4400,X   $5E  3   7\n\nLSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.\n \n\nWrap-Around\nUse caution with indexed zero page operations as they are subject to wrap-around. For example, if the X register holds $FF and you execute LDA $80,X you will not access $017F as you might expect; instead you access $7F i.e. $80-1. This characteristic can be used to advantage but make sure your code is well commented.\n\nIt is possible, however, to access $017F when X = $FF by using the Absolute,X addressing mode of LDA $80,X. That is, instead of:\n\n  LDA $80,X    ; ZeroPage,X - the resulting object code is: B5 80\nwhich accesses $007F when X=$FF, use:\n  LDA $0080,X  ; Absolute,X - the resulting object code is: BD 80 00\nwhich accesses $017F when X = $FF (a at cost of one additional byte and one additional cycle). All of the ZeroPage,X and ZeroPage,Y instructions except STX ZeroPage,Y and STY ZeroPage,X have a corresponding Absolute,X and Absolute,Y instruction. Unfortunately, a lot of 6502 assemblers don't have an easy way to force Absolute addressing, i.e. most will assemble a LDA $0080,X as B5 80. One way to overcome this is to insert the bytes using the .BYTE pseudo-op (on some 6502 assemblers this pseudo-op is called DB or DFB, consult the assembler documentation) as follows:\n  .BYTE $BD,$80,$00  ; LDA $0080,X (absolute,X addressing mode)\nThe comment is optional, but highly recommended for clarity.\nIn cases where you are writing code that will be relocated you must consider wrap-around when assigning dummy values for addresses that will be adjusted. Both zero and the semi-standard $FFFF should be avoided for dummy labels. The use of zero or zero page values will result in assembled code with zero page opcodes when you wanted absolute codes. With $FFFF, the problem is in addresses+1 as you wrap around to page 0.\n\n \n\nProgram Counter\nWhen the 6502 is ready for the next instruction it increments the program counter before fetching the instruction. Once it has the op code, it increments the program counter by the length of the operand, if any. This must be accounted for when calculating branches or when pushing bytes to create a false return address (i.e. jump table addresses are made up of addresses-1 when it is intended to use an RTS rather than a JMP).\n\nThe program counter is loaded least signifigant byte first. Therefore the most signifigant byte must be pushed first when creating a false return address.\n\nWhen calculating branches a forward branch of 6 skips the following 6 bytes so, effectively the program counter points to the address that is 8 bytes beyond the address of the branch opcode; and a backward branch of $FA (256-6) goes to an address 4 bytes before the branch instruction.\n\n \n\nExecution Times\nOp code execution times are measured in machine cycles; one machine cycle equals one clock cycle. Many instructions require one extra cycle for execution if a page boundary is crossed; these are indicated by a + following the time values shown.\n\n \n\nNOP (No OPeration)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       NOP           $EA  1   2\n\nNOP is used to reserve space for future modifications or effectively REM out existing code.\n \n\nORA (bitwise OR with Accumulator)\nAffects Flags: S Z\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     ORA #$44      $09  2   2\nZero Page     ORA $44       $05  2   3\nZero Page,X   ORA $44,X     $15  2   4\nAbsolute      ORA $4400     $0D  3   4\nAbsolute,X    ORA $4400,X   $1D  3   4+\nAbsolute,Y    ORA $4400,Y   $19  3   4+\nIndirect,X    ORA ($44,X)   $01  2   6\nIndirect,Y    ORA ($44),Y   $11  2   5+\n\n+ add 1 cycle if page boundary crossed\n               \n\nRegister Instructions\nAffect Flags: S Z\n\nThese instructions are implied mode, have a length of one byte and require two machine cycles.\n\nMNEMONIC                 HEX\nTAX (Transfer A to X)    $AA\nTXA (Transfer X to A)    $8A\nDEX (DEcrement X)        $CA\nINX (INcrement X)        $E8\nTAY (Transfer A to Y)    $A8\nTYA (Transfer Y to A)    $98\nDEY (DEcrement Y)        $88\nINY (INcrement Y)        $C8\n \n\nROL (ROtate Left)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ROL A         $2A  1   2\nZero Page     ROL $44       $26  2   5\nZero Page,X   ROL $44,X     $36  2   6\nAbsolute      ROL $4400     $2E  3   6\nAbsolute,X    ROL $4400,X   $3E  3   7\n\nROL shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.\n \n\nROR (ROtate Right)\nAffects Flags: S Z C\n\nMODE           SYNTAX       HEX LEN TIM\nAccumulator   ROR A         $6A  1   2\nZero Page     ROR $44       $66  2   5\nZero Page,X   ROR $44,X     $76  2   6\nAbsolute      ROR $4400     $6E  3   6\nAbsolute,X    ROR $4400,X   $7E  3   7\n\nROR shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.\n \n\nRTI (ReTurn from Interrupt)\nAffects Flags: all\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       RTI           $40  1   6\n\nRTI retrieves the Processor Status Word (flags) and the Program Counter from the stack in that order (interrupts push the PC first and then the PSW).\nNote that unlike RTS, the return address on the stack is the actual address rather than the address-1.\n\n \n\nRTS (ReTurn from Subroutine)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nImplied       RTS           $60  1   6\n\nRTS pulls the top two bytes off the stack (low byte first) and transfers program control to that address+1. It is used, as expected, to exit a subroutine invoked via JSR which pushed the address-1.\nRTS is frequently used to implement a jump table where addresses-1 are pushed onto the stack and accessed via RTS eg. to access the second of four routines:\n\n LDX #1\n JSR EXEC\n JMP SOMEWHERE\n\nLOBYTE\n .BYTE <ROUTINE0-1,<ROUTINE1-1\n .BYTE <ROUTINE2-1,<ROUTINE3-1\n\nHIBYTE\n .BYTE >ROUTINE0-1,>ROUTINE1-1\n .BYTE >ROUTINE2-1,>ROUTINE3-1\n\nEXEC\n LDA HIBYTE,X\n PHA\n LDA LOBYTE,X\n PHA\n RTS\n \n\nSBC (SuBtract with Carry)\nAffects Flags: S V Z C\n\nMODE           SYNTAX       HEX LEN TIM\nImmediate     SBC #$44      $E9  2   2\nZero Page     SBC $44       $E5  2   3\nZero Page,X   SBC $44,X     $F5  2   4\nAbsolute      SBC $4400     $ED  3   4\nAbsolute,X    SBC $4400,X   $FD  3   4+\nAbsolute,Y    SBC $4400,Y   $F9  3   4+\nIndirect,X    SBC ($44,X)   $E1  2   6\nIndirect,Y    SBC ($44),Y   $F1  2   5+\n\n+ add 1 cycle if page boundary crossed\n\nSBC results are dependant on the setting of the decimal flag. In decimal mode, subtraction is carried out on the assumption that the values involved are packed BCD (Binary Coded Decimal).\nThere is no way to subtract without the carry which works as an inverse borrow. i.e, to subtract you set the carry before the operation. If the carry is cleared by the operation, it indicates a borrow occurred.\n\n \n\nSTA (STore Accumulator)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STA $44       $85  2   3\nZero Page,X   STA $44,X     $95  2   4\nAbsolute      STA $4400     $8D  3   4\nAbsolute,X    STA $4400,X   $9D  3   5\nAbsolute,Y    STA $4400,Y   $99  3   5\nIndirect,X    STA ($44,X)   $81  2   6\nIndirect,Y    STA ($44),Y   $91  2   6\n             \n\nStack Instructions\nThese instructions are implied mode, have a length of one byte and require machine cycles as indicated. The \"PuLl\" operations are known as \"POP\" on most other microprocessors. With the 6502, the stack is always on page one ($100-$1FF) and works top down.\n\nMNEMONIC                        HEX TIM\nTXS (Transfer X to Stack ptr)   $9A  2\nTSX (Transfer Stack ptr to X)   $BA  2\nPHA (PusH Accumulator)          $48  3\nPLA (PuLl Accumulator)          $68  4\nPHP (PusH Processor status)     $08  3\nPLP (PuLl Processor status)     $28  4\n \n\nSTX (STore X register)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STX $44       $86  2   3\nZero Page,Y   STX $44,Y     $96  2   4\nAbsolute      STX $4400     $8E  3   4\n \n\nSTY (STore Y register)\nAffects Flags: none\n\nMODE           SYNTAX       HEX LEN TIM\nZero Page     STY $44       $84  2   3\nZero Page,X   STY $44,X     $94  2   4\nAbsolute      STY $4400     $8C  3   4\nLast Updated May 5, 2017.",
			"settings":
			{
				"buffer_size": 19500,
				"line_ending": "Unix",
				"name": "[Return to Main Page] NMOS 6502 Opcodes by John Pi"
			}
		},
		{
			"file": "core/src/core-extra.a65",
			"settings":
			{
				"buffer_size": 10945,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-io.a65",
			"settings":
			{
				"buffer_size": 19218,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "'stream\t\t( buf size )\n",
			"settings":
			{
				"buffer_size": 22,
				"line_ending": "Unix",
				"name": "'stream\t\t( buf size )"
			}
		},
		{
			"file": "tmp/pettil.mon",
			"settings":
			{
				"buffer_size": 24908,
				"line_ending": "Unix"
			}
		},
		{
			"file": "tools/xap.rb",
			"settings":
			{
				"buffer_size": 20049,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/mnt/data/chitselb/Documents/dev/commodore/pettil/tmp/pettil.csv",
			"settings":
			{
				"buffer_size": 40043,
				"line_ending": "Unix"
			}
		},
		{
			"file": "studio/src/pettil-interpreter.a65",
			"settings":
			{
				"buffer_size": 13966,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/pettil-core.a65",
			"settings":
			{
				"buffer_size": 29210,
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-vm.a65",
			"settings":
			{
				"buffer_size": 39960,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "_block\n    jsr enter\n#include \"page.i65\"\nqmkpkts01\n    .word numblk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word lt\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(qmkpkts02-*+1)\n#include \"page.i65\"\n    .word _pktplus\n#include \"pass.i65\"\n    .word branch\n    .byt <(qmkpkts01-*+1)\n#include \"page.i65\"\nqmkpkts02\n\n\n    editing? \n    if\n        vidram\n    else\n        blkbuf\n        prev 2@ =\n    then\n    .word prev\n#include \"page.i65\"\n    .word twofetch              ; also `blk`\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n   .word editingq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(blk01-*+1)\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word blkbuf\n#include \"pass.i65\"\n    .word branch\n    .byt <(blk04-*+1)\n#include \"page.i65\"\nblk01\n    .word _topkt\n#include \"page.i65\"\n   .word editingq\n#include \"pass.i65\"\n   .word pquerycolon\n   .word vidram\n   .word blkbuf\n#include \"page.i65\"\n   .word nip\n#include \"page.i65\"\n   .word dup\n#include \"page.i65\"\n   .word bperbuf\n#include \"page.i65\"\n   .word isscrq\n#include \"pass.i65\"\n   .word pquerycolon\n   .word blank\n   .word erase\n#include \"page.i65\"\n   .word dup\n#include \"page.i65\"\n   .word _pktsize\n#include \"page.i65\"\n   .word tuck\n#include \"page.i65\"\n   .word minus\n#include \"page.i65\"\n   .word isscrq\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(blk03-*+1)\n#include \"page.i65\"\n   .word threeminusunder\n#include \"pass.i65\"\n   .word zpfrom\n   .byt ACC+2*N8                ; `pkt`\n#include \"page.i65\"\n   .word threeminus\n#include \"page.i65\"\n   .word _dwrapfetch\n#include \"page.i65\"\n   .word editingq\n#include \"pass.i65\"\n   .word pquerycolon\n   .word wrapstore\n   .word _bufwrapstore\n#include \"page.i65\"\nblk03\n   .word dashrot\n#include \"page.i65\"\n   .word uncompressedq\n#include \"pass.i65\"\n   .word pquerycolon\n   .word cmove\n   .word rldecode\n#include \"pass.i65\"\nblk04\n   .word exit\n\n",
			"settings":
			{
				"buffer_size": 1961,
				"line_ending": "Unix",
				"name": "_block"
			}
		},
		{
			"file": "core/src/core-user.a65",
			"settings":
			{
				"buffer_size": 8338,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-double.a65",
			"settings":
			{
				"buffer_size": 10074,
				"line_ending": "Unix"
			}
		},
		{
			"file": "core/src/core-inner.a65",
			"settings":
			{
				"buffer_size": 23131,
				"line_ending": "Unix"
			}
		},
		{
			"contents": ">C:0000  00 58 50 00  bc 07 45 58  19 00 00 00  00 01 00 00  00 02 19 02  b1 54 34 d5  00 01 19 ff  02 ee 86 00   \n>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   \n>C:0040  aa aa aa aa  aa ff e9 7f  22 00 00 80  3b 20 00 01  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb  \n>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb ff 5b 01  00 58 00 00  03 00 00 10  \n>C:0080  00 00 00 00  74 06 e6 8b  e6 8b 6c 31  18 00 18 79  55 e4 55 06  ff b3 00 ff  00 2d 00 ff  00 00 00 00  \n>C:00a0  00 01 00 0f  00 3f ff 01  02 20 00 00  00 00 00 03  03 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  \n>C:00c0  00 00 00 00  00 58 00 c0  83 7d 42 00  00 00 00 00  00 01 00 60  08 50 00 00  18 53 fd 7f  00 00 00 00  \n>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82  82 82 02 82  03 83 03 83  83 00 00 7d  42 ff ff 15  \n>C:01e0  2c 8c 32 aa  0f df 50 53  18 63 18 5b  6a 64 6a 5c  71 e0 71 00  00 1f 01 21  00 e0 0f 72  71 a3 71 04  \n>C:0200  49 4e 46 4f  01 5e 05 46  4f 52 54 48  05 57 4f 52  44 53 04 49  4e 46 4f 01  31 04 4c 4f  41 44 20 2e  \n>C:0220  53 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  \n>C:0240  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  \n>C:033a  00 00 00 00  00 00 ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  \n>C:035a  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  \n>C:037a  ff ff ff ff  ff ff 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  \n>C:039a  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  \n>C:03ba  00 00 00 00  00 00 ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff  \n>C:03da  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff 10  10 09 10 02  00 ff 00 00  00 00 00 00  00 00 00 00  \n",
			"settings":
			{
				"buffer_size": 2054,
				"line_ending": "Unix",
				"name": ">C:0000  00 58 50 00  bc 07 45 58  19 00 00 00  00"
			}
		},
		{
			"contents": "; pettil-interpreter.a65\n#echo .       pettil-interpreter.a65    Outer Interpreter\n\n;--------------------------------------------------------------\n#if 0\nname=~ Error messages\ntags=general,nosymbol\nPETTIL system messages, output by [[FAIL]]\n#endif\nerrptr\n    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08\n    .word msg09,msg10,msg11\n\nmsg01\n    .byt msg02-*-1\n    .asc \"STACK UNDERFLOW\"\nmsg02\n    .byt msg03-*-1\n    .asc \"STACK OVERFLOW\"\nmsg03\n    .byt msg04-*-1\n    .asc \"NOT FOUND\"\nmsg04\n    .byt msg05-*-1\n    .asc \"DEFINITION UNFINISHED\"\nmsg05\n    .byt msg06-*-1\n    .asc \"COMPILATION ONLY\"\nmsg06\n    .byt msg07-*-1\n    .asc \"UNPAIRED CONDITIONALS\"\nmsg07\n    .byt msg08-*-1\n    .asc \"CAN'T FORGET BELOW FENCE\"\nmsg08\n    .byt msg09-*-1\n    .asc \"BLOCK OUT OF RANGE\"\nmsg09\n    .byt msg10-*-1\n    .asc \" MISSING\"\nmsg10\n    .byt msg11-*-1\n    .byt \"CORRUPT VIRTUAL MEMORY\"\nmsg11\n    .byt msg12-*-1\n    .byt \"BAD ADDRESSING MODE\"\nmsg12\n\n;--------------------------------------------------------------\n#if 0\nname=EXISTS?\nstack=( -- addr flag )\ntags=interpreter,ext,nosymbol\nparses the next token in the input stream.  Returns either the\naddress of the (unfound) token at HERE and a 0, or the code\nfield address of the word and -1 for normal, +1 for immediate\nwords\n\n```\n: exists?\n   bl word dup c@ ?: find 0 ;\n```\n#endif\n#include \"align.i65\"\n_existsq\n    jsr enter\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word pquerycolon\n    .word _find\n    .word zero\n#include \"page.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname='\nstack=( -- cfa )\ntags=forth-83\nParse the next token in the input stream and search for it,\nreturning the CFA if successful.  Otherwise aborts with the\nmessage \"NOT FOUND\"\n\n```\n: '   ( \"name\" -- cfa )\n    exists? 0=  3 ?error ;\n```\n#endif\n#include \"align.i65\"\n_tick\n    jsr enter\n#include \"page.i65\"\n    .word _existsq\n#include \"page.i65\"\n    .word zeq\n    .word qerror\n    .byt 3                      ; NOT FOUND\n#include \"page.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.TIB\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from the console.  Leaves\nan address\n\n```\n: source.tib   ( -- addr size )\n    tib #tib @ ;\n```\n#endif\n#include \"align.i65\"\n_sourcetib\n    jsr enter\n#include \"page.i65\"\n    .word tib\n#include \"page.i65\"\n    .word numtib\n#include \"page.i65\"\n    .word fetch\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.BLK\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from the console.  Leaves\nan address and size\n\n```\n: source.blk   ( -- addr size )\n    block b/buf ;\n```\n#endif\n#include \"align.i65\"\n_sourceblk\n    jsr enter\n#include \"page.i65\"\n    .word _block\n#include \"page.i65\"\n    .word bperbuf\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=REFILL.SCR\nstack=( -- flag )\ntags=interpreter,nosymbol\nLoads the next logical line from the virtual screen buffer into another\n80-character buffer, returning a flag indicating if there was a next line\n\n```\n: refill.scr   ( -- )\n    #lin off\n    >in off\n    lin dup 1+! @\n    25 <\n    if\n        lin @                   ( lin )\n        dup >bit blkbuf + cbit@ ( lin flag )\n        swap 24 = or            ( flag )\n        if\n            forty\n        else\n            lin 1+! eighty\n        then                    ( 40|80 )\n        dup    LNMX c!\n        3      DFLTN c!\n        @lin @ PNT dup dup>r 3c@ >r >r !\n        0      PNTR c!          ( 40|80 )\n        cas2buf over 2dup expect -trailing\n        r> r> r> 3c!            ( restore screen cursor )\n        @lin +!\n        span @  #lin !\n    then ;\n\n: refill.scr   ( -- )\n    in off\n    in benjamin +!  in @ msb\n    25 <\n    if\n        lin @                   ( lin )\n        dup >bit blkbuf + cbit@ ( lin flag )\n        swap 24 = or            ( flag )\n        if\n            forty\n        else\n            lin 1+! eighty\n        then                    ( 40|80 )\n        dup    LNMX c!\n        3      DFLTN c!\n        @lin @ PNT dup dup>r 3c@ >r >r !\n        0      PNTR c!          ( 40|80 )\n        cas2buf over 2dup expect -trailing\n        r> r> r> 3c!            ( restore screen cursor )\n        @lin +!\n        span @  #lin !\n    then ;\n```\n#endif\n#include \"align.i65\"\n_refillscr\n    jsr enter\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt 25\n#include \"page.i65\"\n    .word lt\n#include \"page.i65\"\n    .word qbranch\n    .byt <(refillscr03-*+1)\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word tobit\n#include \"page.i65\"\n    .word _blkbuf\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word cbitfetch\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word clit\n    .byt 24\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word orx\n#include \"page.i65\"\n    .word qbranch\n    .byt <(refillscr01-*+1)\n#include \"page.i65\"\n    .word forty\n#include \"page.i65\"\n    .word branch\n    .byt <(refillscr02-*+1)\n#include \"page.i65\"\nrefillscr01\n    .word lin\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word eighty\n#include \"page.i65\"\nrefillscr02\n    .word dup\n#include \"page.i65\"\n    .word clit\n    .byt LNMX\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word three\n#include \"page.i65\"\n    .word clit\n    .byt DFLTN\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt PNT\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word duptor\n#include \"page.i65\"\n    .word threecfetch\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word zero\n#include \"page.i65\"\n    .word clit\n    .byt PNTR\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word plusstore\n#include \"page.i65\"\n    .word cas2buf\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word expect\n#include \"page.i65\"\n    .word dashtrailing\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word span\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word threecstore\nrefillscr03\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=EOL?.SCR\nstack=( -- flag )\ntags=interpreter,nosymbol\nLeaves true when, while parsing a screen, the cursor is at the end of\na line.  This test triggers a refill event.\n\n```\n: eol?.scr   ( -- flag )\n    #lin @  >in @  over min  =\n    lin @ 25 < and ;\n```\n#endif\n#include \"align.i65\"\n_eolqscr\n    jsr enter\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word over\n#include \"page.i65\"\n    .word _min\n#include \"page.i65\"\n    .word eq\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word clit\n    .byt 25\n#include \"page.i65\"\n    .word lt\n#include \"page.i65\"\n    .word andx\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE.SCR\nstack=( -- addr size )\ntags=interpreter,nosymbol\nTarget of SOURCE vector when input is from a screen.  Leaves\nan address pointing to the beginning of a line and line size 40|80\n\n```\n: source.scr   ( -- addr size )\n    begin\n        eol?.scr\n    while\n        refill.scr\n    repeat\n    cas2buf  #lin @ ;\n```\n#endif\n#include \"align.i65\"\n_sourcescr\n    jsr enter\n#include \"page.i65\"\nsourcescr01\n    .word _eolqscr\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcescr02-*+1)\n#include \"page.i65\"\n    .word _refillscr\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcescr01-*+1)\n#include \"page.i65\"\nsourcescr02\n    .word cas2buf\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word fetch\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE\nstack=( -- addr size )\ntags=interpret,nosymbol\nReturns the base address of the buffer that [[INTERPRET]] is\nreading from, and the buffer size.\n#endif\nsource\n    jmp (uarea+uservsource-userarea)\n\n;--------------------------------------------------------------\n#if 0\nname=SOURCE!\nstack=( -- )\ntags=vm,interpreter,nosymbol\nSets the input source to TIB, BLK, or SCR\n\n```\n: source!   ( -- )\n    blk @  ?dup\n    if\n        block  isscr?\n        if\n            3+ @lin !  lin on  #lin off  ['] source.scr\n        else\n            drop  ['] source.blk\n        then\n    else\n        ['] source.tib\n    then\n    (source) ! ;\n```\n~ something here so that LOAD can restore position on a screen #41\n#endif\n#include \"align.i65\"\n_sourcestore\n    jsr enter\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word qdup\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcestore02-*+1)\n#include \"page.i65\"\n    .word _block\n#include \"page.i65\"\n    .word isscrq\n#include \"page.i65\"\n    .word qbranch\n    .byt <(sourcestore01-*+1)\n#include \"page.i65\"\n    .word threeplus\n#include \"page.i65\"\n    .word atlin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word lin\n#include \"page.i65\"\n    .word on\n#include \"page.i65\"\n    .word numlin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word plit\n    .word _sourcescr\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcestore03-*+1)\n#include \"page.i65\"\nsourcestore01\n    .word drop\n#include \"page.i65\"\n    .word plit\n    .word _sourceblk\n#include \"page.i65\"\n    .word branch\n    .byt <(sourcestore03-*+1)\n#include \"page.i65\"\nsourcestore02\n    .word zero\n#include \"page.i65\"\n    .word clit\n    .byt DFLTN\n#include \"page.i65\"\n    .word cstore\n#include \"page.i65\"\n    .word plit\n    .word _sourcetib\n#include \"page.i65\"\nsourcestore03\n    .word psource\n#include \"page.i65\"\n    .word store\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=-->\nstack=( -- )\ntags=interpreter\nflags=immediate\nAn immediate word which loads the next screen of Forth source\n\n!!! pronounced: \"next-block\"\n\n```\n: -->   ( -- )\n    blk 1+!  >in off  source! ; immediate\n```\n: -->\n    ?loading 0 in !\n    b/scr blk @ over mod -\n    blk +! ;\nL18be .byt 3 | bit7 | bit6\n .byt \"--\",\">\"|bit7\n .word L1885\nDASHDASHGT\n .word DOCOL\n .word QLOADING\n .word ZERO\n .word IN\n .word STORE\n .word BSCR\n .word BLK\n .word FETCH\n .word OVER\n .word MOD\n .word NEGATE\n .word BLK\n .word PSTORE\n .word SEMIS\n#endif\n#include \"align.i65\"\n_nextblock\n    jsr enter\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word oneplusstore\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _sourcestore\n#include \"pass.i65\"\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=SKIP\nstack=( addr1 size1 char -- addr2 count2 )\ntags=numword,nosymbol\n\n addr1 is the starting address in the input stream where up\n to size1 bytes are skipped *WHILE* they match char.  Returns\n addr2 as the address of the first non-matching character and\n count2 as the remaining number of bytes in the buffer.\n#endif\nskip\n    brk\n    .byt bs, <(skipscan01-*-2)      ; setup\nskip01\n    .byt bs, <(skipscan02-*-2)      ; next char\n    .byt bz, <(skip01-*-2)\n    .byt br, <(skipscan04-*-2)      ; exit\n;--------------------------------------------------------------\n#if 0\nname=SCAN\nstack=( addr count char -- addr count )\ntags=numword,nosymbol\n\n addr1 is the starting address in the input stream where up\n to count1 bytes are skipped *UNTIL* they match char.  Returns\n addr2 as the address of the first non-matching character and\n count2 as the remaining number of bytes in the buffer.\n\n#endif\nscan\n    brk\n    .byt bs, <(skipscan01-*-2)      ; setup\nscan01\n    .byt bs, <(skipscan02-*-2)      ; next char\n    .byt bnz, <(scan01-*-2)\n    .byt br, <(skipscan04-*-2)\n\nskipscan01\n    .byt ld | TOS   ; char\n    .byt st | N1\n    .byt pull\n    .byt st | N0\n    .byt pull       ; addr\n    .byt rs\nskipscan02\n    .byt ldi | TOS\n    .byt dcr | N0\n    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0\n    .byt sub | N1\n    .byt rs\nskipscan03\n    .byt popd | R12 ; drop the BS return\nskipscan04\n    .byt dcr | TOS\n    .byt inr | N0\n    .byt ld | N0\n    .byt push\n    .byt nxt\n\n;--------------------------------------------------------------\n#if 0\nname='STREAM\nstack=( -- addr size )\ntags=numword,nosymbol\nCalculates SOURCE offset by >IN with respect to buffer size.\n\n```\n : 'stream   ( -- addr size )\n       source   ( baseaddr size )\n       dup >in @ min /string ;\n```\n#endif\n#include \"align.i65\"\n_tickstream\n    jsr enter\n#include \"page.i65\"\n    .word source\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word _min\n#include \"page.i65\"\n    .word _slashstring\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=WORD\nstack=( char -- addr )\ntags=interpreter\n Generates a counted string by non-destructively accepting\n characters from the input stream until the delimiting\n character char is encountered or the input stream is\n exhausted.  Leading delimiters are ignored.  The entire\n character string is stored in memory beginning at addr as a\n sequence of bytes.  The string is followed by a blank which\n is not included in the count.  The first byte of the string\n is the number of characters {0..255}.  If the string is\n longer than 255 characters, the count is unspecified.  If\n the input stream is already exhausted as WORD is called,\n then a zero length character string will result.\n\n If the delimiter is not found the value of >IN is the size\n of the input stream.  If the delimiter is found >IN is\n adjusted to indicate the offset to the character following\n the delimiter.  #TIB is unmodified.\n\n The counted string returned by WORD may reside in the \"free\"\n dictionary area at HERE or above.  Note that the text\n interpreter may also use this area.\nSee: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream\n\n```\n: word   ( char -- addr )\n    >r 'stream\n    under r@ skip  under r> scan  drop\n    2dup swap -  >r\n    rot - 1+ >in +!\n    r> here dup bl blank $!\n    here ;\n```\n#endif\n#include \"align.i65\"\n_word\n    jsr enter\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word _tickstream\n#include \"page.i65\"\n    .word under\n#include \"page.i65\"\n    .word rfetch\n#include \"page.i65\"\n    .word skip\n#include \"page.i65\"\n    .word under\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word scan\n#include \"page.i65\"\n    .word drop\n#include \"page.i65\"\n    .word twodup\n#include \"page.i65\"\n    .word swap\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word tor\n#include \"page.i65\"\n    .word rot\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word oneplus\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word plusstore\n#include \"page.i65\"\n    .word rfrom\n#include \"page.i65\"\n    .word here\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _blank\n#include \"page.i65\"\n    .word _dolstore\n#include \"page.i65\"\n    .word here\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=?CHAR\nstack=( char -- addr )\ntags=compiler,nosymbol\nScans ahead in the input stream until `char` is found.  Moves >IN beyond\nthat character.\n#endif\n#include \"align.i65\"\n_qchar\n    jsr enter\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word oneplusstore\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=INTERPRET\nstack=( -- )\ntags=fig,forth-83,interpreter\nThe Forth interpreter loop\n\nconsistent eager-loaded approach\nTIB source comes already loaded from QUIT\nBLK source comes already loaded from BLOCK\nSCR source will eager-load each line from the block buffer, already loaded by BLOCK\n\n```\ncreate jumptable  next ,   dlit ,  drop ,  droplit ,\n                \\ double  double,  single    single,\n: interpret   ( -- )\n    begin\n        ?stack                  \\ make sure things are okay\n        bl word   ( addr )      \\ eager-load for screens is done by SOURCE\n        dup c@    ( addr len )  \\ WORD returns zero-length when SOURCE is exhausted\n    while\n        find ?dup\n        if        ( cfa findflag )\n            \\               find -1    find +1\n            \\             ____________________\n            \\ state -1   | compile     execute\n            \\ state 0    | execute     execute\n            state @ <>  ?: execute ,xt\n        else      ( here )\n            number\n            jumptable  dpl @ 0< 2*  state @ + 2* -\n            @ execute\n        then\n    repeat\n    drop ;\n```\n#endif\n#include \"align.i65\"\n_interpret\n    jsr enter\n#include \"page.i65\"\ninterpret01\n    .word qstack\n#include \"page.i65\"\n    .word bl\n#include \"page.i65\"\n    .word _word\n#include \"page.i65\"\n    .word dup\n#include \"page.i65\"\n    .word cfetch\n#include \"page.i65\"\n    .word qbranch\n    .byt <(interpret04-*+1)\n#include \"page.i65\"\n    .word _find\n#include \"page.i65\"\n    .word qdup\n#include \"page.i65\"\n    .word qbranch\n    .byt <(interpret02-*+1)\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word ne\n#include \"page.i65\"\n    .word pquerycolon\n    .word execute\n    .word _xtcomma\n#include \"page.i65\"\n    .word branch\n    .byt <(interpret03-*+1)\n#include \"page.i65\"\ninterpret02\n    .word _number\n#include \"page.i65\"\n    .word plit\n    .word interpret06           ; case table\n#include \"page.i65\"\n    .word dpl\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zlt\n#include \"page.i65\"\n    .word twostar\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word plus\n#include \"page.i65\"\n    .word twostar\n#include \"page.i65\"\n    .word minus\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word execute\n#include \"page.i65\"\ninterpret03\n    .word branch\n    .byt <(interpret01-*+1)\n#include \"page.i65\"\ninterpret04\n    .word drop\n    .word exit\n\ninterpret06\n    .word next\n    .word _dlit\n    .word drop\n    .word _droplit\n\n;--------------------------------------------------------------\n#if 0\nname=QUERY\nstack=( -- )\ntags=forth-83,fig\nAccept a line of input from the user\n\n```\n: query   ( -- )\n    tib 80 expect\n    span @ #tib !\n    >in off ;\n```\n#endif\n#include \"align.i65\"\n_query\n    jsr enter\n#include \"page.i65\"\n    .word tib\n#include \"page.i65\"\n    .word clit\n    .byt 80\n#include \"page.i65\"\n    .word expect\n#include \"page.i65\"\n    .word span\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word numtib\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word off\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=QUIT\nstack=( -- )\ntags=forth-83,interpreter\nThis is the infinite outer interpreter loop:\n      - resets the return stack (RP!)\n      - outputs a carriage return (CR)\n      - waits for a line of input (QUERY)\n      - interprets that line\n\n```\n: quit\n    [ rp!\n    blk off  source!\n    begin\n        cr\n        query interpret\n        state @ 0=\n        if\n            .\" OK\"\n        then\n    again ;\n```\n#endif\n#include \"align.i65\"\n_quit\n    jsr enter\n#include \"page.i65\"\n    .word _lbracket             ; STATE OFF\n#include \"page.i65\"\n    .word rpstore\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word off\n#include \"page.i65\"\n    .word _sourcestore          ; set input source\n#include \"page.i65\"\nquit01                          ; BEGIN\n    .word cr\n#include \"page.i65\"\n    .word _query\n#include \"page.i65\"\n    .word _interpret\n#include \"page.i65\"\n    .word state\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word zeq\n#include \"page.i65\"\n    .word qbranch           ; IF\n    .byt <(quit03-*+1)\n#include \"page.i65\"\n    .word _pdq\n    .byt (quit02-*-1)\n    .asc    \" OK\"\nquit02\n#include \"page.i65\"\nquit03                                  ; THEN AGAIN\n    .word branch\n    .byt <(quit01-*+1)\n;#include \"page.i65\"\n;    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=ABORT\nstack=( -- )\ntags=fig,forth-79,forth-83,interpreter\n#endif\n#include \"align.i65\"\n_abort\n    jsr enter\n#include \"page.i65\"\n    .word spstore\n#include \"page.i65\"\n    .word _forth\n#include \"page.i65\"\n    .word _definitions\n#include \"page.i65\"\n    .word _quit\n\n;--------------------------------------------------------------\n#if 0\nname=LOAD\nstack=( u -- )\ntags=interpreter\n\n The contents of >IN and BLK , which locate the current input\n stream, are saved.  The input stream is then redirected to\n the beginning of screen u by setting >IN to zero and BLK to\n u.  The screen is then interpreted.  If interpretation from\n screen u is not terminated explicitly it will be terminated\n when the input stream is exhausted and then the contents of\n >IN and BLK will be restored.  An error condition exists if\n u is zero.  See  >IN  BLK  BLOCK\n\n```\n: load   ( scr -- )\n    ?dup\n    if\n        blk @  >in @ 2>r\n        blk !  source! interpret\n        r> >in !  r> blk !  source!\n    then ;\n```\n#endif\n#include \"align.i65\"\n_load\n    jsr enter\n#include \"page.i65\"\n    .word qdup\n#include \"pass.i65\"\n    .word qbranch\n    .byt <(load01-*+1)\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word fetch\n#include \"page.i65\"\n    .word twotor\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _sourcestore\n#include \"page.i65\"\n    .word _interpret\n#include \"page.i65\"\n    .word tworfrom\n#include \"page.i65\"\n    .word toin\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word blk\n#include \"page.i65\"\n    .word store\n#include \"page.i65\"\n    .word _sourcestore\n#include \"pass.i65\"\nload01\n    .word exit\n",
			"file": "src/pettil-interpreter.a65",
			"file_size": 22174,
			"file_write_time": 131742508122111140,
			"settings":
			{
				"buffer_size": 22771,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "_qrefill\n    jsr enter\n    .word span\n    .word fetch\n    .word _qexit\n    .word blkfetch\n    .word qbranch               ; keyboard? go directly to `query`\n    .byt <(qrefill01-*+1)\n    .word blkfetch\n    .word _block\n    \n    .word clit\n    .byt PNT                    ; ($C4) pointer current screen line address\n    .word store\n    .word in\n    .word cfetchplus            ; `in.l` cursor offset on logical line\n    .word clit\n    .byt PNTR                   ; $C6 Cursor Column on Current Line\n    .word cstore\n    .word cfetch                ; `in.h` cursor physical line number\n    .word clit\n    .byt TBLX                   ; $D8 Current Cursor Physical Line Number\n    .word cstore\n    .word three                 ; get input from screen device #3\n    .word clit\n    .byt DFLTN                  ; $AF Default Input Device (0)\n    .word cstore\n    .word pqrefill\nqrefill01\n    .word _query\n    .word exit\n\n;--------------------------------------------------------------\n#if 0\nname=(?REFILL)\nstack=( -- )\ntags=interpreter,nosymbol\n|Three possible states coming in|<|<|h\n|1|span is 0||\n|2|||\n|3|||\n\n* 'force refill' check first -- exit to outer caller ( of INTERPRET )\n* 'end of line/buffer' check next\n\n    lda userin\n    sta PNTR                    ; $C6\n    lda userin+1\n    sta TBLX                    ; $D8\n    lda #39\n    sta LNMX                    ; $D5 39 or 79\n\n#endif\npqrefill\n    jmp next\n\n\n;--------------------------------------------------------------\n#if 0\nname=NAME\nstack=( char -- nfa | false )\ntags=outer,extra\nParse the next `word` from the `input stream`.  Return `false` if the\n`input stream` is exhausted, or the `nfa` of the found word, built\ndirectly within the input stream.  Advance `in` past the parsed `word`.\n\nLeading delimiters are ignored.   If the delimiter is not found the value of\nIN is the size of the input stream.  If the delimiter is found IN is\n adjusted to indicate the offset to the character following\n the delimiter.  `span` is unmodified.\n\nIn PETTIL `name` replaces the function of Forth-83 //required// reserved\nword `word`, which is //omitted//.\n\nAs much of the `ugly` as I could for the `blk` conspiracy goes in here.\nIsolating conspiracy support in as few words as possible will hopefully\nreduce overall system complexity and present clear transitions between the\nphases of the outer interpreter.\n\n```\n: name   ( nfa -- xfa flag )\n     ?refill 'stream swap >n6 2drop\n     dup skip dup>r 1- <n6 +\n     swap scan r> - >n8 dup\n     if  over c! in 1+!\n     dup \\ something for nip\n     then nip ;\n```\n#endif\n_name\n    jsr enter\n    .word _qrefill\n    .word _tickstream\n    .word swap\n    .word tozp\n    .byt ACC+2*N6               ; set up buffer pointer `n6`\n    .word twodrop\n    .word dup\n    .word skip                  ; start of name\n    .word duptor\n    .word oneminus\n    .word zpfrom\n    .byt ACC+2*N6               ; buf\n    .word plus\n    .word swap\n    .word scan                  ; end of name (and/or buffer)\n    .word rfrom\n    .word minus\n    .word tozp\n    .byt ACC+2*N8               ; name.len\n    .word dup\n    .word qbranch\n    .byt <(name01-*+1)\n    .word over\n    .word cstore                ; prepend name in buffer with name.len\n    .word in\n    .word oneplusstore          ; move `in` past the space that stopped us\n    .word dup                   ; something for `nip` to consume\nname01\n    .word nip\n    .word exit\n\n#print (*-skip)\n",
			"settings":
			{
				"buffer_size": 3411,
				"line_ending": "Unix",
				"name": "_qrefill"
			}
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"ui",
				"UI: Select Color Scheme"
			],
			[
				"pack",
				"Package Control: Install Package"
			]
		],
		"width": 497.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": true,
		"show_open_files": false,
		"show_tabs": true,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/chitselb/Documents/dev/commodore/pettil",
		"/home/chitselb/Documents/dev/commodore/pettil/studio",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src",
		"/home/chitselb/Documents/dev/commodore/pettil/tools"
	],
	"file_history":
	[
		"/home/chitselb/Documents/dev/commodore/pettil/tmp/t.csv",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-assembler.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-studio.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/pettil-core.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-nucleus.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-vm.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-compiler.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-editor.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-interpreter.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/tmp/pettil.mon",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-name.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-inner.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-utils.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-dictionary.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-extra.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-io.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/cbm.def",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/Makefile",
		"/home/chitselb/Documents/dev/commodore/pettil/t.t",
		"/home/chitselb/Documents/dev/commodore/pettil/pettil.dbg",
		"/home/chitselb/Documents/dev/commodore/pettil/Makefile",
		"/home/chitselb/Documents/dev/commodore/vice-3.2/src/arch/unix/x11/gnome/uimon.c",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/pettil.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/foo.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/mon1.mon",
		"/mnt/data/chitselb/Documents/dev/commodore/pettil/enter.mon",
		"/home/chitselb/Documents/dev/commodore/pettil/wrapper.mon",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/inc/pettil-tdict.def",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-user.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-user.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-double.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/core/src/core-locals.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/docs/statictiddlers/EditorDesign.tid",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-number.a65",
		"/home/chitselb/Documents/pettilmobile/resources/history/end.vsf",
		"/home/chitselb/Documents/pettilmobile/resources/history/start.vsf",
		"/home/chitselb/.config/sublime-text-3/Packages/DA UI/DA Color.sublime-settings",
		"/home/chitselb/.config/sublime-text-3/Packages/DA UI/DA Dark.tmTheme",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/; pettil-editor.old2",
		"/home/chitselb/Documents/dev/commodore/pettil/src/pettil-editor.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/src/core-vm.a65",
		"/home/chitselb/Documents/dev/commodore/pettil/studio/src/pettil-editor.old",
		"/home/chitselb/Documents/dev/commodore/pettil/tools/xap.rb",
		"/home/chitselb/.config/autokey/data/My Phrases/pds.txt",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-user.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-nucleus.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-assembler.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-editor.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-user.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-utils.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-interpreter.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-studio.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-dictionary.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-extra.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/pettil-core.a65",
		"/home/chitselb/core-vm.a65",
		"/home/chitselb/dev/commodore/pettil/tools/xap.rb",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/tiddlywiki.info",
		"/home/chitselb/dev/commodore/pettil/core/src/pettil-corewtf.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-locals.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/sweet16.a65",
		"/home/chitselb/dev/commodore/pettil/studio/src/pettil-compiler.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-inner.a65",
		"/home/chitselb/dev/commodore/pettil/core/src/core-double.a65",
		"/mnt/sdc1/chitselb/dev/commodore/otherpet/kenross/download",
		"/home/chitselb/.local/share/applications/xpet.desktop",
		"/home/chitselb/.local/share/applications/xvic.desktop",
		"/home/chitselb/dev/commodore/pettil/core/src/inc/pettil.def",
		"/home/chitselb/dev/commodore/pettil/studio/src/inc/pettil-studio.def",
		"/home/chitselb/dev/commodore/pettil/core/src/inc/cbm.def",
		"/home/chitselb/dev/commodore/pettil/core/src/core-vm.a65",
		"/home/chitselb/dev/commodore/pettil/pettil.dbg",
		"/home/chitselb/dev/commodore/pettil/core/src/core-io.a65",
		"/home/chitselb/.vice/PET/chitselb.vpl",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure.ac",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure.proto",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.guess",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.log",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.rpath",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.status",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/config.sub",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/configure",
		"/mnt/sdc1/chitselb/dev/commodore/emulators/vice-2.4.28/t.t",
		"/home/chitselb/dev/commodore/pettil/Makefile",
		"/home/chitselb/dev/commodore/vic20/vickeymap.txt",
		"/home/chitselb/vickeymap.txt",
		"/home/chitselb/dev/commodore/pettil/tmp/symtab.csv",
		"/home/chitselb/dev/commodore/activity.log",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/F83 05. Definitions of Terms.tid",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/AboutPETTIL.tid",
		"/home/chitselb/dev/commodore/pettil/README",
		"/home/chitselb/dev/commodore/pettil/docs/statictiddlers/F83 Appendix B. Uncontrolled Reference Words.tid",
		"/home/chitselb/.vice/sdl-vicerc",
		"/home/chitselb/dev/commodore/pettil/t.t"
	],
	"find":
	{
		"height": 56.0
	},
	"find_in_files":
	{
		"height": 135.0,
		"where_history":
		[
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/vice-3.2/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/.config/sublime-text-3/Packages/DA UI",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src,/home/chitselb/Documents/dev/commodore/pettil/src",
			"/home/chitselb/Documents/dev/commodore/pettil/core/src,/home/chitselb/Documents/dev/commodore/pettil/studio/src",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src,/home/chitselb/dev/commodore/pettil/docs/statictiddlers",
			"/home/chitselb/dev/commodore/pettil/core/src,/home/chitselb/dev/commodore/pettil/studio/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"vocab",
			",a,",
			"hex4out",
			"wikiname",
			"hex4out",
			"hexout",
			"hash",
			"csv",
			"outputfile",
			"write_xpet_csvfile",
			"addr",
			"labels",
			"write_xpet_csvfile",
			"fortytimes",
			"DFLTN",
			"cursor",
			"blkbuf",
			"userlin",
			"_blkbuf",
			"userin",
			"userlin",
			"_block",
			".word prev",
			"topkt",
			"userprev",
			"_block",
			"_load",
			"userprev",
			"prev",
			"blk02",
			"blkbuf",
			"blk02",
			"_topkt",
			"topkt",
			"prev",
			".word prev",
			"plugh",
			"bcc put",
			"putay",
			"ldy tos+1",
			"putay",
			"put",
			"putya",
			"bcc put",
			"^put",
			"cswap",
			"qlineplus",
			"bit ",
			"userlin",
			"qlineplus",
			"_query",
			"qlineplus",
			"cursor",
			"DFLTN",
			"$AF",
			"expect",
			"C4",
			"^expect",
			"^_expect",
			"^expect",
			"ptickstream",
			"span",
			"LNMX",
			"bvc",
			"qlineplus",
			"userlin",
			"eosq",
			"sib",
			"nop",
			"userin",
			"_info",
			".word cr",
			"qpause",
			"qterminal",
			"numout",
			"_qcr",
			"_iddotl",
			"id.l",
			"_wordlist",
			"name=WORDS",
			"eoss",
			"linesa",
			"sorting symbols",
			"xyzzy",
			"userin",
			"usering",
			"Searching",
			"userin+1",
			"lda userin+1",
			"lda userlin+1",
			"qlineplus",
			"_qrefill",
			"^lin$",
			"_qrefill",
			".word span",
			"xpushc",
			"putnotc",
			"ult",
			"name=U",
			"^ult",
			"ult",
			".word lt",
			"name=>",
			"gt",
			"name=>$",
			"name=<",
			"name=>=",
			"^ge",
			"interpret03",
			"qlineplus",
			"_query",
			"_tickstream",
			"_ticksteam",
			"_name",
			"sib",
			"github",
			"personal ele",
			"for the commo",
			"LPERSCR",
			"^expect",
			"dashtrailing",
			"deadbeef",
			"github.com",
			"^expect",
			"dashtrailing",
			"github\\.com",
			"^_name",
			"^_interpret"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"",
			" ",
			"",
			"^$",
			"$",
			"",
			";",
			"bk .",
			"^bk .",
			"crap",
			"wget https://web.archive.org/web/20051201020459/http://freespace.virgin.net:80/ken.ross1/\\1",
			"\\2",
			" ",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 5,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19500,
						"regions":
						{
						},
						"selection":
						[
							[
								10119,
								10119
							]
						],
						"settings":
						{
							"auto_name": "[Return to Main Page] NMOS 6502 Opcodes by John Pi",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 660.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "core/src/core-extra.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10945,
						"regions":
						{
						},
						"selection":
						[
							[
								8913,
								8913
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8758.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "core/src/core-io.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 19218,
						"regions":
						{
						},
						"selection":
						[
							[
								4859,
								4859
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3295.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22,
						"regions":
						{
						},
						"selection":
						[
							[
								22,
								22
							]
						],
						"settings":
						{
							"auto_name": "'stream\t\t( buf size )",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "tmp/pettil.mon",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24908,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "tools/xap.rb",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20049,
						"regions":
						{
						},
						"selection":
						[
							[
								12248,
								12248
							]
						],
						"settings":
						{
							"syntax": "Packages/Ruby/Ruby.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7000.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/mnt/data/chitselb/Documents/dev/commodore/pettil/tmp/pettil.csv",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40043,
						"regions":
						{
						},
						"selection":
						[
							[
								25503,
								25503
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "studio/src/pettil-interpreter.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13966,
						"regions":
						{
						},
						"selection":
						[
							[
								12404,
								12404
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9141.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "core/src/pettil-core.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29210,
						"regions":
						{
						},
						"selection":
						[
							[
								7146,
								7146
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3991.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "core/src/core-vm.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 39960,
						"regions":
						{
						},
						"selection":
						[
							[
								23538,
								23538
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 19366.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 10,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1961,
						"regions":
						{
						},
						"selection":
						[
							[
								407,
								407
							]
						],
						"settings":
						{
							"auto_name": "_block",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "core/src/core-user.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8338,
						"regions":
						{
						},
						"selection":
						[
							[
								6392,
								6392
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4771.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "core/src/core-double.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10074,
						"regions":
						{
						},
						"selection":
						[
							[
								10011,
								10011
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 9756.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "core/src/core-inner.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23131,
						"regions":
						{
						},
						"selection":
						[
							[
								1269,
								1269
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 617.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 14,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2054,
						"regions":
						{
						},
						"selection":
						[
							[
								2054,
								2054
							]
						],
						"settings":
						{
							"auto_name": ">C:0000  00 58 50 00  bc 07 45 58  19 00 00 00  00",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "src/pettil-interpreter.a65",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22771,
						"regions":
						{
						},
						"selection":
						[
							[
								3967,
								3967
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 228.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 16,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3411,
						"regions":
						{
						},
						"selection":
						[
							[
								223,
								223
							]
						],
						"settings":
						{
							"auto_name": "_qrefill",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 33.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 229.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "pettil.sublime-project",
	"replace":
	{
		"height": 95.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"tiddly",
				"docs/statictiddlers/tiddlywiki.info"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 199.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}

#!/home/chitselb/bin/ruby
	require 'json'
	
    # given a string (name) and address (symbol), construct and
    # return a hash with a symbol table entry in it
    def make_symbol(name="", cfa=0, nfaflags, desc, tags)
        # values calculated by pearson.rb
        # 14..22        102 162 3 150 98 88 207 149
        # 27, 120, 229, 241, 111, 44, 47, 141
        # 
        pearson = [231, 8, 197, 27, 61, 59, 64, 192]
        psize=pearson.length-1

        c1 = [cfa.to_i].pack("S<")
        c2 = [name.length].pack("C")
    #   puts c2
        c3 = name.bytes.pack("C")
        namelen = name.length
        namelen |= nfaflags
        nfa = [namelen].pack("C")+name
        data = [cfa.to_i].pack("S<")+nfa

        # the vocabulary identifier byte (if present) is part of the hash
        # the length bits (and psize) are the seed of the hash

        hash=name.length&31
        name.each_byte { |char|
            hash ^= pearson[char&psize]
        }



 #       hash=name.length
 #       name.each_byte { |char|
 #           hash = char^pearson[hash&psize]
 #       }
        eornybble = (hash & 15)^((hash ^ 240)/16)
        t = {
        name: name ,
        data: data ,
        len: name.length ,
        hash1: eornybble,
        desc: desc, 
        tags: tags }
        return t
    end

    # given a string from the .a65 source code, like
    #     .asc "BLOC","K"|bit7
    # returns a string containing just the ascii name of this word, e.g. "DUP"
    def parse_name(nfaline,vocabline)
        while (nfaline =~ /(.*)\|bit[67]$/)
            nfaline = $1
        end
        while (nfaline =~ /^\ *\.asc\ *(.*)/)
            nfaline = $1
        end
        while (nfaline =~ /(.*),(\d+)$/)
            nfaline = $1+',"'+$2.to_i.chr+'"'
        end
        while (nfaline =~ /\"(.+)\",'(\")'$/)
            nfaline = $1 + $2
        end
        while (nfaline =~ /\"(.+)\",'(\")',\"(.+)\"$/)
            nfaline = $1 + $2 + $3
        end
        while (nfaline =~ /\"(.+)\",\"(.)\"$/)
            nfaline = $1 + $2
        end
        while (nfaline =~ /\"(.+)\"$/)
            nfaline = $1
        end
        if (vocabline =~ /.byt\ (\d+)$/)
            nfaline += $1.to_i.chr
        end
        return nfaline
    end

    def add_symbols(symhash, filename)
        if File.exist? filename
            result = File.open(filename,'r') do |f|
                while (line = f.gets) do
                    line.chomp!
                    a = line.split(",")
                    symhash[a[0]] = a[1].hex
                end
            end
        end
    end

    # read the symbol table generated by the xa65 assembler into a hash
    # for translating the symbol into its hex address
    symbols = Hash.new
    add_symbols(symbols,"pettil-core.lab")


    # build a label file so pettil-tdict.a65 can find things in core
    # fix problems with reserved words e.g. bc add in hex address
    use_decimal = ' pushya number02 i usercurrent userarea userup _symbuf type02 _pdot _pktplus warm02 doslashmod '
    always_use_decimal = false
    symfile = File.open("pettil-core.def",'w') do |f|
#       symfile.write(#{a[0]}=#{a[1]}\n")
        symbols.each do |k, v|
            if use_decimal.include?(' '+k+' ') | always_use_decimal
                f.write("#{k} = #{v.to_s}\n")
            else
                f.write("#{k} = $#{v.to_s(16).rjust(4,'0')}\n")
            end
        end
    end

    add_symbols(symbols,"modules/pettil-tdict.lab")

    # build a monitor file with all the symbols
    symfile = File.open("pettil.mon",'w') do |f|
#       symfile.write(#{a[0]}=#{a[1]}\n")
        symbols.each do |k, v|
            f.write("al C:#{v.to_s(16).rjust(4,'0')} .#{k}\n")
        end
    end

    # build a text file for the pearson cruncher
    symfile = File.open("junk/pearson.txt",'w') do |f|
#       symfile.write(#{a[0]}=#{a[1]}\n")
        symbols.each do |k, v|
            f.write("#{k}\n")
        end
    end

=begin

#if 0
+++NAME+++
immediate
vocabulary 1
#endif
_plus3nameplus3
#include "enter.i65"
    .word exit

=end
    # Scan the assembler source file for headers, that look something like
    # the block up above this comment.  parse them and create a binary
    # output file with the symbol table in it
    b=Hash.new

    coredict = "../pettil-core.a65 " +
                "core-subroutines.a65 " +
                "core-user.a65 " +
                "core-inner.a65 " +
                "core-nucleus.a65 " +
                "core-device.a65 " +
                "core-pet.a65 " +
                "core-numword.a65 " +
                "core-double.a65 " +
                "core-string.a65 " +
                "core-vm.a65 " +
                "sweet16.a65 "

    tempdict = "pettil-tdict.a65 " +
                "pettil-user.a65 " +
                "pettil-interpreter.a65 " +
                "pettil-compiler.a65 " +
                "pettil-editor.a65 " +
                "pettil-assembler.a65"

    #["pettil-interpreter.a65"].each do |filename|
    ((coredict+tempdict).split " ").each do |filename|
    #((coredict).split " ").each do |filename|
    #((tempdict).split " ").each do |filename|
        infile = File.open("modules/"+filename,'r')
        while (line = infile.gets) do 
			line.chomp!
			if line =~ /\#if 0$/
				wordname, flags, vocab, desc, t = nil
				nfaflags = 0
				capture_desc = false
				tags = []
				desc=""
                while !((line = infile.gets.chomp) =~ /^\#endif$/)
					wordname = t   if t = line.split(/^name=/)[1]
					flags = t   if t = line.split(/^flags=/)[1]
					vocab = t   if t = line.split(/^vocab=/)[1]
					desc = "!! " + wordname + "&nbsp;&nbsp;&nbsp;" + t +"\n"  if t = line.split(/^stack=/)[1]
					tags = t.split(',')   if t = line.split(/^tags=/)[1]
					capture_desc = false  if line =~ /^\[\/desc\]$/
					desc += "\n" + line   if capture_desc
					capture_desc = true  if line =~ /^\[desc\]$/
				end
				nfaflags |= 0x80   if flags =~ /immediate/
				if vocab != nil
					wordname += vocab.to_i.chr
					nfaflags |= 0x40
				end
				symbol = infile.gets.chomp


				code = "\n```\n" + symbol
				
				codeblock = true
				while codeblock && (line = infile.gets) do
					codeblock = !(line =~ /^\;(-)\1*$/)
					keepline = !(line =~ /#include "(page|enter|pad).i65"/) 
						code += "\n" + line.chomp   if codeblock && keepline
				end
				code += "\n```\n"
#				while !((line = infile.gets.chomp) =~ /^;(-)(\1)*/)
#					puts line
#				end
				text = desc+"\n\n"\
				"<$button popup=\"$:/state/codeSlider\">code</$button>"\
				"<$reveal type=\"nomatch\" text=\"\" default=\"\" state=\"$:/state/codeSlider\" animate=\"yes\">\n"\
				+ code + "</$reveal>"
                a = make_symbol(wordname, symbols[symbol], nfaflags, text, tags)
                b[a[:name]] = a
			end
		end
=begin
         =~ /\#if 0$/) do
				while !((line = infile.gets.chomp) =~ /^\#endif$/) do
					puts line
				end
			end
        end
            if (line =~ /\#if 0$/)
                nfaflags = 0
                while !(line =~ /^\#endif$/)
					wordname = line[/^name=/,1]
					modifier = line[/^modifier=/,1]
					modifier = infile.gets.chomp
					line = infile.gets.chomp
				end
				symbol = infile.gets.chomp
				if modifier =~ /immediate/
					
				end
				if modifier =~ /vocab/
					nfaflags |= 0x40
				end
                print "#{wordname} #{symbol} #{nfaflags.to_s}  #{modifier}\n"
                a = make_symbol(wordname, symbols[symbol], nfaflags)
                b[a[:name]] = a
			end
			line = infile.gets.chomp
		end
=end
    end
    symfile = File.open("pettil.sym",'w')
    Hash[b.sort_by { | k, v | v[:hash1]*32+v[:len] }].each do |h|
        a = h[1][:data].bytes
        symfile.write a.pack("C*")   unless h[1][:tags].index("nosymbol")
    end
    symfile.write [0,0,0].pack("C*")        # null length ends pettil.sym

    symfile = File.open("junk/pearson.txt",'w')
    Hash[b.sort_by { | k, v | v[:hash1]*32+v[:len] }].each do |h|
        a = h[1][:name]
        symfile.write "#{a}\n"   unless h[1][:tags].index("nosymbol")
    end

	symfile = File.open("junk/pettil.json",'w')
	symfile.write "[\n"
	glossary=""
	b.each do |h|
		glossary += "\[\["+ h[1][:name] + "\]\] "
		symfile.write "\{ \"title\":#{h[1][:name].to_json},\"text\":#{h[1][:desc].to_json},\"tags\":#{h[1][:tags].to_json}\},\n"

#,\"tags\":#{h[1][:tags].to_json}
	end
	symfile.write "\{ \"title\":\"Glossary\",\"text\":#{glossary.to_json}\}\]"

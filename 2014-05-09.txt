Virtual Memory on Cassette Tape

It is pretty easy (read: already done for me by someone else) to map a floppy disk to virtual memory, and eventually I'll be doing that too.  I have a PETdisk by bitfixer, which puts a 2 gigabyte microSD card on the IEEE bus of the PET, and eventually I'll be turning that into a virtual memory device.  Support will also be provided for reading SEQ files as raw source streams, without using block buffers, and for converting blocks to and from these SEQ stream files.

But in the meantime, here's another "back in the day" story. Back in the day, most of us PET owners did not have disk drives, only datassette.  And our keyboards were made of rocks and sticks.  And we liked it! That's a lie, except for the not having disk drives part.  Given such a contstrained hardware configuration (one tape drive), how can PETTIL permanently store data and source code on cassette tape, and do it in a Forth-like manner, meaning as 1024 byte blocks?  Doing real virtual memory as 1K blocks on cassette would be painful.  Tape is sequential, not random access.  The tape can't be accurately positioned when swapping back and forth between two cassettes.  So two decks are required, one for recording and one for playback.  Updating a single byte in a single block of tape would necessarily entail copying the entire virtual memory space from one tape to the other.  There really didn't seem to be any good way to solve this problem.  On a bad day, I can't even come up with a good reason to solve this problem, because the hardware is available for free now, if only in VICE emulation.  But for the retro nature of PETTIL, the problem persists.  What follows is my attempt at a solution, which involves a few compromises that I hope I can live with.

The Commodore SEQ tape format stores data in 192 byte blocks, but the kernel steals the first byte of the cassette buffer as a block identifier marker: 1=PRG header; 2=data block; 4=SEQ header; 5=EOT (end of tape) mark.  That leaves 191 bytes available for data, not exactly a convenient number considering we want to store 1024-byte blocks.  To make matters worse, the PET treats the null ($00) character as an end of file marker, and records an inter-record gap (three seconds of tone) after the header and in between data blocks.  Worst of all, zero page address $10 is used by the ROM tape routines when the STOP key is pressed during tape i/o, and all abnormal exits from tape i/o will drop out to BASIC.  And that's just the problems with tape.  

I have chosen to use the PET native screen editor, which treats the screen as a collection of logical lines (40 or 80 characters each). This screen geometry (40x25, 1000 bytes) is at odds with the classical Forth block (1024 bytes, 64x16).  You can't even fit an entire Forth block on the PET screen to edit it!  Enough complaining (for now).  Here's the design I eventally came up with:

Batches
Instead of reading or writing just one block at a time, PETTIL will store and retrieve blocks in batches from tape (or disk) using PRG files.  The load address of the file will vary, depending on the number of blocks in this batch and how compressible they are, but the PRG file end address will always be $7C00 on a 32K PET, $3C00 on a 16K PET.  The requirement is that a batch has to load higher than the top of the dictionary (and probably PAD).  Blocks build downward, starting at 1K below MEMSIZ ($34).  This last 1K of RAM is used as the buffer for packing and unpacking blocks, and may be used by other Forth words too.  The address of this buffer BLKBUF is calculated, similar to PAD, by subtracting 1024 from the top of memory.  The area stored to tape is referred to as VMBUF.  Packets in VMBUF begin at BLKBUF-2, with the packet lengths stored in the last two bytes of each packet.  The head of VMBUF is marked by a zero word.  Here's what it looks like on a 32K PET.

| Video memory                  | MEMSIZ ($8000)
+===============================+
|                               | 
| 1K block buffer               | BLKBUF ($7C00, MEMSIZ-1K)
+-------------------------------+
[x]             packet 0 size   | x=1, packet is stored uncompressed
+-------------------------------+
| packet 0 compressed data      | 
|               +---------------+
|          ...  |n m l k j i h g|
+---------------+---------------+
|f e d c b a 9 8|7 6 5 4 3 2 1 0| packet 0 linewrap bits 0..n        
+---------------+---------------+
|           .                   | 
|           .                   | 
|           .                   | 
| packet N compressed data      | 
|               +---------------+
|          ...  |n m l k j i h g|
+---------------+---------------+
|f e d c b a 9 8|7 6 5 4 3 2 1 0|
+---------------+---------------+
|             0000              |  VMBUF (BLKBUF-sum(packets)-2) 
+-------------------------------+

Packets
Each block is reconstructed from a compressed packet.  The packet ends with a 2-byte length.  The top bit of the length word will be set if the block is stored, not RLE-compressed.  The length includes +2 bytes for storing the length, to make it easier to hopscotch through all the packets.  Just keep subtracting the length until we hit the tail (packet length = 0).  The block number itself is not stored in the packet, but is determined by counting the number of hops to get there from the top of VMBUF.  BLKBUF is first filled with spaces, then the packet is RLDECODEd to BLKBUF until length-2 bytes of packet are exhausted.

Packet Types
Forth eschews data types, and for some good reasons.  I really tried to avoid taking this path, but in the end it seemed like the best way to design things.  I can sleep at night with the mealymouthed rationaization that it isn't Forth typing the packets, but the screen editor.  That said, here are the two packet types

Screen packets
Screens are a special type of packet.  The first three bytes of a screen packet are the 40/80 linewrap bits for lines 1..24 and will become the high bits of $E1-$F8.  Line 0 ($E0[bit7]) is not stored, because it is always $80.  For screens, I am using a trick that I call "short blocks."  Before unpacking a screen packet, the BLKBUF is first filled with spaces.  Then RLDECODE unpacks thc compressed screen packet there, starting with the three bytes of linewrap and going until {length-2} characters have been unpacked.  After this, PETTIL can tell it's a screen packet (and not a data block) if two conditions are met.  1) The first three bytes can't have two or more consecutive 0 bits, because that would indicate a logical line longer than 80 characters.  2) The last 21 bytes of the unpacked screen buffer are all spaces.  When the PETTIL editor creates a new blocks, it is stored as a screen packet.

In the screen editor, clearing the screen and leaving it causes an UPDATE,  producing the following result somewhere in VMBUF
1 BLOCK 5 DUMP 
ff ff ff 05 00 ok

Data packets
Packets that don't pass the two-pronged test for being screen blocks are data blocks.  If a block is not a screen, the PETTIL screen editor will treat it differently, just displaying the first 1000 bytes as screen codes in read-only mode.  Haing these lets the programmer store arbitrary data in blocks.  Just like screen blocks, data blocks are created by addressing them.  
50 BLOCK
would return $7C00 (BLKBUF, the address of the block buffer), and it would also create packets for block 0..50 if they do not already exist.  Packets created by BLOCK are ERASEd with zeros (not spaces) at creation, and there is no 3-byte linewrap structure at the beginning.

50 BLOCK 14 HEX DUMP
00 00 00  00 00 00  00 00 00  00 00 00  0E 00

What does this mean?
00 00 00, that's two nulls followed by a repeat count of 0, which is the maximum RLE repeat value (255x)
This "00 00 00" is repeated 4x for a total 1024 bytes of null.
0E 00, is the length of this empty data packet, 14 bytes.  It is a positive number which means the packet is RLE-compressed.  As with screen packets, the packet length is stored at the end.

INTERPRET
One subtle but important difference between SCREEN blocks and DATA blocks is that in screen blocks, PETTIL will treat the implicit end of line characters as whitespace.  What this means is that a colon definition on a screen can jam words up all the way to the last column (39 or 79), and the next line can begin a word in column 0.  Even though the word at the end of the previous line and the word at the beginning of the following line are adjacent in memory with no blank in between, PETTIL will recognize that this block is a screen and it will parse it as a set of logical 40/80 character lines.

Conversely, when a data packet is interpreted, there is no concept of linewrap, and those whitespace boundaries are not implied between the nonexistent 40|80 character lines.  Blocks extracted from data packets are treated like a gigantic 1024-byte line.  The programmer can flip back and forth between using either native PET screens or 1024 byte Forth blocks for source code, and the virtual memory knows the difference.

New USER variables
MEMSIZ top of memory, $8000 on a 32K PET
BLKBUF address of the 1K block buffer used to pack/unpack packets.  BLOCK alwas returns this value.
VMBUF the bottom of the virtual memory buffer, which grows downward from BLKBUF.  There is always a zero word here to mark the end of VMBUF.
VMSIZ the number of packets currently available in VMBUF.  Afer "50 BLOCK" this uservariable will contain 51 (0..50).

This leaves only that pesky business with ROM tape routines overwriting address $10 and ROM dropping to BASIC for abnormal tape i/o conditions.  It's just going to be that way, because I'm too cheap with RAM to embrace and extend (read: copy and corrupt) the ROM into my Forth kernel.  Upon cold start, a routine called zpswap exchanges about half of the zero page as BASIC likes to see it with a cached copy.  Immediately prior to entering the machine language monitor via MON or performing tape operations, zpswap is invoked to make BASIC happy in case of failure or the user hitting the STOP key.  If the tape operation is successful, zpswap runs again to restore the zero page to what PETTIL expects.

: empty-buffers vmsiz off blkbuf 2- dup off vmbuf ! ;
: ?block   ( blk -- flag )
    vmsiz @ < ;


Lumierre Manifesto
arthouse
What if the world's greatest director made a modern movie using Lumierre era equipment?

Retromodern
What would happen if 


Compression
Compress the blocks using run-length encoding.  If a block becomes larger than 1024 bytes when it is "compressed" then just store it as-is.  Flag such "stored" blocks by setting the high bit of the length word so the RLE decoder won't attempt to unpack them.

* Treat screens and blocks differently.  Forth eschews data types, and this is a slippery slope I really tried hard to avoid.  Forth eschews data types.  The 



How big of a party foul would it be to treat ends of logical lines as whitespace? (a space character) configurable
VIRTSIZ total virtual blocks available
are two block buffers required?
are short blocks okay?
use compressed size for unpack. rldecode until src exhausted
rlencode must test to see if actual compression occurred. else store the block uncompressed

blocks
forth bio
In 1981 I was 19.  My first job in IT (back then we called it "computers") was at the Tysons Corner ComputerLand store.  In the morning, I worked tickets in the service department, responding to customer software questions.  In the afternoon I moved boxes of gear with a hand cart from the warehouse to the store for customers to pick up.  There were only a few computer stores in the DC metro area then, which meant a *lot* of boxes being moved.  There was a book and magazine rack in the store, and we got in a copy of Loeliger's "Threaded Interpretive Languages" which I immediately bought.  That was my introduction to Forth.  It intrigued me that Forth was written in Forth, and that it ran faster than BASIC, and had virtual memory, which I had never heard of, and an editor, and a compiler, all fitting in a few K of RAM.  This was a panacea!  Unfortunately I had a PET and this book was all Z-80.  But I already knew Z-80 from the TRS-80 model 1 at my high school, and I knew 6502.  How hard could it be to get this working?

In 1984 and 1985 I worked at a push rod factory in Port Clinton, OH (Superior Push Rod) programming their Radio Shack model 4 for the princely sum of $17K/year.  This was the ultimate widget factory.  They turned cups, balls and tubes into push rods for engines, mostly bigger truck and tractor engines.  At first I was using MBASIC under TRS-DOS but eventually I talked my boss into letting me pick up a copy of MMSForth by Dick and Jill Miller.  It was a very slick product.  Mostly I wrote reports to summarize job tickets, track parts inventory, other accounting software. I used Microsoft Multiplan to enter in the data on a spreadsheet.  The Forth code parsed the CSV files and cranked out reports.  They even sent me up to the Rochester Forth Conference in 1985!



shout out to merlin

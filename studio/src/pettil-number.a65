; pettil-number.a65
#echo .       pettil-number.a65         Number parser

;--------------------------------------------------------------
#if 0
name=NUM.CHAR+
stack=( -- c )
tags=numword,nosymbol
Return next character of the number we're parsing.  Return 0 at end of string.

~#comfortablynumber
#endif
numcharplus
    brk
    .byt dcr | N8
    .byt ld | N8
    .byt bz , <(numch01-*-2)
    .byt ldi | N7
numch01
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=MORE.CHAR?
stack=( -- f )
tags=numword,nosymbol
Returns `true` when `n8` reaches 0.

~#comfortablynumber
#endif
morecharq
    sec
    dec ACC+2*N8
    beq morecharq01
    clc
morecharq01
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=PREFIXES
stack=( -- addr )
tags=numword,nosymbol
`number` prefix indexed jump table (no `cfa`)
~#comfortablynumber
#endif
prefixes
    jsr docreate
     .byt prefixes01-*          ; number of prefixes
     .asc ".-<=>RN#$%"
prefixes01
    .byt 0

;--------------------------------------------------------------
#if 0
name=FLAGME
stack=( -- )
tags=numword,nosymbol

#endif
flagme
    ldy #2
    lda (ip),y
    pha
    and ACC+2*N6+1
    beq flagme01                ; blergh! `not found`
    iny                         ; ldy #3
    jmp error
flagme01
    pla
    asl
    asl
    asl
    asl
    ora ACC+2*N6+1
    sta ACC+2*N6+1
    jmp pad3

;--------------------------------------------------------------
#if 0
name=DIGIT
stack=( char -- digit )
tags=numword,nosymbol
Throws a "NOT FOUND" exception if `char` is not a valid digit in the current number base.  Otherwise leave `digit` on the stack.  Operates only on low byte of `tos`

#endif
digit
    lda tos
    sec
    sbc #$30
    bcs digit02                 ; is it maybe a digit?
digit01
    ldy #3
    jmp error
digit02
    cmp #10
    bcc digit03                 ; see if it's a hex digit or a real digit
    sbc #7
digit03
    cmp ACC+2*N6                ; compare to current number base
    bcs digit01                 ; not a digit?
    sta tos
digit04
    jmp next

;--------------------------------------------------------------
#if 0
name=?DPL
stack=( -- )
tags=numword,nosymbol,primitive
If `dpl` is positive, add 1 to `dpl`

#endif
qdpl
    bit userdpl+1
    bmi digit04                 ; next
    inc userdpl
    bpl digit04                 ; bra next

;--------------------------------------------------------------
#if 0
name=(NEXTCHAR)
stack=( d -- d char )
tags=numword,nosymbol
Get next character, part of `number`.

|^n6|^base c@|^//(unchanged)//|
|^n7|^addr|^//+1//|
|^n8|^length|^//(unchanged)//|
|^r11|^0|^//rundown handler//|
|^tos<br/>2os|^0.||


~#comfortablynumber
#endif
nextchar
    brk
    .byt ldi | N7
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(NUMBER)
stack=( addr base -- 0. )
tags=numword,nosymbol
Setup for number parser

* n7 = addr
* n6 = base c@
* n8 = length
* r11 = 0
* tos,2os = 0.

~#comfortablynumber
#endif
pnumber
    brk
    .byt set | R11              ; `number.rundown`
    .word next
    .byt ldi | TOS              ; `base c@`
    .byt st | N6                ; temp number base ; flags=0
    .byt pull
    .byt st | N7                ; address of text buffer
    .byt ldi | N7
    .byt st | N8                ; `len` and bump char pointer
    .byt sub | ACC
    .byt st | N4                ; rundown cfa set to `0` (positive number)
    .byt st | TOS
    .byt push                   ; leave `0.` as initial result
    .byt dcr | ACC              ; -1 means not a register (used by rundown)
    .byt st | N5                ; register offset N=4; R=0
    .byt nxt

;--------------------------------------------------------------
#if 0
name=<=>
stack=( cfa d -- )
tags=numword,nosymbol

#endif
#include "align.i65"
_spaceshipx
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N4
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(spaceship01-*+1)
#include "page.i65"
    .word _xtcomma
#include "page.i65"
    .word _ccomma
#include "pass.i65"
spaceship01
    .word exit

;--------------------------------------------------------------
#if 0
name=<=>N4
stack=( -- )
tags=numword,nosymbol,primitive

#endif
sshipn4
    ldy tos
    lda sshipl-'<',y
    sta ACC+2*N4
    lda sshiph-'<',y        ; could be 'lda #7'
                                ; if zpfrom zpex tozp are on page 7
    sta ACC+2*N4+1
    jmp drop

sshipl
    .byt <zpfrom, <zpex, <tozp
sshiph
    .byt >zpfrom, >zpex, >tozp

;--------------------------------------------------------------
#if 0
name=REGOFFSET
stack=( R|N -- )
tags=numword,nosymbol,primitive

#endif
regoffset
    sec
    lda #10                     ; for R0..R15, N0..N8
    sta ACC+2*N6                ; register numbers are base 10
    lda #'R'
    sbc tos                     ; +0 for `R`, or +4 if it's `N`
    sta ACC+2*N5
    jmp drop

;--------------------------------------------------------------
#if 0
name=REBASE
stack=( #|$|% -- )
tags=numword,nosymbol,primitive

#endif
rebasex
    ldy tos
    lda allurbases-'#',y
    sta ACC+2*N6
    jmp drop

allurbases
    .byt 10,16,2                ; #$%

;--------------------------------------------------------------
#if 0
name=:BASE
stack=( #|$|% -- )
tags=numword,nosymbol

#endif
#include "pass.i65"
__base
    .word flagme
    .byt %00110001
#include "pass.i65"
    .word allurbases
#include "pass.i65"
    .word branch
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=:REGISTER
stack=( R|N -- )
tags=numword,nosymbol

#endif
#include "pass.i65"
__register
    .word flagme
    .byt %10110010
#include "page.i65"
    .word regoffset
#include "pass.i65"
    .word branch
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=:<=>
stack=( addr -- d )
tags=numword,nosymbol

#endif
#include "pass.i65"
__spaceship
    .word qcomp
#include "pass.i65"
    .word flagme
    .byt %11110100
#include "page.i65"
    .word sshipn4
#include "pass.i65"
    .word branch
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=NUMBER
stack=( addr -- d )
tags=numword,nosymbol
`number` rewritten for `studio`, this variant recognizes several prefix
characters

|prefix|purpose|
|`-`|''negative''|
|`digit`|valid ''digit'' in current number base|
|`.`|''point''|
|`<`|''from'' //(`addr` push to `tos`)//|
|`=`|''exchange'' //(swap `tos` with `addr`)//|
|`>`|''to'' //(copy `tos` to `addr`)//|
|`N`|''N'' register|
|`R`|Sweet16 ''R'' register|
|`#`|''decimal'' number base|
|`$`|''hex'' number base|
|`%`|''binary'' number base|

# push single/char
# push double
# enclose lit
# enclose clit
# enclose dlit
# compile zpfrom
# compile addrfrom
# compile zpex
# compile addrex
# compile tozp
# compile toaddr

# `-` `.` `digit` characters work like ''standard Forth''
#* `-` negate this number
#** `-` works with `.` and `#$%`
#** do not combine `-` with `<=>` or `nr`
#* `.` decimal point
#** treat this number as a 32-bit double
#** set `dpl` to location of decimal point
#** or `dpl` is -1 if not present
#** `.` works with `-` and `#$%`
#** do not combine `.` with `<=>` or `nr`
#* `digit`
#** decimal -- //0 1 2 3 4 5 6 7 8 9//
#** hex -- //0 1 2 3 4 5 6 7 8 9 A B C D E F//
#** binary -- //0 1//
#** must be less than base
# `<` `=` `>` ''spaceship'' group copies 16-bit values between `tos` and memory
#* //compilation only//
#* works with registers `>n3` `<r11`
#* uses default number base `decimal >142 hex =E820`
#* also works with explicit base operator `>#142` `=$E820`
#* may not be combined with `-` or `.`
#* `<` push contents of address to `tos`
#* `=` exchange `tos` with contents of address
#* `>` copy `tos` to an address, stack unchanged
# `n` `r` ''register'' group references Sweet16 registers
#* push register address to `tos`
#** `n3` pushes 10 to `tos`
#* works with spaceship operators `=r6` `>n8`
#* do not combine with `-` or `.`
#* `n` Forth registers `n0`.. `n8`
#* `r` Sweet16 registers `r0`..`r15`
# `#` `$` `%` ''base''  group sets number base for this number only
#* idea stolen from Volksforth
#* `#` decimal //(base 10)//
#* `$` hexadecimal //(base 16)//
#* `%` binary //(base 2)//

```
: number   ( 123 -- d )
    (number)                    \ set things up
                                    \ initialize prefix flags = 0
                                    \ `n7` already has `addr`
                                    \ `n8` already has `len`
                                    \ set `n6` to `base`
                                    \ push 0.
    begin
        num.char+ dup
        " -<=>RN#$%"+null $index 2*
        >dispatch
        :digits? ,
        :minus ,
        :from ,  :exchange ,  :to ,
        :r ,  :n ,
        :decimal ,  :hex ,  :binary ,
:num.next
                                ( flag )
    until
    ;



    begin
        num.char+ ?dup
    while
        " -<=>RN#$%" $index 2*
        >dispatch
        :digits? ,
        :minus ,
        :from ,  :exchange ,  :to ,
        :r ,  :n ,
        :decimal ,  :hex ,  :binary ,
:num.next
    repeat
    ;

:minus  ( -- )
    %11101000 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `-`
                                    \ disallow another `-`
                                    \ disallow `<=>`
                                    \ disallow `rn`
                                    \ allow `#$%`
        >num.next               \ another character


:<=>
                                \ state off: "COMPILATION ONLY"
                                \ state on: compile one of:
                                    `tozp`
                                    ;`tomem`
                                    `zpex`
                                    ;`exchgmem`
                                    `zpfrom`
                                    ;`memfrom`
    ?comp                       \ compile mode only
    %11000100 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `<=>`
                                    \ disallow `-`
                                    \ disallow another `<=>`
                                    \ allow `rn`
                                    \ allow `#$%`
:from
zpfrom
:exchange
zpex
:to
tozp

:register
    %11110010 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `rn`
                                    \ disallow `-`
                                    \ disallow `<=>`
                                    \ disallow another `rn`
                                    \ disallow `#$%`
                                \ `this.chr`
                                \ eor #$04    r or n
                                \ adc ACC     offset
                                \ + 2* `value`

    prefix?
                                \ addr -> n7
                                ( flag )

:r
+4
:n
+0

:base
                                \ sets default number `base`
    %11110001 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `#$%`
                                    \ disallow `-`
                                    \ disallow `<=>`
                                    \ disallow `rn`
                                    \ disallow another `#$%`
                                \ change 'n6l'

:decimal
10 >base
:hex
16 >base
:binary
2 >base


     0 0 rot count
                                ( 0 0 addr+1 len )
     over c@ [ ascii - ] literal  =
                                ( 0 0 addr+1 len negative? )
     dup>r
                                ( 0 0 addr+1 len negative? )  ( R; negative? )
     +                          \ adjust length for sign char )
                                ( 0 0 addr+1 lenadj )
     over + r@ -
                                ( 0 0 addr+1 addrhigh+1 )
     swap  r@ -
                                ( 0 0 addrhigh+1 addrlow )
     dpl on                     \ -1 means no decimal place
     ?do
                                ( d )
         base @ >r
                                ( d ) ( R; base negative? )
         i c@  r@
                                ( )
         digit
                                ( -- d currdigit~?~ flag )
         if
             swap r@ um*
             drop rot
             r@ um* d+
             dpl @ 1+  0= negate dpl +!
         else
             i c@ [ ascii . ] literal  =
             dpl @ 0<  and
             if
                 dpl off
             else
                 3 fail ( abort" not found" )
             then
         then
         r> drop
                                ( R; negative? ; discard base )
     loop
     r>  if  dnegate  then ;

Inspired by what I read about PLASMA, another 6502 retro language targeting very similar Apple II hardware, I thought, well here's 32 bytes of Sweet16 register space just sitting around while Forth spins itself dizzy at the tip of the stack. Why not put in something like local variables which map to the Sweet16 register space, and have certain sets of primitives like the outer interpreter share information there? A place to spread out some of the work and speed things up, reduce code size, maybe other goodness too.

In traditional Forth, `number` leaves a signed `d` on the stack and sets `dpl`.



For implementation, I'm hooking it into NUMBER so that R0 >R0 <R0 >N8 N8 <N0 >R15 etc... won't have to be in the dictionary. While I'm at it, e.g. $BEEF will momentarily switch BASE to hexadecimal and switch back after converting the NUMBER after the leading dollar-sign, #31415 for decimal constants, %1001100 for binary

: number ( addr -- )
    dpl on  base (number)
                                ( 0. )
    begin
        (nextchar)




        \ out of characters?
    until
    brk
    ldi n7

( dlo dhi )
dpl @ 1+ ?dup 2drop
( dlo dhi )


```


~#comfortablynumber
#endif
#include "align.i65"
_number
    jsr enter
#include "page.i65"
    .word dpl
#include "page.i65"
    .word on
#include "page.i65"
    .word base
#include "page.i65"
    .word pnumber               ; ( 0. )
#include "page.i65"
number01
    .word nextchar              ; ( result. char )
#include "page.i65"
    .word dup
#include "page.i65"
    .word prefixes
#include "page.i65"
    .word swap
#include "page.i65"
    .word dolindex
#include "page.i65"
;    .word xyzzy
#include "page.i65"
    .word twostar
#include "pass.i65"
    .word _dodispatch
    .word __digits-2            ; digit <base
    .word __punkt-2             ; .
    .word __minus-2             ; -
    .word __spaceship-2         ; <
    .word __spaceship-2         ; =
    .word __spaceship-2         ; >
    .word __register-2          ; R
    .word __register-2          ; N
    .word __base-2              ; #
    .word __base-2              ; $
    .word __base-2              ; %
#include "page.i65"
number02
    .word morecharq
#include "pass.i65"
    .word qbranch
    .byt <(number01-*+1)
                                ; dnegate if the negator is on

#include "page.i65"
    .word dpl                   ; transform double to single if `dpl` is -1
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qdup
#include "page.i65"
    .word twodrop
                                ; double (and add 4?) for register prefix
#include "page.i65"
    .word extuntil02            ; jmp(r11) performs `number` rundown
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:DIGITS
stack=( addr -- d )
tags=numword,nosymbol
:digits   ( d 0 -- )
#endif
#include "page.i65"
__digits
    .word digit
#include "page.i65"
    .word tor
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6
#include "page.i65"
    .word lsb
#include "page.i65"
    .word zero
#include "pass.i65"
    .word tozp
    .byt ACC
#include "page.i65"
    .word pumstar
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _mplus
#include "page.i65"
    .word qdpl
#include "pass.i65"
    .word branch                ; ( result. )
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=:.
stack=( addr -- d )
tags=numword,nosymbol
Decimal point `.` handler for `number`


#endif
#include "pass.i65"
__punkt
    .word flagme
    .byt %01101111              ; - <=> NR #$%
#include "page.i65"
    .word dpl
#include "page.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "pass.i65"
    .word qerror
    .byt 3
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word branch
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=:-
stack=( addr -- d )
tags=numword,nosymbol

set rundown vector to negate routine for either double/single

#endif
#include "pass.i65"
__minus
    .word flagme
    .byt %11111000              ; - <=> NR #$%
#include "page.i65"
    .word minusone
#include "pass.i65"
    .word tozp
    .byt ACC+2*N4               ; for rundown handler
#include "page.i65"
    .word twodrop               ; discard `-` sign and -1 flag
#include "pass.i65"
    .word branch
    .byt <(number02-*+1)

;--------------------------------------------------------------
#if 0
name=FOO
stack=( )
tags=numword

#endif
#include "align.i65"
_foo
    jsr enter
#include "page.i65"
    .word seven
#include "page.i65"
    .word bar
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BAR
stack=( )
tags=numword

erase 8 bytes of z.p. register space
#endif
bar
    ldy #$08                    ; erase `n0`..`n5`
    lda #0
    jsr erases02
    jmp drop

#print (*-numcharplus)

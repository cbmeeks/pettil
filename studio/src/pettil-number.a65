; pettil-number.a65
#echo .       pettil-number.a65         Number parser

;--------------------------------------------------------------
#if 0
name=NUM.CHAR+
stack=( -- c )
tags=numword,nosymbol
Return next character of the number we're parsing.  Return 0 at end of string.

~#comfortablynumber
#endif
numcharplus
    brk
    .byt dcr | N8
    .byt ld | N8
    .byt bz , <(numch01-*-2)
    .byt ldi | N7
numch01
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PREFIXES
tags=numword,nosymbol
`number` prefix indexed jump table (no `cfa`)
~#comfortablynumber
#endif
prefixes
    jsr docreate
     .byt prefixes01-*          ; number of prefixes
     .asc ".-<=>RN#$%"
prefixes01
    .byt 0

;--------------------------------------------------------------
#if 0
name=:DIGITS
stack=( addr -- d )
tags=numword,nosymbol
:digits   ( d 0 -- )
#endif
#include "pass.i65"
__digits
;    .word flagme
;    .byt %11110000
;#include "page.i65"
    .word digits
#include "page.i65"
                                ; ( result. flag )
    .word branch
    .byt <(devnum02-*+1)

;--------------------------------------------------------------
#if 0
name=DIGITS
stack=( char -- flag )
tags=numword,nosymbol
Crunch through allowable characters, by now limited to just digits in the
current number base at `n6` and a first occurrence of decimal point (`.`)

For valid digits, `multiply` the double at `n0-n3` by `n6` and add the digit

is this a digit?
nope:  throw "NOT FOUND"

stash it in ACC
multiply n6-base by current number
add digit

decrement n8
push (n8 <> 0)

#endif
digits
    lda tos
    sec
    sbc #$30
    bcs digits02                ; is it maybe a digit?
digits01
    ldy #3
    jmp error
digits02
    cmp #10
    bcc digits03                ; see if it's a hex digit or a real digit
    sbc #7
digits03
    cmp ACC+2*N6                ; compare to current number base
    bcs digits01                ; not a digit?
    sta tos
    jmp next

    lda ACC+2*N6
    sta tos
;    lda #0
;    sta tos+1
    jsr multiplude
    pla
    adc ACC+2*N0
    sta ACC+2*N0
    bcc digits03
    inc ACC+2*N0+1
    bne digits03
    inc ACC+2*N1+1
    bne digits03
    inc ACC+2*N1+1

digits04
    sta tos                     ; sloppy flag for `number`
    jmp next

    nop
    nop
    nop

multiplude
    jsr harvests4
    ldy #16
mude01
    lsr tos+1
    ror tos
    bcc mude01                  ; Go rotate right if c = 0
    clc
    lda ACC+2*N1                ; Get upper half of product
    adc ACC+2*N2                ; and add multiplicand toit
    sta ACC+2*N1
    lda ACC+2*N1+1
    adc ACC+2*N2+1
mude02
    ror                         ; shift partial product right
    sta ACC+2*N1+1
    ror ACC+2*N1
    ror ACC+2*N0+1
    ror ACC+2*N0
    dey                         ; Decrement bit count and
    bne mude02                  ; loop
    jsr plants4
    rts

;--------------------------------------------------------------
#if 0
name=:.
stack=( addr -- d )
tags=numword,nosymbol

#endif
#include "pass.i65"
__decimal
    .word punkt
#include "page.i65"
    .word dpl
#include "page.i65"
    .word off
#include "page.i65"
    .word branch
    .byt <(devnum02-*+1)

;--------------------------------------------------------------
#if 0
name=PUNKT
stack=( addr -- d )
tags=numword,nosymbol

#endif
punkt
    lda #%11110000
    jsr flagme
    jmp next

;--------------------------------------------------------------
#if 0
name=:-
stack=( addr -- d )
tags=numword,nosymbol

set rundown vector to negate routine for either double/single

#endif
#include "pass.i65"
__minus
    .word flagme
    .byt %11111110              ; - <=> NR #$%
#include "pass.i65"
    .word numberrundown
    .word negator
#include "pass.i65"
    .word branch
    .byt <(devnum02-*+1)

;--------------------------------------------------------------
#if 0
name=NEGATOR
stack=( )
tags=numword,nosymbol

#endif
negator
    jmp next

;--------------------------------------------------------------
#if 0
name=:<=>
stack=( addr -- d )
tags=numword,nosymbol

#endif
#include "pass.i65"
__spaceship
    .word flagme
    .byt %11111100
#include "pass.i65"
    .word numberrundown
    .word spaceshippor
#include "pass.i65"
    .word branch
    .byt <(devnum02-*+1)

;--------------------------------------------------------------
#if 0
name=SPACESHIPPOR
stack=( )
tags=numword,nosymbol

#endif
spaceshippor
    jmp next

;--------------------------------------------------------------
#if 0
name=<=>
stack=(  )
tags=numword,nosymbol

#endif
spaceship
    dex
    ldy ACC
    lda spaceshiph-'<',y
    sta stackh,x
    lda spaceshipl-'<',y
    sta stackl,x
    lda #%11000100              ; no `-` or other `<=>`
flagmerotate
    jsr flagme
    jmp dashrot

spaceshipl
    .byt <zpfrom, <zpex, <tozp
spaceshiph
    .byt >zpfrom, >zpex, >tozp

;--------------------------------------------------------------
#if 0
name=FLAGME
stack=( -- )
tags=numword,nosymbol

#endif
flagme
    ldy #2
    lda (ip),y
    pha
    and ACC+2*N6+1
    beq flagme01                ; blergh! `not found`
    iny                         ; ldy #3
    jmp error
flagme01
    pla
    asl
    asl
    asl
    asl
    ora ACC+2*N6+1
    sta ACC+2*N6+1
    jmp pad3

;--------------------------------------------------------------
#if 0
name=NUMBER.RUNDOWN
stack=( )
tags=numword,nosymbol

#endif
numberrundown
    ldy #2
    lda (ip),y
    sta ACC+2*R11
    iny
    lda (ip),y
    sta ACC+2*R11+1
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=:REGISTER
stack=(  )
tags=numword,nosymbol

#endif
#include "pass.i65"
__register
    .word flagme
    .byt %10111111
#include "pass.i65"
    .word numberrundown
    .word registor
#include "pass.i65"
    .word branch
    .byt <(devnum02-*+1)

;--------------------------------------------------------------
#if 0
name=REGISTER
stack=( addr -- d )
tags=numword,nosymbol

#endif
registor
    lda #10
    sta ACC+2*N6                ; set base to decimal
    dex
    sec
    lda ACC
    sbc #'N'                    ; 0 or 4 for n or r
    sta stackl,x
    lda #0
    sta stackh,x
    dex
    lda #%11110010
    bne flagmerotate

;--------------------------------------------------------------
#if 0
name=:BASE
stack=( )
tags=numword,nosymbol

#endif
#include "pass.i65"
__base
    .word xyzzy
    ldy ACC
    lda bases-'#',y
    sta ACC+2*N6
    lda #%11110001
    jsr flagme
    jmp swap

bases
    .byt 10,16,2                ; #$%

;--------------------------------------------------------------
#if 0
name=:RUNDOWN
stack=( )
tags=numword,nosymbol

#endif
#include "pass.i65"
__rundown
    .word xyzzy

;--------------------------------------------------------------
#if 0
name=(NEXTCHAR)
stack=( d -- d char )
tags=numword,nosymbol
Get next character, part of `number`.

|^n6|^base c@|^//(unchanged)//|
|^n7|^addr|^//+1//|
|^n8|^length|^//(unchanged)//|
|^r11|^0|^//rundown handler//|
|^tos<br/>2os|^0.||


~#comfortablynumber
#endif
nextchar
    brk
    .byt ldi | N7
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(NUMBER)
stack=( addr base -- 0. )
tags=numword,nosymbol
Setup for number parser

* n7 = addr
* n6 = base c@
* n8 = length
* r11 = 0
* tos,2os = 0.

~#comfortablynumber
#endif
pnumber
    brk
    .byt ldi | TOS              ; `base c@`
    .byt st | N6                ; base / flags=0
    .byt pull
    .byt st | N7                ; address of text buffer
    .byt ldi | N7
    .byt st | N8                ; `len` and bump char pointer
    .byt sub | ACC
    .byt st | R11               ; initialize rundown vector
    .byt st | TOS
    .byt push                   ; leave `0.`
    .byt nxt

;--------------------------------------------------------------
#if 0
name=NUMBER
stack=( addr -- d )
tags=numword,nosymbol
`number` rewritten for `studio`, this variant recognizes several prefix
characters

|prefix|purpose|
|`-`|''negative''|
|`digit`|valid ''digit'' in current number base|
|`.`|''point''|
|`<`|''from'' //(`addr` push to `tos`)//|
|`=`|''exchange'' //(swap `tos` with `addr`)//|
|`>`|''to'' //(copy `tos` to `addr`)//|
|`N`|''N'' register|
|`R`|Sweet16 ''R'' register|
|`#`|''decimal'' number base|
|`$`|''hex'' number base|
|`%`|''binary'' number base|

# `-` `.` `digit` characters work like ''standard Forth''
#* `-` negate this number
#** `-` works with `.` and `#$%`
#** do not combine `-` with `<=>` or `nr`
#* `.` decimal point
#** treat this number as a 32-bit double
#** set `dpl` to location of decimal point
#** or `dpl` is -1 if not present
#** `.` works with `-` and `#$%`
#** do not combine `.` with `<=>` or `nr`
#* `digit`
#** decimal -- //0 1 2 3 4 5 6 7 8 9//
#** hex -- //0 1 2 3 4 5 6 7 8 9 A B C D E F//
#** binary -- //0 1//
#** must be less than base
# `<` `=` `>` ''spaceship'' group copies 16-bit values between `tos` and memory
#* //compilation only//
#* works with registers `>n3` `<r11`
#* uses default number base `decimal >142 hex =E820`
#* also works with explicit base operator `>#142` `=$E820`
#* may not be combined with `-` or `.`
#* `<` push contents of address to `tos`
#* `=` exchange `tos` with contents of address
#* `>` copy `tos` to an address, stack unchanged
# `n` `r` ''register'' group references Sweet16 registers
#* push register address to `tos`
#** `n3` pushes 10 to `tos`
#* works with spaceship operators `=r6` `>n8`
#* do not combine with `-` or `.`
#* `n` Forth registers `n0`.. `n8`
#* `r` Sweet16 registers `r0`..`r15`
# `#` `$` `%` ''base''  group sets number base for this number only
#* idea stolen from Volksforth
#* `#` decimal //(base 10)//
#* `$` hexadecimal //(base 16)//
#* `%` binary //(base 2)//

```
: number   ( 123 -- d )
    (number)                    \ set things up
                                    \ initialize prefix flags = 0
                                    \ `n7` already has `addr`
                                    \ `n8` already has `len`
                                    \ set `n6` to `base`
                                    \ push 0.
    begin
        num.char+ dup
        " -<=>RN#$%"+null $index 2*
        >dispatch
        :digits? ,
        :minus ,
        :from ,  :exchange ,  :to ,
        :r ,  :n ,
        :decimal ,  :hex ,  :binary ,
        :rundown ,
:num.next
                                ( flag )
    until
    ;



    begin
        num.char+ ?dup
    while
        " -<=>RN#$%" $index 2*
        >dispatch
        :digits? ,
        :minus ,
        :from ,  :exchange ,  :to ,
        :r ,  :n ,
        :decimal ,  :hex ,  :binary ,
:num.next
    repeat
    ;

:minus  ( -- )
    %11101000 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `-`
                                    \ disallow another `-`
                                    \ disallow `<=>`
                                    \ disallow `rn`
                                    \ allow `#$%`
        >num.next               \ another character


:<=>
                                \ state off: "COMPILATION ONLY"
                                \ state on: compile one of:
                                    `tozp`
                                    ;`tomem`
                                    `zpex`
                                    ;`exchgmem`
                                    `zpfrom`
                                    ;`memfrom`
    ?comp                       \ compile mode only
    %11000100 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `<=>`
                                    \ disallow `-`
                                    \ disallow another `<=>`
                                    \ allow `rn`
                                    \ allow `#$%`
:from
zpfrom
:exchange
zpex
:to
tozp

:register
    %11110010 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `rn`
                                    \ disallow `-`
                                    \ disallow `<=>`
                                    \ disallow another `rn`
                                    \ disallow `#$%`
                                \ `this.chr`
                                \ eor #$04    r or n
                                \ adc ACC     offset
                                \ + 2* `value`

    prefix?
                                \ addr -> n7
                                ( flag )

:r
+4
:n
+0

:base
                                \ sets default number `base`
    %11110001 prefix.flags      \ -<N#-<N# disallow/set
                                \ set prefix flag `#$%`
                                    \ disallow `-`
                                    \ disallow `<=>`
                                    \ disallow `rn`
                                    \ disallow another `#$%`
                                \ change 'n6l'

:decimal
10 >base
:hex
16 >base
:binary
2 >base


     0 0 rot count
                                ( 0 0 addr+1 len )
     over c@ [ ascii - ] literal  =
                                ( 0 0 addr+1 len negative? )
     dup>r
                                ( 0 0 addr+1 len negative? )  ( R; negative? )
     +                          \ adjust length for sign char )
                                ( 0 0 addr+1 lenadj )
     over + r@ -
                                ( 0 0 addr+1 addrhigh+1 )
     swap  r@ -
                                ( 0 0 addrhigh+1 addrlow )
     dpl on                     \ -1 means no decimal place
     ?do
                                ( d )
         base @ >r
                                ( d ) ( R; base negative? )
         i c@  r@
                                ( )
         digit
                                ( -- d currdigit~?~ flag )
         if
             swap r@ um*
             drop rot
             r@ um* d+
             dpl @ 1+  0= negate dpl +!
         else
             i c@ [ ascii . ] literal  =
             dpl @ 0<  and
             if
                 dpl off
             else
                 3 fail ( abort" not found" )
             then
         then
         r> drop
                                ( R; negative? ; discard base )
     loop
     r>  if  dnegate  then ;

Inspired by what I read about PLASMA, another 6502 retro language targeting very similar Apple II hardware, I thought, well here's 32 bytes of Sweet16 register space just sitting around while Forth spins itself dizzy at the tip of the stack. Why not put in something like local variables which map to the Sweet16 register space, and have certain sets of primitives like the outer interpreter share information there? A place to spread out some of the work and speed things up, reduce code size, maybe other goodness too.

In traditional Forth, `number` leaves a signed `d` on the stack and sets `dpl`.



For implementation, I'm hooking it into NUMBER so that R0 >R0 <R0 >N8 N8 <N0 >R15 etc... won't have to be in the dictionary. While I'm at it, e.g. $BEEF will momentarily switch BASE to hexadecimal and switch back after converting the NUMBER after the leading dollar-sign, #31415 for decimal constants, %1001100 for binary

: number ( addr -- )
    dpl on  base (number)
                                ( 0. )
    begin
        (nextchar)




        \ out of characters?
    until
    brk
    ldi n7


```


~#comfortablynumber
#endif
#include "align.i65"
_number
    jsr enter
#include "page.i65"
    .word dpl
#include "page.i65"
    .word on
#include "page.i65"
    .word base
#include "page.i65"
    .word pnumber               ; ( 0. )
#include "page.i65"
devnum01
    .word nextchar
                                ; ( result. char )
#include "page.i65"
    .word dup
#include "page.i65"
    .word prefixes
#include "page.i65"
    .word swap
#include "page.i65"
    .word dolindex
#include "page.i65"
    .word twostar
#include "page.i65"
    .word xyzzy
#include "pass.i65"
    .word _dodispatch
    .word __digits-2            ; digit <base
    .word __decimal-2           ; .
    .word __minus-2             ; -
    .word __spaceship-2         ; <
    .word __spaceship-2         ; =
    .word __spaceship-2         ; >
    .word __register-2          ; R
    .word __register-2          ; N
    .word __base-2              ; #
    .word __base-2              ; $
    .word __base-2              ; %
    .word __rundown-2           ; null
#include "pass.i65"
devnum02
                                ; ( flag )
    .word qbranch
    .byt <(devnum01-*+1)
    .word exit
#print (*-numcharplus)

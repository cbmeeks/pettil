; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years. 
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate
bit5	= $20		; smudge

; zero page usage
stackl	= $00		; stackl = $00..$3b (60 bytes)
stackh	= $30		; stackh = $3c..$79 (60 bytes)
bos	= stackh-stackl	; includes TOS
up	= $76		; user area pointer
n	= $78		; scratch space
w	= $7e		; w overlaps n
tos	= $80		; top of stack
zi	= $82		; innermost DO LOOP counter/limit

next	= $86
;0086 next	inc ip
next1	= $88
;0088 next1	inc ip
nexto	= $8a
ip	= $8b
;008a nexto	jmp ($cafe)

;$8d..$ff kernel zeropage area

outputted	= cas2buf+26		; #out	~ a cleaner way to do this?
inputted	= cas2buf+42		; span
linesout	= cas2buf+54		; #line

basic		= $0400
		.word basic+1		; PET BASIC storage starts here
*		= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc "(1040)",0		; sys $0410
basend		.word 0

		.dsb basic+$10-*,$ea
coldvector	jmp cold
warmvector	jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userarea

userntop	.word ntop				; 4..5
userup		.word cas2buf				; 6..7
usersp0		.word bos				; 8..9
userrp0		.word $01ff				; 10..11
userwidth	.word 31				; 12..13
userwarning	.word -1				; 14..15

userwarm

userfence	.word forgetfence			; 16..17
userdp		.word endofile				; 18..19
uservoclink	.word lastvoc				; 20..21
userviewquery	.word 2					; 22..23
userblk		.word $1908				; 24..25

usercold



		;dictionary hash link table used by rechaining words
latestl		.dsb 16,0
latesth		.dsb 16,0

;--------------------------------------------------------------
;
;	NEXT
;
; * inner interpreter headerless
;
;		+IP
;		[IP] -> PC
;
; this NEXT routine gets copied to $0086 by COLD.  See project
; tiddlywiki for the rationale behind this minimalist design
;
azpnext
	inc ip
	inc ip
	jmp ($cafe)
zzpnext

; Page boundary crossing within a secondary is handled by the compiler inserting
; 'page' when the DP gets to $xxFD or $xxFE.  DP having a value of $xxFF is
; not supposed to happen, and indicates an error in the compiler.
page		lda #0
		sta ip
		inc ip+1
		jmp nexto

;--------------------------------------------------------------
;
;	EXECUTE
;
; * compiler
;
; Executes the definition found at addr.
;
;"	: execute ( cfa --- )
;"		jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa	.word 0			; <-- last word in dictionary
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7	; length and final byte are OR $80
execute		lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1	; [SP] -> [W1]
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx		; SP+
		lda ip
		sta w1+4
		lda ip+1
		sta w1+5	; IP -> [W1+4]
		lda #<w1
		sta ip
		lda #>w1
		sta ip+1	; W1 -> IP
		jmp nexto

; These three words are used by EXECUTE as a 'fragment secondary'
; (for those occasions when you just need a W register)
				; dummy value $DEAD, we wind up at $BEEF
w1		.word $dead
		.word branch
		.word $beef

;--------------------------------------------------------------
;
;	(LIT)
;
; * inner interpreter headerless
;
; push the word of memory following (IP)
;
;plitlfa	.word $adde
;		.byt (plit-*-1)|bit7
;		.asc "(LIT",")"|bit7
plit		ldy #3
		lda (ip),y
		sta n+1
		dey
		lda (ip),y
		sta n
skiplit		ldy ip
		cpy #$fb
		bcc nopage
		bne l003
		iny
l003		inc ip+1
nopage		iny
		iny
		sty ip
pushn		ldy n+1
		lda n

push		sta n
		dex
		lda tos+1
		sta stackh,x
		lda tos
		sta stackl,x
		lda n
put		sty tos+1
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	CLIT
;
; * inner interpreter headerless
;
; takes the byte of memory following and pushes it to the data stack
;
;"      : clit ( -- c )
;"         ip c@  1 ip +! ;
;
;clitlfa	.word $adde
;		.byt (clit-*-1)|bit7
;		.asc "CLI","T"|bit7
clit            ldy #2
                lda (ip),y
		dec ip
                sta n
                lda #0
                sta n+1
                beq skiplit

;--------------------------------------------------------------
;
;       ?BRANCH   ( flag -- )
;
; * inner interpreter control headerless
;
;qbranchlfa	.word $adde
;		.byt (qbranch-*-1)|bit7
;		.asc "?BRANC","H"|bit7
qbranch         lda tos
		ora tos+1
		ldy stackl,x
		sty tos
		ldy stackh,x
		sty tos+1
		inx             ; drop
		tay		; to set the Z flag
		beq branch
bump		lda #4
nexta           clc		;[2]
		adc ip		;[3]
		sta ip		;[3]
		bcc l023	;[2]
		inc ip+1	;[5]
l023            jmp nexto	;[3]

;--------------------------------------------------------------
;
;       BRANCH
;
; * inner interpreter control headerless
;
; Compiles an unconditional branch operation.
;" When used in the form:  COMPILE BRANCH
; an  unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated  by following BRANCH
; with <RESOLVE or >MARK .
;
;"      : branch ( -- )
;
;branchlfa	.word $adde
;		.byt (branch-*-1)|bit7
;		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
; Y = 1
branch          ldy #2          ; [2]
		lda (ip),y      ; [5+]
		sta n           ; [3]
		iny             ; [2]
		lda (ip),y      ; [5+]
		sta ip+1        ; [3]
		lda n           ; [3]
		sta ip          ; [3] (IP+2) -> IP
		jmp nexto       ; [3]
				; [29/30 cycles] (runs in constant time)

;--------------------------------------------------------------
;
;       (+LOOP)   ( n -- )
;
; * inner interpreter control headerless
;
; add n to inner loop index.  If loop index exceeds loop limit,
; then iterate to the (do), otherwise skip past the branch and
; proceed
;pplooplfa	.word $adde
;		.byt (pploop-*-1)|bit7
;		.asc "(+LOOP",")"|bit7
pploop		clc
		lda tos
		adc zi
		sta zi
		lda tos+1
		adc zi+1
		sta zi+1
		lda zi+2
		cmp zi
		lda zi+3
		sbc zi+1
		ldy tos+1
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx
		tay
		bcc l043
		eor #$80
l043		bmi branch
		bpl bump

;--------------------------------------------------------------
;
;       (LOOP)
;
; * inner interpreter control headerless
;
;plooplfa	.word $adde
;		.byt (ploop-*-1)|bit7
;		.asc "(LOOP",")"|bit7
ploop           inc zi
		bne pl1
		inc zi+1
pl1		lda zi+2
		eor zi
		bne branch
		lda zi+3
		eor zi+1
		bne branch
		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp bump

;--------------------------------------------------------------
;
;	(DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; loops from 'begin' to 'end'
;pdolfa		.word $adde
;		.byt (pdo-*-1)|bit7
;		.asc "(DO",")"|bit7
pdo		lda zi+3
		pha
		lda zi+2
		pha
		lda zi+1
		pha
		lda zi
		pha
		lda stackh,x
		sta zi+3
		lda stackl,x
		sta zi+2
		lda tos+1
		sta zi+1
		lda tos
		sta zi
poptwo		inx
pop		ldy stackh,x
		lda stackl,x
		inx
		jmp put

;--------------------------------------------------------------
;
;	(?DO)
;
; * inner interpreter control headerless
;
;pqdolfa	.word $adde
;		.byt (_pqdo-*-1)|bit7
;		.asc "(?DO",")"|bit7
_pqdo
#include enter.a65

;--------------------------------------------------------------
;
;	I
;
; * inner interpreter control
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		lda zi
		ldy zi+1
		jmp push

;--------------------------------------------------------------
;
;	J
;
jlfa		.word $adde
		.byt (_j-*-1)|bit7
		.asc "J"|bit7
_j
#include enter.a65

;--------------------------------------------------------------
;
;	(LEAVE)
;
; * inner interpreter control headerless
;
;pleavelfa	.word $adde
;		.byt (_pleave-*-1)|bit7
;		.asc "(LEAVE",")"|bit7
_pleave
#include enter.a65

;--------------------------------------------------------------
;
;	(?LEAVE)
;
; * inner interpreter control headerless
;
;pqleavelfa	.word $adde
;		.byt (_pqleave-*-1)|bit7
;		.asc "(?LEAVE",")"|bit7
_pqleave
#include enter.a65

;--------------------------------------------------------------
;
;	DIGIT
;
digitlfa	.word $adde
		.byt (_digit-*-1)|bit7
		.asc "DIGI","T"|bit7
_digit
#include enter.a65

;--------------------------------------------------------------
;
;	(FIND)   ( addr1 addr2 -- addr flag )
;
; * outer interpreter headerless
;
; first search the context dictionary, which may be unhashed
; then hash the word and search only that thread in the main dictionary
;
;pfindlfa	.word $adde
;		.byt (pfind-*-1)|bit7
;		.asc "(FIND",")"|bit7
pfind		lda tos
		sta n
		lda tos+1
		sta n+1
		lda stackl,x
		sta n+2
		lda stackh,x
		sta n+3
		ldy #1
l9		dey		; ~ ewww
		lda (n),y
		eor (n+2),y
		and #($100-bit7-bit6)
		bne l8
l6		iny
		lda (n),y
		eor (n+2),y
		asl
		bne l8
		bcc l6
		dex
		dex
		iny
		tya
		clc
		adc n
		sta stackl+1,x
		ldy #0
		tya
		adc n+1
		sta stackh+1,x
		sty tos+1
		lda (n),y
		asl
		bpl l7		; branch if non-immediate
		lda #1		; immediate
		sta tos
		jmp next
l7		lda #$ff	;true
		tya
		jmp put

l8		sec
		lda n		; traverse the LFAs?
		sbc #2
		sta n
		lda n+1
		sbc #0
		sta n+1
		ldy #0
		lda (n),y
		tax
		iny
		lda (n),y
		sta n+1
		stx n
		ora n
		bne l9
		ldx n+4
		dex
		dex
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		lda #0		;false
		pha
		jmp push

;--------------------------------------------------------------
		; pops up to 4 words from the split stack to the N area
		; A = how many words to pop (valid range 1-4)
		;
		; returns
		; TOS -> N0, 2OS -> N1, 3OS -> N2, 4OS -> N3
		;      1          2          3          4
popnwords	ldy tos
		sty n
		ldy tos+1
		sty n+1
		sta tos			; temporarily use TOS as loop counter
		ldy #0
l004		dec tos
		beq l005
		iny
		iny
		lda stackl,x
		sta n,y
		lda stackh,x
		sta n+1,y
		inx
		bne l004		; bra
l005		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx
		rts

;--------------------------------------------------------------
;
;	SKIP
;
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		lda #3			; ~ mostly Blazin'.  fixed double DEX
		jsr popnwords		; and other minor differences
l13		lda n+2
		ora n+3
		beq l10
		lda (n+4),y
		eor n
		asl
		bne l10
		inc n+4
		bne l11
		inc n+5
l11		lda n+2
		bne l12
		dec n+3
l12		dec n+2
		jmp l13
l10		dex
		lda n+4
		sta tos
		lda n+5
		sta tos+1
		ldy n+2
		lda n+3
		jmp push


;--------------------------------------------------------------
;
;	SCAN
;
scanlfa		.word $adde
		.byt (_scan-*-1)|bit7
		.asc "SCA","N"|bit7
_scan
#include enter.a65
		lda #3
		jsr popnwords
l16		lda n+2
		ora n+3
		beq l10
		lda (n+4),y
		eor n
		asl
		beq l10
		inc n+4
		bne l14
		inc n+5
l14		lda n+2
		bne l15
		dec n+3
l15		dec n+2
		jmp l16


;--------------------------------------------------------------
;
;	EMIT
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp emitvector
emitvector	inc outputted
		bne l130
		inc outputted+1
l130		lda tos
		jsr CHROUT
		jmp pop

;--------------------------------------------------------------
;
;	KEY
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp keyvector
keyvector	stx n
l131		jsr GETIN
		beq l131
		ldx n
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp qtermvector
qtermvector	stx n
		ldy #0
		jsr STOP
		bne l132
		dey
l132		tya
		pha
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	CR
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp crvector
crvector	lda #$0d
		jsr CHROUT
		ldy #0
		sty outputted
		sty outputted+1
		inc linesout
		bne l133
		inc linesout+1
l133		jmp next

;--------------------------------------------------------------
;
;	CMOVE
;
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		lda #3
		jsr popnwords		; ~ maybe PETTIL should make one CMOVE
					; that is smart enough to not poop
					; on overlapping source/target?
					; or would this break compatibility
					; for FORTH-83 (or ANS or whatever)
					; code that relies on this "feature"
					; of having two CMOVEs?
		stx n+6
		ldx n+1
		beq l17
l18		lda (n+4),y
		sta (n+2),y
		iny
		bne l18
		inc n+5
		inc n+3
		dex
		bne l18
l17		ldx n
		beq l19
l20		lda (n+4),y
		sta (n+2),y
		iny
		dex
		bne l20
l19		ldx n+6
		jmp next

;"http://6502.org/source/general/memory_move.html
; Move memory down
;
; FROM = source start address
;   TO = destination start address
; SIZE = number of bytes to move
;~ 
;FROM = 0
;TO = 2
;SIZE = 4

;MOVEDOWN LDY #0
;         LDX SIZE+1
;         BEQ MD2
;MD1      LDA (FROM),Y ; move a page at a time
;         STA (TO),Y
;         INY
;         BNE MD1
;         INC FROM+1
;         INC TO+1
;         DEX
;         BNE MD1
;MD2      LDX SIZE
;         BEQ MD4
;MD3      LDA (FROM),Y ; move the remaining bytes
;         STA (TO),Y
;         INY
;         DEX
;         BNE MD3
;MD4      RTS




;--------------------------------------------------------------
;
;	CMOVE>
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		lda #3			; ~ straight from Blazin'
		jsr popnwords
		stx n+6
		lda n+1
		pha
		clc
		adc n+5
		sta n+5
		pla
		clc
		adc n+3
		sta n+3
		ldy n
		beq l21
l22		dey
		lda (n+4),y
		sta (n+2),y
		cpy #0
		bne l22
l21		ldx n+1
		beq l23
l25		dec n+5
		dec n+3
l24		dey
		lda (n+4),y
		sta (n+2),y
		cpy #0
		bne l24
		dex
		bne l25
l23		ldx n+6
		jmp next

;--------------------------------------------------------------
;
;	FILL   ( from howmany value -- )
;
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		lda #3
		jsr popnwords
		ldy #0
		lda n+2
		ora n+3
		beq l026
		lda n+4
		ldy n+2
l025		dey
		sta (n),y
		bne l025
		dec n+3
		bpl l025
l026		jmp next

;" check http://6502.org/source/ for multiply and divide and stuff
;--------------------------------------------------------------
;
;	UM*
;
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		jsr multiply
		jmp next
				; ~ this is straight out of blazin'
				; ! but seriously ! It won't work !
				; ! make it work with the split stack + TOS
				; ! model we're using in PETTIL
				; I seem to recall a faster general 
				; purpose multiply on 6502.org using LSR?
multiply	rts
;		lda stack+2,x
;		sta n
;		sty stack+2,x
;		lda stack+3,x
;		sta n+1
;l150		sty stack+3,x
;		ldy #$10
;l30		asl stack+2,x
;		rol stack+3,x
;		rol stack,x
;		rol stack+1,x
;		bcc l29
;		clc
;		lda n
;		adc stack+2,x
;		sta stack+2,x
;		lda n+1
;		adc stack+3,x
;		sta stack+3,x
;		bcc l29
;		inc stack,x
;		bne l29
;		inc stack+1,x
;l29		dey
;		bne l30
;		rts

;--------------------------------------------------------------
;
;	UM/MOD   ( ud u -- rem quot )
;
;"	http://6502.org/source/integers/ummodfix/ummodfix.htm
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	lda #6
		jsr popnwords
		sec
		lda n+2		; Subtract hi cell of dividend by
		sbc n		; divisor to see if there's an overflow condition.
		lda n+3
		sbc n+1
		bcs l039	; Branch if /0 or overflow.
;        SEC
;        LDA     2,X     ; Subtract hi cell of dividend by
;        SBC     0,X     ; divisor to see if there's an overflow condition.
;        LDA     3,X
;        SBC     1,X
;        BCS     oflo$   ; Branch if /0 or overflow.

		;clc
		txa
		pha		; preserve data stack pointer
		ldx #16		; loop 16x
l038		rol n+4		; Rotate dividend lo cell left one bit.
		rol n+5
		dex		; loop counter
		bmi l040
		rol n+2
		rol n+3
		lda #0
		sta n+6
		rol n+6

;        LDA     #11H    ; Loop 17x.
;        STA     N       ; Use N for loop counter.
; loop   ROL     4,X     ; Rotate dividend lo cell left one bit.
;        ROL     5,X
;        DEC     N       ; Decrement loop counter.
;        BEQ     end$    ; If we're done, then branch to end.
;        ROL     2,X     ; Otherwise rotate dividend hi cell left one bit.
;        ROL     3,X
;        STZ     N+1
;        ROL     N+1     ; Rotate the bit carried out of above into N+1.

		sec
		lda n+2
		sbc n
		sta n+7
		lda n+3
		sbc n+1
		tay
		lda n+6
		sbc #0
		bcc l038

;        SEC
;        LDA     2,X     ; Subtract dividend hi cell minus divisor.
;        SBC     0,X
;        STA     N+2     ; Put result temporarily in N+2 (lo byte)
;        LDA     3,X
;        SBC     1,X
;        TAY             ; and Y (hi byte).
;        LDA     N+1     ; Remember now to bring in the bit carried out above.
;        SBC     #0
;        BCC     loop

		lda n+7
		sta n+2
		sty n+3
		bcs l038	; bra

;        LDA     N+2     ; If that didn't cause a borrow,
;        STA     2,X     ; make the result from above to
;        STY     3,X     ; be the new dividend hi cell
;        BRA     loop    ; and then brach up.  (NMOS 6502 can use BCS here.)

l039		lda #$ff
		sta n+2
		sta n+3
		sta n+4
		sta n+5

; oflo$  LDA     #FFH    ; If overflow or /0 condition found,
;        STA     2,X     ; just put FFFF in both the remainder
;        STA     3,X
;        STA     4,X     ; and the quotient.
;        STA     5,X

l040		pla
		tax
		jmp swap	; more to do here... put stuff back on the stack

; end$   INX             ; When you're done, show one less cell on data stack,
;        INX             ; (INX INX is exactly what the Forth word DROP does) 
;        JMP     SWAP    ; and swap the two top cells to put quotient on top.
                        ; (Actually you'll jump to the beginning of SWAP's
                        ; executable code.  Assembler label "SWAP" is at SWAP's
                        ; PFA, not the CFA that ' SWAP would give you in Forth.
;-------------------

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx            lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx             lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor             lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		txa
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	SP!
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		ldy #usersp0-userarea
		lda (up),y
		tax
		jmp next

;--------------------------------------------------------------
;
;	RP!
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		stx n
		ldy #userrp0-userarea
		lda (up),y
		tax
		txs
		ldx n
		jmp next

;--------------------------------------------------------------
;
;       EXIT
;
;           [RP+] -> IP
;           NEXT
exitlfa         .word $adde
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
exit            pla
		sta ip
		pla
		sta ip+1        ; [RP+] -> IP
		jmp next        ; NEXT

;--------------------------------------------------------------
;
;	>R   ( n -- )
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		lda tos+1
		pha
		lda tos
		pha
		jmp pop

;--------------------------------------------------------------
;
;	R>   ( -- n )
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		pla
		sta n
		pla
		tay
		lda n
		jmp push

;--------------------------------------------------------------
;
;	R@   ( -- n )
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		stx n
		tsx
		ldy $0102,x
		lda $0101,x
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	0>   ( n -- flag )
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		ldy #$ff
		bit tos+1
		bpl l022
		iny
l022		tya
		jmp put

;--------------------------------------------------------------
;
;	<>   ( n1 n2 -- flag )
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		ldy #$ff		; assume inequality
		lda tos
		eor stackl,x
		bne l021
		lda tos+1
		eor stackh,x
		bne l021
		iny			; they're equal
l021		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	ON   ( addr -- )
;
; store -1 at ADDR
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		ldy #0
		sta (tos),y
		iny
		sta (tos),y
		jmp pop

;--------------------------------------------------------------
;
;	OFF
;
; store 0 at ADDR
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+
;
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;	
;       D+
;
dpluslfa	.word $adde
		.byt (dplus-*-1)|bit7
		.asc "D","+"|bit7
dplus		clc
		lda stackl,x
		adc stackl+2,x
		sta stackl+2,x
		lda stackh,x
		adc stackh+2,x
		sta stackh+2,x
		lda tos
		adc stackl+1,x
		sta stackl+1,x
		lda tos+1
		adc stackh+1,x
		sta stackh+1,x
		jmp poptwo

;--------------------------------------------------------------
;
;       D<
;
dltlfa		.word $adde
		.byt (dlt-*-1)|bit7
		.asc "D","<"|bit7
dlt		ldy #0		; false
		jsr dcmp
		bvc l43
		eor #$80
l43		bpl l44
		dey		; true
l44		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next
dcmp		sec
		lda stackl+2,x
		sbc stackl,x
		lda stackh+2,x
		sbc stackh,x
		lda stackl+1,x
		sbc tos
		lda stackh+1,x
		sbc tos+1
		rts
	
;--------------------------------------------------------------
;
;	NEGATE
;
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		jsr donegate
		jmp next
donegate	sec
neg2		lda #0
		sbc tos
		sta tos
		lda #0
		sbc tos+1
		sta tos+1
		rts

;--------------------------------------------------------------
;
;	DNEGATE
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		sec
		dey
		tya
		sbc stackl,x
		sta stackl,x
		tya
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER
;
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp push

;--------------------------------------------------------------
;
;	DROP
;
droplfa		.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pop

;--------------------------------------------------------------
;
;	SWAP
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp push

;--------------------------------------------------------------
;
;	+!   ( n addr -- )
;
; add N to the cell at ADDR
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	ldy #0
		clc
		lda stackl,x
		adc (tos),y
		sta (tos),y
		iny
		lda stackh,x
		adc (tos),y
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		lda stackl,x
		sta n
		lda stackh,x
		sta n+1
		ldy #0
		lda (n),y
		eor tos
		sta (n),y
		jmp poptwo

;--------------------------------------------------------------
;
;	@   ( addr -- n )
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #0
		lda (tos),y
		sta n
		iny
		lda (tos),y
		sta tos+1
		lda n
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	C@   ( addr -- 8b )
;
; "c-fetch" 
; 8b is the contents of the byte at addr.
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		ldy #0
		lda (tos),y
		sta tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!   ( 16b addr -- )
;
; "store" 
; 16b is stored at addr.
;
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		ldy #0
		lda stackl,x
		sta (tos),y
		iny
		lda stackh,x
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!   ( 16b addr -- )
;
; "c-store"
; The least-significant 8 bits of 16b are stored into the byte
; at addr.
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		ldy #0
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;	
; "colon"
;" A defining word executed in the form: 
;" : <name> ... ;                
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.   
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .  
;
		.word _storecsp
		.word current
		.word fetch
		.word context
		.word store
		.word _create
		.word _smudge
		.word _rbracket
		.word _psemi
;--------------------------------------------------------------
;
;       ENTER
;
;           IP    -> -[RP]
;           W     -> IP
;           NEXT
enter           pla             ;[4]
                tay             ;[2]
                pla             ;[4]
                sta n+1         ;[3]
                lda ip+1        ;[3]
                pha             ;[3]
                lda ip          ;[3]
                pha             ;[3]
                lda n+1         ;[3]
                sta ip+1        ;[3]
                iny             ;[2]
                beq l001        ;[2]
l002            sty ip          ;[3]
                jmp nexto       ;[3]
l001            inc ip+1
                bne l002

;--------------------------------------------------------------
;
;       ;   ( -- )
;
semilfa		.word $adde
		.byt (semi-*-1)|bit7|bit6
		.asc ";"|bit7
semi		.word _qcsp
		.word _compile
		.word exit
		.word _smudge
		.word _lbracket
		.word exit

;--------------------------------------------------------------
;
;	CONSTANT   ( -- n )
;
constantlfa	.word $adde
		.byt (_constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
_constant
#include enter.a65
		.word _create
		.word _comma
		.word _psemi
doconst		ldy #4
		lda (ip),y
		sta n
		dey
		lda (ip),y
		ldy n
		jmp push

;--------------------------------------------------------------
;
;	VARIABLE
;
variablelfa	.word $adde
		.byt (_variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
_variable
#include enter.a65
		.word _create
		.word two
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	USER
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user		.word enter
		.word _constant
		.word _psemi
uservar         pla
		tay
		pla
		sta n+1
		iny
		bne l008
		inc n+1
l008		sty n
		ldy #0
		clc
		lda up
		adc (n),y
		sta n
		lda up+1
		adc #0
		tay
		lda n
		jmp push

;--------------------------------------------------------------
;
;	-1   ( -- -1 )
;
minusonelfa	.word $adde
		.byt (minusone-*-1)|bit7
		.asc "-","1"|bit7
minusone	lda #$ff
		tay
		jmp push

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		lda #0
		tay
		jmp push

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		jmp doconst
		.word 1

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jmp doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jmp doconst
		.word 3

;--------------------------------------------------------------
;
;	BL
;
bllfa		.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jmp doconst
		.word $20

;--------------------------------------------------------------
;
;	C/L
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jmp doconst
		.word 64

;--------------------------------------------------------------
;
;	FIRST
;
;~ fix this to read actual top of memory
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jmp doconst
		.word $7000

;--------------------------------------------------------------
;
;	LIMIT
;
;~ fix this to read actual top of memory
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jmp doconst
		.word $8000

;--------------------------------------------------------------
;
;	#BUF
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jmp doconst
		.word 4

;--------------------------------------------------------------
;
;	#BCQ
;
;~ a BFORTH-ism
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jmp doconst
		.word 32

;--------------------------------------------------------------
;
;	B/BUF
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jmp doconst
		.word 1024

;--------------------------------------------------------------
;
;	B/SCR
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jmp doconst
		.word 4

;--------------------------------------------------------------
;
;	TIB
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jmp doconst
		.word $0100

;--------------------------------------------------------------
;
;	TRUE
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		jmp minusone

;--------------------------------------------------------------
;
;	FALSE
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		lda #0
		tay
		jmp push

;--------------------------------------------------------------
;
;	0=
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		ldy #$ff
		lda tos
		ora tos+1
		beq l031
		iny
l031		tya
		jmp put

;--------------------------------------------------------------
;
;	0<
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		ldy #0
		bit tos+1
		bpl l032
		dey
l032		tya
		jmp put

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		beq l033
		lda #$ff
l033		tay
			jmp put

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (_plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
_plusorigin	
#include enter.a65
		.word plit
		.word userarea
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (sp0-*-1)|bit7
		.asc "SP","0"|bit7
sp0		jsr uservar
		.byt usersp0-userarea

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rp0-*-1)|bit7
		.asc "RP","0"|bit7
rp0		jsr uservar
		.byt userrp0-userarea

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr uservar
		.byt userwidth-userarea

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr uservar
		.byt userwarning-userarea

; ^ warm
; |
;  >  user variables pre-initialized from the dictionary
; |
; v cold

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr uservar
		.byt userfence-userarea

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jsr uservar
		.byt userdp-userarea

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr uservar
		.byt uservoclink-userarea

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr uservar
		.byt userviewquery-userarea

;--------------------------------------------------------------
;
;	BLK
;
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr uservar
		.byt userblk-userarea

;
; user variables beyond this point are not pre-initialized from the dictionary
;

;--------------------------------------------------------------
;
;	>IN   ( -- addr )
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The  address of a user variable which contains the present
; character offset within  the  input stream.  See: WORD
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr uservar
		.byt 24

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr uservar
		.byt 26

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr uservar
		.byt 28

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr uservar
		.byt 30

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr uservar
		.byt 32

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr uservar
		.byt 34

;--------------------------------------------------------------
;
;	STATE
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr uservar
		.byt 36

;--------------------------------------------------------------
;
;	BASE
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr uservar
		.byt 38

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr uservar
		.byt 40

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; Returns  the  address of the user variable that
; contains the count of characters  received  and
; stored by the most recent execution of EXPECT .
; The  address    of the user variable containing
; the count of characters actually  received  and
; stored by the last execution of EXPECT .
span		jmp uservar
		.byt 42

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr uservar
		.byt 44

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr uservar
		.byt 46

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr uservar
		.byt 48

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jsr uservar
		.byt 50

;--------------------------------------------------------------
;
;	#TIB
;
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr uservar
		.byt 52

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr uservar
		.byt 54

;--------------------------------------------------------------
;
;	1+
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		inc tos
		bne l027
		inc tos+1
l027		jmp next

;--------------------------------------------------------------
;
;	1-
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	bit tos
		bne l028
		dec tos+1
l028		dec tos
		jmp next

;--------------------------------------------------------------
;
;	2+
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		clc
		lda tos
		adc #2
		sta tos
		bcc l029
		inc tos+1
l029		jmp next

;--------------------------------------------------------------
;
;	2-
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	sec
		lda tos
		sbc #2
		sta tos
		bcs l030
		dec tos+1
l030		jmp next

;--------------------------------------------------------------
;
;	2/
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	lsr tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		asl tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	HERE
;
herelfa		.word $adde
		.byt (_here-*-1)|bit7
		.asc "HER","E"|bit7
_here
#include enter.a65
		.word dp
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	ALLOT
;
allotlfa	.word $adde
		.byt (_allot-*-1)|bit7
		.asc "ALLO","T"|bit7
_allot
#include enter.a65
		.word dp
		.word plusstore
		.word exit

;--------------------------------------------------------------
;
;	,
;
commalfa	.word $adde
		.byt (_comma-*-1)|bit7
		.asc ","|bit7
_comma
#include enter.a65
		.word _here
		.word store
		.word two
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (_ccomma-*-1)|bit7
		.asc "C",","|bit7
_ccomma
#include enter.a65
		.word _here
		.word cstore
		.word one
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	-
;
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr donegate
		jmp plus

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		ldy #0
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	U<
;
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
sgntst		bvc l012
		eor #bit7
l012		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
; V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc ">"|bit7
gt		ldy #0
		lda tos
		cmp stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT   ( a b c -- b c a )
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		ldy stackh+1,x
		lda stackh,x
		sta stackh+1,x
		lda tos+1
		sta stackh,x
		sty tos+1
		ldy stackl+1,x
		lda stackl,x
		sta stackl+1,x
		lda tos
		sta stackl,x
		sty tos
		jmp next

;--------------------------------------------------------------
;
;	LROT   ( a b c -- c a b )
;
lrotlfa		.word $adde
		.byt (lrot-*-1)|bit7
		.asc "LRO","T"|bit7
lrot		ldy tos+1	; c
		lda stackh,x
		sta tos+1	; b -> tos
		lda stackh+1,x
		sta stackh,x	; a -> 2os
		sty stackh+1,x	; c -> 3os
		ldy tos
		lda stackl,x
		sta tos
		lda stackl+1,x
		sta stackl,x
		sty stackl+1,x
		jmp next

;--------------------------------------------------------------
;
;	SPACE
;
spacelfa	.word $adde
		.byt (_space-*-1)|bit7
		.asc "SPAC","E"|bit7
_space
#include enter.a65
		.word bl
		.word emit
		.word exit

;--------------------------------------------------------------
;
;	?DUP   ( 0 -- 0 | n -- n n )
;
; DUP if top of stack is nonzero
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		lda tos
		ora tos+1
		beq l034
		lda tos
		ldy tos+1
		jmp push
l034		jmp next

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; * dictionary
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"     SWAP
;"     BEGIN
;"         OVER +  127  OVER C@  <
;"     UNTIL
;"     SWAP DROP ;
traverselfa	.word $adde
		.byt (_traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
_traverse
#include enter.a65
		.word swap
l010		.word over
		.word plus
		.word clit
		.byt $7f
		.word over
		.word cfetch
		.word lt
		.word qbranch
		.word l010
		.word swap
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of  the  top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (_latest-*-1)|bit7
		.asc "LATES","T"|bit7
_latest
#include enter.a65
		.word current
		.word fetch
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	FORTH-83
;
; ~ make sure it's really Forth-83 compliant before making this word available
;
;forth83lfa	.word $adde
;		.byt (forth83-*-1)|bit7
;		.asc "FORTH-8","3"|bit7
;forth83		jmp next

; ~ better to follow ANS-Forth standard for this group?
;--------------------------------------------------------------
;
;	>BODY
;
tobodylfa	.word $adde
		.byt (_tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
_tobody
#include enter.a65
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt (_toname-*-1)|bit7
		.asc ">NAM","E"|bit7
_toname
#include enter.a65
		.word oneminus
		.word true
		.word _traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt (_tolink-*-1)|bit7
		.asc ">LIN","K"|bit7
_tolink
#include enter.a65
		.word _toname
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>   ( PFA -- CFA )
;
bodyfromlfa	.word $adde			; ~ Blazin
		.byt (_bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
_bodyfrom
#include enter.a65
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	NAME>
;
namefromlfa	.word $adde
		.byt (_namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
_namefrom
#include enter.a65
		.word one
		.word _traverse
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	LINK>
;
linkfromlfa	.word $adde
		.byt (_linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
_linkfrom
#include enter.a65
		.word twoplus
		.word _namefrom
		.word exit

;--------------------------------------------------------------
;
;	N>LINK
;
ntolinklfa	.word $adde
		.byt (_ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
_ntolink
#include enter.a65
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	L>NAME
;
linktonamelfa	.word $adde
		.byt (_linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
_linktoname
#include enter.a65
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (_storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
_storecsp
#include enter.a65
		.word spfetch
		.word csp
		.word store
		.word exit

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (_where-*-1)|bit7
		.asc "WHER","E"|bit7
_where
#include enter.a65
		.word blk
		.word fetch
		.word qbranch
		.word l58
		.word blk
		.word fetch
		.word dup
		.word scr
		.word store
		.word cr
		.word cr
		.word _pdotq
		.byt s001-*-1
		.asc "SCR# "
s001		.word dup
		.word _dot
		.word toin
		.word fetch
		.word bperbuf
		.word _min
		.word cperl
		.word _slashmod
		.word dup
		.word _pdotq
		.byt s002-*-1
		.asc "LINE# "
s002		.word _dot
		.word cperl
		.word _star
		.word rot
		.word _block
		.word plus
		.word cr
		.word cr
		.word cperl
		.word _dashtrailing
		.word type
		.word toin
		.word fetch
		.word bperbuf
		.word gt
		.word plus
		.word branch
		.word l59
l58		.word toin
		.word fetch
l59		.word cr
		.word _here
		.word cfetch
		.word dup
		.word tor
		.word minus
		.word oneminus
		.word _spaces
		.word rfrom
		.word dup
		.word zeq
		.word minus
		.word zero
		.word pdo
l60		.word clit
		.asc '^'
		.word emit
		.word ploop
		.word l60
		.word exit

;--------------------------------------------------------------
;
;	(ABORT")
;
; * outer interpreter headerless
;
;pabortqlfa	.word $adde
;		.byt (_pabortq-*-1)|bit7
;		.asc "(ABORT",'"',")"|bit7
_pabortq
#include enter.a65
		.word qbranch
		.word l61
		.word _cmdoff
		.word _where
		.word cr
		.word rfetch
		.word count
		.word type
		.word startup
		.word fetch
		.word execute
		.word branch
		.word l62
l61		.word rfrom
		.word dup
		.word cfetch
		.word plus
		.word oneplus
		.word tor
l62		.word exit

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (_commadollar-*-1)|bit7
		.asc ",","$"|bit7
_commadollar
#include enter.a65
		.word swap
		.word over
		.word _here
		.word _twodup
		.word cstore
		.word oneplus
		.word swap
		.word cmove
		.word oneplus
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	ABORT"
;
abortqlfa	.word $adde
		.byt (_abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
_abortq
#include enter.a65
		.word _compile
		.word _pabortq
		.word clit
		.asc '"'
		.word _qchar
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (_qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
_qcomp
#include enter.a65
		.word state
		.word fetch
		.word zeq
		.word _pabortq
		.byt s003-*-1
		.asc "COMPILATION ONLY, USE IN DEFINITION"
s003		.word exit

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (_qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
_qfind
#include enter.a65
		.word _pabortq
		.byt s004-*-1
		.asc "NOT IN CURRENT SEARCH ORDER"
s004		.word exit

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (_qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
_qpairs
#include enter.a65
		.word minus
		.word _pabortq
		.byt s005-*-1
		.asc "CONDITIONALS NOT PAIRED"
s005		.word exit

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (_qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
_qcsp
#include enter.a65
		.word spfetch
		.word csp
		.word fetch
		.word ne
		.word _pabortq
		.byt s006-*-1
		.asc "DEFINITION NOT FINISHED"
s006		.word exit

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (_qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
_qchar
#include enter.a65

;--------------------------------------------------------------
;
;	COMPILE
;
compilelfa	.word $adde
		.byt (_compile-*-1)|bit7
		.asc "COMPIL","E"|bit7
_compile
#include enter.a65
		.word _qcomp
		.word rfrom
		.word dup
		.word twoplus
		.word tor
		.word fetch
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	[
;
lbracketlfa	.word $adde
		.byt (_lbracket-*-1)|bit7
		.asc "["|bit7
_lbracket
#include enter.a65
		.word state
		.word off
		.word exit

;--------------------------------------------------------------
;
;	]
;
rbracketlfa	.word $adde
		.byt (_rbracket-*-1)|bit7
		.asc "]"|bit7
_rbracket
#include enter.a65
		.word state
		.word on
l68		.word _qstack
		.word _existsq
		.word dup
		.word qbranch
		.word l64
		.word zlt
		.word qbranch
		.word l65
		.word _comma
		.word branch
		.word l66
l65		.word execute
		.word branch
		.word l66
l64		.word drop
		.word _number
		.word dpl
		.word fetch
		.word oneplus
		.word qbranch
		.word l67
		.word _dliteral
		.word branch
		.word l66
l67		.word drop
		.word _literal
l66		.word true
		.word _quitq
		.word qbranch
		.word l68
		.word exit

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (_smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
_smudge
#include enter.a65
		.word _latest
		.word clit
		.byt bit5	; $20
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (_hex-*-1)|bit7
		.asc "HE","X"|bit7
_hex
#include enter.a65
		.word clit
		.byt 16
		.word base
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DECIMAL
;
decimallfa	.word $adde
		.byt (_decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
_decimal
#include enter.a65
		.word clit
		.byt 10
		.word base
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(;CODE)
;
psemilfa	.word $adde
		.byt (_psemi-*-1)|bit7
		.asc "(;CODE",")"|bit7
_psemi
#include enter.a65
		.word rfrom
		.word _latest
		.word _namefrom
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DOES>
;
doeslfa		.word $adde
		.byt (_does-*-1)|bit7
		.asc "DOES",">"|bit7
_does
#include enter.a65
		.word _qcsp
		.word _compile
		.word _psemi
		.word clit
		.byt $20	; jsr instruction
		.word _ccomma
		.word _compile
		.word dodoes
		.word exit
dodoes		lda ip+1	; we get here by JSR
		pha
		lda ip
		pha
		clc
		lda (w),y
		adc #3
		sta ip
		iny
		lda (w),y
		adc #0
		sta ip+1
		clc
		lda w
		adc #2
		pha
		lda w+1
		adc #0
		jmp push

;--------------------------------------------------------------
;
;	-TRAILING
;
dashtrailinglfa	.word $adde
		.byt (_dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
_dashtrailing
#include enter.a65
		.word dup
		.word zero
		.word pdo
l72		.word _twodup
		.word plus
		.word oneminus
		.word cfetch
		.word bl
		.word ne
		.word _pqleave
		.word l73
		.word oneminus
		.word ploop
		.word l72
l73		.word exit

;--------------------------------------------------------------
;
;	(.")
;
; * headerless
;
;pdotqlfa	.word $adde
;		.byt (_pdotq-*-1)|bit7
;		.asc "(.",'"',")"|bit7
_pdotq
#include enter.a65
		.word rfetch
		.word twoplus		; because we pre-increment?
		.word count
		.word dup
		.word oneplus
		.word rfrom
		.word plus
		.word tor
		.word type
		.word exit

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; Leaves  the address,  addr2 and the character
; count +n of text  beginning at addr1.
; addr2 is addr1+1 and n1 is the  length  of  the
; counted string at addr1.  The byte at addr1 con-
; tains  the  byte  count  +n.    Range  of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		ldy #0
		lda (tos),y
		inc tos
		bne l020
		inc tos+1
l020		jmp push

;--------------------------------------------------------------
;
;	TYPE   ( addr count -- )
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		clc
		lda tos
		adc outputted
		sta outputted
		lda tos+1
		adc outputted+1
		sta outputted+1
		lda #2
		jsr popnwords
		ldy #0
l041		cpy n
		bne l042
		dec n+1
		bpl l042
		jmp next
l042		lda (n+2),y
		jsr CHROUT
		iny
		bne l041
		inc n+3
		bne l041

;--------------------------------------------------------------
;
;	."
;
dotqlfa		.word $adde
		.byt (_dotq-*-1)|bit7
		.asc ".",'"'|bit7
_dotq
#include enter.a65
		.word _compile
		.word _pdotq
		.word clit
		.asc '"'
		.word _qchar
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	.(
;
dotplfa		.word $adde
		.byt (_dotp-*-1)|bit7
		.asc ".","("|bit7
_dotp
#include enter.a65
		.word clit
		.asc ')'
		.word _qchar
		.word type 
		.word exit

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; Stores up to +n characters into  memory  begin-
; ning at addr.
; Receive  characters and store each into memory.
; The transfer begins at addr proceeding  towards
; higher  addresses  one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.   No  more  than  +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or  transfered  if +n is zero.   All characters
; actually received and stored into  memory  will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp expectvector
expectvector	lda #2
		jsr popnwords
		stx n+4
		ldy #$ff
l74		iny
		cpy n
		bcs l75
		jsr CHRIN
		cmp #$0d
		beq l75
		sta (n+2),y
		bne l74
l75		sty inputted		; ~ probably should do a USER dereference
		lda #0
		sta inputted+1
		ldx n+4
		jmp next

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (_query-*-1)|bit7
		.asc "QUER","Y"|bit7
_query
#include enter.a65
		.word tib
		.word clit
		.byt 80
		.word expect
		.word span
		.word fetch
		.word numtib
		.word store
		.word blk
		.word off
		.word toin
		.word off
		.word exit

;--------------------------------------------------------------
;
;	" "
;
spacenplfa	.word $adde
		.byt (_spacenp-*-1)|bit7|bit6
		.asc " "|bit7
_spacenp
#include enter.a65
		.word doneq
		.word on
		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (_quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
_quitq
#include enter.a65
		.word state
		.word fetch
		.word ne
		.word doneq
		.word fetch
		.word orx
		.word doneq
		.word off
		.word exit

;--------------------------------------------------------------
;
;	ERASE
;
eraselfa	.word $adde
		.byt (_erase-*-1)|bit7
		.asc "ERAS","E"|bit7
_erase
#include enter.a65
		.word zero
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (_blank-*-1)|bit7
		.asc "BLAN","K"|bit7
_blank
#include enter.a65
		.word bl
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	HOLD
;
holdlfa		.word $adde
		.byt (_hold-*-1)|bit7
		.asc "HOL","D"|bit7
_hold
#include enter.a65
		.word true
		.word hld
		.word plusstore
		.word hld
		.word fetch
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	PAD
;
padlfa		.word $adde
		.byt (_pad-*-1)|bit7
		.asc "PA","D"|bit7
_pad
#include enter.a65
		.word _here
		.word clit
		.byt 80
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	'STREAM
;
tickstreamlfa	.word $adde
		.byt (_tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
_tickstream
#include enter.a65
		.word blk
		.word fetch
		.word qdup
		.word qbranch
		.word l76
		.word _block
		.word bperbuf
		.word branch
		.word l77
l76		.word tib
		.word numtib
		.word fetch
l77		.word toin
		.word fetch
		.word over
		.word _min
		.word tor
		.word swap
		.word rfetch
		.word plus
		.word swap
		.word rfrom
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	WORD
;
wordlfa		.word $adde
		.byt (_word-*-1)|bit7
		.asc "WOR","D"|bit7
_word
#include enter.a65
		.word tor
		.word _tickstream
		.word over
		.word swap
		.word rfetch
		.word skip
		.word over
		.word swap
		.word rfrom
		.word _scan
		.word drop
		.word over
		.word over
		.word swap
		.word minus
		.word tor
		.word rot
		.word minus
		.word oneplus
		.word toin
		.word plusstore
		.word rfrom
		.word _here
		.word over
		.word over
		.word cstore
		.word oneplus
		.word swap
		.word cmove
		.word _here
		.word dup
		.word count
		.word plus
		.word bl
		.word swap
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	>LOWER
;
; ~ a Blazin' thing that doesn't really fit in with case-sensitive PETTIL
tolowerlfa	.word $adde
		.byt (tolower-*-1)|bit7
		.asc ">LOWE","R"|bit7
tolower		lda #2
		jsr popnwords
l79		cpy n
		bne l78
		dec n+1
		bpl l78
		jmp next
l78		lda (n+2),y
		and #$7f
		sta (n+2),y
		iny
		bne l79
		inc n+3
		jmp l79

;--------------------------------------------------------------
;
;	(PUNCT?)
;
ppunctqlfa	.word $adde
		.byt (_ppunctq-*-1)|bit7
		.asc "(PUNCT?",")"|bit7
_ppunctq
#include enter.a65
		.word clit
		.byt '.'
		.word eq
		.word exit

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (_punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
_punctq
#include enter.a65
		.word _ppunctq
		.word exit


;--------------------------------------------------------------
;
;	CONVERT
;
convertlfa	.word $adde
		.byt (_convert-*-1)|bit7
		.asc "CONVER","T"|bit7
_convert
#include enter.a65
l81		.word oneplus
		.word dup
		.word tor
		.word cfetch
		.word base
		.word fetch
		.word _digit
		.word qbranch
		.word l80
		.word swap
		.word base
		.word fetch
		.word umstar
		.word drop
		.word rot
		.word base
		.word fetch
		.word umstar
		.word dplus
		.word dpl
		.word fetch
		.word oneplus
		.word qbranch
		.word l82
		.word one
		.word dpl
		.word plusstore
l82		.word rfrom
		.word branch
		.word l81
l80		.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	NUMBER
;
numberlfa	.word $adde
		.byt (_number-*-1)|bit7
		.asc "NUMBE","R"|bit7
_number
#include enter.a65
		.word true
		.word over
		.word count
		.word over
		.word plus
		.word swap
		.word _pqdo
		.word l83
l84		.word i
		.word cfetch
		.word base
		.word fetch
		.word _digit
		.word qbranch
		.word l87
		.word twodrop
		.word false
		.word _pleave
		.word l83
l87		.word ploop
		.word l84
l83		.word _qfind
		.word zero
		.word zero
		.word rot
		.word dup
		.word oneplus
		.word cfetch
		.word clit
		.byt '-'
		.word eq
		.word dup
		.word tor
		.word minus
		.word dpl
		.word on
l85		.word _convert
		.word dup
		.word cfetch
		.word _punctq
		.word qbranch
		.word l88
		.word dpl
		.word off
		.word branch
		.word l85
l88		.word cfetch
		.word bl
		.word ne
		.word _qfind
		.word rfrom
		.word qbranch
		.word l86
		.word dnegate
l86		.word exit

;--------------------------------------------------------------
;
;	FIND   ( addr1 -- addr2 n )
;
; addr1 is the address of a counted string.  The string
; contains a word name to be located in the currently active
; search order.  If the word is not found, addr2 is the string
; address addr1, and n is zero.  If the word is found, addr2
; is the compilation address and n is set to one of two non-
; zero values.  If the word found has the immediate attribute,
; n is set to one.  If the word is non-immediate, n is set to
; minus one (true).
;
findlfa		.word $adde
		.byt (_find-*-1)|bit7
		.asc "FIN","D"|bit7
_find
#include enter.a65
		.word context
		.word fetch
		.word fetch
		.word pfind
		.word dup
		.word zeq
		.word qbranch
		.word l89
		.word drop
		.word _latest
		.word pfind
l89		.word exit

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (_existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
_existsq
#include enter.a65
		.word bl
		.word _word
		.word dup
		.word count
		.word tolower		; ~ really?
		.word _find
		.word exit

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (_iddot-*-1)|bit7
		.asc "ID","."|bit7
_iddot
#include enter.a65
		.word _pad
		.word clit
		.byt 32
		.word clit
		.asc '*'
		.word fill
		.word dup
		.word _namefrom
		.word over
		.word minus
		.word _pad
		.word swap
		.word cmove
		.word _pad
		.word count
		.word clit
		.byt $1f
		.word andx
		.word _twodup
		.word tolower		; ~ really?
		.word type
		.word exit

;--------------------------------------------------------------
;
;	CREATE
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"  @ + + u< (abort") dictionary full exists?
;"  over (lit) 6017 = (abort") name required
;"  warning @ and ?branch 41 >name cr
;"  clit 18 emit id. clit 146 emit (.") already exists
;"  branch 4 drop here dup c@
;"  over 2+ view? @ + dup >r swap 1+ cmove>
;"  r> dup c@ width @ min 1+ 2dup + clit 255
;"  and clit 255 = ?branch 25 2dup swap
;"  dup 1+ rot cmove> clit 234 c, swap 1+
;"  swap 2+ view? @ + allot dup clit 128 toggle
;"  here 1- clit 128 toggle latest over
;"  2- ! view? @ ?branch 14 blk @ over 2-
;"  2- ! 2 allot current @ ! (;code)
;".C:1b0b   18         CLC
;".C:1b0c   A5 87      LDA $87
;".C:1b0e   69 02      ADC #$02
;".C:1b10   48         PHA
;".C:1b11   98         TYA
;".C:1b12   65 88      ADC $88
;".C:1b14   4C 4A 08   JMP $084A
createlfa	.word $adde
		.byt (_create-*-1)|bit7
		.asc "CREAT","E"|bit7
_create
#include enter.a65
		.word _frombcq
		.word _here
		.word width
		.word fetch
		.word twoplus
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word plus
		.word ult
		.word _pabortq
		.byt l013-*-1
		.asc "DICTIONARY FULL"
l013		.word _existsq
		.word over
		.word plit
		.word _spacenp
		.word eq
		.word _pabortq
		.byt l014-*-1
		.asc "NAME REQUIRED"
l014		.word warning
		.word fetch
		.word andx
		.word qbranch
		.word l016
		.word _toname
		.word cr
		.word clit
		.byt $12	; rvs
		.word emit
		.word _iddot
		.word clit
		.byt $92	; off
		.word emit
		.word _pdotq
		.byt l015-*-1
		.asc " ALREADY EXISTS "
l015		.word branch
		.word l017
l016		.word drop
l017		.word _here
		.word dup
		.word cfetch
		.word over
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word dup
		.word tor
		.word swap
		.word oneplus
		.word cmovegt
		.word rfrom
		.word dup
		.word cfetch
		.word width
		.word fetch
		.word _min
		.word oneplus
		.word _twodup
		.word plus
		.word clit
		.byt $ff
		.word andx
		.word clit
		.byt $ff
		.word eq
		.word qbranch
		.word l018
		.word _twodup
		.word swap
		.word dup
		.word oneplus
		.word rot
		.word cmovegt
		.word clit
		.byt $ea
		.word _ccomma
		.word swap
		.word oneplus
		.word swap
l018		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word _allot
		.word dup
		.word clit
		.byt $80
		.word toggle
		.word _here
		.word oneminus
		.word clit
		.byt $80
		.word toggle
		.word _latest
		.word over
		.word twominus
		.word store
		.word viewq
		.word fetch
		.word qbranch
		.word l019
		.word blk
		.word fetch
		.word over
		.word twominus
		.word twominus
		.word store
l019		.word two
		.word _allot
		.word current
		.word fetch
		.word store
		.word _psemi
docreate	pla
		tay
		pla
		sta n+1
		iny
		bne l035
		inc n+1
l035		sty n
		jmp pushn

;--------------------------------------------------------------
;
;	[COMPILE]
;
bcompilelfa	.word $adde
		.byt (_bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
_bcompile
#include enter.a65

;--------------------------------------------------------------
;
;	LITERAL
;
literallfa	.word $adde
		.byt (_literal-*-1)|bit7
		.asc "LITERA","L"|bit7
_literal
#include enter.a65

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (_dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
_dliteral
#include enter.a65

;--------------------------------------------------------------
;
;	?STACK
;
qstacklfa	.word $adde
		.byt (_qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
_qstack
#include enter.a65

;--------------------------------------------------------------
;
;	INTERPRET
;
interpretlfa	.word $adde
		.byt (_interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
_interpret
#include enter.a65

;--------------------------------------------------------------
;
;	IMMEDIATE
;
immediatelfa	.word $adde
		.byt (_immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
_immediate
#include enter.a65

;--------------------------------------------------------------
;
;	VOCABULARY
;
vocabularylfa	.word $adde
		.byt (_vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
_vocabulary
#include enter.a65
		.word _create
		.word current
		.word fetch
		.word twoplus
		.word _comma
		.word plit
		.word $a081		; ~ what is it?
		.word _comma
		.word _here
		.word voclink
		.word fetch
		.word _comma
		.word voclink
		.word store
		.word _psemi
vocabdoes	jmp dodoes
		.word context
		.word store
		.word exit

;--------------------------------------------------------------
;
;	FORTH
;
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jmp vocabdoes
		.word ntop		; last nfa in this vocabulary
		.word $a081		; some magic number?
lastvoc		.word 0			; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;	DEFINITIONS
;
definitionslfa	.word $adde
		.byt (_definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
_definitions
#include enter.a65
		.word context
		.word fetch
		.word current
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(
;
lparenlfa	.word $adde
		.byt (_lparen-*-1)|bit7
		.asc "("|bit7
_lparen
#include enter.a65
		.word clit
		.asc ')'
		.word _qchar
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (_run-*-1)|bit7
		.asc "RU","N"|bit7
_run
#include enter.a65

;--------------------------------------------------------------
;
;	ABORT
;
abortlfa	.word $adde
		.byt (_abort-*-1)|bit7
		.asc "ABOR","T"|bit7
_abort
#include enter.a65
		.word spstore
		.word _quit
		.word exit	; make the decompiler happy

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jmp docreate
		.word _abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		sei
;~debug - leave patterns to make things easier in the debugger
	ldy #<next
	lda #$3e
d000	sta $FFFF,y
	dey
	bne d000

	ldy #bos-1
d001	lda #$bb
	sta stackl,y
	lda #$aa
	sta stackh,y
	dey
	bpl d001

	lda #$cc
	ldy #$07
d002	sta n,y
	dey
	bpl d002

	lda #$dd
	ldy #$03
d003	sta zi,y
	dey
	bpl d003

	lda #$ba
	sta tos+1
	lda #$ab
	sta tos
;~debug


		lda #<warmvector
		sta errlnk
		lda #>warmvector
		sta errlnk+1

		lda userntop
		sta forth+3
		lda userntop+1
		sta forth+4
;
		ldy #zzpnext-azpnext+1
l011		lda azpnext-1,y
		sta next-1,y
		dey
		bne l011

		lda #>_cold2
		sta w1+1
		lda #<_cold2
		sta w1

		ldy #usercold-userarea-1
		bne l036

warm		lda #>_warm2
		sta w1+1
		lda #<_warm2
		sta w1

		ldy #userwarm-userarea-1

l036		lda userup
		sta up
		lda userup+1
		sta up+1
l037		lda userarea,y
		sta (up),y
		dey
		bpl l037
		cld
		cli
		jsr CLRCHN
		jsr CLALL

		lda #>(w1-2)
		sta ip+1
		lda #<(w1-2)
		sta ip

		jmp rpstore		; and we're off

_cold2
#include enter.a65
		.word spstore
		.word _pdotq
		.byt s015-*-1
		.byt CLRSCR
.byt 236,239,17,157,157,234,32,41,17,157,157,157,234,247,17,157,157,252
.byt 32,32,145,145,145
.byt 236,239,251,17,157,157,157,234,17,157,234,247,17,157,157
.byt 252,247,254,145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 239,239,17,157,157,234,17,157,234,17,157
.byt 247,247,145,145,145
.byt 236,17,157,234,17,157,234,17,157,252,247,247,254
.byt 145,145,145
		.asc "6502 FORTH FOR THE"
.byt 17,17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "COMMODORE PET 2001"
.byt 17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "......... ... ...."

		.byt $0d,$0d
		.asc "HTTP:"
		.byt 47,47
		.asc "CHITSELB.COM 2010"
		.byt $0d,$0d
s015		.word _rethread
		.word _bar
		.word _unthread

_warm2		.word _emptybuffers
		.word _decimal
		.word forth
		.word _definitions
		.word _pdotq
		.byt s016-*-1
		.asc "WELCOME TO PETTIL!"
s016		.word startup
		.word fetch
		.word execute
		.word exit

;--------------------------------------------------------------
;
;	QUIT
;
; * outer interpreter infinite loop
;
quitlfa		.word $adde
		.byt (_quit-*-1)|bit7
		.asc "QUI","T"|bit7
_quit
#include enter.a65
		.word blk
		.word off
		.word _lbracket
l007		.word rpstore
		.word cr
		.word _query
		.word _interpret
		.word state
		.word fetch
		.word zeq
		.word qbranch
		.word l006
		.word _pdotq
		.byt (l006-*-1)
		.asc "OK"
l006		.word branch
		.word l007

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (_stod-*-1)|bit7
		.asc "S>","D"|bit7
_stod
#include enter.a65

;--------------------------------------------------------------
;
;	ABS
;
abslfa		.word $adde
		.byt (_abs-*-1)|bit7
		.asc "AB","S"|bit7
_abs
#include enter.a65

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (_dabs-*-1)|bit7
		.asc "DAB","S"|bit7
_dabs
#include enter.a65

;--------------------------------------------------------------
;
;	MIN
;
minlfa		.word $adde
		.byt (_min-*-1)|bit7
		.asc "MI","N"|bit7
_min
#include enter.a65

;--------------------------------------------------------------
;
;	MAX
;
maxlfa	.word $adde
		.byt (_max-*-1)|bit7
		.asc "MA","X"|bit7
_max
#include enter.a65

;--------------------------------------------------------------
;
;	M*
;
mstarlfa	.word $adde
		.byt (_mstar-*-1)|bit7
		.asc "M","*"|bit7
_mstar
#include enter.a65

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (_mslash-*-1)|bit7
		.asc "M","/"|bit7
_mslash
#include enter.a65

;--------------------------------------------------------------
;
;	*
;
starlfa		.word $adde
		.byt (_star-*-1)|bit7
		.asc "*"|bit7
_star
#include enter.a65

;--------------------------------------------------------------
;
;	/MOD
;
slashmodlfa	.word $adde
		.byt (_slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
_slashmod	jsr enter

;--------------------------------------------------------------
;
;	/
;
slashlfa	.word $adde
		.byt (_slash-*-1)|bit7
		.asc "/"|bit7
_slash
#include enter.a65

;--------------------------------------------------------------
;
;	MOD
;
modlfa		.word $adde
		.byt (_mod-*-1)|bit7
		.asc "MO","D"|bit7
_mod
#include enter.a65

;--------------------------------------------------------------
;
;	*/MOD
;
starslashmodlfa	.word $adde
		.byt (_starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
_starslashmod	jsr enter

;--------------------------------------------------------------
;
;	*/
;
starslashlfa	.word $adde
		.byt (_starslash-*-1)|bit7
		.asc "*","/"|bit7
_starslash	jsr enter

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (_mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
_mslashmod	jsr enter

;--------------------------------------------------------------
;
;	<BCQ
;
frombcqlfa	.word $adde
		.byt (_frombcq-*-1)|bit7
		.asc "<BC","Q"|bit7
_frombcq	jsr enter

;--------------------------------------------------------------
;
;	BCQ>
;
bcqfromlfa	.word $adde
		.byt (_bcqfrom-*-1)|bit7
		.asc "BCQ",">"|bit7
_bcqfrom	jsr enter

;--------------------------------------------------------------
;
;	>BCQ
;
tobcqlfa	.word $adde
		.byt (_tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
_tobcq
#include enter.a65

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (_latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
_latestq	jsr enter

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (_absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
_absentq	jsr enter

;--------------------------------------------------------------
;
;	UPDATE
;
updatelfa	.word $adde
		.byt (_update-*-1)|bit7
		.asc "UPDAT","E"|bit7
_update
#include enter.a65

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (_drzero-*-1)|bit7
		.asc "DR","0"|bit7
_drzero
#include enter.a65

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (_drone-*-1)|bit7
		.asc "DR","1"|bit7
_drone
#include enter.a65

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (_discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
_discard	jsr enter

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (_missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
_missing	jsr enter

;--------------------------------------------------------------
;
;	BUFFER
;
bufferlfa	.word $adde
		.byt (_buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
_buffer
#include enter.a65

;--------------------------------------------------------------
;
;	BLOCK
;
blocklfa	.word $adde
		.byt (_block-*-1)|bit7
		.asc "BLOC","K"|bit7
_block
#include enter.a65

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS
;
emptybufferslfa	.word $adde
		.byt (_emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
_emptybuffers	jsr enter

;--------------------------------------------------------------
;
;	SAVE-BUFFERS
;
savebufferslfa	.word $adde
		.byt (_savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
_savebuffers	jsr enter

;--------------------------------------------------------------
;
;	FLUSH
;
flushlfa	.word $adde
		.byt (_flush-*-1)|bit7
		.asc "FLUS","H"|bit7
_flush
#include enter.a65

;--------------------------------------------------------------
;
;	LOAD
;
loadlfa		.word $adde
		.byt (_load-*-1)|bit7
		.asc "LOA","D"|bit7
_load
#include enter.a65

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (_todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
_todisc
#include enter.a65

;--------------------------------------------------------------
;
;	(R/W)
;
prslashwlfa	.word $adde
		.byt (_prslashw-*-1)|bit7
		.asc "(R/W",")"|bit7
_prslashw	jsr enter

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (_rslashw-*-1)|bit7
		.asc "R/","W"|bit7
_rslashw	jsr enter

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
tnslfa		.word $adde
		.byt (_tns-*-1)|bit7
		.asc "T&","S"|bit7
_tns
#include enter.a65

;--------------------------------------------------------------
;
;	(OPEN)
;
popenlfa	.word $adde
		.byt (_popen-*-1)|bit7
		.asc "(OPEN",")"|bit7
_popen
#include enter.a65

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (_close-*-1)|bit7
		.asc "CLOS","E"|bit7
_close
#include enter.a65

;--------------------------------------------------------------
;
;	(CMDIN)
;
pcmdinlfa	.word $adde
		.byt (_pcmdin-*-1)|bit7
		.asc "(CMDIN",")"|bit7
_pcmdin
#include enter.a65

;--------------------------------------------------------------
;
;	(CMDOUT)
;
pcmdoutlfa	.word $adde
		.byt (_pcmdout-*-1)|bit7
		.asc "(CMDOUT",")"|bit7
_pcmdout	jsr enter

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (_cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
_cmdoff
#include enter.a65

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (_status-*-1)|bit7
		.asc "STATU","S"|bit7
_status
#include enter.a65

;--------------------------------------------------------------
;
;	(?DISC)
;
pqdisclfa	.word $adde
		.byt (_pqdisc-*-1)|bit7
		.asc "(?DISC",")"|bit7
_pqdisc
#include enter.a65

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (_ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
_ioerr
#include enter.a65
		.word qdup
		.word qbranch
		.word s028
		.word dup
		.word one
		.word eq
		.word _pabortq
		.byt s020-*-1
		.asc "TOO MANY OPEN FILES"
s020		.word dup
		.word two
		.word eq
		.word _pabortq
		.byt s021-*-1
		.asc "FILE ALREADY OPEN"
s021		.word dup
		.word three
		.word eq
		.word _pabortq
		.byt s022-*-1
		.asc "FILE NOT OPEN"
s022		.word dup
		.word clit
		.byt 4
		.word eq
		.word _pabortq
		.byt s023-*-1
		.asc "FILE NOT FOUND"
s023		.word dup
		.word clit
		.byt 5
		.word eq
		.word _pabortq
		.byt s024-*-1
		.asc "DEVICE NOT PRESENT"
s024		.word dup
		.word clit
		.byt 6
		.word eq
		.word _pabortq
		.byt s025-*-1
		.asc "NOT INPUT FILE"
s025		.word dup
		.word clit
		.byt 7
		.word eq
		.word _pabortq
		.byt s026-*-1
		.asc "NOT OUTPUT FILE"
s026		.word dup
		.word clit
		.byt 8
		.word eq
		.word _pabortq
		.byt s027-*-1
		.asc "MISSING FILE NAME"
s027		.word dup
		.word clit
		.byt 9
		.word eq
		.word _pabortq
		.byt s028-*-1
		.asc "ILLEGAL DEVICE NUMBER"
s028		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (_dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
_dotderr	jsr enter

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (_mount-*-1)|bit7
		.asc "MOUN","T"|bit7
_mount
#include enter.a65

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (_qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
_qdisc
#include enter.a65

;--------------------------------------------------------------
;
;	'
;
ticklfa		.word $adde
		.byt (_tick-*-1)|bit7
		.asc "'"|bit7
_tick
#include enter.a65

;--------------------------------------------------------------
;
;	[']
;
brticklfa	.word $adde
		.byt (_brtick-*-1)|bit7
		.asc "['","]"|bit7
_brtick
#include enter.a65

;--------------------------------------------------------------
;
;	?>MARK
;
qtomarklfa	.word $adde
		.byt (_qtomark-*-1)|bit7
		.asc "?>MAR","K"|bit7
_qtomark	jsr enter

;--------------------------------------------------------------
;
;	?<MARK
;
qfrommarklfa	.word $adde
		.byt (_qfrommark-*-1)|bit7
		.asc "?<MAR","K"|bit7
_qfrommark	jsr enter

;--------------------------------------------------------------
;
;	?>RESOLVE
;
qtoresolvelfa	.word $adde
		.byt (_qtoresolve-*-1)|bit7
		.asc "?>RESOLV","E"|bit7
_qtoresolve	jsr enter

;--------------------------------------------------------------
;
;	?<RESOLVE
;
qfromresolvelfa	.word $adde
		.byt (_qfromresolve-*-1)|bit7
		.asc "?<RESOLV","E"|bit7
_qfromresolve	jsr enter

;--------------------------------------------------------------
;
;	ADD>MARK
;
addtomarklfa	.word $adde
		.byt (_addtomark-*-1)|bit7
		.asc "ADD>MAR","K"|bit7
_addtomark	jsr enter

;--------------------------------------------------------------
;
;	BEGIN
;
beginlfa	.word $adde
		.byt (_begin-*-1)|bit7
		.asc "BEGI","N"|bit7
_begin
#include enter.a65

;--------------------------------------------------------------
;
;	THEN
;
thenlfa		.word $adde
		.byt (_then-*-1)|bit7
		.asc "THE","N"|bit7
_then
#include enter.a65

;--------------------------------------------------------------
;
;	DO
;
dolfa		.word $adde
		.byt (_do-*-1)|bit7
		.asc "D","O"|bit7
_do
#include enter.a65

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (_qdo-*-1)|bit7
		.asc "?D","O"|bit7
_qdo
#include enter.a65

;--------------------------------------------------------------
;
;	LOOP
;
looplfa		.word $adde
		.byt (_loop-*-1)|bit7
		.asc "LOO","P"|bit7
_loop
#include enter.a65

;--------------------------------------------------------------
;
;	+LOOP
;
pluslooplfa	.word $adde
		.byt (_plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
_plusloop	jsr enter

;--------------------------------------------------------------
;
;	LEAVE
;
leavelfa	.word $adde
		.byt (_leave-*-1)|bit7
		.asc "LEAV","E"|bit7
_leave
#include enter.a65

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (_qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
_qleave
#include enter.a65

;--------------------------------------------------------------
;
;	UNTIL
;
untillfa	.word $adde
		.byt (_until-*-1)|bit7
		.asc "UNTI","L"|bit7
_until
#include enter.a65

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (_again-*-1)|bit7
		.asc "AGAI","N"|bit7
_again
#include enter.a65

;--------------------------------------------------------------
;
;	REPEAT
;
repeatlfa	.word $adde
		.byt (_repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
_repeat
#include enter.a65

;--------------------------------------------------------------
;
;	IF
;
iflfa		.word $adde
		.byt (_if-*-1)|bit7
		.asc "I","F"|bit7
_if
#include enter.a65

;--------------------------------------------------------------
;
;	ELSE
;
elselfa		.word $adde
		.byt (_else-*-1)|bit7
		.asc "ELS","E"|bit7
_else
#include enter.a65

;--------------------------------------------------------------
;
;	WHILE
;
whilelfa	.word $adde
		.byt (_while-*-1)|bit7
		.asc "WHIL","E"|bit7
_while
#include enter.a65

;--------------------------------------------------------------
;
;	SPACES
;
spaceslfa	.word $adde
		.byt (_spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
_spaces
#include enter.a65

;--------------------------------------------------------------
;
;	<#
;
ltsharplfa	.word $adde
		.byt (_ltsharp-*-1)|bit7
		.asc "<","#"|bit7
_ltsharp	jsr enter

;--------------------------------------------------------------
;
;	#>
;
sharpgtlfa	.word $adde
		.byt (_sharpgt-*-1)|bit7
		.asc "#",">"|bit7
_sharpgt	jsr enter

;--------------------------------------------------------------
;
;	SIGN
;
signlfa		.word $adde
		.byt (_sign-*-1)|bit7
		.asc "SIG","N"|bit7
_sign
#include enter.a65

;--------------------------------------------------------------
;
;	#
;
sharplfa	.word $adde
		.byt (_sharp-*-1)|bit7
		.asc "#"|bit7
_sharp
#include enter.a65

;--------------------------------------------------------------
;
;	#S
;
sharpslfa	.word $adde
		.byt (_sharps-*-1)|bit7
		.asc "#","S"|bit7
_sharps
#include enter.a65

;--------------------------------------------------------------
;
;	(U.)
;
pudotlfa	.word $adde
		.byt (_pudot-*-1)|bit7
		.asc "(U.",")"|bit7
_pudot
#include enter.a65

;--------------------------------------------------------------
;
;	U.
;
udotlfa		.word $adde
		.byt (_udot-*-1)|bit7
		.asc "U","."|bit7
_udot
#include enter.a65

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (_udotr-*-1)|bit7
		.asc "U.","R"|bit7
_udotr
#include enter.a65

;--------------------------------------------------------------
;
;	(.)
;
pdotlfa		.word $adde
		.byt (_pdot-*-1)|bit7
		.asc "(.",")"|bit7
_pdot
#include enter.a65

;--------------------------------------------------------------
;
;	.
;
dotlfa		.word $adde
		.byt (_dot-*-1)|bit7
		.asc "."|bit7
_dot
#include enter.a65

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (_dotr-*-1)|bit7
		.asc ".","R"|bit7
_dotr
#include enter.a65

;--------------------------------------------------------------
;
;	(UD.)
;
puddotlfa	.word $adde
		.byt (_puddot-*-1)|bit7
		.asc "(UD.",")"|bit7
_puddot
#include enter.a65

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (_uddot-*-1)|bit7
		.asc "UD","."|bit7
_uddot
#include enter.a65

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (_uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
_uddotr
#include enter.a65

;--------------------------------------------------------------
;
;	(D.)
;
pdddotlfa	.word $adde
		.byt (_pddot-*-1)|bit7
		.asc "(D.",")"|bit7
_pddot
#include enter.a65

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (_ddot-*-1)|bit7
		.asc "D","."|bit7
_ddot
#include enter.a65

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (_ddotr-*-1)|bit7
		.asc "D.","R"|bit7
_ddotr
#include enter.a65

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (_question-*-1)|bit7
		.asc "?"|bit7
_question	jsr enter

;--------------------------------------------------------------
;
;	PICK
;
picklfa		.word $adde
		.byt (_pick-*-1)|bit7
		.asc "PIC","K"|bit7
_pick
#include enter.a65

;--------------------------------------------------------------
;
;	ROLL
;
rolllfa		.word $adde
		.byt (_roll-*-1)|bit7
		.asc "ROL","L"|bit7
_roll
#include enter.a65

;--------------------------------------------------------------
;
;	DEPTH
;
depthlfa	.word $adde
		.byt (_depth-*-1)|bit7
		.asc "DEPT","H"|bit7
_depth
#include enter.a65

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp poptwo

;--------------------------------------------------------------
;
;	2DUP   ( n1 n2 -- n1 n2 n1 n2 )
;
twoduplfa	.word $adde
		.byt (_twodup-*-1)|bit7
		.asc "2DU","P"|bit7
_twodup
#include enter.a65
		.word over
		.word over
		.word exit

;--------------------------------------------------------------
;
;	2OVER   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
;
twooverlfa	.word $adde
		.byt (_twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
_twoover	jsr enter

;--------------------------------------------------------------
;
;	2ROT
;
tworotlfa	.word $adde
		.byt (_tworot-*-1)|bit7
		.asc "2RO","T"|bit7
_tworot
#include enter.a65

;--------------------------------------------------------------
;
;	2SWAP
;
twoswaplfa	.word $adde
		.byt (_twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
_twoswap	jsr enter

;--------------------------------------------------------------
;
;	2!
;
twostorelfa	.word $adde
		.byt (_twostore-*-1)|bit7
		.asc "2","!"|bit7
_twostore	jsr enter

;--------------------------------------------------------------
;
;	2@
;
twofetchlfa	.word $adde
		.byt (_twofetch-*-1)|bit7
		.asc "2","@"|bit7
_twofetch	jsr enter

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (_twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
_twoconst	jsr enter

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (_twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
_twovariable	jsr enter

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (_dminus-*-1)|bit7
		.asc "D","-"|bit7
_dminus
#include enter.a65

;--------------------------------------------------------------
;
;	D0=
;
dzeqlfa		.word $adde
		.byt (_dzeq-*-1)|bit7
		.asc "D0","="|bit7
_dzeq
#include enter.a65

;--------------------------------------------------------------
;
;	D=
;
deqlfa		.word $adde
		.byt (_deq-*-1)|bit7
		.asc "D","="|bit7
_deq
#include enter.a65

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (_dult-*-1)|bit7
		.asc "DU","<"|bit7
_dult
#include enter.a65

;--------------------------------------------------------------
;
;	D2/
;
dtwoslashlfa	.word $adde
		.byt (_dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
_dtwoslash	jsr enter

;--------------------------------------------------------------
;
;	D2*
;
dtwostarlfa	.word $adde
		.byt (_dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
_dtwostar	jsr enter

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (_dgt-*-1)|bit7
		.asc "D",">"|bit7
_dgt
#include enter.a65

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (_dmin-*-1)|bit7
		.asc "DMI","N"|bit7
_dmin
#include enter.a65

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (_dmax-*-1)|bit7
		.asc "DMA","X"|bit7
_dmax
#include enter.a65

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (_configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
_configure	jsr enter

;--------------------------------------------------------------
;
;	FREEZE
;
freezelfa	.word $adde
		.byt (_freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
_freeze
#include enter.a65

;--------------------------------------------------------------
;
;	(BSAVE)
;
pbsavelfa	.word $adde
		.byt (_pbsave-*-1)|bit7
		.asc "(BSAVE",")"|bit7
_pbsave
#include enter.a65

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (_saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
_saveforth	jsr enter

;--------------------------------------------------------------
;
;	DHASH	( nfa -- hash )
;
; input is NFA or counted string. Output is one of 16 values in
; the range $00 to $0f.  Used to break the dictionary into smaller
; pieces for (FIND)
;
; The hash is calculated by XORing all the nybbles of the string
; together.
dhashlfa	.word $adde
		.byt (dhash-*-1)|bit7
		.asc "DHAS","H"|bit7
dhash		ldy #0
		lda (tos),y
		and #$1f		; turn off flag bits, just keep the length
		tay
l009		eor (tos),y		; xor the string together
		and #$7f		; gets rid of bit7 of the last byte
		dey
		bne l009
l049		sty tos+1		; 0 -> msb
		sta tos
		lsr
		lsr
		lsr
		lsr
		eor tos			; squish both nybbles together
		and #$0f		; mask off the high nybble
		sta tos			; hash value in the range 0..f
;~debug
;	stx n
;	sed	
;	cmp	#10
;	adc	#'0'
;	cld
;	jsr CHROUT
;	ldx n
;~debug
		jmp next

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieves the LFA of the latest word in this hash thread
;
dhashfetchlfa	.word $adde
		.byt (dhashfetch-*-1)|bit7
		.asc "DHASH","@"|bit7
dhashfetch	ldy tos
		lda latestl,y
		sta tos
		lda latesth,y
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hashkey -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
dhashstorelfa	.word $adde
		.byt (dhashstore-*-1)|bit7
		.asc "DHASH","!"|bit7
dhashstore	lda #2
		jsr popnwords		; N0 = hashkey, N1 = LFAnew
		ldy n			; get link from hashkey table -> N2
		lda latestl,y
		sta n+4
		lda latesth,y
		sta n+5			; LFAlatest -> N2
		bne l045
		lda #<executelfa
		sta n+4
		lda #>executelfa
		sta n+5
l045		lda n+2
		sta latestl,y
		lda n+3
		sta latesth,y		; LFAnew -> hashtable(key)
		ldy #0
		lda n+4
		sta (n+2),y
		iny
		lda n+5
		sta (n+2),y		; LFAlatest -> [LFAnew]
		jmp next

;--------------------------------------------------------------
;
;	DEADLFA?   ( addr -- flag )
;
; true if addr points to { $DEAD len "wordnam","e"|bit7 }
deadlfaqlfa	.word $adde
		.byt (_deadlfaq-*-1)|bit7
		.asc "DEADLFA","?"|bit7
_deadlfaq	jsr enter	; ( addr )
		.word dup	; ( addr addr )
		.word fetch	; ( addr word )
		.word plit
		.word $adde	; ( addr word $dead )
		.word eq	; ( addr f1 )
		.word qbranch	; ( addr )
		.word l047
		.word twoplus	; ( a+2 )
		.word dup	; ( a+2 a+2 )
		.word cfetch	; ( a+2 len80 )
		.word dup	; ( a+2 len80 len80 )
		.word clit
		.byt $80	; ( a+2 len80 len80 $80 )
		.word gt	; ( a+2 len80 f2 )
		.word lrot	; ( f2 a+2 len80 )
		.word clit
		.byt $3f	; ( f2 a+2 len80 $3f )
		.word andx	; ( f2 a+2 len )
		.word plus	; ( f2 a+2+len )
		.word cfetch	; ( f2 last80 )
		.word clit
		.byt $80	; ( f2 last80 $80 )
		.word gt	; ( f2 f3 )
		.word andx	; ( flag )
		.word branch
		.word l048
l047		.word drop	; ( )
		.word false	; ( 0 )
l048		.word exit

;--------------------------------------------------------------
;
;	UNTHREAD   ( -- )
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;	16 0 do				( )
;		i dhash@		( lfa1 )
;		begin
;			dup		( lfa1 lfa1 )
;			@		( lfa1 lfa2 )
;			?dup		( lfa1 lfa2 true | lfa1 false )
;		while			( lfa1 lfa2 )
;			$dead		( lfa1 lfa2 $dead )
;			rot		( lfa2 $dead lfa1 )
;			!		( lfa2 )
;		repeat
;					( lfa )
;		drop			( )
;	loop
;  ;
unthreadlfa	.word $adde
		.byt (_unthread-*-1)|bit7
		.asc "UNTHREA","D"|bit7
_unthread	jsr enter
		.word clit
		.byt 16
		.word zero
		.word pdo
l051		.word i
		.word dhashfetch
l052		.word dup
		.word fetch
		.word qdup
		.word qbranch
		.word l053
		.word plit
		.word $adde
		.word rot
		.word store
		.word branch
		.word l052
l053		.word drop
		.word zero
		.word i
		.word dhashstore
		.word ploop
		.word l051
		.word exit

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity for the programmer.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.  
; It also marks the last word in the core dictionary.
; links all LFAs
rethreadlfa	.word $adde
		.byt (_rethread-*-1)|bit7
		.asc "RETHREA","D"|bit7
xpetp
_rethread	jsr enter
		.word _pdotq
		.byt (s007-*-1)
		.asc "HASHING DICTIONARY "
s007		.word _here
		.word zero
		.word _plusorigin
		.word pdo
l044		.word i
		.word _deadlfaq
		.word qbranch
		.word l024
		.word i
		.word dup
		.word twoplus
		.word dhash
		.word dhashstore
l024		.word ploop
		.word l044
		.word exit

;--------------------------------------------------------------
;
;	MON   ( -- )
;
; perform a BRK instruction to get to the TIM machine language monitor
monlfa		.word $adde
		.byt (mon-*-1)|bit7
		.asc "MO","N"|bit7
mon		brk
		jmp next

;--------------------------------------------------------------
;
;	FORGET
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
forgetlfa	.word $adde
ntop		.byt (_forget-*-1)|bit7
		.asc "FORGE","T"|bit7
_forget
#include enter.a65

forgetfence

;==============================================================

;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde
		.byt (_thru-*-1)|bit7
		.asc "THR","U"|bit7
_thru
#include enter.a65

foolfa		.word $adde
		.byt (_foo-*-1)|bit7
		.asc "FO","O"|bit7
_foo
#include enter.a65
		.word exit

barlfa		.word $adde
		.byt (_bar-*-1)|bit7
		.asc "BA","R"|bit7
_bar
#include enter.a65
		.word exit

endofile

; words that use psemi
;"	:		jsr	enter
;	constant	jmp	doconst
;	user		jsr	uservar
;	does>			dodoes
;	create			docreate
;	vocabulary		vocabdoes


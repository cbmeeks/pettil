; pettil.a65
;
; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
;" http://pettil.tumblr.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

; e.g. only a 48-cell stack so the bytes line up visually
#define DEBUG
#define PET_ROM4                ; target machine
#define HEADERS                 ; put headers in code?
;
;26c7 no headers
;2f8f headers
;
#include cbm.def
#include pettil.def

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================
#define basic $0400
    .word basic+1                   ; this will be the load address
* = basic+1
    .word basend
    .word 10
    .byt $9e                        ; SYS token
    .asc "1037",0
basend
    .word 0
    jmp ice

; xor of two vectors, to switch between Sweet16 and TIM
brktoggle       .word TIMBRK^SW16

;--------------------------------------------------------------
; W register, used by EXECUTE
w1
    .word $dead             ; (for when you just need a W register)
    .word exit              ; 'fragment secondary' used by EXECUTE


;--------------------------------------------------------------
; using ROM tape I/O drops to BASIC if there's a problem.
; we'd like the user to be able to type RUN and pick up
; more or less at the dropping off point if this happens.
; this subroutine performs that BASIC/PETTIL zp switch
; between $00-$8C inclusive.
swapzp
    stx storex      ; preserve Forth data stack pointer
    ldx #TIME       ; everything below the jiffy clock
swapzp01
    lda $ff,x
    ldy zpbuf-1,x
    sty $ff,x
    sta zpbuf-1,x
    dex
    bne swapzp01
    ldx storex      ; restore Forth data stack pointer
    rts

;--------------------------------------------------------------
zpbuf
;$00
    .word $0000,$1001,$2002,$3003
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack

;--------------------------------------------------------------
;
;       NEXT
;
; * inner interpreter headerless
;
;               +IP
;               [IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ; 
    nop                     ; see "RANDU" for how it works
    nop                     ; 
;$86    
zpnext
    inc ip                  ; 5
    inc ip                  ; 5
;ip = *+1
    jmp ($cafe)             ; 5

                            ;15 cycles total
;$8D TIME


;--------------------------------------------------------------
; Pops cells from the split stack to N area, working backwards.
; Used for setting up primitives that consume multiple arguments
;
; input
; Y = how many words to pop
;
; returns
; Y = 0
; C = clear
; TOS unchanged
;
; Y     1         2         3         4
; 2OS-->N0
; 2OS-->N1; 3OS-->N0
; 2OS-->N2; 3OS-->N1; 4OS-->N0
; 2OS-->N3; 3OS-->N2; 4OS-->N1; 5OS-->N0
;
; inverts the order in the N area from what was on the stack
;
locals
    tya
    asl     ; doubled, now Y is a countdown index, also clc
    tay
locals01
    lda stackh,x
    dey
    sta n,y
    lda stackl,x
    inx
    dey
    sta n,y
    bne locals01
    rts

;--------------------------------------------------------------
pearson
    .byt 150,191,252,0,194,202,129,7
pearsonx

;--------------------------------------------------------------
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;--------------------------------------------------------------
;
; Tables used by Pearson hash function and Bloom filter for root
; vocabulary.  The Pearson hash is used by hash1 to evenly distribute
; words among the multiple threads of the dictionary. The Bloom
; filter lets us skip looking for things that we know aren't in
; the dictionary (e.g. numbers).  For now, keep bloom and lfalist
; consecutive in memory, with bloom first so RETHREAD won't break
bloom
    .dsb 8,$b1      ; 64-bit, used by hash2 (bloom filter)
bloomx

lfalist
    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
    ; heads of link threads for root vocabulary

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================
#include sweet16.a65
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================




;==============================================================
;==== zeropage buffer and user area                        ====
;==============================================================
;
; this is an image of PETTIL zeropage at cold start.  Swapping it
; with the BASIC zeropage makes hopping back and forth possible
;
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100
;==============================================================
; userarea initialization data
; this gets copied to the uarea
; and is pointed to by the UP (user pointer)
userarea
userup          .word uarea                             ; WARM
usersp0         .word bos+1             ; =2            ;
userrp0         .word $01fe                             ;
userwarm
userfence       .word forgetfence                       ; COLD
userdp          .word endofile                          ;
usermemsiz      .word VIDRAM                            ;
usercold
userblk         = usercold                              ; SOFT
usertoin        = usercold+2                            ;
usernumout      = usercold+4                            ;
userscr         = usercold+6                            ;
useroffset      = usercold+8                            ;
usercontext     = usercold+10                           ;
usercurrent     = usercold+12                           ;
userstate       = usercold+14                           ;
userbase        = usercold+16                           ;
usercsp         = usercold+18                           ;
userspan        = usercold+20                           ;
userdpl         = usercold+22                           ;
userrsharp      = usercold+24                           ;
userhld         = usercold+26                           ;
usertib         = usercold+28                           ;
userline        = usercold+30                           ;
uservmsiz       = usercold+32                           ;
usersymtab      = usercold+34                           ;
uservmbuf       = usercold+36                           ;
; live userarea has 2 bytes for each initializer
; extra memory beyond warm/cold initialized user variables
; is reserved for "soft" user variables
; e.g. STATE
uarea           .dsb usercold-userarea+48,0
;==============================================================
;==== Error messages                                       ====
;==============================================================
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08


msg01
    .byt msg02-*-1
    .asc "STACK EMPTY"
msg02   
    .byt msg03-*-1
    .asc "STACK FULL"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "VOCABULARIES UNIMPLEMENTED"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09

;--------------------------------------------------------------
; Drop down from high-level Forth to inline 6502
#ifdef HEADERS
to6502lfa
    .byt $de,$ad
    .byt (to6502-*-1)|bit7
    .asc ">650","2"|bit7
#endif
to6502
    ldy ip
    iny
    clc
    bne to650201
    sec
to650201
    lda ip+1
    adc #0
    pha
    tya
    pha
    rts     ; [15]

;--------------------------------------------------------------
    ; negate the double at n0..n3
dnegaten
    ldy #0
    sec
    tya
    sbc n+2
    sta n+2         ; low order byte
    tya
    sbc n+3
    sta n+3
    tya
    sbc n
    sta n
    tya
    sbc n+1
    sta n+1         ; high order byte
    rts
;==============================================================
;==== PETTIL dictionary                                    ====
;==============================================================
rootlfa
    .word 0
    .byt 31                 ; longest word in the dictionary
;
; The dictionary root is 31 characters long so it will be at the
; end of the linked list, which is ordered by word name length
;
;--------------------------------------------------------------
;
;       EXECUTE
;
; * 83 nucleus
;
; Executes the definition found at addr.
;
;"      : execute ( cfa --- )
;"              jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
#ifdef HEADERS
executelfa
    .byt $de,$ad
    .byt (execute-*-1)|bit7
    .asc "EXECUT","E"|bit7
#endif
execute
    lda tos                 ; <-- code field address
    sta w1                  ; in direct-threaded models, this
    lda tos+1               ; contains code instead of a pointer
    sta w1+1                ; [SP] -> [W1]
    lda ip+1
    pha
    lda ip
    pha
    lda #<(w1-2)
    sta ip
    lda #>(w1-2)
    sta ip+1
    jmp pops

;--------------------------------------------------------------
;
;       (LIT)
;
; * inner interpreter headerless
;
; push the word of memory following (IP)
;
;#ifdef HEADERS
;plitlfa
;    .byt $de,$ad
;    .byt (plit-*-1)|bit7
;    .asc "(LIT",")"|bit7
;#endif
plit
    jsr slip
    ldy #3
    lda (ip),y
    inc ip
    ldy #1
    bne lithi ; bra

;--------------------------------------------------------------
;
;       CLIT
;
; * inner interpreter headerless
;
; takes the byte of memory following and pushes it to the data stack
;
;#ifdef HEADERS
;clitlfa
;    .byt $de,$ad
;    .byt (clit-*-1)|bit7
;    .asc "CLI","T"|bit7
;#endif
clit
    jsr slip
    lda #0
    ldy #2
lithi
    sta tos+1
    lda (ip),y
    sta tos
    lda #3
    jmp pad

;--------------------------------------------------------------
;
;       ?BRANCH   ( flag -- )
;
; * inner interpreter control headerless
;
;#ifdef HEADERS
;qbranchlfa
;    .byt $de,$ad
;    .byt (qbranch-*-1)|bit7
;    .asc "?BRANC","H"|bit7
;#endif
qbranch
    lda tos
    ora tos+1       ; check the flag
    ldy stackl,x
    sty tos
    ldy stackh,x
    sty tos+1
    inx             ; drop
    tay             ; to set the Z flag
    beq branch
bump
    lda #3
    jmp pad

;--------------------------------------------------------------
;
;       (?DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; Performs a do-loop if end<>begin
;#ifdef HEADERS
;pqdolfa
;    .byt $de,$ad
;    .byt (pqdo-*-1)|bit7
;    .asc "(?DO",")"|bit7
;#endif
pqdo
    ldy #1
    jsr locals               ; end -> N0
    lda tos
    eor n
    sta n+2
    lda tos+1
    eor n+1
    ora n+2                 ; are begin and end loop indices the same?
    beq pqdo02              ; yes, nada
    ldy #3
pqdo01
    lda zi,y                ; set up for a loop
    pha
    lda tos,y               ; tos & n must be adjacent in zeropage ~wut?
    sta zi,y
    dey
    bpl pqdo01              ; Y=FF means perform the loop
pqdo02
    jsr slide
    tya                     ; sets the Z flag
    bne bump                ; beanie bump!
;fall through   ;beq branch             ; zero means end = begin (no loop)

;--------------------------------------------------------------
;
;       BRANCH   ( -- )
;
; * inner interpreter control headerless
;
; Compiles an unconditional branch operation.
;" When used in the form: COMPILE BRANCH
; an unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address
; is typically generated by following BRANCH
; with <RESOLVE or >MARK .
;
; IP = address of 'branch' (you are here)
; IP+2 = relative address of the target, same as for 6502 branches
;
;#ifdef HEADERS
;branchlfa
;    .byt $de,$ad
;    .byt (branch-*-1)|bit7
;    .asc "BRANC","H"|bit7
;#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bmi branch01    ; [2|3]
    ldy #0          ; [2]
    .byt $2c        ; [4]
branch01
    ldy #$ff        ; [2]
    sec             ; [2]
    adc ip          ; [3]
    sta ip          ; [3]
    tya             ; [2]
    adc ip+1        ; [3]
    sta ip+1        ; [3]
    jmp nexto       ; [3]   [34 forward |31 backward]

;--------------------------------------------------------------
;
;       (+LOOP)   ( n -- )
;
; * inner interpreter control headerless
;
; add n to inner loop index.  If loop index exceeds loop limit,
; then iterate to the (do), otherwise skip past the branch and
; proceed
;#ifdef HEADERS
;pplooplfa
;    .byt $de,$ad
;    .byt (pploop-*-1)|bit7
;    .asc "(+LOOP",")"|bit7
;#endif
pploop
    clc
    lda tos
    adc zi
    sta zi
    lda tos+1
    adc zi+1
    sta zi+1
    lda zi+2
    cmp zi
    lda zi+3
    sbc zi+1
    ldy tos+1
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
    inx
    tay
    bcc pploop01
    eor #$80
pploop01
    bmi branch
    bpl bump

;--------------------------------------------------------------
;
;       (LOOP)
;
; * inner interpreter control headerless
;
;#ifdef HEADERS
;plooplfa
;    .byt $de,$ad
;    .byt (ploop-*-1)|bit7
;    .asc "(LOOP",")"|bit7
;#endif
ploop
    inc zi
    bne ploop01
    inc zi+1
ploop01
    lda zi+2
    eor zi
    bne branch
    lda zi+3
    eor zi+1
    bne branch
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    jmp bump

;--------------------------------------------------------------
;
;       (DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; loops from 'begin' to 'end'
;#ifdef HEADERS
;pdolfa
;    .byt $de,$ad
;    .byt (pdo-*-1)|bit7
;    .asc "(DO",")"|bit7
;#endif
pdo
    lda stackh,x
    sta n+1
    lda stackl,x
    sta n                   ; end -> N0
    ldy #3
pdo01
    lda zi,y                ; set up for a loop
    pha
    lda tos,y               ; takes advantage of tos being
    sta zi,y                ; adjacent to zi area
    dey
    bpl pdo01
poptwo
    inx
pops
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
;
;       I
;
; * 83 nucleus
;
#ifdef HEADERS
ilfa
    .byt $de,$ad
    .byt (i-*-1)|bit7
    .asc "I"|bit7
#endif
i
    ldy zi+1
    lda zi
    ; pass YA = value to push/put on stack
pushya
    pha
    jsr slip
    pla
    jmp put

;--------------------------------------------------------------
;
;       J
;
; * 83 nucleus
;
#ifdef HEADERS
jlfa
    .byt $de,$ad
    .byt (j-*-1)|bit7
    .asc "J"|bit7
#endif
j
    stx storex
    tsx
    ldy $0102,x
    lda $0101,x             ; ~ test this
    ldx storex
    jmp pushya

;--------------------------------------------------------------
;
;       (LEAVE)
;
; * inner interpreter control headerless
;
;#ifdef HEADERS
;pleavelfa
;    .byt $de,$ad
;    .byt (pleave-*-1)|bit7
;    .asc "(LEAVE",")"|bit7
;#endif
pleave
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    jmp branch

;--------------------------------------------------------------
;
;       (?LEAVE)
;
; * inner interpreter control headerless
;
;#ifdef HEADERS
;pqleavelfa
;    .byt $de,$ad
;    .byt (pqleave-*-1)|bit7
;    .asc "(?LEAVE",")"|bit7
;#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    bne pleave
    jmp bump

;--------------------------------------------------------------
;
;       ?STACK
;
; inspect data stack pointer for sanity, abort if trouble
#ifdef HEADERS
qstacklfa
    .byt $de,$ad
    .byt (qstack-*-1)|bit7
    .asc "?STAC","K"|bit7
#endif
qstack
    ldy #usersp0-userarea           ; 2 = stack full
    txa
    bmi error
    cmp (up),y
    dey                             ; 1 = stack empty
    bcs error       ; stack empty
    jmp next

;--------------------------------------------------------------
; Jump up to high-level Forth from inline 6502
;
; Page boundary crossing is handled by the compiler inserting 'page'
; when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
; to occur, and indicates an error in the compiler.
;
; Pad is used by LITERAL and string routines to offset IP at runtime
;
;~" todo: make an ASSEMBLER vocabulary word >FORTH to insert the call
; and handle pagination properly like the "toforth.i65" include file
;
; also a general-purpose error handler to print a string and abort
; pass in the error # in Y
;       1 stack empty
;       2 stack full
error
    sty tos
    ldy #0
    sty tos+1
    lda #>(fail)
    pha
    lda #<(fail)    ; transfer control to fail, which
    ; prints a numbered error and aborts
    pha
toforth
    pla
    sta ip
    pla
    sta ip+1
    lda #1
pad
    clc                     ; pass A = offset added to IP
    adc ip
    bcs pagen               ; check for page boundary crossing
    cmp #$ff
    bne pado                ; check for xxFF at end of page
page
    lda #0
pagen
    inc ip+1                ; cross the page
pado
    sta ip
    jmp nexto

;--------------------------------------------------------------
;
;       MON    ( char base -- digit true | false )
;
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
;~wut? this only works the first time
;
#ifdef HEADERS
monlfa
    .byt $de,$ad
    .byt (mon-*-1)|bit7
    .asc "MO","N"|bit7
#endif
mon
    jsr swapzp      ; restore BASIC zpage
sw16
    ldy #2
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne sw16+2
    brk
    .byt rtn
plover              ; if we get here, it's unimplemented
xyzzy
    jmp next        ; used as a breakpoint in secondaries

;--------------------------------------------------------------
;
;       DIGIT    ( char base -- digit true | false )
;
; Converts a single character to a digit using the current number
; base.  A flag on TOS indicates whether the conversion succeeded.
;~wut? possible to code golf this down with BCD tricks?
;"http://www.6502.org/tutorials/decimal_mode.html
#ifdef HEADERS
digitlfa
    .byt $de,$ad
    .byt (digit-*-1)|bit7
    .asc "DIGI","T"|bit7
#endif
digit
    ldy #$ff        ; assume success
    lda stackl,x    ; get the character
    sec
    sbc #'0'
    bcc digit02     ; char was < '0'? not a digit, fail
    cmp #10
    bcc digit01     ; digit is in the range 00-09
    sbc #7          ; no? alphabet adjust 'A' --> $0a
digit01
    cmp tos         ; compare to current number base
    bcs digit02     ; not in current number base? fail
    sta stackl,x    ; digit in the current number base
    .byt $2c        ; BIT xxyy, skip the next two bytes
digit02
    iny             ; fail, set flag to 0
    inx             ; drop the stack

    tya             ; ya = flag word $0000 or $ffff
    jmp put         ; next!

;--------------------------------------------------------------
;
;       (FIND)   ( name-2 LFA -- name-2 0 | CFA flag )
;
; * outer interpreter headerless
;
; name-2 is the address-2 of a counted string we are searching for.
; LFA is the LFA at the head of a chain of LFAs
; returns
;       ( CFA -1 ) if found normal word
;       ( CFA 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit

;--------------------------------------------------------------
;
;       SCAN   ( addr count char -- addr count )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt rtn
    lda n
    ldy n+1
    jmp pushya

;--------------------------------------------------------------
;
;       EMIT
;
; * 83 device
;
#ifdef HEADERS
emitlfa
    .byt $de,$ad
    .byt (emit-*-1)|bit7
    .asc "EMI","T"|bit7
#endif
emit
    jmp emitvector
emitvector
    ldy numout+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bne emit01
    iny
    clc
    lda (up),y
    adc #1
    sta (up),y
emit01
    lda tos
    jsr CHROUT
    jmp pops

;--------------------------------------------------------------
;
;       KEY
;
; * 83 device
;
#ifdef HEADERS
keylfa
    .byt $de,$ad
    .byt (key-*-1)|bit7
    .asc "KE","Y"|bit7
#endif
key
    stx storex
key01
    jsr GETIN
    beq key01
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       ?TERMINAL   ( -- flag )
;
; true if stop key pressed
;
#ifdef HEADERS
qterminallfa
    .byt $de,$ad
    .byt (qterminal-*-1)|bit7
    .asc "?TERMINA","L"|bit7
#endif
qterminal
    ldy #0
    lda $9b
    cmp #$ef            ; check STOP key
    bne qterminal01
    dey
qterminal01
    tya
    jmp pushya

;--------------------------------------------------------------
;
;       CR
;
; * 83 device
;
#ifdef HEADERS
crlfa
    .byt $de,$ad
    .byt (cr-*-1)|bit7
    .asc "C","R"|bit7
#endif
cr
    jmp crvector
crvector
    lda #$0d
    jsr CHROUT
    lda #0
    ldy numout+3
    sta (up),y
    iny
    sta (up),y
    ldy numline+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bcc cr01
    iny
    lda (up),y
    adc #0
    sta (up),y
cr01
    jmp next

;--------------------------------------------------------------
;
;       CMOVE   ( from to howmany -- )
;
; * 83 nucleus
;
;"~ see http://6502.org/source/general/memory_move.html
#ifdef HEADERS
cmovelfa
    .byt $de,$ad
    .byt (cmove-*-1)|bit7
    .asc "CMOV","E"|bit7
#endif
cmove
    ldy #2          ; pull two items off the data stack
    jsr locals      ; howmany = TOS, from = N0, to = N1
    ;clc
    ;ldy #0         ; locals returns Y=0 C=0
    stx storex      ; stash the data stack pointer
    ldx #0          ; X,Y=0
cmove01
    dec tos+1
    bpl cmove02     ; do a whole page
    ldx tos         ; last page
    beq cmove03     ; none at all?
    sec             ; exit after this iteration
cmove02
    lda (n),y
    sta (n+2),y
    iny
    dex
    bne cmove02
    inc n+1
    inc n+3
    bcc cmove01
cmove03
    ldx storex      ; revive the data stack pointer
    jmp pops    ; [37]

;--------------------------------------------------------------
;
;       CMOVE>   ( from to howmany -- )
;
; * 83 nucleus
;
; Move the u bytes beginning at address addr1 to
; addr2.  The move begins by moving the byte at
; (addr1 plus u minus 1) to (addr2 plus u minus 1)
; and proceeds to successively lower addresses
; for u bytes.  If u is zero nothing is moved.
; Useful for sliding a string towards higher addresses.
;
#ifdef HEADERS
cmovegtlfa
    .byt $de,$ad
    .byt (cmovegt-*-1)|bit7
    .asc "CMOVE",">"|bit7
#endif
cmovegt
    brk
    .byt ld | TOS
    .byt st | N2                ; howmany
    .byt dcr | N2
    .byt pull
    .byt add | N2
    .byt st | N1                ; to
    .byt pull
    .byt add | N2
    .byt st | N0                ; from
    .byt ld | N2
    .byt bp, <(cmovegt06-*-2)
    .byt pull
    .byt nxt
cmovegt06
    .byt inr | N2
    .byt rtn
    clc
    ldy #0                     ; done by Sweet16
    stx storex
    ldx #0
cmovegt01
    dec n+5
    bpl cmovegt03
cmovegt02       ; last page
    ldx n+4                         
    beq cmovegt05
    sec
cmovegt03
    lda (n),y
    sta (n+2),y
    tya
    bne cmovegt04
    dec n+1
    dec n+3
cmovegt04
    dey
    dex
    bne cmovegt03
    bcc cmovegt01
cmovegt05
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       MOVE   ( from to howmany -- )
;
; Move the u bytes beginning at address addr1 to
; addr2.  Overlap clobber does not occur in either direction
;
;": move   ( from to howmany -- )
;     >r 2dup u< r> swap
;     if
;         cmove>
;     else
;         cmove
;     then ;
;
#ifdef HEADERS
movelfa
    .byt $de,$ad
    .byt (_move-*-1)|bit7
    .asc "MOV","E"|bit7
#endif
_move
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(move01-*+1)
#include "pad.i65"
    .word cmovegt
#include "page.i65"
    .word branch
    .byt <(move02-*+1)
#include "pad.i65"
move01
    .word cmove
#include "page.i65"
move02
    .word exit


; * 83 nucleus
;--------------------------------------------------------------
;
;       FILL   ( addr howmany value -- )
;
; * 83 nucleus
;
; howmany has an upper limit of 32K bytes
;
#ifdef HEADERS
filllfa
    .byt $de,$ad
    .byt (fill-*-1)|bit7
    .asc "FIL","L"|bit7
#endif
fill
    ldy #2
    jsr locals      ; addr -> N0; howmany -> N1
    ;clc            ; C cleared by setup
    ;ldy #0
    lda tos
fill01
    dec n+3
    bpl fill02
    sec             ; fill a partial page then exit
    ldy n+2
    beq fill03      ; nothing to do?
fill02
    dey
    sta (n),y
    bne fill02
    inc n+1
    bcc fill01
fill03
    jmp pops

;--------------------------------------------------------------
;
;       2+
;
; * 83 nucleus
;
#ifdef HEADERS
twopluslfa
    .byt $de,$ad
    .byt (twoplus-*-1)|bit7
    .asc "2","+"|bit7
#endif
twoplus
    clc
    lda tos
    adc #2
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next

;"~ check http://6502.org/source/ for multiply and divide and stuff
;--------------------------------------------------------------
;
;       UM*   ( u1 u2 -- ud )
;
; * 83 nucleus divstar
;
; multiply u1 times u2 returning the double length product ud.
; All values and arithmetic are unsigned.
#ifdef HEADERS
umstarlfa
    .byt $de,$ad
    .byt (umstar-*-1)|bit7
    .asc "UM","*"|bit7
#endif
umstar
    lda stackl,x
    sta n+4
    lda stackh,x            ;multiplicand in tos
    sta n+5                 ;multiplier in N2
    jsr multiply            ;16 bit unsigned multiply
    lda n
    sta stackl,x
    lda n+1
    sta stackh,x
    lda n+2
    sta tos
    lda n+3
    sta tos+1
    jmp next

multiply
    lda #0                  ; unsigned multiply tos*N2 destroys tos
    sta n+2                 ;clear upper half of product
    sta n+3
    ldy #16
rshift
    lsr tos+1
    ror tos
    bcc rrot                ;Go rotate right if c = 0
    clc                     ; and add multiplicand to
    lda n+2                 ;Get upper half of product
    adc n+4                 ; it
    sta n+2
    lda n+3
    adc n+5
rrot
    ror                     ;shift partial product right
    sta n+3
    ror n+2
    ror n+1
    ror n
    dey                     ;Decrement bit count and
    bne rshift
    rts
;You beat me to the punch, but there is some unnecessary code in there (you don't need to clear the carry before a LSR). And trashing X is unnecessary since you can test for zero just as fast with LDA $02. Or with some crazy jujitsu to save a byte...
;Here's my version, handles 8-bit operands:
;--$00 holds operand 1
;--$01 (low byte) and $02 (high byte) hold operand 2
;--$03 (low byte) and $04 (high byte) hold product
;       cld
;Loop
;    lsr $00
;    bcc NoAdd
;    clc
;    lda $03
;    adc $01
;    sta $03
;    lda $04
;    adc $02
;    sta $04
;    .byte $2C
;NoAdd
;    beq Done
;    asl $01
;    rol $02
;    bcc Loop        ;this assumes that operand 2 is 8-bit
;Done
;
;A proper 6502 assembler solution.
;
;Features
;- multiplies two 8-bit numbers with 16 bit result
;- inner loop of only 17 clock cycles per iteration
;- worst case behaviour of 40 clock cycles per iteration
;- minimizes number of iterations
;- total execution time 25 - 320 cycles
;(i.e. only 3x slower (worst case) than MUL on Intel 8088)
;- 43 bytes size
;- relocatable to about anywhere in address space
;- uses C64-friendly memory locations
; INPUT  = op1 in A, op2 in X
; OUTPUT = low byte in X, high byte in Y
; memory locations used as temp space = $fb, $fc, $fd
;    stx $fc    ; save op2
;    cmp $fc    ; compare both operands
;    bcc noswap ; swap them unless op1 < op2
;    sta $fc    ; save op1 instead of op2
;    txa        ; swap op2 for op1
;noswap
;    ldx #$00   ; prepare result low byte
;    stx $fd    ; clear high byte of op2
;    ldy #$00   ; prepare result high byte
;    beq begin  ; skip shift of op2 for first iteration
;loop
;    asl $fc    ; multiply op2 by 2, low byte
;    rol $fd    ; multiply op2 by 2, high byte
;begin
;    lsr        ; divide op1 by 2
;    bcs add    ; if op1 was odd before division, add op2
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;add
;    sta $fb    ; save current value of op1
;    clc        ; prepare addition
;    txa        ; fetch low byte
;    adc $fc    ; add op2, low byte
;    tax        ; store low byte
;    tya        ; fetch high byte
;    adc $fd    ; add op2, high byte
;    tay        ; store high byte
;    lda $fb    ; restore op1
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;

;--------------------------------------------------------------
;
;       UD/MOD   ( d1 n1 -- n2 d2 )
;
; * divstar
;
; d2 is the double quotient of d1/n1.  n2 is the remainder.  All
; values are unsigned.
; ~ make this 32-bit divisor?
; ~ fix for /0
#ifdef HEADERS
udslashmodlfa
    .byt $de,$ad
    .byt (udslashmod-*-1)|bit7
    .asc "UD/MO","D"|bit7
#endif
udslashmod
    ldy #2
    jsr locals               ; udlo -> N0; udhi -> N1
    jsr divmod              ; (unsigned) u31/u16 -> quo31 rem16
    dex
    lda n+1
    sta stackh,x
    lda n
    sta stackl,x            ; remainder
    lda n+9
    sta tos+1
    lda n+8
    sta tos
    ldy n+11
    lda n+10
    jmp pushya

divmod
    stx storex
    ldx #7
divmod00
    sty n+4,x               ; zero the divisor & quotient
    dex
    bpl divmod00
    ldx storex
    lda tos+1
    ora tos
    beq divmod05            ; error division by zero
    ldy #33
divmod01
    lsr tos+1
    ror tos                 ; divisor = divisor/2
    ror n+7
    ror n+6                 ; shift it in until we hit zero
    ror n+5
    ror n+4
    dey
    lda tos+1
    ora tos
    bne divmod01
divmod02
    asl n+8
    rol n+9                 ; quotient low
    rol n+10
    rol n+11                ; double the quotient here
    sec
    lda n
    sbc n+4
    pha
    lda n+1
    sbc n+5
    pha
    lda n+2
    sbc n+6
    pha
    lda n+3
    sbc n+7
    bcc divmod03
    sta n+3
    pla
    sta n+2
    pla
    sta n+1
    pla
    sta n
    inc n+8                 ; add 1 to quotient
    bcs divmod04            ; bra
divmod03
    pla
    pla
    pla                     ; discard result of subtraction
divmod04
    lsr n+7
    ror n+6
    ror n+5
    ror n+4                 ; divisor /2
    dey
    bne divmod02
divmod05
    rts

;--------------------------------------------------------------
;
;       UM/MOD   ( ud u -- rem quot )
;
; * 83 nucleus divstar
;
;       ~ needs a lot of work
;"      http://6502.org/source/integers/ummodfix/ummodfix.htm
#ifdef HEADERS
umslashmodlfa
    .byt $de,$ad
    .byt (_umslashmod-*-1)|bit7
    .asc "UM/MO","D"|bit7
#endif
_umslashmod
#include "enter.i65"
    .word udslashmod
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       AND   ( n1 n2 -- n1&n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
andxlfa
    .byt $de,$ad
    .byt (andx-*-1)|bit7
    .asc "AN","D"|bit7
#endif
andx
    lda tos
    and stackl,x
    sta tos
    lda tos+1
    and stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
;
;       OR   ( n1 n2 -- n1|n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
orxlfa
    .byt $de,$ad
    .byt (orx-*-1)|bit7
    .asc "O","R"|bit7
#endif
orx
    lda tos
    ora stackl,x
    sta tos
    lda tos+1
    ora stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
;
;       XOR   ( n1 n2 -- n1^n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
xorlfa
    .byt $de,$ad
    .byt (xor-*-1)|bit7
    .asc "XO","R"|bit7
#endif
xor
    lda tos
    eor stackl,x
    sta tos
    lda tos+1
    eor stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
;
;       NOT   ( n -- !n )
;
; * 83 nucleus
;
#ifdef HEADERS
notlfa
    .byt $de,$ad
    .byt (not-*-1)|bit7
    .asc "NO","T"|bit7
#endif
not
    lda tos
    eor #$ff
    sta tos
    lda tos+1
    eor #$ff
    sta tos+1
    jmp next

;--------------------------------------------------------------
;
;       SP@   ( -- sp )
;
#ifdef HEADERS
spfetchlfa
    .byt $de,$ad
    .byt (spfetch-*-1)|bit7
    .asc "SP","@"|bit7
#endif
spfetch
    txa
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       SP!   ( -- )
;
#ifdef HEADERS
spstorelfa
    .byt $de,$ad
    .byt (spstore-*-1)|bit7
    .asc "SP","!"|bit7
#endif
spstore
    ldy #usersp0-userarea
    lda (up),y
    tax
    dex             ; because it's 1> to make ?stack faster
    jmp next

;--------------------------------------------------------------
;
;       RP!   ( -- )
;
; Ordinarily the 6502 machine stack (aka PETTIL return stack) is
; initialized to $01ff by BASIC, but the value stored at RP0 defaults
; to $01fe instead.  This is because the PET ROM stores a line of
; input at $0200 (where TIB points) and INTERPRET will be storing a
; count of the first word on the line at $01ff
#ifdef HEADERS
rpstorelfa
    .byt $de,$ad
    .byt (rpstore-*-1)|bit7
    .asc "RP","!"|bit7
#endif
rpstore
    stx storex
    ldy #userrp0-userarea
    lda (up),y
    tax
    txs
    ldx storex
    jmp next

;--------------------------------------------------------------
;
;       EXIT   ( -- )
;
; * 83 nucleus
;
;               [RP+] -> IP
;               NEXT
;
;#ifdef HEADERS
;exitlfa
;    .byt $de,$ad
;    .byt (exit-*-1)|bit7
;    .asc "EXI","T"|bit7
;#endif
exit
    pla
    sta ip
    pla
    sta ip+1        ; [RP+] -> IP
    jmp next        ; NEXT

;--------------------------------------------------------------
;
;       DUP>R   ( n -- )
;
; * 83 nucleus
;
#ifdef HEADERS
duptorlfa
    .byt $de,$ad
    .byt (duptor-*-1)|bit7
    .asc "DUP>","R"|bit7
#endif
duptor
    jsr slip
    jmp tor

;--------------------------------------------------------------
;
;       >R   ( n -- )
;
; * 83 nucleus
;
#ifdef HEADERS
torlfa
    .byt $de,$ad
    .byt (tor-*-1)|bit7
    .asc ">","R"|bit7
#endif
tor
    lda tos+1
    pha
    lda tos
    pha
    jmp pops

;--------------------------------------------------------------
;
;       R>   ( -- n )
;
; * 83 nucleus
;
#ifdef HEADERS
rfromlfa
    .byt $de,$ad
    .byt (rfrom-*-1)|bit7
    .asc "R",">"|bit7
#endif
rfrom
    pla
    sta storex
    pla
    tay
    lda storex
    jmp pushya

;--------------------------------------------------------------
;
;       R@   ( -- n )
;
; * 83 nucleus
;
#ifdef HEADERS
rfetchlfa
    .byt $de,$ad
    .byt (rfetch-*-1)|bit7
    .asc "R","@"|bit7
#endif
rfetch
    stx storex  ; [3]
    tsx         ; [2]
    ldy $0102,x ; [4]
    lda $0101,x ; [4]
    ldx storex  ; [3]
    jmp pushya ; [14|15]
    
;--------------------------------------------------------------
;
;       0>   ( n -- flag )
;
; * 83 nucleus
;
#ifdef HEADERS
zgtlfa
    .byt $de,$ad
    .byt (zgt-*-1)|bit7
    .asc "0",">"|bit7
#endif
zgt
    ldy #0
    lda tos+1
    bmi zgt01                   ; check the sign
    ora tos                     ; check for nonzero
    beq zgt01
    dey
zgt01
    tya
    jmp put

;--------------------------------------------------------------
;
;       <>   ( n1 n2 -- flag )
;
#ifdef HEADERS
nelfa
    .byt $de,$ad
    .byt (ne-*-1)|bit7
    .asc "<",">"|bit7
#endif
ne
    ldy #$ff                ; assume inequality
    lda tos
    eor stackl,x
    bne ne01
    lda tos+1
    eor stackh,x
    bne ne01
    iny                     ; they're equal
ne01
    tya
    inx
    jmp put

;--------------------------------------------------------------
;
;       ON   ( addr -- )
;
; store -1 at ADDR
#ifdef HEADERS
onlfa
    .byt $de,$ad
    .byt (on-*-1)|bit7
    .asc "O","N"|bit7
#endif
on
    lda #$ff
on1
    ldy #0
    sta (tos),y
    iny
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
;
;       OFF   ( addr -- )
;
; store 0 at ADDR
#ifdef HEADERS
offlfa
    .byt $de,$ad
    .byt (off-*-1)|bit7
    .asc "OF","F"|bit7
#endif
off
    lda #$00
    beq on1

;--------------------------------------------------------------
;
;       +   ( n1 n2 -- n1+n2 )
;
; * 83 nucleus
;
; 09/15/10 cah
#ifdef HEADERS
pluslfa
    .byt $de,$ad
    .byt (plus-*-1)|bit7
    .asc "+"|bit7
#endif
plus
    clc
    lda tos
    adc stackl,x
    sta tos
    lda tos+1
    adc stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
;
;       D+   ( d1 d2 -- d1+d2 )
;
; * 83 nucleus
;
#ifdef HEADERS
dpluslfa
    .byt $de,$ad
    .byt (dplus-*-1)|bit7
    .asc "D","+"|bit7
#endif
dplus
    clc
    lda stackl,x
    adc stackl+2,x
    sta stackl+2,x
    lda stackh,x
    adc stackh+2,x
    sta stackh+2,x
    lda tos
    adc stackl+1,x
    pha
    lda tos+1
    adc stackh+1,x
    tay
    pla
    inx
    inx
    jmp put            ; [29]

;--------------------------------------------------------------
;
;       D<   ( d1 d2 -- flag )
;
; * 83 nucleus
;
#ifdef HEADERS
dltlfa
    .byt $de,$ad
    .byt (dlt-*-1)|bit7
    .asc "D","<"|bit7
#endif
dlt
    ldy #0          ; false
    jsr dcmp
    bvc dlt01
    eor #$80
dlt01
    bpl dlt02
    dey             ; true
dlt02
    sty tos
    sty tos+1
    inx
    inx
    inx
    jmp next
dcmp
    sec
    lda stackl+2,x
    sbc stackl,x
    lda stackh+2,x
    sbc stackh,x
    lda stackl+1,x
    sbc tos
    lda stackh+1,x
    sbc tos+1
    rts

;--------------------------------------------------------------
;
;       NEGATE   ( n -- -n )
;
; * 83 nucleus
;
; 09/15/10 cah
#ifdef HEADERS
negatelfa
    .byt $de,$ad
    .byt (negate-*-1)|bit7
    .asc "NEGAT","E"|bit7
#endif
negate
    jsr donegate
    jmp next
donegate
    sec
neg2
    lda #0
    sbc tos
    sta tos
    lda #0
    sbc tos+1
    sta tos+1
    rts

;--------------------------------------------------------------
;
;       DNEGATE   ( d -- -d )
;
; * 83 nucleus
;
#ifdef HEADERS
dnegatelfa
    .byt $de,$ad
    .byt (dnegate-*-1)|bit7
    .asc "DNEGAT","E"|bit7
#endif
dnegate
    jsr dodnegate
    jmp next
dodnegate
    sec
    lda #0
    sbc stackl,x
    sta stackl,x
    lda #0
    sbc stackh,x
    sta stackh,x
    jmp neg2

;--------------------------------------------------------------
;
;       OVER   ( n1 n2 -- n1 n2 n1 )
;
; * 83 nucleus
;
; 09/15/10 cah
#ifdef HEADERS
overlfa
    .byt $de,$ad
    .byt (over-*-1)|bit7
    .asc "OVE","R"|bit7
#endif
over
    ldy stackh,x
    lda stackl,x
    jmp pushya

;--------------------------------------------------------------
;
;       DROP   ( n -- )
;
; * 83 nucleus
;
#ifdef HEADERS
droplfa
    .byt $de,$ad
    .byt (drop-*-1)|bit7
    .asc "DRO","P"|bit7
#endif
drop
    jmp pops

;--------------------------------------------------------------
;
;       SWAP   ( n1 n2 -- n2 n1 )
;
; * 83 nucleus
;
#ifdef HEADERS
swaplfa
    .byt $de,$ad
    .byt (swap-*-1)|bit7
    .asc "SWA","P"|bit7
#endif
swap
    ldy tos+1
    lda stackh,x
    sta tos+1
    sty stackh,x
    ldy tos
    lda stackl,x
    sta tos
    sty stackl,x
    jmp next

;--------------------------------------------------------------
;
;       TUCK   ( n1 n2 -- n2 n1 n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
tucklfa
    .byt $de,$ad
    .byt (_tuck-*-1)|bit7
    .asc "TUC","K"|bit7
#endif
_tuck
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NIP   ( n1 n2 -- n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
niplfa
    .byt $de,$ad
    .byt (_nip-*-1)|bit7
    .asc "NI","P"|bit7
#endif
_nip
#include "enter.i65"
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DUP   ( n -- n n )
;
; * 83 nucleus
;
#ifdef HEADERS
duplfa
    .byt $de,$ad
    .byt (dup-*-1)|bit7
    .asc "DU","P"|bit7
#endif
dup
    jsr slip
    jmp next

;--------------------------------------------------------------
;
;       +!   ( n addr -- )
;
; * 83 nucleus
;
; add N to the cell at ADDR
#ifdef HEADERS
plusstorelfa
    .byt $de,$ad
    .byt (plusstore-*-1)|bit7
    .asc "+","!"|bit7
#endif
plusstore
    ldy #0
    clc
    lda stackl,x
    adc (tos),y
    sta (tos),y
    iny
    lda stackh,x
    adc (tos),y
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
;
;       TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

#ifdef HEADERS
togglelfa
    .byt $de,$ad
    .byt (toggle-*-1)|bit7
    .asc "TOGGL","E"|bit7
#endif
toggle
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1
    ldy #0
    lda (n),y
    eor tos
    sta (n),y
    jmp poptwo

;--------------------------------------------------------------
;
;       @   ( addr -- n )
;
; * 83 nucleus
;
#ifdef HEADERS
fetchlfa
    .byt $de,$ad
    .byt (fetch-*-1)|bit7
    .asc "@"|bit7
#endif
fetch
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    sta tos+1
    pla
    sta tos
    jmp next

;--------------------------------------------------------------
;
;       C@   ( addr -- 8b )
;
; * 83 nucleus
;
; "c-fetch"
; 8b is the contents of the byte at addr.
;
#ifdef HEADERS
cfetchlfa
    .byt $de,$ad
    .byt (cfetch-*-1)|bit7
    .asc "C","@"|bit7
#endif
cfetch
    ldy #0
    lda (tos),y
    sta tos
    sty tos+1
    jmp next

;--------------------------------------------------------------
;
;       !   ( 16b addr -- )
;
; * 83 nucleus
;


; "store"
; 16b is stored at addr.
#ifdef HEADERS
storelfa
    .byt $de,$ad
    .byt (store-*-1)|bit7
    .asc "!"|bit7
#endif
store
    ldy #0
    lda stackl,x
    sta (tos),y
    iny
    lda stackh,x
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
;
;       C!   ( 8b addr --
;
; * 83 nucleus
;
; "c-store"
; The least-significant 8 bits of 16b are stored into the byte
; at addr.
;
#ifdef HEADERS
cstorelfa
    .byt $de,$ad
    .byt (cstore-*-1)|bit7
    .asc "C","!"|bit7
#endif
cstore
    lda stackl,x
    ldy #0
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
;
;       ALLOT
;
; * 83 compiler
;
#ifdef HEADERS
allotlfa
    .byt $de,$ad
    .byt (_allot-*-1)|bit7
    .asc "ALLO","T"|bit7
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,   ( w -- )
;
; * 83 compiler
;
#ifdef HEADERS
commalfa
    .byt $de,$ad
    .byt (_comma-*-1)|bit7
    .asc ","|bit7
#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
    .word exit

;--------------------------------------------------------------
;
;       ,$   ( ?? -- ?? )
;
#ifdef HEADERS
commadollarlfa
    .byt $de,$ad
    .byt (_commadollar-*-1)|bit7
    .asc ",","$"|bit7
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
    .word exit

;--------------------------------------------------------------
;
;       HERELSB   ( -- c )
;
; Returns the least significant byte of DP
;
;#ifdef HEADERS
;herelsblfa
;    .byt $de,$ad
;    .byt (_herelsb-*-1)|bit7
;    .asc "HERELS","B"|bit7
;#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; create the code field of a new definition, taking page alignment
; into account.
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,XT   ( xt -- )
;
; encloses the execution token into the dictionary, paying heed
; to PETTIL's requirement that XTs must be page-aligned and that
; secondaries are responsible for invoking 'page' to cross a page
; boundary
;
;": ,xt   ( xt -- )
;     herelsb $fc >
;     if
;         ['] page ,
;         herelsb
;         if
;             dp 1+!
;         then
;     then
;     , ;
;
;#ifdef HEADERS
;commaxtlfa
;    .byt $de,$ad
;    .byt (_commaxt-*-1)|bit7
;    .asc ",X","T"|bit7
;#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word exit

;--------------------------------------------------------------
;
;       CREATE
;
; * 83 compiler
;
; A defining word executed in the form
;     CREATE <name>                 
;     Creates a dictionary entry for <name>.  After <name> is
;     created, the next available dictionary location is the first
;     byte of <name>'s parameter field.  When <name> is
;     subsequently executed, the address of the first byte of
;     <name>'s parameter field is left on the stack.  CREATE does
;     not allocate space in <name>'s parameter field.
;
;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa ) 
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )                               
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )
#ifdef HEADERS
createlfa
    .byt $de,$ad
    .byt (_create-*-1)|bit7
    .asc "CREAT","E"|bit7
#endif
_create
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word bl                    ; ( bl )
#include "page.i65"
    .word _word                 ; ( nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa nfa )
#include "page.i65"
    .word _find                 ; ( nfa nfa addr2 flag )
#include "page.i65"
    .word swap                  ; ( nfa nfa flag addr2 )
#include "page.i65"
    .word drop                  ; ( nfa nfa flag )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(create03-*+1)
#include "pad.i65"
    .word clit                  ; ( nfa cfa $12 )
    .byt RVSON
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word over                  ; ( nfa cfa nfa )
#include "page.i65"
    .word count                 ; ( nfa cfa addr+1 len )
#include "page.i65"
    .word type                  ; ( nfa cfa )
#include "page.i65"
    .word clit
    .byt RVSOFF                 ; ( nfa cfa $92 )
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word _pdq
    .byt create02-*-1
    .asc    " EXISTS"           ; ( nfa cfa )
create02
#include "pad.i65"              ; ( nfa addr )
create03                        ; THEN
    .word drop                  ; ( nfa )
#include "page.i65"
    .word tor                   ; ( ) ( R; nfa )
#include "page.i65"
    .word clit                  ; ( $80 )
    .byt $80
#include "page.i65"
    .word rfetch                ; ( $80 nfa ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word _twodup               ; ( $80 len $80 len ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( $80 len len|bit7 ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len len|bit7 nfa ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len nfa ) ( R; nfa )
#include "page.i65"
    .word plus                  ; ( $80 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word dup                   ; ( $80 cfa-1 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 cfa-1 last ) ( R; nfa )
#include "page.i65"
    .word rot                   ; ( cfa-1 last $80 ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( cfa-1 last|bit7 ) ( R; nfa )
#include "page.i65"
    .word over                  ; ( cfa-1 last|bit7 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( cfa-1 ) ( R; nfa )
#include "page.i65"
    .word oneplus               ; ( cfa ) ( R; nfa )
#include "page.i65"
    .word dp                    ; ( cfa dp ) ( R; nfa )
#include "page.i65"
    .word store                 ; ( )  ( R; nfa )
#include "page.i65"
    .word plit
    .word docreate              ; ( 'docreate ) ( R; nfa )
#include "pad.i65"
    .word _commacfa             ; ( ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( nfa ) ( R; nfa )
#include "page.i65"
    .word dhash                 ; ( hash1 hash2 ) ( R; nfa )
#include "page.i65"
    .word bloomstore            ; ( hash1 ) ( R; nfa )
#include "page.i65"
    .word rfrom                 ; ( hash1 nfa ) ( R; nfa )
#include "page.i65"
    .word twominus              ; ( hash1 lfa )
#include "page.i65"
    .word swap                  ; ( lfa hash1 )
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word dhashstore            ; ( )
#include "page.i65"
    .word exit                  ; ( )
docreate
    pla
    clc
    adc #1
    sta n
    pla
    tay
    bcc docreate01
    iny
docreate01
    lda n
    jmp pushya

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;
; * 83 compiler
;
; "colon"
;" A defining word executed in the form:
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
;--------------------------------------------------------------
;
;       ENTER
;
;               IP -> -[RP]
;               W -> IP
;               NEXT
;
enter
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta storex      ;[3]
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda storex      ;[3]
    sta ip+1        ;[3]
    iny             ;[2]
    beq enter02     ;[2]
enter01
    sty ip          ;[3]
    jmp nexto       ;[3]
enter02
    inc ip+1
    bne enter01     ; bra

;--------------------------------------------------------------
;
;       ;   ( -- )
;
; * 83 compiler
;
#ifdef HEADERS
semilfa
    .byt $de,$ad
    .byt (semi-*-1)|bit7|bit6
    .asc ";"|bit7
#endif
semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _lbracket
    .word exit

;--------------------------------------------------------------
;
;       CONSTANT   ( n -- )
;
; * 83 compiler
;
#ifdef HEADERS
constantlfa
    .byt $de,$ad
    .byt (_constant-*-1)|bit7
    .asc "CONSTAN","T"|bit7
#endif
_constant
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
doconst
    pla
    sta n
    pla
    sta n+1
    ldy #2
    lda (n),y
    sta n+2         ; high byte
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya

;--------------------------------------------------------------
;
;       VARIABLE   ( -- )
;
; * 83 compiler
;
#ifdef HEADERS
variablelfa
    .byt $de,$ad
    .byt (_variable-*-1)|bit7
    .asc "VARIABL","E"|bit7
#endif
_variable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       USER   ( n -- )
;
#ifdef HEADERS
userlfa
    .byt $de,$ad
    .byt (user-*-1)|bit7
    .asc "USE","R"|bit7
#endif
user
#include "enter.i65"
    .word _constant
#include "page.i65"
    .word _psemi
uservar
    pla
    tay
    pla
    sta n+1
    iny
    bne uservar01
    inc n+1
uservar01
    sty n
    ldy #0
    clc
    lda up
    adc (n),y
    sta n
    lda up+1
    adc #0
    tay
    lda n
    jmp pushya

;--------------------------------------------------------------
;
;       +ORIGIN
;
#ifdef HEADERS
plusoriginlfa
    .byt $de,$ad
    .byt (_plusorigin-*-1)|bit7
    .asc "+ORIGI","N"|bit7
#endif
_plusorigin
#include "enter.i65"
    .word plit
    .word userarea
#include "pad.i65"
    .word plus
    .word exit

;--------------------------------------------------------------
;
;       SP0
;
#ifdef HEADERS
spzlfa
    .byt $de,$ad
    .byt (sp0-*-1)|bit7
    .asc "SP","0"|bit7
#endif
sp0
    jsr uservar
    .byt usersp0-userarea

;--------------------------------------------------------------
;
;       RP0
;
#ifdef HEADERS
rpzlfa
    .byt $de,$ad
    .byt (rp0-*-1)|bit7
    .asc "RP","0"|bit7
#endif
rp0
    jsr uservar
    .byt userrp0-userarea


; ^ warm
; |
;  >  user variables pre-initialized from the dictionary
; |
; v cold

;--------------------------------------------------------------
;
;       FENCE
;
#ifdef HEADERS
fencelfa
    .byt $de,$ad
    .byt (fence-*-1)|bit7
    .asc "FENC","E"|bit7
#endif
fence
    jsr uservar
    .byt userfence-userarea

;--------------------------------------------------------------
;
;       DP
;
#ifdef HEADERS
dplfa
    .byt $de,$ad
    .byt (dp-*-1)|bit7
    .asc "D","P"|bit7
#endif
dp
    jsr uservar
    .byt userdp-userarea

;--------------------------------------------------------------
;
;       MEMSIZ
;
; top of RAM
;
#ifdef HEADERS
memsizlfa
    .byt $de,$ad
    .byt (memsiz-*-1)|bit7
    .asc "MEMSI","Z"|bit7
#endif
memsiz
    jsr uservar
    .byt usermemsiz-userarea


; ^ cold
; |
;  >  user variables pre-initialized from the dictionary
; |
; v soft
;
; user variables beyond this point are not pre-initialized from the dictionary
;

;--------------------------------------------------------------
;
;       BLK   ( -- addr )
;
; * 83 interpreter
;
; The address of a variable containing the number of the mass
; storage block being interpreted as the input stream.  If the
; value of BLK is zero the input stream is taken from the text
; input buffer.  {{0..the number of blocks available -1}}
; -1 = cassette tape 1 ~
; -2 = cassette tape 2 ~
#ifdef HEADERS
blklfa
    .byt $de,$ad
    .byt (blk-*-1)|bit7
    .asc "BL","K"|bit7
#endif
blk
    jsr uservar
    .byt userblk-userarea

;--------------------------------------------------------------
;
;       >IN   ( -- addr )
;
; * 83 interpreter
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The address of a user variable which contains the present
; character offset within the input stream.  See: WORD
#ifdef HEADERS
toinlfa
    .byt $de,$ad
    .byt (toin-*-1)|bit7
    .asc ">I","N"|bit7
#endif
toin
    jsr uservar
    .byt usertoin-userarea

;--------------------------------------------------------------
;
;       #OUT
;
#ifdef HEADERS
numoutlfa
    .byt $de,$ad
    .byt (numout-*-1)|bit7
    .asc "#OU","T"|bit7
#endif
numout
    jsr uservar
    .byt usernumout-userarea

;--------------------------------------------------------------
;
;       SCR   ( -- addr )
;
; The address of a user variable containing the
; number of the screen most recently LISTed or EDITed
;
#ifdef HEADERS
scrlfa
    .byt $de,$ad
    .byt (scr-*-1)|bit7
    .asc "SC","R"|bit7
#endif
scr
    jsr uservar
    .byt userscr-userarea

;--------------------------------------------------------------
;
;       OFFSET
;
#ifdef HEADERS
offsetlfa
    .byt $de,$ad
    .byt (offset-*-1)|bit7
    .asc "OFFSE","T"|bit7
#endif
offset
    jsr uservar
    .byt useroffset-userarea

;--------------------------------------------------------------
;
;       CONTEXT
;
#ifdef HEADERS
contextlfa
    .byt $de,$ad
    .byt (context-*-1)|bit7
    .asc "CONTEX","T"|bit7
#endif
context
    jsr uservar
    .byt usercontext-userarea

;--------------------------------------------------------------
;
;       CURRENT
;
#ifdef HEADERS
currentlfa
    .byt $de,$ad
    .byt (current-*-1)|bit7
    .asc "CURREN","T"|bit7
#endif
current
    jsr uservar
    .byt usercurrent-userarea

;--------------------------------------------------------------
;
;       STATE
;
; * 83 compiler
;
; The address of the user variable containing the
; compilation  state.    A non-zero content indi-
; cates compilation is occuring,  but  the  value
; itself is system dependent.  A Standard Program
; may not modify this variable.
;
#ifdef HEADERS
statelfa
    .byt $de,$ad
    .byt (state-*-1)|bit7
    .asc "STAT","E"|bit7
#endif
state
    jsr uservar
    .byt userstate-userarea

;--------------------------------------------------------------
;
;       BASE
;
; * 83 interpreter
;
#ifdef HEADERS
baselfa
    .byt $de,$ad
    .byt (base-*-1)|bit7
    .asc "BAS","E"|bit7
#endif
base
    jsr uservar
    .byt userbase-userarea

;--------------------------------------------------------------
;
;       DPL
;
#ifdef HEADERS
dpllfa
    .byt $de,$ad
    .byt (dpl-*-1)|bit7
    .asc "DP","L"|bit7
#endif
dpl
    jsr uservar
    .byt userdpl-userarea

;--------------------------------------------------------------
;
;       SPAN   ( -- addr )
;
; * 83 interpreter
;
; Returns the address of the user variable that
; contains the count of characters received and
; stored by the most recent execution of EXPECT .
span
    jsr uservar
    .byt userspan-userarea

;--------------------------------------------------------------
;
;       CSP
;
#ifdef HEADERS
csplfa
    .byt $de,$ad
    .byt (csp-*-1)|bit7
    .asc "CS","P"|bit7
#endif
csp
    jsr uservar
    .byt usercsp-userarea

;--------------------------------------------------------------
;
;       R#
;
#ifdef HEADERS
rsharplfa
    .byt $de,$ad
    .byt (rsharp-*-1)|bit7
    .asc "R","#"|bit7
#endif
rsharp
    jsr uservar
    .byt userrsharp-userarea

;--------------------------------------------------------------
;
;       HLD
;
#ifdef HEADERS
hldlfa
    .byt $de,$ad
    .byt (hld-*-1)|bit7
    .asc "HL","D"|bit7
#endif
hld
    jsr uservar
    .byt userhld-userarea

;--------------------------------------------------------------
;
;       #TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}  See:  "input stream"
#ifdef HEADERS
numtiblfa
    .byt $de,$ad
    .byt (numtib-*-1)|bit7
    .asc "#TI","B"|bit7
#endif
numtib
    jsr uservar
    .byt usertib-userarea

;--------------------------------------------------------------
;
;       #LINE
;
#ifdef HEADERS
numlinelfa
    .byt $de,$ad
    .byt (numline-*-1)|bit7
    .asc "#LIN","E"|bit7
#endif
numline
    jsr uservar
    .byt userline-userarea

;--------------------------------------------------------------
;
;       VMSIZ   ( -- addr )
;
#ifdef HEADERS
vmsizlfa
    .byt $de,$ad
    .byt (vmsiz-*-1)|bit7
    .asc "VMSI","Z"|bit7
#endif
vmsiz
    jsr uservar
    .byt uservmsiz-userarea

;--------------------------------------------------------------
;
;       SYMTAB   ( -- addr )
;
; user variable containing the beginning of the symbol table
;
#ifdef HEADERS
symtablfa
    .byt $de,$ad
    .byt (symtab-*-1)|bit7
    .asc "SYMTA","B"|bit7
#endif
symtab
    jsr uservar
    .byt usersymtab-userarea

;--------------------------------------------------------------
;
;       VMBUF
;
#ifdef HEADERS
vmbuflfa
    .byt $de,$ad
    .byt (vmbuf-*-1)|bit7
    .asc "VMBU","F"|bit7
#endif
vmbuf
    jsr uservar
    .byt uservmbuf-userarea

;--------------------------------------------------------------
;
;       -1   ( -- -1 )
;
#ifdef HEADERS
minusonelfa
    .byt $de,$ad
    .byt (minusone-*-1)|bit7
    .asc "-","1"|bit7
#endif
minusone
    jmp true

;--------------------------------------------------------------
;
;       0   ( -- 0 )
;
#ifdef HEADERS
zerolfa
    .byt $de,$ad
    .byt (zero-*-1)|bit7
    .asc "0"|bit7
#endif
zero
    jmp false

;--------------------------------------------------------------
;
;       1   ( -- 1 )
;
#ifdef HEADERS
onelfa
    .byt $de,$ad
    .byt (one-*-1)|bit7
    .asc "1"|bit7
#endif
one
    jsr doconst
    .word 1

;--------------------------------------------------------------
;
;       2   ( -- 2 )
;
#ifdef HEADERS
twolfa
    .byt $de,$ad
    .byt (two-*-1)|bit7
    .asc "2"|bit7
#endif
two
    jsr doconst
    .word 2

;--------------------------------------------------------------
;
;       3   ( -- 3 )
;
#ifdef HEADERS
threelfa
    .byt $de,$ad
    .byt (three-*-1)|bit7
    .asc "3"|bit7
#endif
three
    jsr doconst
    .word 3

;--------------------------------------------------------------
;
;       BL   ( -- n )
;
#ifdef HEADERS
bllfa
    .byt $de,$ad
    .byt (bl-*-1)|bit7
    .asc "B","L"|bit7
#endif
bl
    jsr doconst
    .word $20

;--------------------------------------------------------------
;
;       C/L   ( -- n )
;
#ifdef HEADERS
cperllfa
    .byt $de,$ad
    .byt (cperl-*-1)|bit7
    .asc "C/","L"|bit7
#endif
cperl
    jsr doconst
    .word 80

;--------------------------------------------------------------
;
;       FIRST   ( -- addr )
;
;~ fix this to read actual top of memory
#ifdef HEADERS
firstlfa
    .byt $de,$ad
    .byt (first-*-1)|bit7
    .asc "FIRS","T"|bit7
#endif
first
    jsr doconst
    .word $7000

;--------------------------------------------------------------
;
;       LIMIT   ( -- addr )
;
;~ fix this to read actual top of memory
#ifdef HEADERS
limitlfa
    .byt $de,$ad
    .byt (limit-*-1)|bit7
    .asc "LIMI","T"|bit7
#endif
limit
    jsr doconst
    .word $8000

;--------------------------------------------------------------
;
;       #BUF   ( -- n )
;
#ifdef HEADERS
numbuflfa
    .byt $de,$ad
    .byt (numbuf-*-1)|bit7
    .asc "#BU","F"|bit7
#endif
numbuf
    jsr doconst
    .word 4

;--------------------------------------------------------------
;
;       #BCQ   ( -- n )
;
#ifdef HEADERS
numbcqlfa
    .byt $de,$ad
    .byt (numbcq-*-1)|bit7
    .asc "#BC","Q"|bit7
#endif
numbcq
    jsr doconst
    .word 32

;--------------------------------------------------------------
;
;       B/BUF   ( -- n )
;
#ifdef HEADERS
bperbuflfa
    .byt $de,$ad
    .byt (bperbuf-*-1)|bit7
    .asc "B/BU","F"|bit7
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
;
;       B/SCR   ( -- n )
;
; Bytes per screen.  Not what it usually means in other Forths,
; (not blocks per screen = 1)
;
#ifdef HEADERS
bperscrlfa
    .byt $de,$ad
    .byt (bperscr-*-1)|bit7
    .asc "B/SC","R"|bit7
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
;
;       TIB   ( -- addr )
;
; * 83 interpreter
;
#ifdef HEADERS
tiblfa
    .byt $de,$ad
    .byt (tib-*-1)|bit7
    .asc "TI","B"|bit7
#endif
tib
    jsr doconst
    .word BUF       ; $0200

;--------------------------------------------------------------
;
;       VIDRAM   ( -- addr )
;
; address of PET video memory $8000
;
#ifdef HEADERS
vidramlfa
    .byt $de,$ad
    .byt (vidram-*-1)|bit7
    .asc "VIDRA","M"|bit7
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
;
;       TRUE   ( -- -1 )
;
#ifdef HEADERS
truelfa
    .byt $de,$ad
    .byt (true-*-1)|bit7
    .asc "TRU","E"|bit7
#endif
true
    lda #$ff
    tay
    jmp pushya

;--------------------------------------------------------------
;
;       FALSE   ( -- 0 )
;
#ifdef HEADERS
falselfa
    .byt $de,$ad
    .byt (false-*-1)|bit7
    .asc "FALS","E"|bit7
#endif
false
    lda #0
    tay
    jmp pushya

;--------------------------------------------------------------
;
;       2DROP
;
#ifdef HEADERS
twodroplfa
    .byt $de,$ad
    .byt (twodrop-*-1)|bit7
    .asc "2DRO","P"|bit7
#endif
twodrop
    jmp poptwo

;--------------------------------------------------------------
;
;       0=
;
; * 83 nucleus
;
#ifdef HEADERS
zeqlfa
    .byt $de,$ad
    .byt (zeq-*-1)|bit7
    .asc "0","="|bit7
#endif
zeq
    ldy #$ff
    lda tos
    ora tos+1
    beq zeq01
    iny
zeq01
    tya
    jmp put

;--------------------------------------------------------------
;
;       0<
;
; * 83 nucleus
;
#ifdef HEADERS
zltlfa
    .byt $de,$ad
    .byt (zlt-*-1)|bit7
    .asc "0","<"|bit7
#endif
zlt
    ldy #0
    bit tos+1
    bpl zlt01
    dey
zlt01
    tya
    jmp put

;--------------------------------------------------------------
;
;       0<>
;
#ifdef HEADERS
znelfa
    .byt $de,$ad
    .byt (zne-*-1)|bit7
    .asc "0<",">"|bit7
#endif
zne
    lda tos
    ora tos+1
    beq zne01
    lda #$ff
zne01
    tay
    jmp put

;--------------------------------------------------------------
;
;       1+
;
; * 83 nucleus
;
#ifdef HEADERS
onepluslfa
    .byt $de,$ad
    .byt (oneplus-*-1)|bit7
    .asc "1","+"|bit7
#endif
oneplus
    inc tos
    bne oneplus01
    inc tos+1
oneplus01
    jmp next

;--------------------------------------------------------------

;
;       1-
;
; * 83 nucleus
;
#ifdef HEADERS
oneminuslfa
    .byt $de,$ad
    .byt (oneminus-*-1)|bit7
    .asc "1","-"|bit7
#endif
oneminus
    lda tos
    bne oneminus01
    dec tos+1
oneminus01      dec tos
    jmp next

;--------------------------------------------------------------
;
;       2-
;
; * 83 nucleus
;
#ifdef HEADERS
twominuslfa
    .byt $de,$ad
    .byt (twominus-*-1)|bit7
    .asc "2","-"|bit7
#endif
twominus
    sec
    lda tos
    sbc #2
    sta tos
    bcs twominus01
    dec tos+1
twominus01
    jmp next

;--------------------------------------------------------------
;
;       2/
;
; * 83 nucleus
;
#ifdef HEADERS
twoslashlfa
    .byt $de,$ad
    .byt (twoslash-*-1)|bit7
    .asc "2","/"|bit7
#endif
twoslash
    lsr tos+1
    ror tos
    jmp next

;--------------------------------------------------------------
;
;       2*
;
#ifdef HEADERS
twostarlfa
    .byt $de,$ad
    .byt (twostar-*-1)|bit7
    .asc "2","*"|bit7
#endif
twostar
    asl tos
    rol tos+1
    jmp next

;--------------------------------------------------------------
;
;       HERE
;
; * 83 interpreter
;
#ifdef HEADERS
herelfa
    .byt $de,$ad
    .byt (here-*-1)|bit7
    .asc "HER","E"|bit7
#endif
here
    ldy #(userdp-userarea)
    lda (up),y
    pha
    iny
    lda (up),y
    tay
    pla
    jmp pushya

;--------------------------------------------------------------
;
;       -
;
; * 83 nucleus
;
; 09/15/10 cah
#ifdef HEADERS
minuslfa
    .byt $de,$ad
    .byt (minus-*-1)|bit7
    .asc "-"|bit7
#endif
minus
    jsr donegate
    jmp plus

;--------------------------------------------------------------
;
;       =   ( n1 n2 -- flag )
;
; * 83 nucleus
;
#ifdef HEADERS
eqlfa
    .byt $de,$ad
    .byt (eq-*-1)|bit7
    .asc "="|bit7
#endif
eq
    ldy #0
    lda tos
    cmp stackl,x
    bne cmpout
    lda tos+1
    cmp stackh,x
    bne cmpout
    dey
cmpout
    inx
    tya
    jmp put

;--------------------------------------------------------------
;
;       U<
;
; * 83 nucleus
;
#ifdef HEADERS
ultlfa
    .byt $de,$ad
    .byt (ult-*-1)|bit7
    .asc "U","<"|bit7
#endif
ult
    ldy #0
    lda stackl,x
    cmp tos
    lda stackh,x
    sbc tos+1
    bcs cmpout
    dey
    bmi cmpout

;--------------------------------------------------------------
;
;       <   ( n1 n2 -- flag )
;
; * 83 nucleus
;
#ifdef HEADERS
ltlfa
    .byt $de,$ad
    .byt (lt-*-1)|bit7
    .asc "<"|bit7
#endif
lt
    ldy #0
    lda stackl,x
    cmp tos
    lda stackh,x
    sbc tos+1
sgntst
    bvc lt01
    eor #bit7
lt01
    bpl cmpout
    dey
    bmi cmpout

;--------------------------------------------------------------
;
;       >   ( n1 n2 -- flag )
;
; * 83 nucleus
;
; V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
#ifdef HEADERS
gtlfa
    .byt $de,$ad
    .byt (gt-*-1)|bit7
    .asc ">"|bit7
#endif
gt
    ldy #0
    lda tos
    cmp stackl,x
    lda tos+1
    sbc stackh,x
    jmp sgntst

;--------------------------------------------------------------
;
;       ROT   ( a b c -- b c a )
;
; * 83 nucleus
;
#ifdef HEADERS
rotlfa
    .byt $de,$ad
    .byt (rot-*-1)|bit7
    .asc "RO","T"|bit7
#endif
rot
    ldy stackh+1,x
    lda stackh,x
    sta stackh+1,x
    lda tos+1
    sta stackh,x
    sty tos+1
    ldy stackl+1,x
    lda stackl,x
    sta stackl+1,x
    lda tos
    sta stackl,x
    sty tos
    jmp next

;--------------------------------------------------------------
;
;       -ROT   ( a b c -- c a b )
;
;": -rot   ( a b c -- c a b )
;     rot rot ;
;
;dashrot
;    ldy tos+1       ; c
;    lda stackh,x
;    sta tos+1       ; b -> tos
;    lda stackh+1,x
;    sta stackh,x    ; a -> 2os
;    sty stackh+1,x  ; c -> 3os
;    ldy tos
;    lda stackl,x
;    sta tos
;    lda stackl+1,x
;    sta stackl,x
;    sty stackl+1,x
;    jmp next
;
#ifdef HEADERS
dashrotlfa
    .byt $de,$ad
    .byt (_dashrot-*-1)|bit7
    .asc "-RO","T"|bit7
#endif
_dashrot
#include "enter.i65"
   .word rot
#include "page.i65"
   .word rot
#include "page.i65"
   .word exit

;--------------------------------------------------------------
;
;       THIRD   ( n1 n2 n3 -- n1 n2 n3 n1 )
;
; * 83 nucleus
;
#ifdef HEADERS
thirdlfa
    .byt $de,$ad
    .byt (third-*-1)|bit7
    .asc "THIR","D"|bit7
#endif
third
    lda stackl+1,x
    ldy stackh+1,x
    jmp pushya

;--------------------------------------------------------------
;
;       +UNDER   ( n1 n2 n3 -- n1+n3 n2 )
;
; * 83 nucleus
;
#ifdef HEADERS
plusunderlfa
    .byt $de,$ad
    .byt (plusunder-*-1)|bit7
    .asc "+UNDE","R"|bit7
#endif
plusunder
    clc
    lda tos
    adc stackl+1,x
    sta stackl+1,x
    lda tos+1
    adc stackh+1,x
    sta stackh+1,x
    jmp pops

;--------------------------------------------------------------
;
;       SPACE
;
; * 83 device
;
#ifdef HEADERS
spacelfa
    .byt $de,$ad
    .byt (_space-*-1)|bit7
    .asc "SPAC","E"|bit7
#endif
_space
#include "enter.i65"
    .word bl
#include "page.i65"
    .word emit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?DUP   ( 0 -- 0 | n -- n n )
;
; * 83 nucleus
;
; DUP if top of stack is nonzero
#ifdef HEADERS
qduplfa
    .byt $de,$ad
    .byt (qdup-*-1)|bit7
    .asc "?DU","P"|bit7
#endif
qdup
    lda tos
    ora tos+1
    beq qdup01
    lda tos
    ldy tos+1
    jmp pushya
qdup01
    jmp next

;--------------------------------------------------------------
;
;       TRAVERSE   ( addr n -- addr )
;
; * dictionary
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"      SWAP
;"      BEGIN
;"              OVER +  127  OVER C@  <
;"      UNTIL
;"      SWAP DROP ;
#ifdef HEADERS
traverselfa
    .byt $de,$ad
    .byt (_traverse-*-1)|bit7
    .asc "TRAVERS","E"|bit7
#endif
_traverse
#include "enter.i65"
    .word swap
#include "page.i65"
traverse01      .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word clit
    .byt $7f
#include "pad.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(traverse01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LATEST   ( -- NFA )
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
#ifdef HEADERS
latestlfa
    .byt $de,$ad
    .byt (_latest-*-1)|bit7
    .asc "LATES","T"|bit7
#endif
_latest
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORTH-83
;
; * 83 interpreter
;
; ~ make sure it's really Forth-83 compliant before making this word available
;
#ifdef HEADERS
forth83lfa
    .byt $de,$ad
    .byt (forth83-*-1)|bit7
    .asc "FORTH-8","3"|bit7
#endif
forth83
    jmp next

; ~ better to follow ANS-Forth standard for this group?
;--------------------------------------------------------------
;
;       >BODY   ( cfa -- pfa )
;
; * 83 interpreter
;
; convert the compilation address (CFA) to the address of the parameter field.
#ifdef HEADERS
tobodylfa
    .byt $de,$ad
    .byt (_tobody-*-1)|bit7
    .asc ">BOD","Y"|bit7
#endif
_tobody
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
#ifdef HEADERS
tonamelfa
    .byt $de,$ad
    .byt (_toname-*-1)|bit7
    .asc ">NAM","E"|bit7
#endif
_toname
#include "enter.i65"
    .word oneminus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
#ifdef HEADERS
tolinklfa
    .byt $de,$ad
    .byt (_tolink-*-1)|bit7
    .asc ">LIN","K"|bit7
#endif
_tolink
#include "enter.i65"
    .word _toname
#include "page.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BODY>   ( PFA -- CFA )
;
#ifdef HEADERS
bodyfromlfa
    .byt $de,$ad
    .byt (_bodyfrom-*-1)|bit7
    .asc "BODY",">"|bit7
#endif
_bodyfrom
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NAME>   ( nfa -- cfa )
;
#ifdef HEADERS
namefromlfa
    .byt $de,$ad
    .byt (_namefrom-*-1)|bit7
    .asc "NAME",">"|bit7
#endif
_namefrom
#include "enter.i65"
    .word one
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LINK>   ( lfa -- cfa )
;
#ifdef HEADERS
linkfromlfa
    .byt $de,$ad
    .byt (_linkfrom-*-1)|bit7
    .asc "LINK",">"|bit7
#endif
_linkfrom
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       N>LINK   ( nfa -- lfa )
;
#ifdef HEADERS
ntolinklfa
    .byt $de,$ad
    .byt (_ntolink-*-1)|bit7
    .asc "N>LIN","K"|bit7
#endif
_ntolink
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       L>NAME   ( lfa -- nfa )
;
#ifdef HEADERS
linktonamelfa
    .byt $de,$ad
    .byt (_linktoname-*-1)|bit7
    .asc "L>NAM","E"|bit7
#endif
_linktoname
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       !CSP
;
#ifdef HEADERS
storecsplfa
    .byt $de,$ad
    .byt (_storecsp-*-1)|bit7
    .asc "!CS","P"|bit7
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       COUNT   ( addr1 -- addr2 n1 )
;
; * 83 nucleus
;
; Leaves the address, addr2 and the character
; count +n of text beginning at addr1.
; addr2 is addr1+1 and n1 is the length of the
; counted string at addr1.  The byte at addr1 con-
; tains the byte count +n.  Range of +n is
; {0...255}.
#ifdef HEADERS
countlfa
    .byt $de,$ad
    .byt (count-*-1)|bit7
    .asc "COUN","T"|bit7
#endif
count
    ldy #0
    lda (tos),y
    inc tos
    bne count01
    inc tos+1
count01         jmp pushya

;--------------------------------------------------------------
;
;       TYPE   ( addr count -- )
;
; * 83 device
;
#ifdef HEADERS
typelfa
    .byt $de,$ad
    .byt (type-*-1)|bit7
    .asc "TYP","E"|bit7
#endif
type
    ldy #1
    jsr locals
    clc
    lda tos
    ldy numout+3
    adc (up),y
    sta (up),y
    iny
    lda tos+1
    adc (up),y
    sta (up),y
    ldy #0
type01
    cpy tos
    bne type02
    dec tos+1
    bpl type02
    jmp pops
type02
    lda (n),y
    jsr CHROUT
    iny
    bne type01
    inc n+1
    bne type01

;--------------------------------------------------------------
;
;       SETIRQ   ( newirq -- oldirq )
;
; Safely changes the IRQ vector at $90-$91 to the new value,
; leaving the previous value on the stack
#ifdef HEADERS
setirqlfa
    .byt $de,$ad
    .byt (setirq-*-1)|bit7
    .asc "SETIR","Q"|bit7
#endif
setirq
    sei
    ldy 1+CINV
    lda CINV                ; old IRQ --> ya
    pha
    lda tos+1
    sta 1+CINV
    lda tos
    sta CINV                ; tos --> IRQ
    pla
    cli
    jmp put

;--------------------------------------------------------------
;
;       3C@   ( addr -- d )
;
; fetches three bytes as a double.  Useful for retrieving screen
; linewrap bits from the beginning of the block buffer or the jiffy
; clock
;
; msb addr+0
; 2sb addr+1
; lsb addr+2
;
;": 3c@   ( addr -- d )
;     dup 1+ @ swap c@ ;
;
#ifdef HEADERS
threecfetchlfa
    .byt $de,$ad
    .byt (threecfetch-*-1)|bit7
    .asc "3C","@"|bit7
#endif
threecfetch
    jsr slip
    ldy #2
    lda (tos),y         ; msb
    sta stackl,x
    dey
    lda (tos),y
    sta stackh,x
    dey
    lda (tos),y
    jmp put             ; [20]

;--------------------------------------------------------------
;
;       3C!   ( d addr -- )
;
; store low 3 bytes of d at addr in jiffy clock order
;
; msb addr
; 2sb addr+1
; lsb addr+2
;
;": 3c!    ( d addr -- )
;     2dup c!  nip 1+ ! ;
;
;_threecstore
;#include "enter.i65"
;    .word _twodup
;#include "page.i65"
;    .word cstore
;#include "page.i65"
;    .word _nip
;#include "page.i65"
;    .word oneplus
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit
;
#ifdef HEADERS
threecstorelfa
    .byt $de,$ad
    .byt (threecstore-*-1)|bit7
    .asc "3C","!"|bit7
#endif
threecstore
    ldy #0
    lda stackl,x                ; msb
    sta (tos),y
    iny
    lda stackh+1,x              ; 2sb
    sta (tos),y
    iny
    lda stackl+1,x              ; lsb
    sta (tos),y
    inx                         ; discard 3 cells
    jmp poptwo

;--------------------------------------------------------------
;
;       IRQ^   ( -- )
;
; toggle the processor IRQ flag
;
#ifdef HEADERS
irqfliplfa
    .byt $de,$ad
    .byt (irqflip-*-1)|bit7
    .asc "IRQ",94|bit7
#endif
irqflip
    php
    pla
    eor #$04        ; toggle I flag
    pha
    plp
    jmp next

;--------------------------------------------------------------
;
;       JIFFY@   ( --  djiffyclock )
;
; returns number of jiffies since powerup or midnight as a double
;
;jiffyfetch
;    sei
;    jsr slip
;    lda TIME+2
;    sta tos
;    lda TIME+1
;    sta tos+1
;    ldy #0
;    lda TIME
;    cli
;    jmp pushya ; [20]
;
#ifdef HEADERS
jiffyfetchlfa
    .byt $de,$ad
    .byt (_jiffyfetch-*-1)|bit7
    .asc "JIFFY","@"|bit7
#endif
_jiffyfetch
#include "enter.i65"
    .word irqflip
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word irqflip
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
;
;       CMDOFF
;
#ifdef HEADERS
cmdofflfa
    .byt $de,$ad
    .byt (cmdoff-*-1)|bit7
    .asc "CMDOF","F"|bit7
#endif
cmdoff
    stx storex
    jsr CLRCHN
    ldx storex
    jmp next

;--------------------------------------------------------------
;
;       FAIL    ( err# -- )
#ifdef HEADERS
faillfa
    .byt $de,$ad
    .byt (fail-*-1)|bit7
    .asc "FAI","L"|bit7
#endif
fail
#include "enter.i65"
    .word oneminus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plit
    .word errptr
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word _abort

;--------------------------------------------------------------
;
;       (ABORT")   ( flag -- )
;
; * outer interpreter headerless
;
; if the flag is nonzero, types the inline counted string from the
; dictionary and executes the word in STARTUP.  Otherwise adjusts IP
; to after the string, paging if necessary
;
;#ifdef HEADERS
;pabortqlfa
;    .byt $de,$ad
;    .byt (_pabortq-*-1)|bit7
;    .asc "(ABORT",'"',")"|bit7
;#endif
_pabortq
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word rot
#include "page.i65"
    .word qbranch
    .byt <(pabortq01-*+1)
#include "pad.i65"
pabortq02
    .word cmdoff
;#include "page.i65"
;               .word _where
;#include "page.i65"
;               .word cr
;#include "page.i65"
;               .word type
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
pabortq01
    .word plus
#include "page.i65"
    .word to6502
    jmp skipinline

;--------------------------------------------------------------
;
;       ABORT"   ( flag -- ) ( -- ; compiling )
;
; * 83 compiler immediate
;
; ~ handle page boundary crossings
#ifdef HEADERS
abortqlfa
    .byt $de,$ad
    .byt (_abortq-*-1)|bit7|bit6
    .asc "ABORT",'"'|bit7
#endif
_abortq
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word _pabortq
#include "page.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?COMP
;
;#ifdef HEADERS
;qcomplfa
;    .byt $de,$ad
;    .byt (_qcomp-*-1)|bit7
;    .asc "?COM","P"|bit7
;#endif
_qcomp
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(qcomp01-*+1)
#include "pad.i65"
    .word clit
    .byt 5
#include "page.i65"
    .word fail
#include "page.i65"
qcomp01
    .word exit

;--------------------------------------------------------------
;
;       ?FIND
;
;#ifdef HEADERS
;qfindlfa
;    .byt $de,$ad
;    .byt (_qfind-*-1)|bit7
;    .asc "?FIN","D"|bit7
;#endif
_qfind
#include "enter.i65"
    .word qbranch
    .byt <(qfind01-*+1)
#include "pad.i65"
    .word three
#include "page.i65"
    .word fail
#include "page.i65"
qfind01
    .word exit

;--------------------------------------------------------------
;
;       ?PAIRS
;
;#ifdef HEADERS
;qpairslfa
;    .byt $de,$ad
;    .byt (_qpairs-*-1)|bit7
;    .asc "?PAIR","S"|bit7
;#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
;
;       ?CSP
;
#ifdef HEADERS
qcsplfa
    .byt $de,$ad
    .byt (_qcsp-*-1)|bit7
    .asc "?CS","P"|bit7
#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
;
;       ?CHAR   ( -- )
;
#ifdef HEADERS
qcharlfa
    .byt $de,$ad
    .byt (_qchar-*-1)|bit7
    .asc "?CHA","R"|bit7
#endif
_qchar
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word over
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(qchar02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word cr
#include "page.i65"
    .word emit
#include "page.i65"
    .word _pdq
    .byt qchar01-*-1
    .asc    " MISSING "
    ;123456789
qchar01
#include "pad.i65"
    .word _abort
#include "page.i65"
qchar02         .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       COMPILE
;
; * 83 compiler
;
#ifdef HEADERS
compilelfa
    .byt $de,$ad
    .byt (_compile-*-1)|bit7
    .asc "COMPIL","E"|bit7
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [
;
; * 83 compiler
;
#ifdef HEADERS
lbracketlfa
    .byt $de,$ad
    .byt (_lbracket-*-1)|bit7
    .asc "["|bit7
#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ]
;
; * 83 compiler
;
#ifdef HEADERS
rbracketlfa
    .byt $de,$ad
    .byt (_rbracket-*-1)|bit7
    .asc "]"|bit7
#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
rbracket01      .word qstack
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02      .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04      .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05      .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       SMUDGE
;
#ifdef HEADERS
smudgelfa
    .byt $de,$ad
    .byt (_smudge-*-1)|bit7
    .asc "SMUDG","E"|bit7
#endif
_smudge
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt bit5       ; $20
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       HEX
;
#ifdef HEADERS
hexlfa
  .byt $de,$ad
    .byt (_hex-*-1)|bit7
    .asc "HE","X"|bit7
#endif
_hex
#include "enter.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DECIMAL
;
; * 83 interpreter
;
#ifdef HEADERS
decimallfa
    .byt $de,$ad
    .byt (_decimal-*-1)|bit7
    .asc "DECIMA","L"|bit7
#endif
_decimal
#include "enter.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (;CODE)
;
;#ifdef HEADERS
;psemilfa
;    .byt $de,$ad
;    .byt (_psemi-*-1)|bit7
;    .asc "(;CODE",")"|bit7
;#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DOES>
;
; * 83 compiler
;
#ifdef HEADERS
doeslfa
    .byt $de,$ad
    .byt (_does-*-1)|bit7
    .asc "DOES",">"|bit7
#endif
_does
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word _psemi
#include "pad.i65"
    .word clit
    .byt $20        ; jsr instruction
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _compile  ; ~ fix paging here
    .word dodoes
#include "pad.i65"
    .word exit
; I've got a pretzel in my brain!
; ~wut? at least comment what's going on here
dodoes          pla
    sta n
    pla
    sta n+1
    pla
    sta n+2
    pla
    sta n+3
    lda ip+1
    pha
    lda ip
    pha
    ldy n
    bne dodoes01
    dec n+1
dodoes01        dey
    sty ip
    lda n+1
    sta ip+1
    ldy n+3
    inc n+2
    bne dodoes02
    iny
dodoes02        lda n+2
    jmp pushya

;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
#ifdef HEADERS
dashtrailinglfa
    .byt $de,$ad
    .byt (dashtrailing-*-1)|bit7
    .asc "-TRAILIN","G"|bit7
#endif
dashtrailing
    brk
    .byt ld | TOS
    .byt st | N1
    .byt pull
    .byt add | N1
    .byt st | N0
    .byt ext
    .word dashtrailing16
    .byt ld | N0
    .byt sub | TOS
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       (.")   ( -- )
;
; * headerless
;
; types the inline counted string from the dictionary and moves IP
; to just after the string, paging if necessary
;
;#ifdef HEADERS
;pdqlfa
;    .byt $de,$ad
;    .byt (_pdq-*-1)|bit7
;    .asc "(.",'"',")"|bit7
;#endif
_pdq
#include "enter.i65"
    .word rfrom             ; ( cstring-2 )
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word type
#include "page.i65"
    .word plus
#include "page.i65"
    .word to6502
skipinline
    lda tos+1
    sta ip+1
    lda tos
    sta ip
    jsr slide
    lda #0
    jmp pad

;--------------------------------------------------------------
;
;       ."   ( -- )
;
; * 83 compiler
;
#ifdef HEADERS
dotqlfa
    .byt $de,$ad
    .byt (_dotq-*-1)|bit7
    .asc ".",'"'|bit7
#endif
_dotq
#include "enter.i65"
    .word _compile
    .word _pdq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .(
;
; * 83 interpreter
;
#ifdef HEADERS
dotplfa
    .byt $de,$ad
    .byt (_dotp-*-1)|bit7
    .asc ".","("|bit7
#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.
#ifdef HEADERS
expectlfa
    .byt $de,$ad
    .byt (expect-*-1)|bit7
    .asc "EXPEC","T"|bit7
#endif
expect
    jmp expectvector
expectvector
    ldy #1
    jsr locals
    stx storex
    dey
expect01
    iny
    cpy tos
    bcs expect02
    jsr CHRIN
    cmp #$0d
    beq expect02
    sta (n),y
    bne expect01
expect02
    tya
    ldy span+3
    sta (up),y
    iny
    lda #0
    sta (up),y
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       QUERY
;
#ifdef HEADERS
querylfa
    .byt $de,$ad
    .byt (_query-*-1)|bit7
    .asc "QUER","Y"|bit7
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;

;       QUIT?   ( flag -- flag )
;
#ifdef HEADERS
quitqlfa
    .byt $de,$ad
    .byt (_quitq-*-1)|bit7
    .asc "QUIT","?"|bit7
#endif
_quitq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ERASE
;
#ifdef HEADERS
eraselfa
    .byt $de,$ad
    .byt (_erase-*-1)|bit7
    .asc "ERAS","E"|bit7
#endif
_erase
#include "enter.i65"
    .word zero
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BLANK
;
#ifdef HEADERS
blanklfa
    .byt $de,$ad
    .byt (_blank-*-1)|bit7
    .asc "BLAN","K"|bit7
#endif
_blank
#include "enter.i65"
    .word bl
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       HOLD   ( char -- )
;
; * 83 interpreter
;
; Inserts  character into a pictured numeric out-
; put string.
; char is inserted into a pictured numeric output
; string.  Typically used between  <#  and  #> .
#ifdef HEADERS
holdlfa
    .byt $de,$ad
    .byt (_hold-*-1)|bit7
    .asc "HOL","D"|bit7
#endif
_hold
#include "enter.i65"
    .word minusone
#include "page.i65"
    .word hld
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PAD   ( -- addr )
;
; * 83 interpreter
;
; The lower address of a scratch area used to hold data for
; intermediate processing.  The address or contents of PAD may
; change and the data lost if the address of the next
; available dictionary location is changed.  The minimum
; capacity of PAD is 84 characters.

#ifdef HEADERS
padlfa
    .byt $de,$ad
    .byt (_pad-*-1)|bit7
    .asc "PA","D"|bit7
#endif
_pad
    ; ~wut? might want to rename the page-hopping primitive 'pad' to avoid confusion
#include "enter.i65"
    .word here
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       'STREAM   ( -- addr size )
;
;" : 'stream
;       blk @ ?dup
;       if      block b/buf
;       else    tib #tib @
;       then
;       >in @ over min >r swap r@ + swap r> - ;
#ifdef HEADERS
tickstreamlfa
   .byt $de,$ad
    .byt (_tickstream-*-1)|bit7
    .asc "'STREA","M"|bit7
#endif
_tickstream
#include "enter.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup              ; ( 0 | blk blk )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(tickstream01-*+1)
#include "pad.i65"
    ; input from block device
    .word plover            ; unimplemented
#include "page.i65"
    ; this is where the BLOCK i/o goes
    ; _block bperbuf        ; ( addr )
    .word branch            ; ELSE
    .byt <(tickstream02-*+1)
#include "pad.i65"
tickstream01                ; input from terminal
    .word tib               ; ( tib )
#include "page.i65"
    .word numtib            ; ( tib #tib.uarea )
#include "page.i65"
    .word fetch             ; ( tib #tib )
#include "page.i65"         ; THEN
tickstream02
    .word toin              ; ( buf size >in )
#include "page.i65"
    .word fetch             ; ( buf size offset )
#include "page.i65"
    .word over              ; ( buf size offset size )
#include "page.i65"
    .word _min              ; ( buf size offset )
#include "page.i65"
    .word tor               ; ( buf size )
#include "page.i65"
    .word swap              ; ( size buf )
#include "page.i65"
    .word rfetch            ; ( size buf offset )
#include "page.i65"
    .word plus              ; ( size addr )
#include "page.i65"
    .word swap              ; ( addr size )
#include "page.i65"
    .word rfrom             ; ( addr size offset )
#include "page.i65"
    .word minus             ; ( addr remaining )
#include "page.i65"
    .word exit

;               .word to6502
;               ldy #2
;               jsr locals
;               brk
;               .byt ldd  | TOS         ; >in @
;               .byt cpr  | N0          ; #tib or b/buf
;               .byt bm,  <(tickstream03-*-2)
;               .byt ld   | N0
;tickstream03   .byt st   | N2          ; smaller of (#tib or b/buf, >in)
;               .byt ld   | N1          ; tib
;               .byt add  | N2          ; cursor position
;               .byt st   | TOS
;               .byt ld   | N0
;               .byt sub  | N2          ; bytes remaining
;               .byt push               ; ( addr remaining )
;               .byt rtn
;               jmp exit
;#include "toforth.i65"
;               .word exit

;--------------------------------------------------------------
;
;       WORD   ( char -- addr )
;
; * 83 interpreter
;
; Generates a counted string by non-destructively accepting
; characters from the input stream until the delimiting
; character char is encountered or the input stream is
; exhausted.  Leading delimiters are ignored.  The entire
; character string is stored in memory beginning at addr as a
; sequence of bytes.  The string is followed by a blank which
; is not included in the count.  The first byte of the string
; is the number of characters {0..255}.  If the string is
; longer than 255 characters, the count is unspecified.  If
; the input stream is already exhausted as WORD is called,
; then a zero length character string will result.
;
; If the delimiter is not found the value of >IN is the size
; of the input stream.  If the delimiter is found >IN is
; adjusted to indicate the offset to the character following
; the delimiter.  #TIB is unmodified.           ; ( 0100 0104 0107 0009 )
;
; The counted string returned by WORD may reside in the "free"
; dictionary area at HERE or above.  Note that the text
;"interpreter may also use this area.
;"See: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream
;
; fig high level
;" : word   ( c -- addr )
;       blk @  if  blk @ block  else  tib @  then
;       >in @ + swap enclose here 34 blank >in +!
;       over - >r r@ here c! + here 1+ r> cmove ;
;
;" : word   ( c -- nfa )
;       >r                              ; ( -- ) r( c )
;       'stream
;       over swap
;       r@ skip
;       over swap
;       r> scan
;       drop 2dup swap -
;       >r
;       rot - 1+
;       >in +!
;       r> here
;       2dup c!
;       1+ swap cmove
;       here bl over
;       count + c! ;
;       here dup count +
;       bl swap c! ;
#ifdef HEADERS
wordlfa
    .byt $de,$ad
    .byt (_word-*-1)|bit7
    .asc "WOR","D"|bit7
#endif
_word
                                ; ( char )
#include "enter.i65"
    .word tor                   ; ( )
#include "page.i65"
    .word _tickstream           ; ( addr size )
#include "page.i65"
    .word over                  ; ( addr size addr )
#include "page.i65"
    .word swap                  ; ( addr addr size )
#include "page.i65"
    .word rfetch                ; ( addr addr size char )
#include "page.i65"
    .word skip                  ; ( addr addr2 size )
#include "page.i65"
    .word over                  ; ( addr addr2 size addr2 )
#include "page.i65"
    .word swap                  ; ( addr addr2 addr2 size )
#include "page.i65"
    .word rfrom                 ; ( addr addr2 addr2 size char )
#include "page.i65"
    .word scan                  ; ( addr addr2 addr3 size )
#include "page.i65"
    .word drop                  ; ( addr addr2 addr3 )
#include "page.i65"
    .word _twodup               ; ( addr addr2 addr3 addr2 addr3 )
#include "page.i65"
    .word swap                  ; ( addr addr2 addr3 addr3 addr2 )
#include "page.i65"
    .word minus                 ; ( addr addr2 addr3 wordlen )
#include "page.i65"
    .word tor                   ; ( addr addr2 addr3 )
#include "page.i65"
    .word rot                   ; ( addr2 addr3 addr )
#include "page.i65"
    .word minus                 ; ( addr2 offset )
#include "page.i65"
    .word oneplus               ; ( addr2 offset )
#include "page.i65"
    .word toin                  ; ( addr2 offset toin )
#include "page.i65"
    .word plusstore             ; ( addr2 )
#include "page.i65"
    .word rfrom                 ; ( addr2 size )
#include "page.i65"
    .word here                  ; ( addr2 size here )
#include "page.i65"
    .word twoplus               ; ( addr2 size here+2 )
#include "page.i65"
    .word _twodup               ; ( addr2 size here+2 size here+2 )
#include "page.i65"
    .word cstore                ; ( addr2 size here+2 )
#include "page.i65"
    .word oneplus               ; ( addr2 size here+3 )
#include "page.i65"
    .word swap                  ; ( addr2 here+3 size )
#include "page.i65"
    .word cmove                 ; ( )
#include "page.i65"
    .word here                  ; ( here )
#include "page.i65"
    .word twoplus               ; ( here+2 )
#include "page.i65"
    .word bl                    ; ( here+2 bl )
#include "page.i65"
    .word over                  ; ( here+2 bl here+2 )
#include "page.i65"
    .word count                 ; ( here+2 bl here+3 size )
#include "page.i65"
    .word plus                  ; ( here+2 bl here+size+3 )
#include "page.i65"
    .word cstore                ; ( here+2 )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (PUNCT?)
;
;#ifdef HEADERS
;ppunctqlfa
;    .byt $de,$ad
;    .byt (_ppunctq-*-1)|bit7
;    .asc "(PUNCT?",")"|bit7
;#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PUNCT?
;
;#ifdef HEADERS
;punctqlfa
;    .byt $de,$ad
;    .byt (_punctq-*-1)|bit7
;    .asc "PUNCT","?"|bit7
;#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       CONVERT   ( addr -- addr )
;
; * 83 interpreter
;
;": convert
;       begin
;               1+ dup >r c@ base @ digit
;       while
;               swap base @ um* drop rot base @ um* d+
;               dpl @ 1+
;               if
;                       1 dpl +!
;               then
;               r>
;       repeat
;       r> ;
;
;#ifdef HEADERS
;convertlfa
;    .byt $de,$ad
;    .byt (_convert-*-1)|bit7
;    .asc "CONVER","T"|bit7
;#endif
_convert
#include "enter.i65"
convert01       .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word digit
#include "page.i65"
    .word qbranch
    .byt <(convert03-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word umstar
#include "page.i65"
    .word drop
#include "page.i65"
    .word rot
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word umstar
#include "page.i65"
    .word dplus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(convert02-*+1)
#include "pad.i65"
    .word one
#include "page.i65"
    .word dpl
#include "page.i65"
    .word plusstore
#include "page.i65"
convert02
    .word rfrom
#include "page.i65"
    .word branch
    .byt <(convert01-*+1)
#include "pad.i65"
convert03
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NUMBER    ( addr -- d )
;
; Convert the counted string at addr, to a signed
; 32-bit integer, using the value of BASE .  If numeric
; conversion is not possible, an error condition exists.  The
; string may contain a preceding minus sign.
;
;( There is a string that is probably a number stored from addrlow..addrhigh -- caveat -- this probably has some bugs )
;": NUMBER  ( addr -- d ; convert a counted string to a signed double, keeping track of the decimal )
;   0 0 ROT COUNT   ( -- 0 0 addr+1 len )
;   OVER C@ [ ASCII - ] LITERAL  =   ( -- 0 0 addr+1 len negative? )
;"  DUP >R   ( -- 0 0 addr+1 len negative? ) ( R: -- negative? )
;   +   ( -- 0 0 addr+1 lenadj ; adjust length for sign char )
;   OVER + 1+   ( -- 0 0 addr+1 addrhigh+1 )
;   SWAP  R@ -   ( -- 0 0 addrhigh+1 addrlow )
;   DPL ON
;   ?DO   ( d )
;"     BASE @ >R   ( -- d ) ( R: -- base negative? )
;      I C@  R@  DIGIT   ( -- d currdigit~?~ flag )
;      IF
;         SWAP R@ UM*
;         DROP ROT
;         R@ UM* D+
;         DPL @ 1+  IF  DPL 1+!  THEN
;      ELSE
;         I C@ [ ASCII . ] LITERAL  =
;         DPL @ 0<  AND
;         IF
;            DPL OFF
;         ELSE
;            3 FAIL ( ABORT" NOT FOUND" - do not pass go do not collect $200 )
;         THEN
;      THEN
;"     R> DROP   ( R: -- negative? ; discard base )
;   LOOP
;   R>  IF  DNEGATE  THEN ;
;
; Blazin' does it like this --
;": number   ( addr -- double )
;       true over count over + swap   ( addr true lastchar firstchar )
;       ?do
;               i c@  base @  digit
;               if
;                       2drop false leave
;               then
;       loop
;       ?find
;       0 0 rot dup 1+
;       c@ [ ascii - ] =
;       dup >r -
;       dpl on
;       begin
;               convert dup c@ punct?
;       while
;               dpl off
;       repeat
;       c@ bl <>
;       ?find  r>
;       if
;               dnegate
;       then ;
;
#ifdef HEADERS
numberlfa
    .byt $de,$ad
    .byt (_number-*-1)|bit7
    .asc "NUMBE","R"|bit7
#endif
_number
#include "enter.i65"
    .word true      ; ( addr true )
#include "page.i65"
    .word over      ; ( addr true addr )
#include "page.i65"
    .word count     ; ( addr true addr+1 length )
#include "page.i65"
    .word over      ; ( addr true addr+1 length addr+1 )
#include "page.i65"
    .word plus      ; ( addr true addr+1 addr+length+1 )
#include "page.i65"
    .word swap      ; ( addr true addr+length+1 addr+1 )
#include "page.i65"
    .word pqdo      ; ( addr true )
    .byt <(number03-*+1)
#include "pad.i65"
number01
    .word i         ; ( addr true i )
#include "page.i65"
    .word cfetch    ; ( addr true char )
#include "page.i65"
    .word base      ; ( addr true char baseaddr )
#include "page.i65"
    .word fetch     ; ( addr true char base )
#include "page.i65"
    .word digit     ; ( addr true  digit true | false )
#include "page.i65"
    .word qbranch
    .byt <(number02-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word false
#include "page.i65"
    .word pleave
    .byt <(number03-*+1)
#include "pad.i65"
number02
    .word ploop
    .byt <(number01-*+1)
#include "pad.i65"
number03
    .word _qfind
#include "page.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word rot
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word minus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word on
#include "page.i65"
number04
    .word _convert
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _punctq
#include "page.i65"
    .word qbranch
    .byt <(number05-*+1)
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word off
#include "page.i65"
    .word branch
    .byt <(number04-*+1)
#include "pad.i65"
number05
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word ne
#include "page.i65"
    .word _qfind
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(number06-*+1)
#include "pad.i65"
    .word dnegate
#include "page.i65"
number06
    .word exit

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"                    ; ( name )
    .word context           ; ( name context )
#include "page.i65"
    .word fetch             ; ( name vocabulary )
#include "page.i65"
    .word fetch             ; ( name LFA|0 )
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"                      ; ( name LFA )
    .word clit
    .byt 7
#include "pad.i65"
    .word fail              ; vocabularies unimplemented
#include "page.i65"
find01                                  ; ( name )
    .word dup               ; ( name name )
#include "page.i65"
    .word dhash             ; ( name hash1 hash2 )
#include "page.i65"
    .word bloomfetch        ; ( name hash1 flag )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(find02-*+1)
#include "pad.i65"
    .word dhashfetch        ; ( name LFA )
#include "page.i65"
    .word swap              ; ( LFA name )
#include "page.i65"
    .word twominus          ; ( LFA name-2 )
#include "page.i65"
    .word swap              ; ( name-2 LFA )
#include "page.i65"
    .word pfind             ; ( addr flag )
#include "page.i65"
    .word qdup              ; ( addr flag flag | addr 0 )
#include "page.i65"
    .word zeq               ; ( addr flag 0 | name-2 true )
#include "page.i65"
    .word qbranch           ; found? exit
    .byt <(find03-*+1)
#include "pad.i65"
    ; bloom filter false positive
    .word twoplus           ; ( name )
#include "page.i65"
    .word false             ; ( name false )
#include "page.i65"
    .word branch
    .byt <(find03-*+1)
#include "pad.i65"
find02                                  ; ELSE
    ; bloom filter negative
    ; ( name hash1 )
    .word drop              ; ( name )
#include "page.i65"
    .word false             ; ( here false )
#include "page.i65"
find03                                  ; THEN
    .word exit              ; ( addr flag )

;--------------------------------------------------------------
;
;       EXISTS?   ( -- addr flag )
;
; scans ahead in the input stream for the next blank-delimited word,
; and returns either
#ifdef HEADERS
existsqlfa
    .byt $de,$ad
    .byt (_existsq-*-1)|bit7
    .asc "EXISTS","?"|bit7
#endif
_existsq
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find             ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ID.
;
#ifdef HEADERS
iddotlfa
    .byt $de,$ad
    .byt (_iddot-*-1)|bit7
    .asc "ID","."|bit7
#endif
_iddot
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word clit
    .asc '*'
#include "pad.i65"
    .word fill
#include "page.i65"
    .word dup
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word count
#include "page.i65"
    .word clit
    .byt $1f                ; ~ shouldn't this use WIDTH?
#include "pad.i65"
    .word andx
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [COMPILE]
;
; * 83 compiler
;
#ifdef HEADERS
bcompilelfa
    .byt $de,$ad
    .byt (_bcompile-*-1)|bit7
    .asc "[COMPILE","]"|bit7
#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LITERAL
;
; * 83 compiler
;
#ifdef HEADERS
literallfa
    .byt $de,$ad
    .byt (_literal-*-1)|bit7
    .asc "LITERA","L"|bit7
#endif
_literal
#include "enter.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01       .word _compile
    .word plit
#include "page.i65"
    .word _comma
#include "page.i65"
literal02       .word exit

;--------------------------------------------------------------
;
;       DLITERAL
;
#ifdef HEADERS
dliterallfa
    .byt $de,$ad
    .byt (_dliteral-*-1)|bit7
    .asc "DLITERA","L"|bit7
#endif
_dliteral
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       INTERPRET
;
;
;": interpret   ( )
;       begin   ?stack
;               exists?
;               if      link>
;                       execute
;               else    number dpl @ 1+ 0=
;                       if      drop
;                       then
;               then
;               false
;               quit?
;       again ;
;
#ifdef HEADERS
interpretlfa
    .byt $de,$ad
    .byt (_interpret-*-1)|bit7
    .asc "INTERPRE","T"|bit7
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack            ; ( )
#include "page.i65"
    .word _existsq          ; ( addr flag )
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word execute
#include "page.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(interpret03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
interpret03
    .word false
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       IMMEDIATE
;
; * 83 compiler
;
#ifdef HEADERS
immediatelfa
    .byt $de,$ad
    .byt (_immediate-*-1)|bit7
    .asc "IMMEDIAT","E"|bit7
#endif
_immediate
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word toggle
    .word exit

;--------------------------------------------------------------
;
;       VOCABULARY
;
; * 83 compiler
;
; see FD-V05N3 p. 5
#ifdef HEADERS
vocabularylfa
    .byt $de,$ad
    .byt (_vocabulary-*-1)|bit7
    .asc "VOCABULAR","Y"|bit7
#endif
_vocabulary
#include "enter.i65"
    .word _create
#include "page.i65"
    .word exit
;#include "page.i65"
;               .word current
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word twoplus
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word here
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word store
;#include "page.i65"
;               .word _psemi
vocabdoes
    jsr dodoes
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORTH
;
; * 83 interpreter
;
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
#ifdef HEADERS
forthlfa
    .byt $de,$ad
    .byt (forth-*-1)|bit7
    .asc "FORT","H"|bit7
#endif
forth
    jsr vocabdoes
    .word 0                 ; flag as root vocabulary
    .byt 1|bit7
    .byt ' '|bit7           ; $a081
lastvoc
    .word 0                 ; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;       DEFINITIONS
;
; * 83 interpreter
;
#ifdef HEADERS
definitionslfa
  .byt $de,$ad
    .byt (_definitions-*-1)|bit7
    .asc "DEFINITION","S"|bit7
#endif
_definitions
#include "enter.i65"
    .word context
#include "page.i65"
    .word fetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (
;
; * 83 interpreter
;
#ifdef HEADERS
lparenlfa
    .byt $de,$ad
    .byt (_lparen-*-1)|bit7
    .asc "("|bit7
#endif
_lparen
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT
;
; * 83 interpreter
;
#ifdef HEADERS
abortlfa
    .byt $de,$ad
    .byt (_abort-*-1)|bit7
    .asc "ABOR","T"|bit7
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _quit
#include "page.i65"
    .word exit      ; make the decompiler happy

;--------------------------------------------------------------
;
;       BLKBUF
;
; return the address of the block buffer (usu. $7C00 on a 32K PET)
;
#ifdef HEADERS
blkbuflfa
    .byt $de,$ad
    .byt (_blkbuf-*-1)|bit7
    .asc "BLKBU","F"|bit7
#endif
_blkbuf
#include "enter.i65"
    .word memsiz
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EMPTY-BUFFERS
;
; Unassign all virtual memory.  UPDATEed blocks are not written
; to mass storage.
;
;": empty-buffers   ( -- )
;     vmsiz off blkbuf 2- dup off vmbuf ! ;
;
#ifdef HEADERS
emptybufferslfa
    .byt $de,$ad
    .byt (_emptybuffers-*-1)|bit7
    .asc "EMPTY-BUFFER","S"|bit7
#endif
_emptybuffers
#include "enter.i65"
    .word vmsiz
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       STARTUP
;
#ifdef HEADERS
startuplfa
    .byt $de,$ad
    .byt (startup-*-1)|bit7
    .asc "STARTU","P"|bit7
#endif
startup
    jsr docreate
    .word _abort

;--------------------------------------------------------------
;
;       COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack

ice
    jsr swapzp
    lda CBINV
    eor #<SW16
    sta brktoggle
    lda CBINV+1
    eor #>SW16
    sta brktoggle+1
    bne cold                ; bra
#ifdef HEADERS
coldlfa
    .byt $de,$ad
    .byt (cold-*-1)|bit7
    .asc "COL","D"|bit7
#endif
cold
    ldy #uarea-userarea-1
    bne warm01              ; bra

warm
    ldy #userwarm-userarea-1

warm01
    lda userup
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
    cld
    jsr CLRCHN
    jsr CLALL
#include "toforth.i65"
    .word sw16              ; set up BRK vector to Sweet16
#include "page.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word plit
    .word zpbuf+MEMSIZ      ; use BASIC memsiz initially
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word memsiz            ; set MEMSIZ uservariable
#include "page.i65"
    .word store
#include "page.i65"
    .word _emptybuffers
#include "page.i65"
    .word _pdq
    .byt (warm03-*-1)
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-05-24",CR
            ;123456789.123456789.123456789.123456789.
    .asc    "1607 ENGLISH SETTLERS LAND IN JAMESTOWN", CR
    .asc    "1844 SAMUEL MORSE SENDS FIRST TELEGRAM",CR
warm03
#include "pad.i65"
    .word _rethread
#include "page.i65"
warm05
    .word _decimal
#include "page.i65"
    .word forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUIT
;
;"This is the infinite outer interpreter loop:
;       - resets the return stack (RP!)
;       - outputs a carriage return (CR)
;       - waits for a line of user input (QUERY)
;       - interprets that line
; * 83 interpreter outer
;
#ifdef HEADERS
quitlfa
    .byt $de,$ad
    .byt (_quit-*-1)|bit7
    .asc "QUI","T"|bit7
#endif
_quit
#include "enter.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _lbracket         ; STATE OFF
#include "page.i65"
quit01                                  ; BEGIN
    .word rpstore
#include "page.i65"
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       S>D
;
#ifdef HEADERS
stodlfa
    .byt $de,$ad
    .byt (_stod-*-1)|bit7
    .asc "S>","D"|bit7
#endif
_stod
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABS   ( n -- +n )
;
; * 83 nucleus
;
#ifdef HEADERS
abslfa
    .byt $de,$ad
    .byt (abs-*-1)|bit7
    .asc "AB","S"|bit7
#endif
abs
    lda tos+1
    bpl abs01
    jmp negate
abs01
    jmp next

;--------------------------------------------------------------
;
;       SGN   ( n -- -1|0|1 )
;
; return the sign of n
;
#ifdef HEADERS
sgnlfa
    .byt $de,$ad
    .byt (sgn-*-1)|bit7
    .asc "SG","N"|bit7
#endif
sgn
    ldy #$ff
    lda tos+1
    bmi sgn01       ; negative
    iny
    ora tos
    beq sgn01       ; zero
    lda #1          ; positive
    .byt $24        ; BIT zp to skip over tya
sgn01
    tya
    jmp put

;--------------------------------------------------------------
;
;       RANDU   ( -- r )
;
; return a random number in the range 0..255
; from the First Book of KIM-1
;
#ifdef HEADERS
randulfa
    .byt $de,$ad
    .byt (randu-*-1)|bit7
    .asc "RAND","U"|bit7
#endif
randu
    stx storex
    sec
    lda rnd+1
    adc rnd+4
    adc rnd+5
    sta rnd
    ldx #4
rpl
    lda rnd,x
    sta rnd+1,x
    dex
    bpl rpl
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       1+!   ( n -- )
;
; increments the word addressed by n
;
#ifdef HEADERS
oneplusstorelfa
    .byt $de,$ad
    .byt (oneplusstore-*-1)|bit7
    .asc "1+","!"|bit7
#endif
oneplusstore
    ldy #$FF
    lda #0
    sec
oneplusstore01
    iny
    adc (tos),y
    sta (tos),y
    tya
    beq oneplusstore01
    jmp pops

;--------------------------------------------------------------
;
;       1-!   ( n -- )
;
; decrements the word addressed by n
;
#ifdef HEADERS
oneminusstorelfa
    .byt $de,$ad
    .byt (oneminusstore-*-1)|bit7
    .asc "1-","!"|bit7
#endif
oneminusstore
    ldy #$ff
    clc
oneminusstore01
    iny
    lda (tos),y
    sbc #0
    sta (tos),y
    tya
    beq oneminusstore01
    jmp pops

;--------------------------------------------------------------
;
;       DABS
;
#ifdef HEADERS
dabslfa
    .byt $de,$ad
    .byt (dabs-*-1)|bit7
    .asc "DAB","S"|bit7
#endif
dabs
    lda tos+1
    bpl abs01
    jmp dnegate

;--------------------------------------------------------------
;
;       MIN
;
; * 83 nucleus
;
#ifdef HEADERS
minlfa
    .byt $de,$ad
    .byt (_min-*-1)|bit7
    .asc "MI","N"|bit7
#endif
_min
#include "enter.i65"
    .word _twodup
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(min01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
min01
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       MAX
;
; * 83 nucleus
;
#ifdef HEADERS
maxlfa
    .byt $de,$ad
    .byt (_max-*-1)|bit7
    .asc "MA","X"|bit7
#endif
_max
#include "enter.i65"
    .word _twodup
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(max01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
max01
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       M*   ( n1 n2 -- d )
;
; * divstar
;
; multiply two signed words, leaving the double product on the stack
#ifdef HEADERS
mstarlfa
    .byt $de,$ad
    .byt (mstar-*-1)|bit7
    .asc "M","*"|bit7
#endif
mstar
    jsr mult
    jmp next
mult
    lda stackl,x
    sta n+4
    lda stackh,x
    sta n+5
    eor tos+1
    php                     ; we only care about the sign bit
    bit tos+1
    bpl mult01
    jsr donegate
mult01
    bit n+5
    bpl mult02
    sec
    lda #0
    sbc n+4
    sta n+4
    lda #0
    sbc n+5
    sta n+5
mult02
    jsr multiply
    lda n+1
    sta stackh,x
    lda n
    sta stackl,x
    lda n+3
    sta tos+1
    lda n+2
    sta tos
    plp
    bpl mult03
    jmp dodnegate
mult03
    rts

;--------------------------------------------------------------
;
;       M/   ( d n -- rem quotient )
;
#ifdef HEADERS
mslashlfa
    .byt $de,$ad
    .byt (mslash-*-1)|bit7
    .asc "M","/"|bit7
#endif
mslash
    jsr domslash
    jmp next
domslash
    cpx #$6f
    bcc domslash02
domslash01
    ldx #bos
    ;       sty stack,x
    ;       sty stack+1,x
    tya
    rts
domslash02
    ;      lda stack,x
    ;       ora stack+1,x
    beq domslash01
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    ;       lda stack+1,x
    ;       eor stack+3,x
    pha
    ;       lda stack+1,x
    pha
    bpl domslash03
    jsr donegate
domslash03
    ;       lda stack+3,x
    bpl domslash04
    inx
    inx
    jsr dnegate
    dex
    dex
domslash04
    jsr divmod
    pla
    bpl domslash05
    jsr remult
domslash05
    pla
    bpl domslash07
    jsr donegate
    ;       lda stack+2,x
    ;       ora stack+3,x
    beq domslash07
    ;       lda stack,x
    bne domslash06
    ;       dec stack+1,x
domslash06
    ;       dec stack,x
    jsr remult
    clc
    pla
    ;       adc stack+2,x
    ;       sta stack+2,x
    pla
    ;       adc stack+3,x
    ;       sta stack+3,x
    rts
domslash07
    pla
    pla
    rts
remult
    inx
    inx
    jsr donegate
    dex
    dex
    rts

;--------------------------------------------------------------
;
;       M*/   ( n1 n2 n3 -- d )
;
; * divstar
;
; multiplies n1*n2 giving an intermediate 16-bit value, and divides
; that by n3 yielding a 16-bit quotient.  Remainder is ignored,
; all values are signed.
;
#ifdef HEADERS
mstarslashlfa
    .byt $de,$ad
    .byt (mstarslash-*-1)|bit7
    .asc "M*","/"|bit7
#endif
mstarslash

;--------------------------------------------------------------
;
;       *   ( n1 n2 -- n1*n2 )
;
; * 83 nucleus divstar
;
; multiply two signed words
#ifdef HEADERS
starlfa
    .byt $de,$ad
    .byt (star-*-1)|bit7
    .asc "*"|bit7
#endif
star
    jsr mult
    jmp pops

;--------------------------------------------------------------
;
;       /MOD    ( n1 n2 -- n3 n4 )
;
; * 83 nucleus divstar
;
; n3 is the remainder and n4 the floor of the
; quotient of n1 divided by the divisor n2.  n3
; has the same sign as n2 or is zero.  An error
; condition results if the divisor is zero or if
; the quotient falls outside the range {-32,768
; ... 32,676}.
; ~wut? should probably use ud/mod and then set signs
#ifdef HEADERS
slashmodlfa
    .byt $de,$ad
    .byt (slashmod-*-1)|bit7
    .asc "/MO","D"|bit7
#endif
slashmod
    jsr doslashmod
    jmp next
doslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    ;       lda stack+3,x
    bpl doslashmod01
    dey
doslashmod01
    ;       sty stack,x
    ;       sty stack+1,x
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
    ldy #0
    jmp domslash

;--------------------------------------------------------------
;
;       /   ( n1 n2 -- n3 )
;
; * 83 nucleus divstar
;
; n3 is the floor of the quotient of n1 divided
; by the divisor n2.  An error condition results
; if the divisor is zero or if the quotient falls
; outside the range {-32,768 ... 32,767}.
#ifdef HEADERS
slashlfa
    .byt $de,$ad
    .byt (slash-*-1)|bit7
    .asc "/"|bit7
#endif
slash
    jsr doslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
;
;       MOD   ( n1 n2 -- n3 )
;
; * 83 nucleus divstar
;
; n3 is the remainder after dividing n1 by the
; divisor n2.  n3 has the same sign as n2 or is
; zero.  An error condition results if the
; divisor is zero or if the quotient falls out-
; side the range {32,768...32,768}.
;
#ifdef HEADERS
modlfa
    .byt $de,$ad
    .byt (mod-*-1)|bit7
    .asc "MO","D"|bit7
#endif
mod
    jsr doslashmod
    jmp pops

;--------------------------------------------------------------
;
;       */MOD   ( n1 n2 n3 -- n4 n5 )
;
; * 83 nucleus divstar
;
; n1 is first multiplied by n2 producing an inter-
; mediate 32 bit result.  n4 is the remainder and
; n5 is the floor of the quotient of the inter-
; mediate 32-bit result divided by the divisor
; n3.  A 32-bit intermediate product is used for
; */ .  n4 has the same sign as n3 or is zero.
; An error condition results if the divisor is
; zero or if the quotient falls outside of the
; range {-32,768...32,767}.
;
#ifdef HEADERS
starslashmodlfa
    .byt $de,$ad
    .byt (starslashmod-*-1)|bit7
    .asc "*/MO","D"|bit7
#endif
starslashmod
    jsr dostarslashmod
    jmp next
dostarslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    inx
    inx
    jsr mult
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
    jmp domslash

;--------------------------------------------------------------
;
;       */   ( n1 n2 n3 -- n4 )
;
; * 83 nucleus divstar
;
; n1 is first multiplied by n2 producing an inter-
; mediate 32-bit result.  n4 is the floor of the
; quotient of the intermediate 32-bit result
; divided by the divisor n3.  The product of n1
; times n2 is maintained as an intermediate 32-
; bit result for greater precision than the other-
; wise equivalent sequence n1 n2 * n3 / .  An
; error condition results if the divisor is zero
; or if the quotient falls outside the range
; {-32,768...32,767}.
;
#ifdef HEADERS
starslashlfa
    .byt $de,$ad
    .byt (starslash-*-1)|bit7
    .asc "*","/"|bit7
#endif
starslash
    jsr dostarslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
;
;       M/MOD   ( d n1 -- n2 n3 )
;
; * divstar
;
; n2 is the remainder and n3 is the floor of the
; quotient after dividing d by the divisor n1.
; All values and arithmetic are unsigned.  An er-
; ror condition results if the divisor is zero or
; if the quotient lies outside the range
; {-32,768...32,767}.
;
#ifdef HEADERS
mslashmodlfa
    .byt $de,$ad
    .byt (mslashmod-*-1)|bit7
    .asc "M/MO","D"|bit7
#endif
mslashmod
    ldy #2
    jsr locals       ; udhi -> N0; udlo -> N1
    lda tos+1
    pha
    bpl mslashmod01
    jsr donegate
mslashmod01
    pla
    eor n+1         ; xor the sign bits
    sta n+7
    lda n+1
    sta n+6         ; original sign of divisor
    bpl mslashmod02
    jsr dnegaten    ; negate the double at n..n+3
mslashmod02
    jsr divmod
    sty n+1
    sta n           ; stash the quotient
    lda n+6
    bpl mslashmod03
    jsr donegate
mslashmod03
    lda n+7
    bpl mslashmod04
    jsr dnegaten
mslashmod04
    ldy n+1
    lda n
    jmp pushya

;--------------------------------------------------------------
;
;       '
;
; * 83 interpreter
;
#ifdef HEADERS
ticklfa
    .byt $de,$ad
    .byt (_tick-*-1)|bit7
    .asc "'"|bit7
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qfind
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [']
;
; * 83 compiler
;
#ifdef HEADERS
brticklfa
    .byt $de,$ad
    .byt (_brtick-*-1)|bit7
    .asc "['","]"|bit7
#endif
_brtick
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       ?>MARK
;
;#ifdef HEADERS
;qtomarklfa
;    .byt $de,$ad
;    .byt (_qtomark-*-1)|bit7
;    .asc "?>MAR","K"|bit7
;#endif
_qtomark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?<MARK
;
;#ifdef HEADERS
;qfrommarklfa
;   .byt $de,$ad
;    .byt (_qfrommark-*-1)|bit7
;    .asc "?<MAR","K"|bit7
;#endif
_qfrommark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?>RESOLVE
;
;#ifdef HEADERS
;qtoresolvelfa
;  .byt $de,$ad
;    .byt (_qtoresolve-*-1)|bit7
;    .asc "?>RESOLV","E"|bit7
;#endif
_qtoresolve
#include "enter.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word here
#include "page.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
;
;       ?<RESOLVE
;
;#ifdef HEADERS
;qltresolvelfa
;  .byt $de,$ad
;    .byt (_qltresolve-*-1)|bit7
;    .asc "?<RESOLV","E"|bit7
;#endif
_qltresolve
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       ADD>MARK
;
;#ifdef HEADERS
;addtomarklfa
;    .byt $de,$ad
;    .byt (_addtomark-*-1)|bit7
;    .asc "ADD>MAR","K"|bit7
;#endif
_addtomark
#include "enter.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01     .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02     .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BEGIN
;
; * 83 compiler
;
#ifdef HEADERS
beginlfa
    .byt $de,$ad
    .byt (_begin-*-1)|bit7
    .asc "BEGI","N"|bit7
#endif
_begin
#include "enter.i65"
    .word _qfrommark
#include "page.i65"
    .word one
    .word exit

;--------------------------------------------------------------
;
;       THEN
;
; * 83 compiler
;
#ifdef HEADERS
thenlfa
    .byt $de,$ad
    .byt (_then-*-1)|bit7
    .asc "THE","N"|bit7
#endif
_then
#include "enter.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       DO
;
; * 83 compiler
;
#ifdef HEADERS
dolfa
    .byt $de,$ad
    .byt (_do-*-1)|bit7
    .asc "D","O"|bit7
#endif
_do
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word pdo
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?DO
;
#ifdef HEADERS
qdolfa
    .byt $de,$ad
    .byt (_qdo-*-1)|bit7
    .asc "?D","O"|bit7
#endif
_qdo
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LOOP
;
; * 83 compiler
;
#ifdef HEADERS
looplfa
    .byt $de,$ad
    .byt (_loop-*-1)|bit7
    .asc "LOO","P"|bit7
#endif
_loop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       +LOOP
;
; * 83 compiler
;
#ifdef HEADERS
pluslooplfa
    .byt $de,$ad
    .byt (_plusloop-*-1)|bit7
    .asc "+LOO","P"|bit7
#endif
_plusloop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LEAVE
;
; * 83 compiler
;
#ifdef HEADERS
leavelfa
    .byt $de,$ad
    .byt (_leave-*-1)|bit7
    .asc "LEAV","E"|bit7
#endif
_leave
#include "enter.i65"
    .word _compile
    .word pleave
#include "pad.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       ?LEAVE
;
#ifdef HEADERS
qleavelfa
    .byt $de,$ad
    .byt (_qleave-*-1)|bit7
    .asc "?LEAV","E"|bit7
#endif
_qleave
#include "enter.i65"
    .word _compile
    .word pqleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       UNTIL
;
; * 83 compiler
;
#ifdef HEADERS
untillfa
    .byt $de,$ad
    .byt (_until-*-1)|bit7
    .asc "UNTI","L"|bit7
#endif
_until
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
    .word exit

;--------------------------------------------------------------
;
;       AGAIN
;
#ifdef HEADERS
againlfa
    .byt $de,$ad
    .byt (_again-*-1)|bit7
    .asc "AGAI","N"|bit7
#endif
_again
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       REPEAT
;
; * 83 compiler
;
#ifdef HEADERS
repeatlfa
    .byt $de,$ad
    .byt (_repeat-*-1)|bit7
    .asc "REPEA","T"|bit7
#endif
_repeat
#include "enter.i65"
    .word _again
    .word exit

;--------------------------------------------------------------
;
;       IF
;
; * 83 compiler
;
#ifdef HEADERS
iflfa
    .byt $de,$ad
    .byt (_if-*-1)|bit7
    .asc "I","F"|bit7
#endif
_if
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ELSE
;
; * 83 compiler
;
#ifdef HEADERS
elselfa
    .byt $de,$ad
    .byt (_else-*-1)|bit7
    .asc "ELS","E"|bit7
#endif
_else
#include "enter.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       WHILE
;
; * 83 compiler
;
#ifdef HEADERS
whilelfa
    .byt $de,$ad
    .byt (_while-*-1)|bit7
    .asc "WHIL","E"|bit7
#endif
_while
#include "enter.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SPACES
;
; * 83 device
;
#ifdef HEADERS
spaceslfa
    .byt $de,$ad
    .byt (_spaces-*-1)|bit7
    .asc "SPACE","S"|bit7
#endif
_spaces
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(spaces02-*+1)
#include "pad.i65"
spaces01        .word _space
#include "page.i65"
    .word ploop
    .byt <(spaces01-*+1)
#include "pad.i65"
spaces02        .word exit

;--------------------------------------------------------------
;
;       <#   ( -- )
;
; * 83 interpreter
;
#ifdef HEADERS
ltsharplfa
    .byt $de,$ad
    .byt (_ltsharp-*-1)|bit7
    .asc "<","#"|bit7
#endif
_ltsharp
#include "enter.i65"
    .word _pad              ; ( pad )
#include "page.i65"
    .word hld               ; ( pad hld )
#include "page.i65"
    .word store             ; ( )
    .word exit

;--------------------------------------------------------------
;
;       #>
;
; * 83 interpreter
;
#ifdef HEADERS
sharpgtlfa
    .byt $de,$ad
    .byt (_sharpgt-*-1)|bit7
    .asc "#",">"|bit7
#endif
_sharpgt
#include "enter.i65"
    .word twodrop
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
    .word exit

;--------------------------------------------------------------
;
;       SIGN    ( n -- )
;
; * 83 interpreter
;
; If n is negative, an ASCII "-" (minus sign) is appended to the
; pictured numeric output string.  Typically used between <# and #> .
;
#ifdef HEADERS
signlfa
    .byt $de,$ad
    .byt (_sign-*-1)|bit7
    .asc "SIG","N"|bit7
#endif
_sign
#include "enter.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(sign01-*+1)
#include "pad.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word _hold
#include "page.i65"
sign01          .word exit

;--------------------------------------------------------------
;
;       #   ( +d1 -- +d2 )
;
; * 83 interpreter
;
; +d1 is divided by BASE and the quotient is
; placed onto the stack.  The remainder is con-
; verted to an ASCII character and appended to
; the output string toward lower memory ad-
; dresses.
; The remainder of +d1 divided by the value of
; BASE is converted to an ASCII character and ap-
; pended to the output string toward lower memory
; addresses.  +d2 is the quotient and is main-
; tained for further processing.  Typically used
; between <# and #> .
#ifdef HEADERS
sharplfa
    .byt $de,$ad
    .byt (_sharp-*-1)|bit7
    .asc "#"|bit7
#endif
_sharp
#include "enter.i65"
    .word base              ; ( d base )
#include "page.i65"
    .word fetch             ; ( d @base )
#include "page.i65"
    .word udslashmod        ; ( rem d )
#include "page.i65"
    .word rot               ; ( d rem )
#include "page.i65"
    .word to6502
    lda tos
    sed
    cmp #10
    adc #'0'
    cld
    sta tos                 ; ( d char )
#include "toforth.i65"
    .word _hold             ; ( d )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       #S   ( d -- )
;
; * 83 interpreter
;
#ifdef HEADERS
sharpslfa
    .byt $de,$ad
    .byt (_sharps-*-1)|bit7
    .asc "#","S"|bit7
#endif
_sharps
#include "enter.i65"
sharps01        .word _sharp            ; ( d )
#include "page.i65"
    .word _twodup           ; ( d d )
#include "page.i65"
    .word dzeq              ; ( d flag )
#include "page.i65"
    .word qbranch
    .byt <(sharps01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       (U.)
;
;#ifdef HEADERS
;pudotlfa
;    .byt $de,$ad
;    .byt (_pudot-*-1)|bit7
;    .asc "(U.",")"|bit7
;#endif
_pudot
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       U.
;
; * 83 interpreter
;
#ifdef HEADERS
udotlfa
    .byt $de,$ad
    .byt (_udot-*-1)|bit7
    .asc "U","."|bit7
#endif
_udot
#include "enter.i65"
    .word _pudot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       U.R    ( u n -- )
;
; u is converted using the value of BASE and then
; displayed as an unsigned number right-aligned
; in a field +n characters wide.  If the number
; of characters required to display u is greater
; than +n, an error condition exists.

#ifdef HEADERS
udotrlfa
    .byt $de,$ad
    .byt (_udotr-*-1)|bit7
    .asc "U.","R"|bit7
#endif
_udotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pudot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (.)   ( n -- )
;
;#ifdef HEADERS
;pdotlfa
;    .byt $de,$ad
;    .byt (_pdot-*-1)|bit7
;    .asc "(.",")"|bit7
;#endif
_pdot
#include "enter.i65"
    .word dup               ; ( n n )
#include "page.i65"
    .word abs               ; ( n +n )
#include "page.i65"
    .word zero              ; ( n +d )
#include "page.i65"
    .word _ltsharp          ; ( n +d )
#include "page.i65"
    .word _sharps           ; (
#include "page.i65"
    .word rot
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .   ( n -- )
;
; * 83 interpreter
;
; The value of n is displayed in a free field for-
; mat with a leading minus sign if n is negative.
#ifdef HEADERS
dotlfa
    .byt $de,$ad
    .byt (_dot-*-1)|bit7
    .asc "."|bit7
#endif
_dot
#include "enter.i65"
    .word _pdot             ; ( addr count )
#include "page.i65"
    .word type              ; ( )
#include "page.i65"
    .word _space            ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .R
;
#ifdef HEADERS
dotrlfa
    .byt $de,$ad
    .byt (_dotr-*-1)|bit7
    .asc ".","R"|bit7
#endif
_dotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pdot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (UD.)
;
;#ifdef HEADERS
;puddotlfa
;    .byt $de,$ad
;    .byt (_puddot-*-1)|bit7
;    .asc "(UD.",")"|bit7
;#endif
_puddot
#include "enter.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
    .word exit

;--------------------------------------------------------------
;
;       UD.
;
#ifdef HEADERS
uddotlfa
    .byt $de,$ad
    .byt (_uddot-*-1)|bit7
    .asc "UD","."|bit7
#endif
_uddot
#include "enter.i65"
    .word _puddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       UD.R
;
#ifdef HEADERS
uddotrlfa
    .byt $de,$ad
    .byt (_uddotr-*-1)|bit7
    .asc "UD.","R"|bit7
#endif
_uddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _puddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (D.)
;
;#ifdef HEADERS
;pdddotlfa
;    .byt $de,$ad
;    .byt (_pddot-*-1)|bit7
;    .asc "(D.",")"|bit7
;#endif
_pddot
#include "enter.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word dabs
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       D.
;
#ifdef HEADERS
ddotlfa
    .byt $de,$ad
    .byt (_ddot-*-1)|bit7
    .asc "D","."|bit7
#endif
_ddot
#include "enter.i65"
    .word _pddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
    .word exit

;--------------------------------------------------------------
;
;       D.R
;
#ifdef HEADERS
ddotrlfa
    .byt $de,$ad
    .byt (_ddotr-*-1)|bit7
    .asc "D.","R"|bit7
#endif
_ddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
    .word exit

;--------------------------------------------------------------
;
;       ?
;
#ifdef HEADERS
questionlfa
    .byt $de,$ad
    .byt (_question-*-1)|bit7
    .asc "?"|bit7
#endif
_question
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word _dot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PICK   ( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
;
; * 83 nucleus
;
; 0 pick = same as dup
; 1 pick = same as over
#ifdef HEADERS
picklfa
    .byt $de,$ad
    .byt (pick-*-1)|bit7
    .asc "PIC","K"|bit7
#endif
pick
    txa
    clc
    adc tos
    tay
    lda stackl,y
    sta tos
    lda stackh,y
    sta tos+1
    jmp next

;--------------------------------------------------------------
;
;       ROLL   ( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
;
; * 83 nucleus
;
; remove the nth stack element (excluding n itself) to TOS, dropping n
;
; 2 roll = rot
; 1 roll = swap
; 0 roll has no effect
;
#ifdef HEADERS
rolllfa
    .byt $de,$ad
    .byt (roll-*-1)|bit7
    .asc "ROL","L"|bit7
#endif
roll
    stx storex
    txa
    clc
    adc tos
    tax
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
roll01
    cpx storex
    beq roll02
    lda stackh+$ff,x
    sta stackh,x
    lda stackl+$ff,x        ; ~wut? probably not work!
    sta stackl,x
    dex
    bne roll01
roll02
    inx
    jmp next

;--------------------------------------------------------------
;
;       DEPTH
;
; * 83 nucleus
;
#ifdef HEADERS
depthlfa
    .byt $de,$ad
    .byt (depth-*-1)|bit7
    .asc "DEPT","H"|bit7
#endif
depth
    txa
    eor #$ff
    sec
    adc #<bos
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       2DUP   ( n1 n2 -- n1 n2 n1 n2 )
;
#ifdef HEADERS
twoduplfa
    .byt $de,$ad
    .byt (_twodup-*-1)|bit7
    .asc "2DU","P"|bit7
#endif
_twodup
#include "enter.i65"
    .word over
#include "page.i65"
    .word over
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2OVER   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
;
#ifdef HEADERS
twooverlfa
    .byt $de,$ad
    .byt (twoover-*-1)|bit7
    .asc "2OVE","R"|bit7
#endif
twoover
    dex
    dex
    lda tos+1
    sta stackh+1,x
    lda tos
    sta stackl+1,x
    lda stackh+4,x
    sta stackh,x
    lda stackl+4,x
    sta stackl,x
    lda stackh+3,x
    sta tos+1
    lda stackl+3,x
    sta tos
    jmp next

;--------------------------------------------------------------
;
;       2ROT   ( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )
;
; hi1 is stored in TOS, the rest in stackl/stackh ... stack+4
#ifdef HEADERS
tworotlfa
    .byt $de,$ad
    .byt (tworot-*-1)|bit7
    .asc "2RO","T"|bit7
#endif
tworot
    ldy stackh+4,x
    lda stackh+2,x
    sta stackh+4,x
    lda stackh,x
    sta stackh+2,x
    sty stackh,x
    ldy stackl+4,x
    lda stackl+2,x
    sta stackl+4,x
    lda stackl,x
    sta stackl+2,x
    sty stackl,x            ; done moving lo words
    ldy stackh+3,x
    lda stackh+1,x
    sta stackh+3,x
    lda tos+1
    sta stackh+1,x
    sty tos+1
    ldy stackl+3,x
    lda stackl+1,x
    sta stackl+3,x
    lda tos
    sta stackl+1,x
    sty tos                 ; done moving hi words
    jmp next

;--------------------------------------------------------------
;
;       2SWAP   ( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )
;
#ifdef HEADERS
twoswaplfa
    .byt $de,$ad
    .byt (twoswap-*-1)|bit7
    .asc "2SWA","P"|bit7
#endif
twoswap
    ldy tos+1
    lda stackh+1,x
    sta tos+1
    sty stackh+1,x
    ldy tos
    lda stackl+1,x
    sta tos
    sty stackl+1,x
    ldy stackh,x
    lda stackh+2,x
    sta stackh,x
    sty stackh+2,x
    ldy stackl,x
    lda stackl+2,x
    sta stackl,x
    sty stackl+2,x
    jmp next

;--------------------------------------------------------------
;
;       2!   ( hi lo addr -- )
;
#ifdef HEADERS
twostorelfa
    .byt $de,$ad
    .byt (twostore-*-1)|bit7
    .asc "2","!"|bit7
#endif
twostore
    ldy #0
twostore01
    lda stackh,x
    sta (tos),y
    iny
    lda stackl,x
    sta (tos),y
    iny
    inx
    cpy #4
    bne twostore01
    jmp pops

;--------------------------------------------------------------
;
;       2@   ( addr -- hi lo )
;
#ifdef HEADERS
twofetchlfa
    .byt $de,$ad
    .byt (twofetch-*-1)|bit7
    .asc "2","@"|bit7
#endif
twofetch
    ldy #3
    dex
    lda (tos),y
    sta stackh,x
    dey
    lda (tos),y
    sta stackl,x
    dey
    lda (tos),y
    sta n
    dey
    lda (tos),y
    ldy n
    jmp put

;--------------------------------------------------------------
;
;       2CONSTANT
;
#ifdef HEADERS
twoconstlfa
    .byt $de,$ad
    .byt (_twoconst-*-1)|bit7
    .asc "2CONSTAN","T"|bit7
#endif
_twoconst
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jsr dodoes
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2VARIABLE
;
#ifdef HEADERS
twovariablelfa
  .byt $de,$ad
    .byt (_twovariable-*-1)|bit7
    .asc "2VARIABL","E"|bit7
#endif
_twovariable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       D-
;
#ifdef HEADERS
dminuslfa
    .byt $de,$ad
    .byt (dminus-*-1)|bit7
    .asc "D","-"|bit7
#endif
dminus
    jsr dodnegate
    jmp dplus

;--------------------------------------------------------------
;
;       D0=   ( d -- flag )
;
#ifdef HEADERS
dzeqlfa
    .byt $de,$ad
    .byt (dzeq-*-1)|bit7
    .asc "D0","="|bit7
#endif
dzeq
    ldy #0
    lda tos
    ora tos+1
    ora stackl,x
    ora stackh,x
    bne dzeq01
    dey
dzeq01
    inx
    tya
    jmp put

;--------------------------------------------------------------
;
;       D=   ( hi2 lo2 hi1 lo1 -- flag )
;
#ifdef HEADERS
deqlfa
    .byt $de,$ad
    .byt (deq-*-1)|bit7
    .asc "D","="|bit7
#endif
deq
    ldy #0
    lda tos
    eor stackl+1,x
    bne deq01
    lda tos+1
    eor stackh+1,x
    bne deq01
    lda stackl,x
    eor stackl+2,x
    bne deq01
    lda stackh,x
    eor stackh+2,x
    bne deq01
    dey
deq01           inx
    inx
    inx
    tya
    jmp put

;--------------------------------------------------------------
;
;       DU<
;
#ifdef HEADERS
dultlfa
    .byt $de,$ad
    .byt (dult-*-1)|bit7
    .asc "DU","<"|bit7
#endif
dult
    jsr dcmp
    bcs dult01
    dey
dult01
;    sty stack+6,x
;    sty stack+7,x
    inx
    inx
    jmp poptwo

;--------------------------------------------------------------
;
;       D2/   ( hi lo -- hi/2 lo/2 )
;
#ifdef HEADERS
dtwoslashlfa
    .byt $de,$ad
    .byt (dtwoslash-*-1)|bit7
    .asc "D2","/"|bit7
#endif
dtwoslash
    lsr stackh,x
    ror stackl,x
    ror tos+1
    ror tos
    jmp next

;--------------------------------------------------------------
;
;       D2*   ( hi lo -- hi*2 lo*2 )
;
#ifdef HEADERS
dtwostarlfa
    .byt $de,$ad
    .byt (dtwostar-*-1)|bit7
    .asc "D2","*"|bit7
#endif
dtwostar
    asl stackl,x
    rol stackh,x
    rol tos
    rol tos+1
    jmp next

;--------------------------------------------------------------
;
;       D>
;
#ifdef HEADERS
dgtlfa
    .byt $de,$ad
    .byt (_dgt-*-1)|bit7
    .asc "D",">"|bit7
#endif
_dgt
#include "enter.i65"
    .word twoswap
#include "page.i65"
    .word dlt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DMIN
;
#ifdef HEADERS
dminlfa
    .byt $de,$ad
    .byt (_dmin-*-1)|bit7
    .asc "DMI","N"|bit7
#endif
_dmin
#include "enter.i65"
    .word twoover
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(dmin01-*+1)
#include "pad.i65"
    .word twoswap
#include "page.i65"
dmin01          .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DMAX
;
#ifdef HEADERS
dmaxlfa
    .byt $de,$ad
    .byt (_dmax-*-1)|bit7
    .asc "DMA","X"|bit7
#endif
_dmax
#include "enter.i65"
    .word twoover
#include "page.i65"
    .word twoover
#include "page.i65"
    .word dlt
#include "page.i65"
    .word qbranch
    .byt <(dmax01-*+1)
#include "pad.i65"
    .word twoswap
#include "page.i65"
dmax01          .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BRINGOUTYERDEAD   ( addr -- deadlfa|0 )
;
; scans forward in memory returning the address of the next $DE $AD
; in memory that is followed by a name
;" http://www.youtube.com/watch?v=grbSQ6O6kbs
;
;#ifdef HEADERS
;boydlfa
;    .byt $de,$ad
;    .byt (boyd-*-1)|bit7
;    .asc "BRINGOUTYERDEA","D"|bit7
;#endif
boyd
    brk
    .byt set  | R10
    .word $de
    .byt set  | R11
    .byt $de,$ad
    .byt set  | N0
    .word userdp-userarea
    .byt ld   | UP
    .byt add  | N0
    .byt st   | N0
    .byt ldd  | N0
    .byt st   | N0          ; here
    .byt ldd  | N0
    .byt popd | N0          ; restore N0
    .byt st   | N1
    .byt ld   | R11
    .byt std  | N0          ; here+2 -> N0
    .byt rtn
boyd01
    brk
    .byt ldi  | TOS
    .byt cpr  | R10
    .byt bnz, <(boyd01-*-1)
    .byt dcr  | TOS
    .byt ldd  | TOS
    .byt cpr  | R11
    .byt bz,  <(boyd02-*-2)
    .byt dcr  | TOS
    .byt br,  <(boyd01-*-1)
boyd02
    .byt ld   | TOS
    .byt cpr  | N0          ; TOS=here+2?
    .byt bnz, <(boyd03-*-2)
    .byt sub  | ACC
    .byt st   | TOS
    .byt br,  <(boyd06-*-2)
boyd03
    .byt rtn                ; TOS points to probable NFA
    ldy #0
    lda (tos),y
    bpl boyd01              ; NFA length must be negative
    and #$1f
    tay
    lda (tos),y
    bpl boyd01              ; last NFA byte must be negative
boyd04
    dey
    beq boyd05
    lda (tos),y
    bpl boyd04
    bmi boyd01              ; middle NFA bytes must be positive
boyd05
    brk
    .byt popd | TOS         ; point at the LFA
boyd06
    .byt popd | N0          ; back up the pointer
    .byt ld   | N1
    .byt std  | N0          ; restore previous contents of here
    .byt nxt

;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table 
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?		   (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$3f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
; DEBUG
;    jsr debug               ; print out some entertainment
; /DEBUG
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya

;DEBUG
; hex dump the byte in A
;debug
;    pha
;    pha
;    and #$0f
;    jsr print
;    pla
;    lsr
;    lsr
;    lsr
;    lsr
;    jsr print
;    pla
;dbout
;    rts
;print
;    sed
;    cmp #10
;    adc #'0'
;    cld
;    jmp CHROUT
; ;/DEBUG

;--------------------------------------------------------------
;
;       DHASH@   ( hashkey -- LFA )
;
; retrieve the head of this hash thread
;
;#ifdef HEADERS
;dhashfetchlfa
;  .byt $de,$ad
;    .byt (dhashfetch-*-1)|bit7
;    .asc "DHASH","@"|bit7
;#endif
dhashfetch
    brk
    .byt set  | ACC
    .word lfalist
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | TOS
    .byt ldd  | TOS
    .byt st   | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       BLOOM!   ( hash -- )
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;#ifdef HEADERS
;bloomstorelfa
;  .byt $de,$ad
;    .byt (bloomstore-*-1)|bit7
;    .asc "BLOOM","!"|bit7
;#endif
bloomstore
    lda tos                 ; set bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
    and #(bloomx-bloom-1)   ; don't write outside filter area
    tay
    lda n
    ora bloom,y
    sta bloom,y
    jmp pops

;--------------------------------------------------------------
;
;       BLOOM@   ( hash -- flag )
;
; test a bit in the filter
; hash indexes a single bit in the bloom filter
; input value is in the range 0-63, representing which bit to test
;
; flag values
; false = it can't be in there (bit was clear)
; true = it might be in there (bit was set)
;#ifdef HEADERS
;bloomfetchlfa
;    .byt $de,$ad
;    .byt (bloomfetch-*-1)|bit7
;    .asc "BLOOM","@"|bit7
;#endif
bloomfetch
    lda tos                 ; read bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
    and #(bloomx-bloom-1)   ; don't read outside filter area
    tay
    lda bloom,y
    ldy #0
    and n
    beq bloomfetch01
    dey
bloomfetch01
    tya
    jmp put

;--------------------------------------------------------------
;
;       DHASH!   ( LFAnew hash1 -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
; sweet16 saved 51 bytes vs. 6502
;#ifdef HEADERS
;dhashstorelfa
;    .byt $de,$ad
;    .byt (dhashstore-*-1)|bit7
;    .asc "DHASH","!"|bit7
;#endif
dhashstore
    ldy #1
    jsr locals               ; LFAnew -> N0
    brk
    .byt set  | R11
    .word lfalist
    .byt sub  | ACC
    .byt st   | N2          ; 0 -> N2
    .byt ld   | R11
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | R11         ; R11+hash1*2 -> R11
    .byt ldd  | R11
    .byt popd | R11         ; back up the pointer
    .byt bnz, <(dhashstore01-*-2)
    .byt set  | ACC
    .word rootlfa
    .byt std  | R11
    .byt popd | R11
dhashstore01
    .byt st   | N1          ; head -> N1
    .byt rtn
    ldy #2
    lda (n),y
    and #$1f
    sta n+7                 ; length of name being inserted
dhashstore02
    lda (n+2),y
    and #$1f
    sta n+6
    lda n+7
    cmp n+6                 ; compare lengths
    bcc dhashstore05
    bne dhashstore04
    ;sec
    adc #1
    tay                     ; last char in names
dhashstore03
    lda (n),y
    eor (n+2),y
    asl                     ; compare char ignoring bit7
    bne dhashstore04
    dey
    cpy #2
    bne dhashstore03        ; stop at first char
    dey
    brk
    .byt set  | ACC
    .byt $de,$ad
    .byt std  | N1
    .byt rtn
dhashstore04
    brk
    .byt ld   | N1
    .byt st   | N2          ; keep track of where we've just been
    .byt ldd  | N1
    .byt st   | N1          ; (N1) -> N1
    .byt rtn
    ldy #2
    bne dhashstore02
dhashstore05
    brk
    .byt ld   | N2
    .byt bnz, <(dhashstore06-*-2)
    .byt ld   | R11         ; empty list, insert at the head
    .byt st   | N2          ; head -> N2
dhashstore06
    .byt ld   | N0
    .byt std  | N2          ; N0 -> (N2)
    .byt ld   | N1
    .byt std  | N0          ; N1 -> (N0)
    .byt pull               ; drop the hash
    .byt nxt

;--------------------------------------------------------------
;
;       RETHREAD   ( -- )
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.
; It also marks the last word in the core dictionary.
; links all LFAs
;" : rethread   ( -- )
;       lfalist 40 erase
;       0 +origin
;       begin   bringoutyerdead
;               ?dup
;       while   dup dup 2+
;               dhash
;               bloom!
;               dhash!
;       until ;
;
;#ifdef HEADERS
;rethreadlfa
;    .byt $de,$ad
;    .byt (_rethread-*-1)|bit7
;    .asc "RETHREA","D"|bit7
;#endif
_rethread
#include "enter.i65"
    .word plit
    .word bloom
#include "pad.i65"
    .word clit
    .byt 40                 ; bloom filter (8) and lfalist (32)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word zero
#include "page.i65"
    .word _plusorigin
#include "page.i65"
rethread01
    .word boyd              ; begin boyd ?dup while ... repeat
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(rethread02-*+1)
#include "pad.i65"
    .word dup               ; ( lfa lfa )
#include "page.i65"
    .word dup               ; ( lfa lfa lfa )
#include "page.i65"
    .word twoplus           ; ( lfa lfa nfa )
#include "page.i65"
    .word dhash             ; ( lfa lfa hash1 hash23 )
#include "page.i65"
    .word bloomstore        ; ( lfa lfa hash1 )
#include "page.i65"
    .word dhashstore        ; ( lfa )
#include "page.i65"
    .word branch
    .byt <(rethread01-*+1)
#include "pad.i65"
rethread02
    .word exit

;--------------------------------------------------------------
;
;       UNTHREAD   ( -- )
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;       16 0 do                         ( )
;               i dhash@                ( lfa1 )
;               begin
;                       dup             ( lfa1 lfa1 )
;                       @               ( lfa1 lfa2 )
;                       ?dup            ( lfa1 lfa2 true | lfa1 false )
;               while                   ( lfa1 lfa2 )
;                       $dead           ( lfa1 lfa2 $dead )
;                       rot             ( lfa2 $dead lfa1 )
;~ dup 2- ( nfa ) dup c@ ( nfa len ) $80 or ( nfa len ) swap c! ( )
;                       !               ( lfa2 )
;               repeat
;                                       ( lfa )
;               drop                    ( )
;       loop
;
;#ifdef HEADERS
;unthreadlfa
;    .byt $de,$ad
;    .byt (_unthread-*-1)|bit7
;    .asc "UNTHREA","D"|bit7
;#endif
_unthread
#include "enter.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
unthread01      .word i
#include "page.i65"
    .word dhashfetch
#include "page.i65"
unthread02      .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(unthread03-*+1)
#include "pad.i65"
    .word plit
    .byt $de,$ad
#include "pad.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word branch
    .byt <(unthread02-*+1)
#include "page.i65"
unthread03      .word drop
#include "page.i65"
    .word zero
#include "page.i65"
    .word i
#include "page.i65"
    .word dhashstore
#include "page.i65"
    .word ploop
    .byt <(unthread01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       .S ( -- )
;
; Output the data stack
#ifdef HEADERS
dotslfa
    .byt $de,$ad
    .byt (_dots-*-1)|bit7
    .asc ".","S"|bit7
#endif
_dots
#include "enter.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word _pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
;
;       FORGET
;
; * 83 interpreter
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
; ~ work this over to use pointers only (no RETHREAD/UNTHREAD)
#ifdef HEADERS
forgetlfa
    .byt $de,$ad
    .byt (_forget-*-1)|bit7
    .asc "FORGE","T"|bit7
#endif
_forget
#include "enter.i65"
    .word exit

forgetfence

;==============================================================

;--------------------------------------------------------------
#ifdef HEADERS
evquelfa
    .byt $de,$ad
    .byt (evque-*-1)|bit7
    .asc "EVQU","E"|bit7
#endif
evque
    .dsb 5*10,0

;--------------------------------------------------------------
;
;       EVENT ( n -- ; word )
;
; after n jiffies, perform word
; e.g. 300 EVENT BLINK
;
;" : event
;       10 0 do
;               i 5 *  evque + dup @  0=
;               ?dup  if  leave then
;       loop
;       bl word find
;       over !  2+  swap dup 0
;       $8f c@
;       $8e c@ 256 * + 0 d+
;       swap rot !
;       $8d c@ + swap 1+ c!
;       ;
#ifdef HEADERS
eventlfa
    .byt $de,$ad
    .byt (_event-*-1)|bit7
    .asc "EVEN","T"|bit7
#endif
_event
#include "enter.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
event01
    .word i
#include "page.i65"
    .word dup
#include "page.i65"
    .word twostar
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word evque
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(event02-*+1)
#include "pad.i65"
    .word pleave
    .byt <(event03-*+1)
#include "page.i65"
event02
    .word ploop
    .byt <(event01-*+1)
#include "pad.i65"
event03
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word _find
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt $8f
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $8e
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word star
#include "page.i65"
    .word plus
#include "page.i65"
    .word zero
#include "page.i65"
    .word rot
#include "page.i65"
    .word dplus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word clit
    .byt $8d
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FLIPSCR ( -- )
;
; invert the entire screen
#ifdef HEADERS
flipscrlfa
    .byt $de,$ad
    .byt (flipscr-*-1)|bit7
    .asc "FLIPSC","R"|bit7
#endif
flipscr
    ldy #0
flipscr01
    lda VIDRAM,y            ; [4]
    eor #$80                ; [2]
    sta VIDRAM,y            ; [5]
    lda VIDRAM+$100,y
    eor #$80
    sta VIDRAM+$100,y
    lda VIDRAM+$200,y
    eor #$80
    sta VIDRAM+$200,y
    lda VIDRAM+$300,y
    eor #$80
    sta VIDRAM+$300,y
    iny                     ; [2]
    bne flipscr01           ; [3] 49 * 256 = 12544 clocks
    jmp next

;--------------------------------------------------------------
;
;       FOO ( -- )
;
; 
;
;
#ifdef HEADERS
foolfa
    .byt $de,$ad
    .byt (_foo-*-1)|bit7
    .asc "FO","O"|bit7
#endif
_foo
#include "enter.i65"
foo01                           ; BEGIN
    .word randu
#include "page.i65"
    .word two
#include "page.i65"
    .word andx
#include "page.i65"
    .word sgn
#include "page.i65"
    .word clit
    .byt 205
#include "pad.i65"
    .word plus
#include "page.i65"
    .word emit
#include "page.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 39
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(foo02-*+1)
#include "pad.i65"
    .word cr
#include "page.i65"
foo02
    .word qterminal
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(foo01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       BAZ ( -- )
;
; draw some beer
;
;
#ifdef HEADERS
bazlfa
    .byt $de,$ad
    .byt (baz-*-1)|bit7
    .asc "BA","Z"|bit7
#endif
baz
    sei
    lda #<baz02
    sta $90
    lda #>baz02
    sta $91
    cli
    lda #$a0
    sta VIDRAM+19*40+17
    sta VIDRAM+20*40+17
    jmp next
countdown
    .byt 17
baz02
    lda TIME+2
    and #$03f
    bne baz05               ; every 64 ticks
bazoo
    dec countdown
    beq baz04
    lda countdown
    cmp #8
    bcc baz03
    sbc #8
    ;sec
baz03
    tay
    lda bevlvl,y
    bcs baz01
    ldy #40
    .byt $2c
baz01
    ldy #0
    sta VIDRAM+19*40+17,y
baz05
    jmp $e455
baz04
    lda #17
    sta countdown
    lda #$a0
    sta VIDRAM+19*40+17
    sta VIDRAM+20*40+17
    bne baz05

bevlvl          .byt $20,$64,$6f,$79,$62,$f8,$f7,$e3,$a0

;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
;
; test cases -- 
; vvwwxxyyyzz
; xxyyzz
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R10   ; input counter - when this hits zero, we're done
    .byt st | R11   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R10   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R11   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R10
    .byt sti | N1   ; write output stream
    .byt dcr | R11
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R10
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | R10
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R10              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R11
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       RLDECODE ( srcaddr targaddr srclen -- )
;
; decode length {srclen} bytes beginning at source address
; {srcaddr} to the target address (targaddr).
;
;       RLDECODE ( srcaddr targaddr srclen -- )
#ifdef HEADERS
rldecodelfa
    .byt $de,$ad
    .byt (rldecode-*-1)|bit7
    .asc "RLDECOD","E"|bit7
#endif
rldecode
    ldy #2
    jsr locals
    brk
    .byt set | R9
    .word $100
rldecode01
    .byt ld | R9
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | R9
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt

;--------------------------------------------------------------
;
;       BLOCK   ( n -- addr )
;
#ifdef HEADERS
blocklfa
    .byt $de,$ad
    .byt (_block-*-1)|bit7
    .asc "BLOC","K"|bit7
#endif
_block
#include "enter.i65"
    .word _pblock
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       $INDEX   ( addr char -- index|0 )
;
; returns the position of char within the counted string at addr
; otherwise returns 0
#ifdef HEADERS
dolindexlfa
    .byt $de,$ad
    .byt (dolindex-*-1)|bit7
    .asc "$INDE","X"|bit7
#endif
dolindex
    ldy #1
    jsr locals
    lda (n),y
    tay             ; Y = length of string
dolindex01
    lda (n),y
    eor tos
    beq dolindex02
    dey
    bne dolindex01
dolindex02
    sty tos
    ;ldy #0         ; we started with a char at tos
    ;sty tos+1      ; so high byte is already 0
    jmp next

;--------------------------------------------------------------
;
;       TOGGLEVECTOR   ( eorvalue $90|$92 -- )
;
; Apply a difference value to the interrupt vector, pointing
; it to a new destination.  The same difference value restores the
; original target.
;
#ifdef HEADERS
togglevectorlfa
    .byt $de,$ad
    .byt (togglevector-*-1)|bit7
    .asc "TOGGLEVECTO","R"|bit7
#endif
togglevector
    sei
    ldy #0
    lda (tos),y
    eor stackl,x
    sta (tos),y
    iny
    lda (tos),y
    eor stackh,x
    sta (tos),y
    cli
    jmp poptwo          ; [20]

;--------------------------------------------------------------
;
;       CMENU   ( char -- )
;
; Find the index of a character in a string.  Execute a word 
; (by CFA) from a corresponding list of CFA addresses.
;
; In the dictionary, CMENU is followed by a counted string, then
; a list of words 
;
; the first byte following cmenu is the size of the menu,
; followed by that many characters, one per choice,
; followed by the CFA for each choice
;
; Used for inline jump tables
;
; example
;": editcmd 
;     flipscr key flipscr        ( char )
;     cmenu [
;     16 c,
;       ascii q c,  ascii i c,  ascii s c,  ascii l c,
;       ascii v c,  ascii z c,  ascii r c,  ascii d c,
;       ascii c c,  ascii p c,  DELETE c,   INSERT c,
;       HOME c,     CLR c,      CRSRDOWN c, CRSRUP c,   
;       ' editquit ,    ' editindex ,   ' editsave ,    ' editload ,
;       ' editverify ,  ' editzilch ,   ' editrestore , ' editdel ,
;       ' editcopy ,    ' editpaste ,   ' editdelscr ,  ' editinssrc ,
;       ' edittopscr ,  ' editnowrap ,  ' editnextscr , ' editprevscr ,
;       ] ;
#ifdef HEADERS
cmenulfa
    .byt $de,$ad
    .byt (_cmenu-*-1)|bit7
    .asc "CMEN","U"|bit7
#endif
_cmenu
#include "enter.i65"
    .word rfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word dolindex
#include "page.i65"
    .word twostar
#include "page.i65"
    .word 
#include "page.i65"

;--------------------------------------------------------------
;
;       EXPECT2   ( addr +n -- )
;
; A variant of EXPECT, this uses a phantom screen
;
#ifdef HEADERS
expect2lfa
    .byt $de,$ad
    .byt (expect2-*-1)|bit7
    .asc "EXPECT","2"|bit7
#endif
expect2
    jmp expect2vector
expect2vector
    ldy #1
    jsr locals
    stx storex

    lda #3      ; Screen = device 3
    sta $af     ; DFLTN Default Input Device = screen
    lda #$0
    sta $c4     ; PNT pointer - current scren line address
    sta $c6     ; PNTR cursor column on current line
    lda #$7c
    sta $c5     ; PNT
    lda #39
    sta $d5     ; LNMX physical screen line length

    dey
expect201
    iny
    cpy tos
    bcs expect202
    jsr CHRIN
    cmp #$0d
    beq expect202
    sta (n),y
    bne expect201
expect202
    tya
    ldy span+3
    sta (up),y
    iny
    lda #0
    sta (up),y
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;        REHASH   ( -- )
;
; rebuilds the symbol table in high memory.
;
; *** TRICK ALERT ***
; Uses the address on the return stack to determine if the caller 
; was COLD.  Doesn't copy stuff to PAD if that's the case (it's 
; already there from load) 
;
#ifdef HEADERS
rehashlfa
    .byt $de,$ad
    .byt (_rehash-*-1)|bit7
    .asc "REHAS","H"|bit7
#endif
_rehash
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#include "editor.a65"

endofile
    .dsb 80,$00
;_pad
;the build will be concatenating the symbol table right here.
;REHASH will be expecting it.

; PETTIL 
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate (nfa len)

;zero page
*=$18					; bnextend-bnextbegin
tos = *			: *=*+2
n = *			: *=*+8
up = *			: *=*+2
stash = *		: *=*+1
ireg = *		: *=*+4
stackl = *		: * = *+((time-*)/2)
stackh = *				; and from here to time for stackh
bos = stackh-stackl			; bos+stack(l|h) = bottom of stack

basic	= $0400
		.word basic+1		; PET BASIC storage starts here
*		= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc "(1040)",0		; sys $0410
basend		.word 0

		.dsb basic+$10-*,$ea
		jmp cold
		jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userup		.word tape2buf				; 6..7
usersp0		.word bos				; 8..9
userrp0		.word $01ff				; 10..11
userwidth	.word 31				; 12..13
userwarning	.word -1				; 14..15
userfence	.word $2f25				; 16..17
uservoclink	.word $650b				; 18..19
userviewquery	.word $36a2				; 20..21
userblk		.word 2					; 22..23
usertoin	.word $1908				; 24..25
userbase	.word 10				; 26..27
usercontext	.word 0					; 28..29 ~
usercsp		.word 0					; 30..31

		;dictionary hash link table used by rechaining words
latestl		.dsb 16,0
latesth		.dsb 16,0

;--------------------------------------------------------------
; Inner Interpreter words  NEXT ENTER EXIT EXECUTE
;
;" The classic way of implementing a direct-threaded inner interpreter:
;" (source: http://www.forthfreak.net/index.cgi?DirectThreadedCodePseudoCode)
;"
;" NEXT:
;"    [IP+] -> W
;"    W+    -> PC       \ W is incremented by the instruction length at W.
;"                      \ A subroutine call is sometimes used, pulling the  
;"                      \ return address into W has the desired effect.
;" 
;" NEST:
;"    IP    -> [-RP]
;"    W     -> IP
;"    NEXT
;" 
;" UNNEST:
;"    [RP+] -> IP
;"    NEXT

;--------------------------------------------------------------
;
;	NEXT
;
; PETTIL takes a few left turns from the classic model, but it's fast.
; Props to Anton Ertl on comp.lang.forth for the design idea.
;
; NEXT is the heart and soul of a Forth interpreter.  It executes
; more often, than any other routine, so it's the best place to 
; optimize.
;
; pseudocode for a typical indirect-threaded NEXT is
; [IP+] -> W
; JMP [W]
; 
; PETTIL's NEXT is unorthodox because it pre-increments IP and 
; uses a direct-threaded model, which drops one level of indirection.
; It's self-modifying code that lives on the zero page.  By 
; dispensing with W register, we get it down to 17 cycles!
;
; JMP [+IP]
;
; Since the 6502 can't pull this off in one neat little instruction,
; our NEXT has tons of entry points, described in the code comments.
; "next1" and "nexty" appear to be redundant, but it is that way so
; NEXT will return the expected results whether entered at the top,
; or from the bottom (nexto/nexty/nextx have no IP increment)
;
; NEXT is headerless, and is copied by COLD to the bottom of zeropage
; PETTIL primitives can expect Y = 1, C = clear on exit from NEXT
;
bnextbegin
ip				= $000f	; dummy value $CAFE
putya				= $0000	; YA to the TOS register
		sty tos+1
puta				= $0002	; your mom
		sta tos
next1				= $0004 ; entry to reset Y = 1
		ldy #1
next				= $0006	; entry for most purposes
		tya			;[2]
nexta				= $0007 ; adds an arbitrary amount to IP
		sec			;[2]
		adc ip			;[3]
		sta ip			;[3]
		bcs nextp +bnextbegin	;[2]
nexto				= $000e	; outtie!  doesn't alter IP, Y or C
		jmp ($cafe)		;[5] total 17 cycles
nextp				= $0011	; next page
		inc ip+1
nexty				= $0013	; like nexto, also fixes CLC & Y
		ldy #1
nextx				= $0015	; just fix CLC, then nexto
		clc
		bcc nexto +bnextbegin	; bra
bnextend			; $0018

;--------------------------------------------------------------
;
;	ENTER
;
; IP -> [-RP]
; [IP] -> W
; W+3 -> IP
; NEXT
;
; ENTER is headerless
enter		lda ip+1
		pha
		lda ip
		pha			; IP -> [-RP]
		lda (ip),y
		sta w1+1
		dey
		lda (ip),y
		sta w1			; [IP] -> W
		ldy w1+1
		lda w1
		adc #3
		bcc l001
		iny
l001		sty ip+1
		sta ip			; W+3 -> IP
		jmp nexty

;--------------------------------------------------------------
;
;	EXIT
;
; [RP+] -> IP
; NEXT
exitlfa		.word 0			; 0 LFA marks base of dictionary
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
; NEXT
exit		pla
		sta ip
		pla
		sta ip+1	; [RP+] -> IP
		jmp next	; NEXT

;--------------------------------------------------------------
;
;	EXECUTE
;
; Executes the definition found at addr.
;
;"	: execute ( cfa ---   )
;"	    jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa	.word $adde
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7	; length and final byte are OR $80
execute		lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1	; [SP] -> [W1]
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx		; SP+
		lda #<ip
		sta w1+4
		lda #>ip
		sta w1+5	; IP -> [W1+4]
		lda #<w1
		sta ip
		lda #>w1
		sta ip+1	; W1 -> IP
		jmp nexto

; These three words are used by EXECUTE as a 'fragment secondary'
; (for those occasions when you just need a W register)
; also used by ENTER
w1				; dummy value $DEAD, we wind up at $BEEF
		.word $dead
		.word branch
		.word $beef

;--------------------------------------------------------------
;
;	(LIT)
;
; push the word of memory following (IP)
;
plitlfa		.word $adde
		.byt (plit-*-1)|bit7
		.asc "(LIT",")"|bit7
plit		iny			; (IP),0 (IP),1 = address of plit
		lda (ip),y		; (IP),2 = low byte of literal
		sta n
		iny
		lda (ip),y		; (IP),3 = high byte of literal
		sta n+1

		lda #2
		adc ip
		sta ip
		bcc pushn
		inc ip+1

pushn		ldy n+1			; pushn entry - pushes n
		lda n			; n -> YA

push		sta stash		; push entry - pushes YA
		dex			; copy TOS to the real stack
		lda tos
		sta stackl,x
		lda tos+1
		sta stackh,x
		lda stash
		jmp putya

;--------------------------------------------------------------
;
;	CLIT
;
; takes the byte of memory following and pushes it to the data stack
;
;"	: clit ( -- c )
;"	  ip c@  1 ip +! ;
;
clitlfa		.word $adde
		.byt (clit-*-1)|bit7
		.asc "CLI","T"|bit7
clit		iny			; Y = 2
		lda (ip),y		; (IP),2 = low byte
		ldy #0			; high byte always zero
		inc ip
		bne push
		inc ip+1
		bcc push

;--------------------------------------------------------------
;
;	BRANCH
;
; Compiles an unconditional branch operation.
;" When used in the form:  COMPILE BRANCH
; an  unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated  by following BRANCH
; with <RESOLVE or >MARK .
;
;"	: branch ( -- )
;
branchlfa	.word $adde
		.byt (branch-*-1)|bit7
		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
; Y = 1
branch		iny		; [2]
		lda (ip),y	; [5+]
		sta stash	; [3]
		iny		; [2]
		lda (ip),y	; [5+]
		sta ip+1	; [3]
		lda stash	; [3]
		sta ip		; [3] (IP+2) -> IP
		jmp nexty	; [3] in through the out door (leaves IP alone)
				; [29/30 cycles] (runs in constant time)
;--------------------------------------------------------------
;
;	?BRANCH   ( flag -- )
;
qbranchlfa	.word $adde
		.byt (qbranch-*-1)|bit7
		.asc "?BRANC","H"|bit7
qbranch		bit tos
		php
		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx		; drop
		plp
		bne branch
		lda #4
		jmp nexta

;--------------------------------------------------------------
;
;	(LOOP)
;
plooplfa	.word $adde
		.byt (ploop-*-1)|bit7
		.asc "(LOOP",")"|bit7
ploop		jmp enter

;--------------------------------------------------------------
;
;	(+LOOP)
;
pplooplfa	.word $adde
		.byt (pploop-*-1)|bit7
		.asc "(+LOOP",")"|bit7
pploop		jmp enter

;--------------------------------------------------------------
;
;	(DO)
;
pdolfa		.word $adde
		.byt (pdo-*-1)|bit7
		.asc "(DO",")"|bit7
pdo		lda stackh,x
		pha
		lda stackl,x
		pha
		lda tos+1
		pha
		lda tos
		pha
poptwo		inx
pop		lda stackh,x
		ldy stackl,x
		inx
		jmp putya

;--------------------------------------------------------------
;
;	(?DO)
;
pqdolfa		.word $adde
		.byt (pqdo-*-1)|bit7
		.asc "(?DO",")"|bit7
pqdo		jmp enter

;--------------------------------------------------------------
;
;	I
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		jmp enter

;--------------------------------------------------------------
;
;	J
;
jlfa		.word $adde
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		jmp enter

;--------------------------------------------------------------
;
;	(LEAVE)
;
pleavelfa	.word $adde
		.byt (pleave-*-1)|bit7
		.asc "(LEAVE",")"|bit7
pleave		jmp enter

;--------------------------------------------------------------
;
;	(?LEAVE)
;
pqleavelfa	.word $adde
		.byt (pqleave-*-1)|bit7
		.asc "(?LEAVE",")"|bit7
pqleave		jmp enter

;--------------------------------------------------------------
;
;	DIGIT
;
digitlfa	.word $adde
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit		jmp enter

;--------------------------------------------------------------
;
;	(FIND)
;
pfindlfa	.word $adde
		.byt (pfind-*-1)|bit7
		.asc "(FIND",")"|bit7
pfind		jmp enter

;--------------------------------------------------------------
;
;	SKIP
;
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		jmp enter

;--------------------------------------------------------------
;
;	SCAN
;
scanlfa		.word $adde
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		jmp enter

;--------------------------------------------------------------
;
;	EMIT
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp enter

;--------------------------------------------------------------
;
;	KEY
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp enter

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp enter

;--------------------------------------------------------------
;
;	CR
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp enter

;--------------------------------------------------------------
;
;	CMOVE
;
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		jmp enter

;--------------------------------------------------------------
;
;	CMOVE>
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		jmp enter

;--------------------------------------------------------------
;
;	FILL
;
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		jmp enter

;--------------------------------------------------------------
;
;	UM*
;
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		jmp enter

;--------------------------------------------------------------
;
;	UM/MOD
;
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	jmp enter

;--------------------------------------------------------------
;
;	AND
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx		jmp enter

;--------------------------------------------------------------
;
;	OR
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx		jmp enter

;--------------------------------------------------------------
;
;	XOR
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor		jmp enter

;--------------------------------------------------------------
;
;	NOT
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		jmp enter

;--------------------------------------------------------------
;
;	SP@
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		jmp enter

;--------------------------------------------------------------
;
;	SP!
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		jmp enter

;--------------------------------------------------------------
;
;	RP!
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		jmp enter

;--------------------------------------------------------------
;
;	>R
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		jmp enter

;--------------------------------------------------------------
;
;	R>
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		jmp enter

;--------------------------------------------------------------
;
;	R@
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		jmp enter

;--------------------------------------------------------------
;
;	0>
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		jmp enter

;--------------------------------------------------------------
;
;	<>
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		jmp enter


;--------------------------------------------------------------
;
;	ON
;
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		sta (tos),y
		dey
		sta (tos),y
		jmp next

;--------------------------------------------------------------
;
;	OFF
;
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+
;
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
; d+
;--------------------------------------------------------------
; d<

;--------------------------------------------------------------
;
;	NEGATE
;
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		sec
		dey
neg2		tya
		sbc tos
		sta tos
		tya
		sbc tos+1
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	DNEGATE
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		sec
		dey
		tya
		sbc stackl,x
		sta stackl,x
		tya
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER
;
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp push

;--------------------------------------------------------------
;
;	DROP
;
droplfa		.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pop

;--------------------------------------------------------------
;
;	SWAP
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next1

;--------------------------------------------------------------
;
;	DUP
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp push

;--------------------------------------------------------------
;
;	+!
;
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE
;
togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		jmp pop

;--------------------------------------------------------------
;
;	@
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		lda (tos),y
		sta stash
		dey
		lda (tos),y
		sta tos
		lda stash
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	C@
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		lda (tos),y
		sta tos
		dey
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!
;
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		lda stackh,x
		sta (tos),y
		lda stackl,x
		dey
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		dey
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;" :
;--------------------------------------------------------------
; ;

;--------------------------------------------------------------
;
;	CONSTANT   ( -- n )
;
constantlfa	.word $adde
		.byt (constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
constant	jmp enter
		.word create
		.word comma
		.word psemi
doconst		lda (ip),y
		sta n+3
		dey
		lda (ip),y
		sta n+2
		ldy #3
		lda (n+2),y
		sta n
		iny
		lda (n),y
		sta n+1
		jmp pushn

;--------------------------------------------------------------
; variable
variablelfa	.word $adde
		.byt (variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
variable	jmp enter
		.word create
		.word two
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	USER
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user		.word enter
		.word constant
		.word psemi
uservar		ldy #3
		lda (ip),y		; byte offset into user area
		ldy up+1
		adc up
		bcc l008
		iny
l008		jmp push

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		dey
		tya
		jmp push

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		tya
		dey
		jmp push

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jmp doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jmp doconst
		.word 3

;--------------------------------------------------------------
;
;	BL
;
bllfa	.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jmp enter

;--------------------------------------------------------------
;
;	C/L
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jmp enter

;--------------------------------------------------------------
;
;	FIRST
;
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jmp enter

;--------------------------------------------------------------
;
;	LIMIT
;
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jmp enter

;--------------------------------------------------------------
;
;	#BUF
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jmp enter

;--------------------------------------------------------------
;
;	#BCQ
;
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jmp enter

;--------------------------------------------------------------
;
;	B/BUF
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jmp enter

;--------------------------------------------------------------
;
;	B/SCR
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jmp enter

;--------------------------------------------------------------
;
;	TIB
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jmp enter


;--------------------------------------------------------------
;
;	TRUE
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		ldy #$FF
		bmi false+1	; bra

;--------------------------------------------------------------
;
;	FALSE
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		dey
		tya
		jmp push

;--------------------------------------------------------------
;
;	0=
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		lda tos
		ora tos+1
		beq true
		bne false

;--------------------------------------------------------------
;
;	0<
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		bit tos+1
		bmi true
		bpl false

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		bne true
		beq false

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
plusorigin	jmp enter

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (spz-*-1)|bit7
		.asc "SP","0"|bit7
spz		jmp enter

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rpz-*-1)|bit7
		.asc "RP","0"|bit7
rpz		jmp enter

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jmp enter

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jmp enter

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jmp enter

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jmp enter

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jmp enter

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jmp enter

;--------------------------------------------------------------
;
;	BLK
;
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jmp enter

;--------------------------------------------------------------
;
;	>IN
;
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jmp enter

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jmp enter

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jmp enter

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jmp enter

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jmp enter

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jmp enter

;--------------------------------------------------------------
;
;	STATE
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jmp enter

;--------------------------------------------------------------
;
;	BASE
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jmp enter

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jmp enter

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; Returns  the  address of the user variable that
; contains the count of characters  received  and
; stored by the most recent execution of EXPECT .
; The  address    of the user variable containing
; the count of characters actually  received  and
; stored by the last execution of EXPECT .
span		jmp uservar
		.byt 42

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jmp enter

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jmp enter

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jmp enter

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jmp enter

;--------------------------------------------------------------
;
;	#TIB
;
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jmp enter

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jmp enter

;--------------------------------------------------------------
;
;	1+
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		jmp enter

;--------------------------------------------------------------
;
;	1-
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	jmp enter

;--------------------------------------------------------------
;
;	2+
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		jmp enter

;--------------------------------------------------------------
;
;	2-
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	jmp enter

;--------------------------------------------------------------
;
;	2/
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	jmp enter

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		jmp enter

;--------------------------------------------------------------
;
;	HERE
;
herelfa		.word $adde
		.byt (here-*-1)|bit7
		.asc "HER","E"|bit7
here		jmp enter

;--------------------------------------------------------------
;
;	ALLOT
;
allotlfa	.word $adde
		.byt (allot-*-1)|bit7
		.asc "ALLO","T"|bit7
allot		jmp enter

;--------------------------------------------------------------
;
;	,
;
commalfa	.word $adde
		.byt (comma-*-1)|bit7
		.asc ","|bit7
comma	jmp enter

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (ccomma-*-1)|bit7
		.asc "C",","|bit7
ccomma		jmp enter

;--------------------------------------------------------------
;
;	-
;
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jmp enter

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		dey
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		tya
		inx
		jmp putya

;--------------------------------------------------------------
;
;	u<
;
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
sgntst		bvc l012
		eor #bit7
l012		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc "<"|bit7
gt		dey
		sec
		lda tos
		sbc stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		jmp enter

;--------------------------------------------------------------
;
;	SPACE
;
spacelfa	.word $adde
		.byt (space-*-1)|bit7
		.asc "SPAC","E"|bit7
space		jmp enter

;--------------------------------------------------------------
;
;	?DUP
;
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		jmp enter

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"     SWAP
;"     BEGIN
;"         OVER +  127  OVER C@  <
;"     UNTIL
;"     SWAP DROP ;
traverselfa	.word $adde
		.byt (traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
traverse	jmp enter
		.word swap
l010		.word over
		.word plus
		.word clit
		.byt $7f
		.word over
		.word cfetch
		.word lt
		.word qbranch
		.word l010
		.word swap
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of  the  top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (latest-*-1)|bit7
		.asc "LATES","T"|bit7
latest		jmp enter

;--------------------------------------------------------------
;
;	FORTH-83
;
forth83lfa	.word $adde
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jmp enter

;--------------------------------------------------------------
;
;	>BODY
;
tobodylfa	.word $adde
		.byt (tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
tobody		jmp enter


;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt 5|bit7
		.asc ">NAM","E"|bit7
toname		jmp enter
		.word oneminus
		.word true
		.word traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt 5|bit7
		.asc ">LIN","K"|bit7
tolink		jmp enter
		.word toname
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>
;
bodyfromlfa	.word $adde
		.byt (bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
bodyfrom	jmp enter

;--------------------------------------------------------------
;
;	NAME>
;
namefromlfa	.word $adde
		.byt (namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
namefrom	jmp enter

;--------------------------------------------------------------
;
;	LINK>
;
linkfromlfa	.word $adde
		.byt (linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
linkfrom	jmp enter

;--------------------------------------------------------------
;
;	N>LINK
;
ntolinklfa	.word $adde
		.byt (ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
ntolink		jmp enter


;--------------------------------------------------------------
;
;	L>NAME
;
linktonamelfa	.word $adde
		.byt (linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
linktoname	jmp enter

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
storecsp	jmp enter

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (where-*-1)|bit7
		.asc "WHER","E"|bit7
where	jmp enter

;--------------------------------------------------------------
;
;	(ABORT")
;
pabortqlfa	.word $adde
		.byt (pabortq-*-1)|bit7
		.asc "(ABORT",'"',")"|bit7
pabortq		jmp enter

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (commadollar-*-1)|bit7
		.asc ",","$"|bit7
commadollar	jmp enter

;--------------------------------------------------------------
;
;	ABORT"
;
abortqlfa	.word $adde
		.byt (abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
abortq		jmp enter

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
qcomp		jmp enter

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
qfind		jmp enter

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
qpairs		jmp enter

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
qcsp		jmp enter

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
qchar		jmp enter

;--------------------------------------------------------------
;
;	COMPILE
;
compilelfa	.word $adde
		.byt (compile-*-1)|bit7
		.asc "COMPIL","E"|bit7
compile		jmp enter

;--------------------------------------------------------------
;
;	[
;
lbracketlfa	.word $adde
		.byt (lbracket-*-1)|bit7
		.asc "["|bit7
lbracket	jmp enter

;--------------------------------------------------------------
;
;	]
;
rbracketlfa	.word $adde
		.byt (rbracket-*-1)|bit7
		.asc "]"|bit7
rbracket	jmp enter

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
smudge		jmp enter

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (hex-*-1)|bit7
		.asc "HE","X"|bit7
hex	jmp enter

;--------------------------------------------------------------
;
;	DECIMAL
;
decimallfa	.word $adde
		.byt (decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
decimal		jmp enter

;--------------------------------------------------------------
;
;	(;CODE)
psemilfa	.word $adde
		.byt (psemi-*-1)|bit7
		.asc "(;CODE",")"|bit7
psemi		jmp enter

;--------------------------------------------------------------
;
;	DOES>
;
doeslfa		.word $adde
		.byt (does-*-1)|bit7
		.asc "DOES",">"|bit7
does		jmp enter

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; Leaves  the address,  addr2 and the character
; count +n of text  beginning at addr1.
; addr2 is addr1+1 and n1 is the  length  of  the
; counted string at addr1.  The byte at addr1 con-
; tains  the  byte  count  +n.    Range  of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		dey
		lda (tos),y
		inc tos
		bne l020
		inc tos+1
l020		jmp push

;--------------------------------------------------------------
;
;	TYPE
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		jmp enter

;--------------------------------------------------------------
;
;	-TRAILING
;
dashtrailinglfa	.word $adde
		.byt (dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
dashtrailing	jmp enter

;--------------------------------------------------------------
;
;	(.")
;
pdotqlfa	.word $adde
		.byt (pdotq-*-1)|bit7
		.asc "(.",'"',")"|bit7
pdotq		jmp enter

;--------------------------------------------------------------
;
;	."
;
dotqlfa		.word $adde
		.byt (dotq-*-1)|bit7
		.asc ".",'"'|bit7
dotq		jmp enter

;--------------------------------------------------------------
;
;	.(
;
dotplfa		.word $adde
		.byt (dotp-*-1)|bit7
		.asc ".","("|bit7
dotp		jmp enter

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; Stores up to +n characters into  memory  begin-
; ning at addr.
; Receive  characters and store each into memory.
; The transfer begins at addr proceeding  towards
; higher  addresses  one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.   No  more  than  +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or  transfered  if +n is zero.   All characters
; actually received and stored into  memory  will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp enter

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (query-*-1)|bit7
		.asc "QUER","Y"|bit7
query		jmp enter

;--------------------------------------------------------------
;
;	" "
;
spacenplfa	.word $adde
		.byt (spacenp-*-1)|bit7|bit6
		.asc " "|bit7
spacenp		.word enter
		.word doneq
		.word on
		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
quitq		jmp enter

;--------------------------------------------------------------
;
;	ERASE
;
eraselfa	.word $adde
		.byt (erase-*-1)|bit7
		.asc "ERAS","E"|bit7
erase		jmp enter

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (blank-*-1)|bit7
		.asc "BLAN","K"|bit7
blank	jmp enter

;--------------------------------------------------------------
;
;	HOLD
;
holdlfa		.word $adde
		.byt (hold-*-1)|bit7
		.asc "HOL","D"|bit7
hold		jmp enter

;--------------------------------------------------------------
;
;	PAD
;
padlfa		.word $adde
		.byt (pad-*-1)|bit7
		.asc "PA","D"|bit7
pad		jmp enter

;--------------------------------------------------------------
;
;	'STREAM
;
tickstreamlfa	.word $adde
		.byt (tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
tickstream	jmp enter


;--------------------------------------------------------------
;
;	WORD
;
wordlfa		.word $adde
		.byt (word-*-1)|bit7
		.asc "WOR","D"|bit7
word		jmp enter

;--------------------------------------------------------------
;
;	>LOWER
;
tolowerlfa	.word $adde
		.byt (tolower-*-1)|bit7
		.asc ">LOWE","R"|bit7
tolower		jmp enter

;--------------------------------------------------------------
;
;	(PUNCT?)
;
ppunctqlfa	.word $adde
		.byt (ppunctq-*-1)|bit7
		.asc "(PUNCT?",")"|bit7
ppunctq		jmp enter

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
punctq		jmp enter

;--------------------------------------------------------------
;
;	CONVERT
;
convertlfa	.word $adde
		.byt (convert-*-1)|bit7
		.asc "CONVER","T"|bit7
convert		jmp enter

;--------------------------------------------------------------
;
;	NUMBER
;
numberlfa	.word $adde
		.byt (number-*-1)|bit7
		.asc "NUMBE","R"|bit7
number		jmp enter

;--------------------------------------------------------------
;
;	FIND
;
findlfa		.word $adde
		.byt (find-*-1)|bit7
		.asc "FIN","D"|bit7
find		jmp enter

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
existsq		jmp enter

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (iddot-*-1)|bit7
		.asc "ID","."|bit7
iddot		jmp enter

;--------------------------------------------------------------
;
;	CREATE
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"  @ + + u< (abort") dictionary full exists?
;"  over (lit) 6017 = (abort") name required
;"  warning @ and ?branch 41 >name cr
;"  clit 18 emit id. clit 146 emit (.") already exists
;"  branch 4 drop here dup c@
;"  over 2+ view? @ + dup >r swap 1+ cmove>
;"  r> dup c@ width @ min 1+ 2dup + clit 255
;"  and clit 255 = ?branch 25 2dup swap
;"  dup 1+ rot cmove> clit 234 c, swap 1+
;"  swap 2+ view? @ + allot dup clit 128 toggle
;"  here 1- clit 128 toggle latest over
;"  2- ! view? @ ?branch 14 blk @ over 2-
;"  2- ! 2 allot current @ ! (;code)
;".C:1b0b   18         CLC
;".C:1b0c   A5 87      LDA $87
;".C:1b0e   69 02      ADC #$02
;".C:1b10   48         PHA
;".C:1b11   98         TYA
;".C:1b12   65 88      ADC $88
;".C:1b14   4C 4A 08   JMP $084A
createlfa	.word $adde
		.byt (create-*-1)|bit7
		.asc "CREAT","E"|bit7
create		jmp enter
		.word frombcq
		.word here
		.word width
		.word fetch
		.word twoplus
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word plus
		.word ult
		.word pabortq
		.byt l013-*-1
		.asc "DICTIONARY FULL"
l013		.word existsq
		.word over
		.word plit
		.word spacenp
		.word eq
		.word pabortq
		.byt l014-*-1
		.asc "NAME REQUIRED"
l014		.word warning
		.word fetch
		.word andx
		.word qbranch
		.word l016
		.word toname
		.word cr
		.word clit
		.byt $12	; rvs
		.word emit
		.word iddot
		.word clit
		.byt $92	; off
		.word emit
		.word pdotq
		.byt l015-*-1
		.asc " ALREADY EXISTS "
l015		.word branch
		.word l017
l016		.word drop
l017		.word here
		.word dup
		.word cfetch
		.word over
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word dup
		.word tor
		.word swap
		.word oneplus
		.word cmovegt
		.word rfrom
		.word dup
		.word cfetch
		.word width
		.word fetch
		.word min
		.word oneplus
		.word twodup
		.word plus
		.word clit
		.byt $ff
		.word andx
		.word clit
		.byt $ff
		.word eq
		.word qbranch
		.word l018
		.word twodup
		.word swap
		.word dup
		.word oneplus
		.word rot
		.word cmovegt
		.word clit
		.byt $ea
		.word ccomma
		.word swap
		.word oneplus
		.word swap
l018		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word allot
		.word dup
		.word clit
		.byt $80
		.word toggle
		.word here
		.word oneminus
		.word clit
		.byt $80
		.word toggle
		.word latest
		.word over
		.word twominus
		.word store
		.word viewq
		.word fetch
		.word qbranch
		.word l019
		.word blk
		.word fetch
		.word over
		.word twominus
		.word twominus
		.word store
l019		.word two
		.word allot
		.word current
		.word fetch
		.word store
		.word psemi
docreate	lda w1
		adc #3
		tay
		lda #0
		adc w1+1
		jmp push

;--------------------------------------------------------------
;
;	[COMPILE]
;
bcompilelfa	.word $adde
		.byt (bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
bcompile	jmp enter

;--------------------------------------------------------------
;
;	LITERAL
;
literallfa	.word $adde
		.byt (literal-*-1)|bit7
		.asc "LITERA","L"|bit7
literal		jmp enter

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
dliteral	jmp enter

;--------------------------------------------------------------
;
;	?STACK
;
qstacklfa	.word $adde
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		jmp enter

;--------------------------------------------------------------
;
;	INTERPRET
;
interpretlfa	.word $adde
		.byt (interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
interpret	jmp enter

;--------------------------------------------------------------
;
;	IMMEDIATE
;
immediatelfa	.word $adde
		.byt (immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
immediate	jmp enter

;--------------------------------------------------------------
;
;	VOCABULARY
;
vocabularylfa	.word $adde
		.byt (vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
vocabulary	jmp enter

;--------------------------------------------------------------
;
;	FORTH
;
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jmp enter

;--------------------------------------------------------------
;
;	DEFINITIONS
;
definitionslfa	.word $adde
		.byt (definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
definitions	jmp enter

;--------------------------------------------------------------
;
;	(
;
lparenlfa	.word $adde
		.byt (lparen-*-1)|bit7
		.asc "("|bit7
lparen		jmp enter

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (run-*-1)|bit7
		.asc "RU","N"|bit7
run		jmp enter

;--------------------------------------------------------------
;
;	ABORT
;
abortlfa	.word $adde
		.byt (abort-*-1)|bit7
		.asc "ABOR","T"|bit7
abort		jmp enter

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jmp docreate
		.word abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		sei
		cld
		ldx #$f8
		txs
		jsr CLRCHN
		jsr CLALL
		cli

		ldy #bnextend-bnextbegin+1
l011		lda bnextbegin-1,y
		sta putya-1,y
		dey
		bne l011
		iny			; Y = 1 to make primitives happy

		; initialize the data stack pointer
		ldx #bos
		; move up to high-level
xpetp		lda #>cold2
		sta ip+1
		lda #<cold2
		sta ip
		jmp nexty
cold2		.word rethread
		.word startup
		.word fetch
		.word execute

;Warm start
;--------------------------------------------------------------
;
;	WARM
warm		rts

;--------------------------------------------------------------
;
;	QUIT
;
; PETTIL's outer interpreter infinite loop
;
quitlfa		.word $adde
		.byt (quit-*-1)|bit7
		.asc "QUI","T"|bit7
quit		.word enter
		.word zero
		.word blk
		.word store
		.word lbracket
l007		.word rpstore
		.word cr
		.word query
		.word interpret
		.word state
		.word fetch
		.word zeq
		.word qbranch
		.word l006
		.word pdotq
		.byt (l006-*-1)
		.asc "OK"
l006		.word branch
		.word l007

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (stod-*-1)|bit7
		.asc "S>","D"|bit7
stod		jmp enter

;--------------------------------------------------------------
;
;	ABS
;
abslfa		.word $adde
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs		jmp enter

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs		jmp enter

;--------------------------------------------------------------
;
;	MIN
;
minlfa		.word $adde
		.byt (min-*-1)|bit7
		.asc "MI","N"|bit7
min		jmp enter

;--------------------------------------------------------------
;
;	MAX
;
maxlfa	.word $adde
		.byt (max-*-1)|bit7
		.asc "MA","X"|bit7
max	jmp enter

;--------------------------------------------------------------
;
;	M*
;
mstarlfa	.word $adde
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jmp enter

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash		jmp enter

;--------------------------------------------------------------
;
;	*
;
starlfa		.word $adde
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jmp enter

;--------------------------------------------------------------
;
;	/MOD
;
slashmodlfa	.word $adde
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jmp enter

;--------------------------------------------------------------
;
;	/
;
slashlfa	.word $adde
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jmp enter

;--------------------------------------------------------------
;
;	MOD
;
modlfa		.word $adde
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jmp enter

;--------------------------------------------------------------
;
;	*/MOD
;
starslashmodlfa	.word $adde
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jmp enter

;--------------------------------------------------------------
;
;	*/
;
starslashlfa	.word $adde
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jmp enter

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jmp enter

;--------------------------------------------------------------
;
;	<BCQ
;
frombcqlfa	.word $adde
		.byt (frombcq-*-1)|bit7
		.asc "<BC","Q"|bit7
frombcq		jmp enter

;--------------------------------------------------------------
;
;	BCQ>
;
bcqfromlfa	.word $adde
		.byt (bcqfrom-*-1)|bit7
		.asc "BCQ",">"|bit7
bcqfrom		jmp enter

;--------------------------------------------------------------
;
;	>bcq
;
tobcqlfa	.word $adde
		.byt (tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
tobcq		jmp enter

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
latestq		jmp enter

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
absentq		jmp enter

;--------------------------------------------------------------
;
;	UPDATE
;
updatelfa	.word $adde
		.byt (update-*-1)|bit7
		.asc "UPDAT","E"|bit7
update		jmp enter

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (drzero-*-1)|bit7
		.asc "DR","0"|bit7
drzero		jmp enter

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (drone-*-1)|bit7
		.asc "DR","1"|bit7
drone		jmp enter

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
discard		jmp enter

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
missing		jmp enter

;--------------------------------------------------------------
;
;	BUFFER
;
bufferlfa	.word $adde
		.byt (buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
buffer		jmp enter

;--------------------------------------------------------------
;
;	BLOCK
;
blocklfa	.word $adde
		.byt (block-*-1)|bit7
		.asc "BLOC","K"|bit7
block		jmp enter

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS
;
emptybufferslfa	.word $adde
		.byt (emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
emptybuffers	jmp enter

;--------------------------------------------------------------
;
;	SAVE-BUFFERS
;
savebufferslfa	.word $adde
		.byt (savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
savebuffers	jmp enter

;--------------------------------------------------------------
;
;	FLUSH
;
flushlfa	.word $adde
		.byt (flush-*-1)|bit7
		.asc "FLUS","H"|bit7
flush		jmp enter

;--------------------------------------------------------------
;
;	LOAD
;
loadlfa		.word $adde
		.byt (load-*-1)|bit7
		.asc "LOA","D"|bit7
load		jmp enter

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
todisc		jmp enter

;--------------------------------------------------------------
;
;	(R/W)
;
prslashwlfa	.word $adde
		.byt (prslashw-*-1)|bit7
		.asc "(R/W",")"|bit7
prslashw	jmp enter

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (rslashw-*-1)|bit7
		.asc "R/","W"|bit7
rslashw		jmp enter

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
tnslfa		.word $adde
		.byt (tns-*-1)|bit7
		.asc "T&","S"|bit7
tns		jmp enter

;--------------------------------------------------------------
;
;	(OPEN)
;
popenlfa	.word $adde
		.byt (popen-*-1)|bit7
		.asc "(OPEN",")"|bit7
popen		jmp enter

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (close-*-1)|bit7
		.asc "CLOS","E"|bit7
close		jmp enter

;--------------------------------------------------------------
;
;	(CMDIN)
;
pcmdinlfa	.word $adde
		.byt (pcmdin-*-1)|bit7
		.asc "(CMDIN",")"|bit7
pcmdin		jmp enter

;--------------------------------------------------------------
;
;	(CMDOUT)
;
pcmdoutlfa	.word $adde
		.byt (pcmdout-*-1)|bit7
		.asc "(CMDOUT",")"|bit7
pcmdout		jmp enter

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff		jmp enter

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (status-*-1)|bit7
		.asc "STATU","S"|bit7
status		jmp enter

;--------------------------------------------------------------
;
;	(?DISC)
;
pqdisclfa	.word $adde
		.byt (pqdisc-*-1)|bit7
		.asc "(?DISC",")"|bit7
pqdisc		jmp enter

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
ioerr		jmp enter
		.word qdup
		.word qbranch
		.word s028
		.word dup
		.word one
		.word eq
		.word pabortq
		.byt s020-*-1
		.asc "TOO MANY OPEN FILES"
s020		.word dup
		.word two
		.word eq
		.word pabortq
		.byt s021-*-1
		.asc "FILE ALREADY OPEN"
s021		.word dup
		.word three
		.word eq
		.word pabortq
		.byt s022-*-1
		.asc "FILE NOT OPEN"
s022		.word dup
		.word clit
		.byt 4
		.word eq
		.word pabortq
		.byt s023-*-1
		.asc "FILE NOT FOUND"
s023		.word dup
		.word clit
		.byt 5
		.word eq
		.word pabortq
		.byt s024-*-1
		.asc "DEVICE NOT PRESENT"
s024		.word dup
		.word clit
		.byt 6
		.word eq
		.word pabortq
		.byt s025-*-1
		.asc "NOT INPUT FILE"
s025		.word dup
		.word clit
		.byt 7
		.word eq
		.word pabortq
		.byt s026-*-1
		.asc "NOT OUTPUT FILE"
s026		.word dup
		.word clit
		.byt 8
		.word eq
		.word pabortq
		.byt s027-*-1
		.asc "MISSING FILE NAME"
s027		.word dup
		.word clit
		.byt 9
		.word eq
		.word pabortq
		.byt s028-*-1
		.asc "ILLEGAL DEVICE NUMBER"
s028		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
dotderr		jmp enter

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (mount-*-1)|bit7
		.asc "MOUN","T"|bit7
mount		jmp enter

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
qdisc		jmp enter

;--------------------------------------------------------------
;
;	'
;
ticklfa		.word $adde
		.byt (tick-*-1)|bit7
		.asc "'"|bit7
tick		jmp enter

;--------------------------------------------------------------
;
;	[']
;
brticklfa	.word $adde
		.byt (brtick-*-1)|bit7
		.asc "['","]"|bit7
brtick		jmp enter

;--------------------------------------------------------------
;
;	?>MARK
;
qtomarklfa	.word $adde
		.byt (qtomark-*-1)|bit7
		.asc "?>MAR","K"|bit7
qtomark		jmp enter

;--------------------------------------------------------------
;
;	?<MARK
;
qfrommarklfa	.word $adde
		.byt (qfrommark-*-1)|bit7
		.asc "?<MAR","K"|bit7
qfrommark	jmp enter

;--------------------------------------------------------------
;
;	?>RESOLVE
;
qtoresolvelfa	.word $adde
		.byt (qtoresolve-*-1)|bit7
		.asc "?>RESOLV","E"|bit7
qtoresolve	jmp enter

;--------------------------------------------------------------
;
;	?<RESOLVE
;
qfromresolvelfa	.word $adde
		.byt (qfromresolve-*-1)|bit7
		.asc "?<RESOLV","E"|bit7
qfromresolve	jmp enter

;--------------------------------------------------------------
;
;	ADD>MARK
;
addtomarklfa	.word $adde
		.byt (addtomark-*-1)|bit7
		.asc "ADD>MAR","K"|bit7
addtomark	jmp enter

;--------------------------------------------------------------
;
;	BEGIN
;
beginlfa	.word $adde
		.byt (begin-*-1)|bit7
		.asc "BEGI","N"|bit7
begin		jmp enter

;--------------------------------------------------------------
;
;	THEN
;
thenlfa		.word $adde
		.byt (then-*-1)|bit7
		.asc "THE","N"|bit7
then		jmp enter

;--------------------------------------------------------------
;
;	DO
;
dolfa		.word $adde
		.byt (do-*-1)|bit7
		.asc "D","O"|bit7
do		jmp enter

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (qdo-*-1)|bit7
		.asc "?D","O"|bit7
qdo		jmp enter

;--------------------------------------------------------------
;
;	LOOP
;
looplfa		.word $adde
		.byt (loop-*-1)|bit7
		.asc "LOO","P"|bit7
loop		jmp enter

;--------------------------------------------------------------
;
;	+LOOP
;
pluslooplfa	.word $adde
		.byt (plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
plusloop	jmp enter

;--------------------------------------------------------------
;
;	LEAVE
;
leavelfa	.word $adde
		.byt (leave-*-1)|bit7
		.asc "LEAV","E"|bit7
leave		jmp enter

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
qleave		jmp enter

;--------------------------------------------------------------
;
;	UNTIL
;
untillfa	.word $adde
		.byt (until-*-1)|bit7
		.asc "UNTI","L"|bit7
until		jmp enter

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (again-*-1)|bit7
		.asc "AGAI","N"|bit7
again		jmp enter

;--------------------------------------------------------------
;
;	REPEAT
;
repeatlfa	.word $adde
		.byt (repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
repeat		jmp enter

;--------------------------------------------------------------
;
;	IF
;
iflfa		.word $adde
		.byt (if-*-1)|bit7
		.asc "I","F"|bit7
if		jmp enter

;--------------------------------------------------------------
;
;	ELSE
;
elselfa		.word $adde
		.byt (else-*-1)|bit7
		.asc "ELS","E"|bit7
else		jmp enter

;--------------------------------------------------------------
;
;	WHILE
;
whilelfa	.word $adde
		.byt (while-*-1)|bit7
		.asc "WHIL","E"|bit7
while		jmp enter

;--------------------------------------------------------------
;
;	SPACES
;
spaceslfa	.word $adde
		.byt (spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
spaces		jmp enter

;--------------------------------------------------------------
;
;	<#
;
ltsharplfa	.word $adde
		.byt (ltsharp-*-1)|bit7
		.asc "<","#"|bit7
ltsharp		jmp enter

;--------------------------------------------------------------
;
;	#>
;
sharpgtlfa	.word $adde
		.byt (sharpgt-*-1)|bit7
		.asc "#",">"|bit7
sharpgt	jmp enter

;--------------------------------------------------------------
;
;	SIGN
;
signlfa		.word $adde
		.byt (sign-*-1)|bit7
		.asc "SIG","N"|bit7
sign		jmp enter

;--------------------------------------------------------------
;
;	#
;
sharplfa	.word $adde
		.byt (sharp-*-1)|bit7
		.asc "#"|bit7
sharp		jmp enter

;--------------------------------------------------------------
;
;	#S
;
sharpslfa	.word $adde
		.byt (sharps-*-1)|bit7
		.asc "#","S"|bit7
sharps		jmp enter

;--------------------------------------------------------------
;
;	(U.)
;
pudotlfa	.word $adde
		.byt (pudot-*-1)|bit7
		.asc "(U.",")"|bit7
pudot		jmp enter

;--------------------------------------------------------------
;
;	U.
;
udotlfa		.word $adde
		.byt (udot-*-1)|bit7
		.asc "U","."|bit7
udot		jmp enter

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (udotr-*-1)|bit7
		.asc "U.","R"|bit7
udotr		jmp enter

;--------------------------------------------------------------
;
;	(.)
;
pdotlfa		.word $adde
		.byt (pdot-*-1)|bit7
		.asc "(.",")"|bit7
pdot		jmp enter

;--------------------------------------------------------------
;
;	.
;
dotlfa		.word $adde
		.byt (dot-*-1)|bit7
		.asc "."|bit7
dot		jmp enter

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (dotr-*-1)|bit7
		.asc ".","R"|bit7
dotr	jmp enter

;--------------------------------------------------------------
;
;	(UD.)
;
puddotlfa	.word $adde
		.byt (puddot-*-1)|bit7
		.asc "(UD.",")"|bit7
puddot		jmp enter

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (uddot-*-1)|bit7
		.asc "UD","."|bit7
uddot		jmp enter

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
uddotr		jmp enter

;--------------------------------------------------------------
;
;	(D.)
;
pdddotlfa	.word $adde
		.byt (pddot-*-1)|bit7
		.asc "(D.",")"|bit7
pddot		jmp enter

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (ddot-*-1)|bit7
		.asc "D","."|bit7
ddot		jmp enter

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (ddotr-*-1)|bit7
		.asc "D.","R"|bit7
ddotr		jmp enter

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (question-*-1)|bit7
		.asc "?"|bit7
question	jmp enter

;--------------------------------------------------------------
;
;	PICK
;
picklfa		.word $adde
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick		jmp enter

;--------------------------------------------------------------
;
;	ROLL
;
rolllfa		.word $adde
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		jmp enter

;--------------------------------------------------------------
;
;	DEPTH
;
depthlfa	.word $adde
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth		jmp enter

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp enter

;--------------------------------------------------------------
;
;	2DUP
;
twoduplfa	.word $adde
		.byt (twodup-*-1)|bit7
		.asc "2DU","P"|bit7
twodup		jmp enter

;--------------------------------------------------------------
;
;	2OVER
;
twooverlfa	.word $adde
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		jmp enter

;--------------------------------------------------------------
;
;	2ROT
;
tworotlfa	.word $adde
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		jmp enter

;--------------------------------------------------------------
;
;	2SWAP
;
twoswaplfa	.word $adde
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		jmp enter

;--------------------------------------------------------------
;
;	2!
;
twostorelfa	.word $adde
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	jmp enter

;--------------------------------------------------------------
;
;	2@
;
twofetchlfa	.word $adde
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	jmp enter

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
twoconst	jmp enter

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
twovariable	jmp enter

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus		jmp enter

;--------------------------------------------------------------
;
;	D0=
;
dzeqlfa		.word $adde
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		jmp enter

;--------------------------------------------------------------
;
;	D=
;
deqlfa		.word $adde
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		jmp enter

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jmp enter

;--------------------------------------------------------------
;
;	D2/
;
dtwoslashlfa	.word $adde
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	jmp enter

;--------------------------------------------------------------
;
;	D2*
;
dtwostarlfa	.word $adde
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	jmp enter

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (dgt-*-1)|bit7
		.asc "D",">"|bit7
dgt		jmp enter

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (dmin-*-1)|bit7
		.asc "DMI","N"|bit7
dmin		jmp enter

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (dmax-*-1)|bit7
		.asc "DMA","X"|bit7
dmax		jmp enter

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
configure	jmp enter

;--------------------------------------------------------------
;
;	FREEZE
;
freezelfa	.word $adde
		.byt (freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
freeze		jmp enter

;--------------------------------------------------------------
;
;	(BSAVE)
;
pbsavelfa	.word $adde
		.byt (pbsave-*-1)|bit7
		.asc "(BSAVE",")"|bit7
pbsave		jmp enter

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
saveforth	jmp enter

;--------------------------------------------------------------
;
;	FORGET
;
forgetlfa	.word $adde
		.byt (forget-*-1)|bit7
		.asc "FORGE","T"|bit7
forget		jmp enter

;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde
		.byt (thru-*-1)|bit7
		.asc "THR","U"|bit7
thru		jmp enter

;==============================================================

; hash-threaded dictionary search
; These won't remain in the final core (LOAD "*") version
; but it will be useful during development to automatically generate
; all LFAs so I can rearrange the dictionary at will without tedious
; LFA editing.
;
; Three top-level words rewrite the entire LFA chain
; 1THREAD resets the LFA chain to a traditional single-threaded linked list
; HASHTHREAD breaks the LFA chain into 16 linked lists
; DEADTHREAD resets all LFAs but the end to appear as DE AD in hex dumps
;
; Changing the LFA threading is an all-or-nothing deal.  These tools
; aren't capable of automagically re-threading everything when the
; LFA chain(s) is/are corrupt.
;
; Vector (DEFER/IS) these words
; LATEST
;
;--------------------------------------------------------------
;
;	DHASH	( addr -- hash )
;
; input is a counted string at "addr"
;
; output "hash" is a value 0..15 that points to the latest LFA
; in this word's dictionary chain
dhashlfa	.word $adde
		.byt (dhash-*-1)|bit7
		.asc "DHAS","H"|bit7
dhash		dey
		lda (tos),y		; get the length
		and #$1f		; mask off flag bits
		tay
		lda #0
l009		eor (tos),y		; xor the string together, ignore length
		dey
		bne l009
		sty tos+1		; 0 -> msb
		sta tos			; temporarily store the result byte
		lsr
		lsr
		lsr
		lsr			; get the high nybble
		eor tos			; mix it with the low nybble
		and #$0f		; mask off the high nybble
		sta tos			; hash value in the range 0..f
		jmp next1

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieves the LFA of the latest word in this hash thread
;
dhashfetchlfa	.word $adde
		.byt (dhashfetch-*-1)|bit7
		.asc "DHASH","@"|bit7
dhashfetch	ldy tos
		lda latestl,y
		sta tos
		lda latesth,y
		sta tos+1
		jmp next1

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hashkey -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
dhashstorelfa	.word $adde
		.byt (dhashstore-*-1)|bit7
		.asc "DHASH","!"|bit7
dhashstore	lda #2
		jsr popnwords		; N0 = hashkey, N1 = LFAnew
		ldy n			; get hashkey
		lda latestl,y
		sta n+4
		lda latesth,y
		sta n+5			; LFAlatest -> N2
		lda n+2
		sta latestl,y
		lda n+3
		sta latesth,y		; LFAnew -> hashtable(key)
		ldy #0
		lda n+4
		sta (n+2),y
		iny
		lda n+5
		sta (n+2),y		; LFAlatest -> [LFAnew]
		jmp next

;--------------------------------------------------------------
;
;	RETHREAD   ( flag -- )
;
; TRUE - builds a hashed LFA structure
; FALSE - resets all LFAs to DE AD
;
; dead - 
; scanning forward sequentially, we find sequences of 
;	 len | $80 	(A)
;	 byte 1
;	 byte 2
;	 byte 3
;	 ...
;	 byte len | $80	(B)
;	 $DE
;	 $AD
; where points (A) and (B) are len bytes apart
; LATEST returns 0
;
; hashed - 
; the dhash array has any nonzero value in it
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
; single - 
; the dhash array is filled with all zeroes
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
;"	: THREADING?  ( -- flag )
;"	    LATEST
;
;	tells us whether we're threaded (true) or unthreaded (false)
;
rethreadlfa	.word $adde
		.byt (rethread-*-1)|bit7
		.asc "RETHREA","D"|bit7
rethread
		.word latest
		.word fetch
		.word zeq
		.word qbranch

unthread


;--------------------------------------------------------------
;
;	DEADTHREAD   ( -- )
;
; assumption -- dictionary is configured in one of the three
;		available schemes
;
;": DEADTHREAD 
;"    THREADING? ?DUP 0=  ( dead )
;"    IF  ." YOU CAN'T KILL ME!  I'M ALREADY DEAD." CR  
;"    ELSE  0<
;"        IF  ." KILLING SINGLE THREADED LINKS" CR  1KILL  THEN
;"        ELSE  ." KILLING HASH THREADED LINKS" CR  HASHKILL  THEN
;"    THEN ;



		; pops up to 4 words from the split stack to the N area
		; A = how many words to pop (valid range 1-4)
		;
		; returns
		; TOS -> N0, 2OS -> N1, 3OS -> N2, 4OS -> N3
popnwords	asl
		tay
		lda tos
		sta n-2,y
		lda tos+1
		sta n-1,y
l004		dey
		dey
		beq l005
		lda stackl,x
		sta n-2,y
		lda stackh,x
		sta n-1,y
		inx
		bne l004		; bra
l005		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx
		rts


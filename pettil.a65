; pettil.a65
;
; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years. 
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

; e.g. only a 48-cell stack so the bytes line up visually 
#define DEBUG
#define PET_ROM4		; target machine

#include cbm.def
#include pettil.def


;==============================================================
;====BASIC cold start and Sweet16, with some ML subroutines====
;==============================================================
#define		basic		$0400
		.word basic+1			; this will be the load address
*		= basic+1

		.word basend
		.word 10
		.byt $9e			; SYS token
		.asc "1037",0			; $040f
basend		.word 0
		jmp ice

;--------------------------------------------------------------
;
; Tables used by Pearson hash function and Bloom filter for root
; vocabulary.  The Pearson hash is used by hash1 to evenly distribute
; words among the multiple threads of the dictionary. The Bloom 
; filter lets us skip looking for things that we know aren't in
; the dictionary (e.g. numbers).  For now, keep bloom and lfalist
; consecutive in memory, with bloom first so RETHREAD won't break
pearson		.byt 150,191,252,0,194,202,129,7
pearsonx
bloom		.dsb 8,0	; 64-bit, used by hash2
bloomx
lfalist		.dsb 32,0	; heads of link threads for root vocabulary

; powers of 2 in a lookup table
power2		.byt $01,$02,$04,$08,$10,$20,$40,$80

; Unlike FIG Forth, PETTIL uses a direct-threaded model for
; greater efficiency (both speed and memory).  So there's
; no W register in the inner interpreter.
w1		.byt $c0,$de		; (for when you just need a W register)
		.word exit		; 'fragment secondary' used by EXECUTE

; using ROM tape I/O drops to BASIC if there's a problem.
; we'd like the user to be able to type RUN and pick up
; more or less at the dropping off point if this happens.
; this subroutine performs that BASIC/PETTIL zp switch
; between $00-$8C inclusive. 
swapzp		stx storex	; preserve Forth data stack pointer
		ldx #TIME	; everything below the jiffy clock
swapzp01	lda $ff,x
		ldy zpbuf-1,x
		sty $ff,x
		sta zpbuf-1,x
		dex
		bne swapzp01
		ldx storex	; restore Forth data stack pointer
		rts

; Putting all this junk between basend and here properly aligns
; Sweet16.  PETTIL's Sweet16 is *mostly* stock Woz. I have made 
; some small adaptations. For example, I call it with BRK instead
; of JSR.  
#include sweet16.a65
; everything above this line puts SET = $0501 and PUSH = $05fc
;==============================================================
;==========SET and PUSH must be on the same page!==============
;==============================================================
; this is an image of PETTIL zeropage at cold start.  Swapping it
; with the BASIC zeropage makes hopping back and forth possible
;
zpbuf		.word $0000,$0101,$0202,$0303
		.word $0404,$0505,$0606,$0707	; PETTIL registers
		.word $0808,$0909,$0a0a,$0b0b	; and
		.word $0c0c,$0d0d,$0e0e,$0f0f	; Sweet16 registers 
		.dsb bos,$aa			; low stack
		.dsb bos,$bb			; high stack
;
;	NEXT
;
; * inner interpreter headerless
;
;		+IP
;		[IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
zpnext		inc ip			; 5 
		inc ip			; 5 
;ip = *+1
		jmp ($cafe)		; 5 
zpnextx					;15 cycles total

; if #DEBUG is on, add enough padding between NEXT and TIME
		.dsb TIME-(*-zpbuf),$69	; more cowbell

; pops up to 4 words from the split stack to N area, backwards
; used for setting up primitives that consume multiple arguments
; Y = how many words to pop (valid range 1-4)
; returns
; Y = 0
; TOS unchanged
;
; Y     1         2         3         4
; 2OS-->N0
; 2OS-->N1; 3OS-->N0
; 2OS-->N2; 3OS-->N1; 4OS-->N0
; 2OS-->N3; 3OS-->N2; 4OS-->N1; 5OS-->N0
;
; this is shorter but it inverts the order in the N area, so all
; callers need to be changed for Y>1
setup		tya
		asl	; doubled, now Y is a countdown index
		tay
setup01		lda stackh,x
		dey
		sta n,y
		lda stackl,x
		inx
		dey
		sta n,y
		bne setup01
		rts		 

;--------------------------------------------------------------
; user area initialization data
; this gets copied to the cassette buffer
; and is pointed to by the UP (user pointer)
userarea
userup		.word uarea				; W
usersp0		.word bos+1		; =2		; A
userrp0		.word $01ff				; R
userwidth	.word 31				; M
userwarning	.word -1				; .
uservmbuf	.word $7b00				; .
userwarm
userfence	.word forgetfence			; C
userdp		.word endofile				; O
uservoclink	.word lastvoc				; L
userviewquery	.word 2					; D
usermlmon	.word TIMBRK				; .
usersw16	.word SW16				; .
uservidbuf	.word $7c00				; .

; live userarea has 2 bytes for each initializer plus 32 bytes
; for "soft" user variables, e.g. #OUT 
uarea		.dsb *-userarea+32,0

; error messages for FAIL
errptr		.word msg01,msg02
msg01		.byt msg02-*-1
		.asc "STACK EMPTY"
msg02		.byt msg03-*-1
		.asc "STACK FULL"
msg03

rootlfa		.word 0
		.byt 31			; longest word in the dictionary ~wut?

;--------------------------------------------------------------
; Drop down from high-level Forth to inline 6502
to6502lfa	.byt $de,$ad
		.byt (to6502-*-1)|bit7
		.asc ">650","2"|bit7
to6502		lda ip
		clc
		adc #2
		sta n
		ldy ip+1
		bcc to650201
		iny
to650201	sty n+1
		jmp (n)

;--------------------------------------------------------------
		; negate the double at n0..n3
dnegaten	ldy #0
		sec
		tya
		sbc n+2
		sta n+2		; low order byte
		tya
		sbc n+3
		sta n+3
		tya
		sbc n
		sta n
		tya
		sbc n+1
		sta n+1		; high order byte
		rts

;--------------------------------------------------------------
;
;	EXECUTE
;
; * 83 nucleus
;
; Executes the definition found at addr.
;
;"	: execute ( cfa --- )
;"		jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa	.byt $de,$ad		; <-- link field address
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7
execute		lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1		; [SP] -> [W1]
		lda ip+1
		pha
		lda ip
		pha
		lda #<(w1-2)
		sta ip
		lda #>(w1-2)
		sta ip+1
		jmp pops

;--------------------------------------------------------------
;
;	(LIT)
;
; * inner interpreter headerless
;
; push the word of memory following (IP)
;
;plitlfa	.byt $de,$ad
;		.byt (plit-*-1)|bit7
;		.asc "(LIT",")"|bit7
plit		jsr slip
		ldy #3
		lda (ip),y
		inc ip
		ldy #1
		bne lithi ; bra

;--------------------------------------------------------------
;
;	CLIT
;
; * inner interpreter headerless
;
; takes the byte of memory following and pushes it to the data stack
;
;clitlfa	.byt $de,$ad
;		.byt (clit-*-1)|bit7
;		.asc "CLI","T"|bit7
clit		jsr slip
		lda #0
		ldy #2
lithi		sta tos+1
		lda (ip),y
		sta tos
		lda #3
		jmp pad

;--------------------------------------------------------------
;
;	?BRANCH   ( flag -- )
;
; * inner interpreter control headerless
;
;qbranchlfa	.byt $de,$ad
;		.byt (qbranch-*-1)|bit7
;		.asc "?BRANC","H"|bit7
qbranch		lda tos
		ora tos+1
		ldy stackl,x
		sty tos
		ldy stackh,x
		sty tos+1
		inx		; drop
		tay		; to set the Z flag
		beq branch
bump		lda #4
		jmp pad

;--------------------------------------------------------------
;
;	(?DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; Performs a do-loop if end<>begin
;pqdolfa	.byt $de,$ad
;		.byt (pqdo-*-1)|bit7
;		.asc "(?DO",")"|bit7
pqdo		ldy #1
		jsr setup		; end -> N0
		lda tos
		eor n
		sta n+2
		lda tos+1
		eor n+1
		ora n+2
		tay			; Y=0 means no loop
		beq pqdo02
		ldy #3
pqdo01		lda zi,y		; set up for a loop
		pha
		lda tos,y		; tos & n must be adjacent in zeropage
		sta zi,y
		dey
		bpl pqdo01		; Y=FF means perform the loop
pqdo02		jsr slide
		tya			; sets the Z flag
		beq branch		; zero means end = begin (no loop)
		jmp bump

;--------------------------------------------------------------
;
;	BRANCH   ( -- )
;
; * inner interpreter control headerless
;
; Compiles an unconditional branch operation.
;" When used in the form: COMPILE BRANCH
; an unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated by following BRANCH
; with <RESOLVE or >MARK .
;
;"	: branch ( -- )
;
;branchlfa	.byt $de,$ad
;		.byt (branch-*-1)|bit7
;		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
branch		ldy #3		; [2]
		lda (ip),y	; [5]
		pha		; [3]
		dey		; [2]
		lda (ip),y	; [5]
		sta ip		; [3]
		pla		; [4]
		sta ip+1	; [3] (IP+2) -> IP
		jmp nexto	; [3]	[30]

;--------------------------------------------------------------
;
;	(+LOOP)   ( n -- )
;
; * inner interpreter control headerless
;
; add n to inner loop index.  If loop index exceeds loop limit,
; then iterate to the (do), otherwise skip past the branch and
; proceed
;pplooplfa	.byt $de,$ad
;		.byt (pploop-*-1)|bit7
;		.asc "(+LOOP",")"|bit7
pploop		clc
		lda tos
		adc zi
		sta zi
		lda tos+1
		adc zi+1
		sta zi+1
		lda zi+2
		cmp zi
		lda zi+3
		sbc zi+1
		ldy tos+1
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx
		tay
		bcc pploop01
		eor #$80
pploop01	bmi branch
		bpl bump

;--------------------------------------------------------------
;
;	(LOOP)
;
; * inner interpreter control headerless
;
;plooplfa	.byt $de,$ad
;		.byt (ploop-*-1)|bit7
;		.asc "(LOOP",")"|bit7
ploop		inc zi
		bne ploop01
		inc zi+1
ploop01		lda zi+2
		eor zi
		bne branch
		lda zi+3
		eor zi+1
		bne branch
		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp bump

;--------------------------------------------------------------
;
;	(DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; loops from 'begin' to 'end'
;pdolfa		.byt $de,$ad
;		.byt (pdo-*-1)|bit7
;		.asc "(DO",")"|bit7
pdo		lda stackh,x
		sta n+1
		lda stackl,x
		sta n			; end -> N0
		ldy #3
pdo01		lda zi,y		; set up for a loop
		pha
		lda tos,y		; takes advantage of tos being
		sta zi,y		; adjacent to zi area
		dey
		bpl pdo01
poptwo		inx
pops		ldy stackh,x
		lda stackl,x
		inx
put		sty tos+1
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	I
;
; * 83 nucleus
;
ilfa		.byt $de,$ad
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		ldy zi+1
		lda zi
		; pass YA = value to push/put on stack
pushya		pha
		jsr slip
		pla
		jmp put

;--------------------------------------------------------------
;
;	J
;
; * 83 nucleus
;
jlfa		.byt $de,$ad
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		stx storex
		tsx
		ldy $0102,x
		lda $0101,x		; ~ test this
		ldx storex
		jmp pushya

;--------------------------------------------------------------
;
;	(LEAVE)
;
; * inner interpreter control headerless
;
;pleavelfa	.byt $de,$ad
;		.byt (pleave-*-1)|bit7
;		.asc "(LEAVE",")"|bit7
pleave		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp branch

;--------------------------------------------------------------
;
;	(?LEAVE)
;
; * inner interpreter control headerless
;
;pqleavelfa	.byt $de,$ad
;		.byt (pqleave-*-1)|bit7
;		.asc "(?LEAVE",")"|bit7
pqleave		lda tos
		ora tos+1
		php
		jsr slide
		plp
		bne pleave
		jmp bump

;--------------------------------------------------------------
;
;	?STACK
;
; inspect data stack pointer for sanity, abort if trouble
qstacklfa	.byt $de,$ad
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		ldy #usersp0-userarea		; 2 = stack full
		txa
		bmi error
		cmp (up),y
		dey				; 1 = stack empty
		bcs error	; stack empty
		jmp next

;--------------------------------------------------------------
; Jump up to high-level Forth from inline 6502
;
; Page boundary crossing is handled by the compiler inserting 'page'
; when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
; to occur, and indicates an error in the compiler.
;
; Pad is used by LITERAL and string routines to offset IP at runtime
;
;~" todo: make an ASSEMBLER vocabulary word >FORTH to insert the call
; and handle pagination properly like the "toforth.i65" include file
;
; also a general-purpose error handler to print a string and abort
; pass in the error # in Y
;	1 stack empty
;	2 stack full
error		sty tos
		ldy #0
		sty tos+1
		lda #>(fail)
		pha
		lda #<(fail)	; transfer control to fail, which
				; prints a numbered error and aborts
		pha
toforth		pla
		sta ip
		pla
		sta ip+1
		lda #1
pad		clc			; pass A = offset added to IP
		adc ip
		bcs pagen		; check for page boundary crossing
		cmp #$ff
		bne pado		; check for xxFF at end of page
page		lda #0
pagen		inc ip+1		; cross the page
pado		sta ip
		jmp nexto

;--------------------------------------------------------------
;
;	MON    ( char base -- digit true | false )
;
monlfa		.byt $de,$ad
		.byt (mon-*-1)|bit7
		.asc "MO","N"|bit7
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
mon		jsr swapzp	; restore BASIC zpage 
		ldy #(usermlmon-userarea)
		.byt $2c	; BIT instruction to skip two bytes
		ldy #(usersw16-userarea)
		lda (up),y
		sta CBINV
		iny
		lda (up),y
		sta CBINV+1
		brk		; either break to TIM
		.byt rtn	; or do nothing in Sweet16 mode
		jmp next

;--------------------------------------------------------------
;
;	DIGIT    ( char base -- digit true | false )
;
digitlfa	.byt $de,$ad
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit		ldy #0			; presume failure
		sec
		lda stackl,x
		sbc #'0'
		bmi digit02		; no num
		cmp #10
		bmi digit01		; is num
		sec
		sbc #7
		cmp #10
		bmi digit02
digit01		cmp tos
		bpl digit02
		sta stackl,x
		dey
		bmi digit03
digit02		inx
digit03		tya
		jmp put

;--------------------------------------------------------------
;
;	(FIND)   ( name-2 LFA -- name-2 0 | CFA flag )
;
; * outer interpreter headerless
;
; name-2 is the address-2 of a counted string we are searching for.
; LFA is the LFA at the head of a chain of LFAs
; returns
;	( CFA -1 ) if found normal word
;	( CFA 1 ) if found immediate word
;	( name 0 ) if not found
;
;pfindlfa	.byt $de,$ad
;		.byt (pfind-*-1)|bit7
;		.asc "(FIND",")"|bit7
pfind		brk
		.byt sub | R0
		.byt st | N3
		.byt ld | TOS
		.byt st | N2
		.byt pull
		.byt ld | TOS
		.byt st | N0
		.byt ext
		.word wordlen16
		.byt ld | R11		; set search length
		.byt st | N1
		.byt ld | N2
pfind02	.byt st | N0
		.byt ext
		.word wordlen16
		.byt ld | N1		; search length
		.byt cpr | R11		; dict length
		.byt bnc , <(pfind06-*-2)	; we went past it.  outtie
		.byt bnz , <(pfind03-*-2)	; different lengths, skip
		.byt ext
		.word strcomp16
		.byt bc , <(pfind04-*-2)
pfind03	.byt ldd | N0			; hop
		.byt br , <(pfind02-*-2)
pfind04	;winner!
		.byt ldd | N0		; add 2 to the LFA
		.byt ld | N0		; now it's an NFA
		.byt add | N1		; add the length
		.byt st | TOS		; now it's almost a CFA
		.byt inr | TOS		; add 1, now it's a CFA
		.byt ldi | N0		; fetch dictionary length byte
		.byt sub | N1		; subtract clean length leaving only bits
		.byt set | N0
		.word $80
		.byt dcr | N3		; assume it's a normal word
		.byt cpr | N0
		.byt bz , <(pfind06-*-2)
		.byt inr | N3
		.byt inr | N3
pfind06	.byt push
		.byt ld | N3
		.byt st | TOS
		.byt rtn
		jmp next

;--------------------------------------------------------------
;
;	SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless selfmodifying
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skiplfa		.byt $de,$ad
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		lda #$d0		; BNE intruction
		sta skip02
skipscan	ldy #2
		jsr setup		; size1 -> N1; addr1 -> N0
		stx storex
		ldx n+2			; sizelo
skip01		txa
		ora n+3			; sizehi
		beq skip05
		lda (n),y		; (addr1),y
		eor tos
		asl			; ignore bit7
skip02		bne skip05
		iny
		bne skip03
		inc n+1
skip03		txa
		bne skip04
		dec n+3
skip04		dex
		jmp skip01
skip05		stx n+2
		ldx storex
		clc
		tya
		adc n
		sta tos
		ldy n+1
		bcc skip06
		iny
skip06		sty tos+1
		ldy n+3
		lda n+2
		jmp pushya

;--------------------------------------------------------------
;
;	SCAN   ( addr count char -- addr count )
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
; ~wut? self-modifying code is a no-no if I'm ever ROMing this
; considering Sweet16
scanlfa		.byt $de,$ad
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		lda #$f0		; BEQ intruction
		sta skip02
		jmp skipscan

;--------------------------------------------------------------
;
;	EMIT
;
; * 83 device
;
emitlfa		.byt $de,$ad
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp emitvector
emitvector	ldy numout+3
		clc
		lda (up),y
		adc #1
		sta (up),y
		bne emit01
		iny
		clc
		lda (up),y
		adc #1
		sta (up),y
emit01		lda tos
		jsr CHROUT
		jmp pops

;--------------------------------------------------------------
;
;	KEY
;
; * 83 device
;
; ~wut? this should maybe use CHRIN not GETIN?
;
keylfa		.byt $de,$ad
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp keyvector
keyvector	stx storex
key01		jsr GETIN
		beq key01	; busy wait? ~wut?
		ldx storex
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.byt $de,$ad
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp qtermvector
qtermvector	stx n
		ldy #0
		jsr STOP
		bne qterminal01
		dey
qterminal01	tya
		pha
		ldx n
		jmp pushya

;--------------------------------------------------------------
;
;	CR
;
; * 83 device
;
crlfa		.byt $de,$ad
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp crvector
crvector	lda #$0d
		jsr CHROUT
		lda #0
		ldy numout+3
		sta (up),y
		iny
		sta (up),y
		ldy numline+3
		clc
		lda (up),y
		adc #1
		sta (up),y
		bcc cr01
		iny
		lda (up),y
		adc #0
		sta (up),y
cr01		jmp next

;--------------------------------------------------------------
;
;	CMOVE   ( from to howmany -- )
;
; * 83 nucleus
;
;"~ see http://6502.org/source/general/memory_move.html
cmovelfa	.byt $de,$ad
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		ldy #2
		jsr setup	; to -> N0; from -> N1
		stx storex
		inc tos+1
		ldx tos
		beq cmove03
cmove01		lda (n),y
		sta (n+2),y
		iny
		bne cmove02
		inc n+1
		inc n+3
cmove02		dex
		bne cmove01
cmove03		dec tos+1
		bne cmove01
		ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	CMOVE>   ( addr1 addr2 u -- )
;
; * 83 nucleus
;
; Move the u bytes beginning at address addr1 to
; addr2.  The move begins by moving the byte at
; (addr1 plus u minus 1) to (addr2 plus u minus 1)
; and proceeds to successively lower addresses
; for u bytes.  If u is zero nothing is moved.
; Useful for sliding a string towards higher addresses.
cmovegtlfa	.byt $de,$ad
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		ldy #2
		jsr setup		; from -> N0; to -> N1
		stx storex
		lda tos+1
		pha
		clc
		adc n+1
		sta n+1
		pla
		clc
		adc n+3
		sta n+3
		ldy tos
		beq cmovegt02
cmovegt01	dey
		lda (n),y
		sta (n+2),y
		cpy #0
		bne cmovegt01
cmovegt02	ldx tos+1
		beq cmovegt05
cmovegt03	dec n+1
		dec n+3
cmovegt04	dey
		lda (n),y
		sta (n+2),y
		cpy #0
		bne cmovegt04
		dex
		bne cmovegt03
cmovegt05	ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	FILL   ( addr howmany value -- )
;
; * 83 nucleus
;
; ~ check this for howmany > 255
filllfa		.byt $de,$ad
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		ldy #2
		jsr setup	; addr -> N0; howmany -> N1
		stx storex
		inc n+3		; high byte of howmany
		lda tos
		;ldy #0		; Y = 0 from setup
		ldx n+2
		beq fill02
fill01		sta (n),y
		iny
		bne fill02
		inc n+1
fill02		dex
		bne fill01
		dec n+3
		bne fill01
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	2+
;
; * 83 nucleus
;
twopluslfa	.byt $de,$ad
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		clc
		lda tos
		adc #2
		sta tos
		bcc twoplus01
		inc tos+1
twoplus01	jmp next

;"~ check http://6502.org/source/ for multiply and divide and stuff
;--------------------------------------------------------------
;
;	UM*   ( u1 u2 -- ud )
;
; * 83 nucleus divstar
;
; multiply u1 times u2 returning the double length product ud.
; All values and arithmetic are unsigned.
umstarlfa	.byt $de,$ad
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		lda stackl,x
		sta n+4
		lda stackh,x		;multiplicand in tos
		sta n+5			;multiplier in N2
		jsr multiply		;16 bit unsigned multiply
		lda n
		sta stackl,x
		lda n+1
		sta stackh,x
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		jmp next

multiply	lda #0			; unsigned multiply tos*N2 destroys tos
		sta n+2			;clear upper half of product
		sta n+3
		ldy #16
rshift		lsr tos+1
		ror tos
		bcc rrot		;Go rotate right if c = 0
		clc			; and add multiplicand to
		lda n+2			;Get upper half of product
		adc n+4			; it
		sta n+2
		lda n+3
		adc n+5
rrot		ror			;shift partial product right
		sta n+3
		ror n+2
		ror n+1
		ror n
		dey			;Decrement bit count and
		bne rshift
		rts
;You beat me to the punch, but there is some unnecessary code in there (you don't need to clear the carry before a LSR). And trashing X is unnecessary since you can test for zero just as fast with LDA $02. Or with some crazy jujitsu to save a byte...
;Here's my version, handles 8-bit operands:
;--$00 holds operand 1
;--$01 (low byte) and $02 (high byte) hold operand 2
;--$03 (low byte) and $04 (high byte) hold product
;	cld
;Loop	lsr $00
;	bcc NoAdd
;	clc
;	lda $03
;	adc $01
;	sta $03
;	lda $04
;	adc $02
;	sta $04
;	.byte $2C
;NoAdd	beq Done
;	asl $01
;	rol $02
;	bcc Loop	;this assumes that operand 2 is 8-bit
;Done
;
;A proper 6502 assembler solution.
;
;Features
;- multiplies two 8-bit numbers with 16 bit result
;- inner loop of only 17 clock cycles per iteration
;- worst case behaviour of 40 clock cycles per iteration
;- minimizes number of iterations
;- total execution time 25 - 320 cycles
;(i.e. only 3x slower (worst case) than MUL on Intel 8088)
;- 43 bytes size
;- relocatable to about anywhere in address space
;- uses C64-friendly memory locations
; INPUT  = op1 in A, op2 in X
; OUTPUT = low byte in X, high byte in Y
; memory locations used as temp space = $fb, $fc, $fd
;	stx $fc    ; save op2
;	cmp $fc    ; compare both operands
;	bcc noswap ; swap them unless op1 < op2
;	sta $fc    ; save op1 instead of op2
;	txa        ; swap op2 for op1
;noswap	ldx #$00   ; prepare result low byte
;	stx $fd    ; clear high byte of op2
;	ldy #$00   ; prepare result high byte
;	beq begin  ; skip shift of op2 for first iteration
;loop	asl $fc    ; multiply op2 by 2, low byte
;	rol $fd    ; multiply op2 by 2, high byte
;begin	lsr        ; divide op1 by 2
;	bcs add    ; if op1 was odd before division, add op2
;	bne loop   ; if op1 is not zero repeat loop
;	rts        ; otherwise return result
;add	sta $fb    ; save current value of op1
;	clc        ; prepare addition
;	txa        ; fetch low byte
;	adc $fc    ; add op2, low byte
;	tax        ; store low byte
;	tya        ; fetch high byte
;	adc $fd    ; add op2, high byte
;	tay        ; store high byte
;	lda $fb    ; restore op1
;	bne loop   ; if op1 is not zero repeat loop
;	rts        ; otherwise return result
;

;--------------------------------------------------------------
;
;	UM/MOD   ( ud u -- rem quot )
;
; * 83 nucleus divstar
;
;	~ needs a lot of work
;"	http://6502.org/source/integers/ummodfix/ummodfix.htm
umslashmodlfa	.byt $de,$ad
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	ldy #2
		jsr setup	; udhi -> N0; udlo -> N1
		jsr divmod
		lda n+3
		sta tos+1
		lda n+2		; remainder
		sta tos
		ldy n+5
		lda n+4
		jmp pushya	; quotient

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
; * 83 nucleus
;
andxlfa		.byt $de,$ad
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx		lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
; * 83 nucleus
;
orxlfa		.byt $de,$ad
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx		lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
; * 83 nucleus
;
xorlfa	.byt $de,$ad
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor		lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT   ( n -- !n )
;
; * 83 nucleus
;
notlfa		.byt $de,$ad
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@   ( -- sp )
;
spfetchlfa	.byt $de,$ad
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		txa
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	SP!   ( -- )
;
spstorelfa	.byt $de,$ad
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		ldy #usersp0-userarea
		lda (up),y
		tax
		dex		; because it's 1> to make ?stack faster
		jmp next

;--------------------------------------------------------------
;
;	RP!   ( -- )
;
rpstorelfa	.byt $de,$ad
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		stx storex
		ldy #userrp0-userarea
		lda (up),y
		tax
		txs
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	EXIT   ( -- )
;
; * 83 nucleus
;
;		[RP+] -> IP
;		NEXT
; 09/15/10 cah
exitlfa		.byt $de,$ad
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
exit		pla
		sta ip
		pla
		sta ip+1	; [RP+] -> IP
		jmp next	; NEXT

;--------------------------------------------------------------
;
;	>R   ( n -- )
;
; * 83 nucleus
;
torlfa		.byt $de,$ad
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		lda tos+1
		pha
		lda tos
		pha
		jmp pops

;--------------------------------------------------------------
;
;	R>   ( -- n )
;
; * 83 nucleus
;
rfromlfa	.byt $de,$ad
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		pla
		sta storex
		pla
		tay
		lda storex
		jmp pushya

;--------------------------------------------------------------
;
;	R@   ( -- n )
;
; * 83 nucleus
;
rfetchlfa	.byt $de,$ad
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		stx n
		tsx
		ldy $0102,x
		lda $0101,x
		ldx n
		jmp pushya

;--------------------------------------------------------------
;
;	0>   ( n -- flag )
;
; * 83 nucleus
;
zgtlfa		.byt $de,$ad
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		ldy #$ff
		bit tos+1
		bpl zgt01
		iny
zgt01		tya
		jmp put

;--------------------------------------------------------------
;
;	<>   ( n1 n2 -- flag )
;
nelfa	.byt $de,$ad
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		ldy #$ff		; assume inequality
		lda tos
		eor stackl,x
		bne ne01
		lda tos+1
		eor stackh,x
		bne ne01
		iny			; they're equal
ne01		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	ON   ( addr -- )
;
; store -1 at ADDR
onlfa		.byt $de,$ad
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		ldy #0
		sta (tos),y
		iny
		sta (tos),y
		jmp pops

;--------------------------------------------------------------
;
;	OFF   ( addr -- )
;
; store 0 at ADDR
offlfa		.byt $de,$ad
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+   ( n1 n2 -- n1+n2 )
;
; * 83 nucleus
;
; 09/15/10 cah
pluslfa		.byt $de,$ad
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;	
;	D+   ( d1 d2 -- d1+d2 )
;
; * 83 nucleus
;
dpluslfa	.byt $de,$ad
		.byt (dplus-*-1)|bit7
		.asc "D","+"|bit7
dplus		clc
		lda stackl,x
		adc stackl+2,x
		sta stackl+2,x
		lda stackh,x
		adc stackh+2,x
		sta stackh+2,x
		lda tos
		adc stackl+1,x
		sta stackl+1,x
		lda tos+1
		adc stackh+1,x
		sta stackh+1,x
		jmp poptwo

;--------------------------------------------------------------
;
;	D<   ( d1 d2 -- flag )
;
; * 83 nucleus
;
dltlfa		.byt $de,$ad
		.byt (dlt-*-1)|bit7
		.asc "D","<"|bit7
dlt		ldy #0		; false
		jsr dcmp
		bvc dlt01
		eor #$80
dlt01		bpl dlt02
		dey		; true
dlt02		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next
dcmp		sec
		lda stackl+2,x
		sbc stackl,x
		lda stackh+2,x
		sbc stackh,x
		lda stackl+1,x
		sbc tos
		lda stackh+1,x
		sbc tos+1
		rts
	
;--------------------------------------------------------------
;
;	NEGATE   ( n -- -n )
;
; * 83 nucleus
;
; 09/15/10 cah
negatelfa	.byt $de,$ad
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		jsr donegate
		jmp next
donegate	sec
neg2		lda #0
		sbc tos
		sta tos
		lda #0
		sbc tos+1
		sta tos+1
		rts

;--------------------------------------------------------------
;
;	DNEGATE   ( d -- -d )
;
; * 83 nucleus
;
dnegatelfa	.byt $de,$ad
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		jsr dodnegate
		jmp next
dodnegate	sec
		lda #0
		sbc stackl,x
		sta stackl,x
		lda #0
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER   ( n1 n2 -- n1 n2 n1 )
;
; * 83 nucleus
;
; 09/15/10 cah
overlfa		.byt $de,$ad
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp pushya

;--------------------------------------------------------------
;
;	DROP   ( n -- )
;
; * 83 nucleus
;
droplfa	.byt $de,$ad
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pops

;--------------------------------------------------------------
;
;	SWAP   ( n1 n2 -- n2 n1 )
;
; * 83 nucleus
;
swaplfa		.byt $de,$ad
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP   ( n -- n n )
;
; * 83 nucleus
;
duplfa		.byt $de,$ad
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		jsr slip
		jmp next

;--------------------------------------------------------------
;
;	+!   ( n addr -- )
;
; * 83 nucleus
;
; add N to the cell at ADDR
plusstorelfa	.byt $de,$ad
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	ldy #0
		clc
		lda stackl,x
		adc (tos),y
		sta (tos),y
		iny
		lda stackh,x
		adc (tos),y
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

togglelfa	.byt $de,$ad
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		lda stackl,x
		sta n
		lda stackh,x
		sta n+1
		ldy #0
		lda (n),y
		eor tos
		sta (n),y
		jmp poptwo

;--------------------------------------------------------------
;
;	@   ( addr -- n )
;
; * 83 nucleus
;
fetchlfa	.byt $de,$ad
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #0
		lda (tos),y
		sta n
		iny
		lda (tos),y
		sta tos+1
		lda n
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	C@   ( addr -- 8b )
;
; * 83 nucleus
;
; "c-fetch" 
; 8b is the contents of the byte at addr.
;
cfetchlfa	.byt $de,$ad
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		ldy #0
		lda (tos),y
		sta tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!   ( 16b addr -- )
;
; * 83 nucleus
;


; "store" 
; 16b is stored at addr.
storelfa	.byt $de,$ad
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		ldy #0
		lda stackl,x
		sta (tos),y
		iny
		lda stackh,x
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!   ( 8b addr -- 
;
; * 83 nucleus
;
; "c-store"
; The least-significant 8 bits of 16b are stored into the byte
; at addr.
;
cstorelfa	.byt $de,$ad
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		ldy #0
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	ALLOT
;
; * 83 compiler
;
allotlfa	.byt $de,$ad
		.byt (_allot-*-1)|bit7
		.asc "ALLO","T"|bit7
_allot
#include "enter.i65"
		.word dp
#include "page.i65"
		.word plusstore
		.word exit

;--------------------------------------------------------------
;
;	,   ( w -- )
;
; * 83 compiler
;
commalfa	.byt $de,$ad
		.byt (_comma-*-1)|bit7
		.asc ","|bit7
_comma
#include "enter.i65"
		.word here
#include "page.i65"
		.word store
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	C,   ( b -- )
;
ccommalfa	.byt $de,$ad
		.byt (_ccomma-*-1)|bit7
		.asc "C",","|bit7
_ccomma
#include "enter.i65"
		.word here
#include "page.i65"20
		.word cstore
#include "page.i65"
		.word one
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	,$   ( ?? -- ?? )
;
commadollarlfa	.byt $de,$ad
		.byt (_commadollar-*-1)|bit7
		.asc ",","$"|bit7
_commadollar
#include "enter.i65"
		.word swap
#include "page.i65"
		.word over
#include "page.i65"
		.word here
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word cstore
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	CREATE
;
; * 83 compiler
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"	@ + + u< (abort") dictionary full exists?
;"	over (lit) 6017 = (abort") name required
;"	warning @ and ?branch 41 >name cr
;"	18 emit id. 146 emit (.") already exists
;"	branch 4 drop here dup c@
;"	over 2+ view? @ + dup >r swap 1+ cmove>
;"	r> dup c@ width @ min 1+ 2dup + 255
;"	and 255 = ?branch 25 2dup swap
;"	dup 1+ rot cmove> 234 c, swap 1+
;"	swap 2+ view? @ + allot dup 128 toggle
;"	here 1- 128 toggle latest over
;"	2- ! view? @ ?branch 14 blk @ over 2-
;"	2- ! 2 allot current @ ! (;code)
;".C:1b0b	18		CLC
;".C:1b0c	A5 87		LDA $87
;".C:1b0e	69 02		ADC #$02
;".C:1b10	48		PHA
;".C:1b11	98		TYA
;".C:1b12	65 88		ADC $88
;".C:1b14	4C 4A 08	JMP $084A
;
createlfa	.byt $de,$ad
		.byt (_create-*-1)|bit7
		.asc "CREAT","E"|bit7
_create
#include "enter.i65"
		.word 0; _ltbcq
#include "page.i65"
		.word here
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word plus
#include "page.i65"
		.word ult
#include "page.i65"
#if (((*&$ff)+3+15)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt create01-*-1
		.asc	"DICTIONARY FULL"
			;123456789.12345
create01
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word over
#include "page.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+13)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt create02-*-1
		.asc	"NAME REQUIRED"
			;123456789.123
create02
#include "page.i65"
		.word warning
#include "page.i65"
		.word fetch
#include "page.i65"
		.word andx
#include "page.i65"
		.word qbranch
		.word create04
#include "page.i65"
		.word _toname
#include "page.i65"
		.word cr
#include "page.i65"
		.word clit
		.byt $12	; rvs
#include "pad.i65"
		.word emit
#include "page.i65"
		.word _iddot
#include "page.i65"
		.word clit
		.byt $92	; off
#include "pad.i65"
		.word emit
#include "page.i65"
		.word _pdq
		.byt create03-*-1
		.asc	" ALREADY EXISTS "
			;1234567869.12345
create03
#include "pad.i65"
		.word branch
		.word create05
#include "page.i65"
create04	.word drop
#include "page.i65"
create05	.word here
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _min
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word andx
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word eq
#include "page.i65"

		.word qbranch
		.word create06
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word swap
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word rot
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word clit
		.byt $ea
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
create06	.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word _allot
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word here
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word _latest
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word create07
#include "page.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
create07	.word two
#include "page.i65"
		.word _allot
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word store
		.word _psemi
docreate	pla
		clc
		adc #1
		sta n
		pla
		tay
		bcc docreate01
		iny
docreate01	lda n
		jmp pushya

;--------------------------------------------------------------
;
;"	:   ( -- sys )
;
; * 83 compiler
;
; "colon"
;" A defining word executed in the form: 
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed. 
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
colonlfa	.byt $de,$ad
		.byt (_colon-*-1)|bit7
		.asc ":"|bit7
_colon		.word _storecsp
		.word current
		.word fetch
		.word context
		.word store
		.word _create
		.word _smudge
		.word _rbracket
		.word _psemi
;--------------------------------------------------------------
;
;	ENTER
;
;		IP -> -[RP]
;		W -> IP
;		NEXT
;
enter		pla		;[4]
		tay		;[2]
		pla		;[4]
		sta storex	;[3]
		lda ip+1	;[3]
		pha		;[3]
		lda ip		;[3]
		pha		;[3]
		lda storex	;[3]
		sta ip+1	;[3]
		iny		;[2]
		beq enter02	;[2]
enter01		sty ip		;[3]
		jmp nexto	;[3]
enter02		inc ip+1
		bne enter01	; bra

;--------------------------------------------------------------
;
;	;   ( -- )
;
; * 83 compiler
;
semilfa		.byt $de,$ad
		.byt (semi-*-1)|bit7|bit6
		.asc ";"|bit7
semi
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word exit
#include "page.i65"
		.word _smudge
#include "page.i65"
		.word _lbracket
		.word exit

;--------------------------------------------------------------
;
;	CONSTANT   ( n -- )
;
; * 83 compiler
;
constantlfa	.byt $de,$ad
		.byt (_constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
_constant
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
; 09/15/10 cah
doconst		pla
		sta n
		pla
		sta n+1
		ldy #2
		lda (n),y
		sta n+2		; high byte
		dey
		lda (n),y	; low byte
		ldy n+2
		jmp pushya

;--------------------------------------------------------------
;
;	VARIABLE   ( -- )
;
; * 83 compiler
;
variablelfa	.byt $de,$ad
		.byt (_variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
_variable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	USER   ( n -- )
;
userlfa		.byt $de,$ad
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user
#include "enter.i65"
		.word _constant
#include "page.i65"
		.word _psemi
uservar		pla
		tay
		pla
		sta n+1
		iny
		bne uservar01
		inc n+1
uservar01	sty n
		ldy #0
		clc
		lda up
		adc (n),y
		sta n
		lda up+1
		adc #0
		tay
		lda n
		jmp pushya

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.byt $de,$ad
		.byt (_plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
_plusorigin	
#include "enter.i65"
		.word plit
		.word userarea
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.byt $de,$ad
		.byt (sp0-*-1)|bit7
		.asc "SP","0"|bit7
sp0		jsr uservar
		.byt usersp0-userarea

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.byt $de,$ad
		.byt (rp0-*-1)|bit7
		.asc "RP","0"|bit7
rp0		jsr uservar
		.byt userrp0-userarea

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.byt $de,$ad
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr uservar
		.byt userwidth-userarea

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.byt $de,$ad
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr uservar
		.byt userwarning-userarea

;--------------------------------------------------------------
;
;	VMBUF   ( -- addr )
;
; User variable storing the address of the next available 256-byte
; page for tape virtual memory.  VMBUF grows downward in memory beginning
; at $7a00 until it hits the top of the dictionary (PAD).  There is a 
; page above it ($7b00) for the in-memory screen index, and a 2K buffer
; from $7c00-$7fff for compression/decompression 
;
vmbuflfa	.byt $de,$ad
		.byt (vmbuf-*-1)|bit7
		.asc "VMBU","F"|bit7
vmbuf		jsr uservar
		.byt uservmbuf-userarea

;--------------------------------------------------------------
;
;	VIDBUF   ( -- addr )
;
; User variable storing the address of a 1024-byte region of memory
; used by the RLENCODE, RLDECODE and SHAMROCK compression routines.
; currently top-of-RAM - $0400 ($7c00)
;
vidbuflfa	.byt $de,$ad
		.byt (vidbuf-*-1)|bit7
		.asc "VIDBU","F"|bit7
vidbuf		jsr uservar
		.byt uservidbuf-userarea

; ^ warm
; |
;  >  user variables pre-initialized from the dictionary
; |
; v cold

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.byt $de,$ad
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr uservar
		.byt userfence-userarea

;--------------------------------------------------------------
;
;	DP
;
dplfa		.byt $de,$ad
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jsr uservar
		.byt userdp-userarea

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.byt $de,$ad
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr uservar
		.byt uservoclink-userarea

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.byt $de,$ad
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr uservar
		.byt userviewquery-userarea

;--------------------------------------------------------------
;
;	MLMON   ( -- addr )
;
; The address of a variable to store the location of the ML monitor.
; COLD sets this from the contents of BRK vector at $0092, then
; points BRK vector to SW16.  The MON primitive sets BRK vector
; back to its original state before exiting to TIM (or TIM's
; replacement e.g. Micromon).  Exiting the ML monitor with
; "G" will reestablish Sweet16 as the BRK instruction target.
;
mlmonlfa	.byt $de,$ad
		.byt (mlmon-*-1)|bit7
		.asc "MLMO","N"|bit7
mlmon		jsr uservar
		.byt usermlmon-userarea

; ^ cold
; |
;  >  user variables pre-initialized from the dictionary
; |
; v soft
;
; user variables beyond this point are not pre-initialized from the dictionary
;

;--------------------------------------------------------------
;
;	BLK   ( -- addr )
;
; * 83 interpreter
;
; The address of a variable containing the number of the mass
; storage block being interpreted as the input stream.  If the
; value of BLK is zero the input stream is taken from the text
; input buffer.  {{0..the number of blocks available -1}}
; -1 = cassette tape 1 ~
; -2 = cassette tape 2 ~
blklfa		.byt $de,$ad
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr uservar
		.byt uarea-userarea

;--------------------------------------------------------------
;
;	>IN   ( -- addr )
;
; * 83 interpreter
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The address of a user variable which contains the present
; character offset within the input stream.  See: WORD
toinlfa		.byt $de,$ad
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr uservar
		.byt uarea-userarea+2

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.byt $de,$ad
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr uservar
		.byt uarea-userarea+4

;--------------------------------------------------------------
;
;	SCR   ( -- addr )
;
; The address of a user variable containing the
; number of the screen most recently LISTed.
;
scrlfa		.byt $de,$ad
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr uservar
		.byt uarea-userarea+6

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.byt $de,$ad

		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr uservar
		.byt uarea-userarea+8

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.byt $de,$ad
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr uservar
		.byt uarea-userarea+10

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.byt $de,$ad
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr uservar
		.byt uarea-userarea+12

;--------------------------------------------------------------
;
;	STATE
;
; * 83 compiler
;
; The address of the user variable containing the
; compilation  state.    A non-zero content indi-
; cates compilation is occuring,  but  the  value
; itself is system dependent.  A Standard Program
; may not modify this variable.
;
statelfa	.byt $de,$ad
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr uservar
		.byt uarea-userarea+14

;--------------------------------------------------------------
;
;	BASE
;
; * 83 interpreter
;
baselfa		.byt $de,$ad
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr uservar
		.byt uarea-userarea+16

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.byt $de,$ad
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr uservar
		.byt uarea-userarea+18

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; * 83 interpreter
;
; Returns the address of the user variable that
; contains the count of characters received and
; stored by the most recent execution of EXPECT .
span		jsr uservar
		.byt uarea-userarea+20

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.byt $de,$ad
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr uservar
		.byt uarea-userarea+22

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.byt $de,$ad
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr uservar
		.byt uarea-userarea+24

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.byt $de,$ad
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr uservar
		.byt uarea-userarea+26

;--------------------------------------------------------------
;
;	#TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}  See:  "input stream"
numtiblfa	.byt $de,$ad
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr uservar
		.byt uarea-userarea+28

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.byt $de,$ad
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr uservar
		.byt uarea-userarea+30

;--------------------------------------------------------------
;
;	-1   ( -- -1 )
;
minusonelfa	.byt $de,$ad
		.byt (minusone-*-1)|bit7
		.asc "-","1"|bit7
minusone	jmp true

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.byt $de,$ad
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		jmp false

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.byt $de,$ad
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		jsr doconst
		.word 1

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.byt $de,$ad
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jsr doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.byt $de,$ad
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jsr doconst
		.word 3

;--------------------------------------------------------------
;
;	BL   ( -- n )
;
bllfa		.byt $de,$ad
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jsr doconst
		.word $20

;--------------------------------------------------------------
;
;	C/L   ( -- n )
;
cperllfa	.byt $de,$ad
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jsr doconst
		.word 80

;--------------------------------------------------------------
;
;	FIRST   ( -- addr )
;
;~ fix this to read actual top of memory
firstlfa	.byt $de,$ad
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jsr doconst
		.word $7000

;--------------------------------------------------------------
;
;	LIMIT   ( -- addr )
;
;~ fix this to read actual top of memory
limitlfa	.byt $de,$ad
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jsr doconst
		.word $8000

;--------------------------------------------------------------
;
;	#BUF   ( -- n )
;
numbuflfa	.byt $de,$ad
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	#BCQ   ( -- n )
;
numbcqlfa	.byt $de,$ad
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jsr doconst
		.word 32

;--------------------------------------------------------------
;
;	B/BUF   ( -- n )
;
bperbuflfa	.byt $de,$ad
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jsr doconst
		.word 1024

;--------------------------------------------------------------
;
;	B/SCR   ( -- n )
;
bperscrlfa	.byt $de,$ad
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jsr doconst
		.word 1

;--------------------------------------------------------------
;
;	TIB   ( -- addr )
;
; * 83 interpreter
;
tiblfa		.byt $de,$ad
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jsr doconst
		.word BUF	; $0200

;--------------------------------------------------------------
;
;	VIDRAM   ( -- addr )
;
; address of PET video memory $8000
;
vidramlfa	.byt $de,$ad
		.byt (vidram-*-1)|bit7
		.asc "VIDRA","M"|bit7
vidram		jsr doconst
		.word VIDRAM

;--------------------------------------------------------------
;
;	TRUE   ( -- -1 )
;
truelfa		.byt $de,$ad
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		lda #$ff
		tay
		jmp pushya

;--------------------------------------------------------------
;
;	FALSE   ( -- 0 )
;
falselfa	.byt $de,$ad
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		lda #0
		tay
		jmp pushya

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.byt $de,$ad
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp poptwo

;--------------------------------------------------------------
;
;	0=
;
; * 83 nucleus
;
zeqlfa		.byt $de,$ad
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		ldy #$ff
		lda tos
		ora tos+1
		beq zeq01
		iny
zeq01		tya
		jmp put

;--------------------------------------------------------------
;
;	0<
;
; * 83 nucleus
;
zltlfa		.byt $de,$ad
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		ldy #0
		bit tos+1
		bpl zlt01
		dey
zlt01		tya
		jmp put

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.byt $de,$ad
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		beq zne01
		lda #$ff
zne01		tay
		jmp put

;--------------------------------------------------------------
;
;	1+
;
; * 83 nucleus
;
onepluslfa	.byt $de,$ad
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		inc tos
		bne oneplus01
		inc tos+1
oneplus01	jmp next

;--------------------------------------------------------------

;
;	1-
;
; * 83 nucleus
;
oneminuslfa	.byt $de,$ad
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	lda tos
		bne oneminus01
		dec tos+1
oneminus01	dec tos
		jmp next

;--------------------------------------------------------------
;
;	2-
;
; * 83 nucleus
;
twominuslfa	.byt $de,$ad
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	sec
		lda tos
		sbc #2
		sta tos
		bcs twominus01
		dec tos+1
twominus01	jmp next

;--------------------------------------------------------------
;
;	2/
;
; * 83 nucleus
;
twoslashlfa	.byt $de,$ad
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	lsr tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.byt $de,$ad
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		asl tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	HERE
;
; * 83 interpreter
;
herelfa		.byt $de,$ad
		.byt (here-*-1)|bit7
		.asc "HER","E"|bit7
here		ldy #(userdp-userarea)
		lda (up),y
		pha
		iny
		lda (up),y
		tay
		pla
		jmp pushya

;--------------------------------------------------------------
;
;	-
;
; * 83 nucleus
;
; 09/15/10 cah
minuslfa	.byt $de,$ad
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr donegate
		jmp plus

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
; * 83 nucleus
;
eqlfa		.byt $de,$ad
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		ldy #0
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	U<
;
; * 83 nucleus
;
;09/16/10 cah
ultlfa		.byt $de,$ad
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
; * 83 nucleus
;
ltlfa		.byt $de,$ad
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
sgntst		bvc lt01
		eor #bit7
lt01		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
; * 83 nucleus
;
; V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
gtlfa		.byt $de,$ad
		.byt (gt-*-1)|bit7
		.asc ">"|bit7
gt		ldy #0
		lda tos
		cmp stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT   ( a b c -- b c a )
;
; * 83 nucleus
;
rotlfa		.byt $de,$ad
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		ldy stackh+1,x
		lda stackh,x
		sta stackh+1,x
		lda tos+1
		sta stackh,x
		sty tos+1
		ldy stackl+1,x
		lda stackl,x
		sta stackl+1,x
		lda tos
		sta stackl,x
		sty tos
		jmp next

;--------------------------------------------------------------
;
;	LROT   ( a b c -- c a b )
;
lrotlfa		.byt $de,$ad
		.byt (lrot-*-1)|bit7
		.asc "LRO","T"|bit7
lrot		ldy tos+1	; c
		lda stackh,x
		sta tos+1	; b -> tos
		lda stackh+1,x
		sta stackh,x	; a -> 2os
		sty stackh+1,x	; c -> 3os
		ldy tos
		lda stackl,x
		sta tos
		lda stackl+1,x
		sta stackl,x
		sty stackl+1,x
		jmp next

;--------------------------------------------------------------
;
;	SPACE
;
; * 83 device
;
spacelfa	.byt $de,$ad
		.byt (_space-*-1)|bit7
		.asc "SPAC","E"|bit7
_space
#include "enter.i65"
		.word bl
#include "page.i65"
		.word emit
		.word exit

;--------------------------------------------------------------
;
;	?DUP   ( 0 -- 0 | n -- n n )
;
; * 83 nucleus
;
; DUP if top of stack is nonzero
qduplfa		.byt $de,$ad
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		lda tos
		ora tos+1
		beq qdup01
		lda tos
		ldy tos+1
		jmp pushya
qdup01		jmp next

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; * dictionary
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE	( addr n -- addr )
;"	SWAP
;"	BEGIN
;"		OVER +  127  OVER C@  <
;"	UNTIL
;"	SWAP DROP ;
traverselfa	.byt $de,$ad
		.byt (_traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
_traverse
#include "enter.i65"
		.word swap
#include "page.i65"
traverse01	.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $7f
#include "pad.i65"
		.word over
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word traverse01
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
latestlfa	.byt $de,$ad
		.byt (_latest-*-1)|bit7
		.asc "LATES","T"|bit7
_latest
#include "enter.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	FORTH-83
;
; * 83 interpreter
;
; ~ make sure it's really Forth-83 compliant before making this word available
;
forth83lfa	.byt $de,$ad
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jmp next

; ~ better to follow ANS-Forth standard for this group?
;--------------------------------------------------------------
;
;	>BODY   ( cfa -- pfa )
;
; * 83 interpreter
;
; convert the compilation address (CFA) to the address of the parameter field.
tobodylfa	.byt $de,$ad
		.byt (_tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
_tobody
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.byt $de,$ad
		.byt (_toname-*-1)|bit7
		.asc ">NAM","E"|bit7
_toname
#include "enter.i65"
		.word oneminus
#include "page.i65"
		.word minusone
#include "page.i65"
		.word _traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.byt $de,$ad
		.byt (_tolink-*-1)|bit7
		.asc ">LIN","K"|bit7
_tolink
#include "enter.i65"
		.word _toname
#include "page.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>   ( PFA -- CFA )
;
bodyfromlfa	.byt $de,$ad			; ~ Blazin
		.byt (_bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
_bodyfrom
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	NAME>   ( nfa -- cfa )
;
namefromlfa	.byt $de,$ad
		.byt (_namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
_namefrom
#include "enter.i65"
		.word one
#include "page.i65"
		.word _traverse
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	LINK>   ( lfa -- cfa )
;
linkfromlfa	.byt $de,$ad
		.byt (_linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
_linkfrom
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word _namefrom
		.word exit

;--------------------------------------------------------------
;
;	N>LINK   ( nfa -- lfa )
;
ntolinklfa	.byt $de,$ad
		.byt (_ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
_ntolink
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	L>NAME   ( lfa -- nfa )
;
linktonamelfa	.byt $de,$ad
		.byt (_linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
_linktoname
#include "enter.i65"
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.byt $de,$ad
		.byt (_storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
_storecsp

#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n1 )
;
; * 83 nucleus
;
; Leaves the address, addr2 and the character
; count +n of text beginning at addr1.
; addr2 is addr1+1 and n1 is the length of the
; counted string at addr1.  The byte at addr1 con-
; tains the byte count +n.  Range of +n is
; {0...255}.
countlfa	.byt $de,$ad
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		ldy #0
		lda (tos),y
		inc tos
		bne count01
		inc tos+1
count01		jmp pushya

;--------------------------------------------------------------
;
;	TYPE   ( addr count -- )
;
; * 83 device
;
typelfa		.byt $de,$ad
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		ldy #1
		jsr setup
		clc
		lda tos
		ldy numout+3
		adc (up),y
		sta (up),y
		iny
		lda tos+1
		adc (up),y
		sta (up),y
		ldy #0
type01		cpy tos
		bne type02
		dec tos+1
		bpl type02
		jmp pops
type02		lda (n),y
		jsr CHROUT
		iny
		bne type01
		inc n+1
		bne type01

;--------------------------------------------------------------
;
;	SETIRQ   ( newirq -- oldirq )
;
; Safely changes the IRQ vector at $90-$91 to the new value,
; leaving the previous value on the stack
setirqlfa	.byt $de,$ad
		.byt (setirq-*-1)|bit7
		.asc "SETIR","Q"|bit7
setirq		sei
		ldy 1+CINV
		lda CINV		; old IRQ --> ya
		pha
		lda tos+1
		sta 1+CINV
		lda tos
		sta CINV		; tos --> IRQ
		pla
		cli
		jmp put

;--------------------------------------------------------------
;
;	SETLFS   ( filenumber device secondary  -- )
;
;	set file parameters
;
setlfslfa	.byt $de,$ad
		.byt (setlfs-*-1)|bit7
		.asc "SETLF","S"|bit7
setlfs		lda tos
		sta SA
		lda stackl,x
		sta FA
		inx
		lda stackl,x
		sta LA
		jmp poptwo

;--------------------------------------------------------------
;
;	SETNAM   ( addr count  -- )
;
;	set file name parameters
;
setnamlfa	.byt $de,$ad
		.byt (setnam-*-1)|bit7
		.asc "SETNA","M"|bit7
setnam		lda tos
		sta FNLEN
		lda stackl,x
		sta FNADR
		lda stackh,x
		sta 1+FNADR
		jmp poptwo

;--------------------------------------------------------------
;
;	OPEN   ( filenumber device secondary nameaddr count  -- status )
;
;	open a file
;	name is a counted string
;
openlfa		.byt $de,$ad
		.byt (_open-*-1)|bit7
		.asc "OPE","N"|bit7
_open
#include "enter.i65"
		.word setnam
#include "page.i65"
		.word setlfs
#include "page.i65"
		.word to6502
		stx storex
		jsr OPEN
		ldx storex
		pla
		sta ip
		pla
		sta ip+1
		ldy #0
		lda STATUS
		jmp pushya

;--------------------------------------------------------------
;
;	CLOSE   ( filenumber -- status )
;
;	close a file
;
closelfa	.byt $de,$ad
		.byt (closecfa-*-1)|bit7
		.asc "CLOS","E"|bit7
closecfa	lda tos
		sta LA
		stx storex
		jsr CLOSE
		ldx storex
		ldy #0
		lda STATUS
		jmp put

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	(CMDIN)
;
;pcmdinlfa	.byt $de,$ad
;		.byt (pcmdin-*-1)|bit7
;		.asc "(CMDIN",")"|bit7
pcmdin		.word *+2
		stx n+7
	;	lda stack,x
		tax
		jsr CHKIN
		bcs pcmdout01
		bcc pcmdout02
pcmdin01	ldx n+7
		lda #0
		inx
		inx
		jmp pushya
#endif

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	(CMDOUT)
;
;pcmdoutlfa	.byt $de,$ad
;		.byt (pcmdout-*-1)|bit7
;		.asc "(CMDOUT",")"|bit7
pcmdout		stx n+7
	;	lda stack,x
		tax
		jsr CHKOUT
		bcc pcmdout02
pcmdout01	pha
		jsr CLRCHN
		pla
		ldx n+7
		inx
		inx
		jmp pushya
pcmdout02;	jsr READST
		and #$80
		beq pcmdin01
		lda #5
		bne pcmdout01
#endif

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.byt $de,$ad
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff		stx storex
		jsr CLRCHN
		ldx storex
		jmp next

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	STATUS		( -- status )
;
statuslfa	.byt $de,$ad
		.byt (_status-*-1)|bit7
		.asc "STATU","S"|bit7
_status
#include "enter.i65"
		.word clit
		.byt <STATUS
#include "pad.i65"
		.word cfetch
#include "page.i65"
		.word exit
#endif

;--------------------------------------------------------------
;
;	FAIL    ( err# -- )
faillfa		.byt $de,$ad
		.byt (fail-*-1)|bit7
		.asc "FAI","L"|bit7
fail
#include "enter.i65"
		.word twostar
#include "page.i65"
		.word _literal
		.word errptr
#include "pad.i65"
		.word plus
#include "page.i65"
		.word branch
		.word pabortq02

;--------------------------------------------------------------
;
;	(ABORT")   ( flag -- )
;
; * outer interpreter headerless
;
; if the flag is nonzero, types the inline counted string from the 
; dictionary and executes the word in STARTUP.  Otherwise adjusts IP
; to after the string, paging if necessary
;
;pabortqlfa	.byt $de,$ad
;		.byt (_pabortq-*-1)|bit7
;		.asc "(ABORT",'"',")"|bit7
_pabortq	
#include "enter.i65"
		.word rfrom
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word count
#include "page.i65"
		.word rot
#include "page.i65"
		.word qbranch
		.word pabortq01
#include "pad.i65"
pabortq02	.word cmdoff
;#include "page.i65"
;		.word _where
;#include "page.i65"
;		.word cr
;#include "page.i65"
;		.word type
#include "page.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
pabortq01
		.word plus
#include "page.i65"
		.word to6502
		jmp skipinline

;--------------------------------------------------------------
;
;	ABORT"   ( flag -- ) ( -- ; compiling ) 
;
; * 83 compiler immediate
;
; ~ handle page boundary crossings
abortqlfa	.byt $de,$ad
		.byt (_abortq-*-1)|bit7|bit6
		.asc "ABORT",'"'|bit7
_abortq
#include "enter.i65"
		.word _compile
		.word _pabortq
#include "page.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.byt $de,$ad
		.byt (_qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
_qcomp
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
#if (((*&$ff)+3+35)=$ff)
	.word next		; ~wut?
	.word next
#endif
		.word _pabortq
		.byt qcomp01-*-1
		.asc	"COMPILATION ONLY, USE IN DEFINITION"
			;123456789.123456789.123456789.12345
qcomp01		.word exit

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.byt $de,$ad
		.byt (_qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
_qfind
#include "enter.i65"
#if (((*&$ff)+3+27)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qfind01-*-1
		.asc	"NOT IN CURRENT SEARCH ORDER"
			;123456789.123456789.1234567
qfind01		.word exit

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.byt $de,$ad
		.byt (_qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
_qpairs
#include "enter.i65"
		.word minus
#include "page.i65"
#if (((*&$ff)+3+23)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qpairs01-*-1
		.asc	"CONDITIONALS NOT PAIRED"
			;123456789.123456789.123
qpairs01	.word exit

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.byt $de,$ad
		.byt (_qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
_qcsp
#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
#if (((*&$ff)+3+23)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qcsp01-*-1
		.asc	"DEFINITION NOT FINISHED"
			;123456789.123456789.123
qcsp01		.word exit

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.byt $de,$ad
		.byt (_qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
_qchar
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _tickstream
#include "page.i65"
		.word over
#include "page.i65"
		.word swap
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word scan
#include "page.i65"
		.word drop
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word tor
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word toin
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word qchar02
#include "pad.i65"
		.word rfrom
#include "page.i65"
		.word cr
#include "page.i65"
		.word emit
#include "page.i65"
		.word _pdq
		.byt qchar01-*-1
		.asc	" MISSING "
			;123456789
qchar01
#include "pad.i65"
		.word _abort
#include "page.i65"
qchar02		.word rfrom
#include "page.i65"
		.word drop
		.word exit


;--------------------------------------------------------------
;
;	COMPILE
;
; * 83 compiler
;
compilelfa	.byt $de,$ad
		.byt (_compile-*-1)|bit7
		.asc "COMPIL","E"|bit7

_compile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word tor
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	[
;
; * 83 compiler
;
lbracketlfa	.byt $de,$ad
		.byt (_lbracket-*-1)|bit7
		.asc "["|bit7
_lbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	]
;
; * 83 compiler
;
rbracketlfa	.byt $de,$ad
		.byt (_rbracket-*-1)|bit7
		.asc "]"|bit7
_rbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word on
#include "page.i65"
rbracket01	.word qstack
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word dup
#include "page.i65"
		.word qbranch
		.word rbracket03
#include "pad.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word rbracket02
#include "pad.i65"
		.word _comma
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket02	.word execute
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket03	.word drop
#include "page.i65"
		.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word rbracket04
#include "pad.i65"
		.word _dliteral
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket04	.word drop
#include "page.i65"
		.word _literal
#include "page.i65"
rbracket05	.word true
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word rbracket01
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.byt $de,$ad
		.byt (_smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
_smudge
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt bit5	; $20
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.byt $de,$ad
		.byt (_hex-*-1)|bit7|bit6
		.asc "HE","X"|bit7
_hex
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DECIMAL
;
; * 83 interpreter
;
decimallfa	.byt $de,$ad
		.byt (_decimal-*-1)|bit7|bit6
		.asc "DECIMA","L"|bit7
_decimal
#include "enter.i65"
		.word clit
		.byt 10
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(;CODE)
;
;psemilfa	.byt $de,$ad
;		.byt (_psemi-*-1)|bit7
;		.asc "(;CODE",")"|bit7
_psemi
#include "enter.i65"
		.word rfrom
#include "page.i65"
		.word _latest
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DOES>
;
; * 83 compiler
;
doeslfa		.byt $de,$ad
		.byt (_does-*-1)|bit7
		.asc "DOES",">"|bit7
_does
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word _psemi
#include "pad.i65"
		.word clit
		.byt $20	; jsr instruction
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word _compile	; ~ fix paging here
		.word dodoes
#include "pad.i65"
		.word exit
; I've got a pretzel in my brain!
dodoes		pla
		sta n
		pla
		sta n+1
		pla
		sta n+2
		pla
		sta n+3
		lda ip+1
		pha
		lda ip
		pha
		ldy n
		bne dodoes01
		dec n+1
dodoes01	dey
		sty ip
		lda n+1
		sta ip+1
		ldy n+3
		inc n+2
		bne dodoes02
		iny
dodoes02	lda n+2
		jmp pushya

;--------------------------------------------------------------
;
;	-TRAILING
;
; * 83 interpreter
;
dashtrailinglfa	.byt $de,$ad
		.byt (_dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
_dashtrailing
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
dashtrailing01	.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word pqleave
		.word dashtrailing02
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word ploop
		.word dashtrailing01
#include "pad.i65"
dashtrailing02	.word exit

;--------------------------------------------------------------
;
;	(.")   ( -- )
;
; * headerless
;
; types the inline counted string from the dictionary and moves IP
; to just after the string, paging if necessary
;
;pdqlfa		.byt $de,$ad
;		.byt (_pdq-*-1)|bit7
;		.asc "(.",'"',")"|bit7
_pdq
#include "enter.i65"
		.word rfrom		; ( cstring-2 )
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word count
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word type
#include "page.i65"
		.word plus
#include "page.i65"
		.word to6502
skipinline	lda tos+1
		sta ip+1
		lda tos
		sta ip
		jsr slide
		lda #0
		jmp pad

;--------------------------------------------------------------
;
;	."   ( -- )
;
; * 83 compiler
;
dotqlfa		.byt $de,$ad
		.byt (_dotq-*-1)|bit7
		.asc ".",'"'|bit7
_dotq
#include "enter.i65"
		.word _compile
		.word _pdq
#include "pad.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	.(
;
; * 83 interpreter
;
dotplfa		.byt $de,$ad
		.byt (_dotp-*-1)|bit7
		.asc ".","("|bit7
_dotp
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.byt $de,$ad
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp expectvector
expectvector	ldy #1
		jsr setup
		stx storex
		dey
expect01	iny
		cpy tos
		bcs expect02
		jsr CHRIN
		cmp #$0d
		beq expect02
		sta (n),y
		bne expect01
expect02	tya
		ldy span+3
		sta (up),y
		iny
		lda #0
		sta (up),y
		ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.byt $de,$ad
		.byt (_query-*-1)|bit7
		.asc "QUER","Y"|bit7
_query
#include "enter.i65"
		.word tib
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word expect
#include "page.i65"
		.word span
#include "page.i65"
		.word fetch
#include "page.i65"
		.word numtib
#include "page.i65"
		.word store
#include "page.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word toin
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;

;	QUIT?   ( flag -- flag )
;
quitqlfa	.byt $de,$ad
		.byt (_quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
_quitq
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word numtib
#include "page.i65"
		.word fetch
#include "page.i65"
		.word gt
#include "page.i65"
		.word orx
		.word exit

;--------------------------------------------------------------
;
;	ERASE
;
eraselfa	.byt $de,$ad
		.byt (_erase-*-1)|bit7
		.asc "ERAS","E"|bit7
_erase
#include "enter.i65"
		.word zero
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.byt $de,$ad
		.byt (_blank-*-1)|bit7
		.asc "BLAN","K"|bit7
_blank
#include "enter.i65"
		.word bl
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	HOLD   ( char -- )
;
; * 83 interpreter
;
; Inserts  character into a pictured numeric out-
; put string.
; char is inserted into a pictured numeric output
; string.  Typically used between  <#  and  #> .
holdlfa		.byt $de,$ad
		.byt (_hold-*-1)|bit7
		.asc "HOL","D"|bit7
_hold
#include "enter.i65"
		.word minusone
#include "page.i65"
		.word hld
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	PAD
;
; * 83 interpreter
;
padlfa		.byt $de,$ad
		.byt (_pad-*-1)|bit7
		.asc "PA","D"|bit7
_pad
#include "enter.i65"
		.word here
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	'STREAM   ( -- addr size )
;
;" : 'stream
;	blk @ ?dup
;	if	block b/buf
;	else	tib #tib @
;	then
;	>in @ over min >r swap r@ + swap r> - ;
tickstreamlfa	.byt $de,$ad
		.byt (_tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
_tickstream
#include "enter.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup		; ( 0 | blk blk )
#include "page.i65"
		.word qbranch		; if
		.word tickstream01
#include "page.i65"
		.word 0; _block		; ( addr )
#include "page.i65"
		.word bperbuf		; ( addr b/buf )
#include "page.i65"
		.word branch		; else
		.word tickstream02
#include "page.i65"
tickstream01	.word tib		; ( tib )
#include "page.i65"
		.word numtib
#include "page.i65"
		.word fetch		; ( tib #tib )
#include "page.i65"			; then
tickstream02	.word toin		; ( buf size >in )
#include "page.i65"
		.word fetch		; ( buf size offset )
#include "page.i65"
		.word over		; ( buf size offset size )
#include "page.i65"
		.word _min		; ( buf size offset )
#include "page.i65"
		.word tor		; ( buf size )
#include "page.i65"
		.word swap		; ( size buf )
#include "page.i65"
		.word rfetch		; ( size buf offset )
#include "page.i65"
		.word plus		; ( size addr )
#include "page.i65"
		.word swap		; ( addr size )
#include "page.i65"
		.word rfrom		; ( addr size offset )
#include "page.i65"
		.word minus		; ( addr remaining )
		.word exit

;		.word to6502
;		ldy #2
;		jsr setup
;		brk
;		.byt ldd  | TOS		; >in @
;		.byt cpr  | N0		; #tib or b/buf
;		.byt bm,  <(tickstream03-*-2)
;		.byt ld   | N0
;tickstream03	.byt st   | N2		; smaller of (#tib or b/buf, >in)
;		.byt ld   | N1		; tib
;		.byt add  | N2		; cursor position
;		.byt st   | TOS
;		.byt ld   | N0
;		.byt sub  | N2		; bytes remaining
;		.byt push		; ( addr remaining )
;		.byt rtn
;		jmp exit
;#include "toforth.i65"
;		.word exit

;--------------------------------------------------------------
;
;	WORD   ( char -- addr )
;
; * 83 interpreter
;
; Generates a counted string by non-destructively accepting
; characters from the input stream until the delimiting
; character char is encountered or the input stream is
; exhausted.  Leading delimiters are ignored.  The entire
; character string is stored in memory beginning at addr as a
; sequence of bytes.  The string is followed by a blank which
; is not included in the count.  The first byte of the string
; is the number of characters {0..255}.  If the string is
; longer than 255 characters, the count is unspecified.  If
; the input stream is already exhausted as WORD is called,
; then a zero length character string will result.
;
; If the delimiter is not found the value of >IN is the size
; of the input stream.  If the delimiter is found >IN is
; adjusted to indicate the offset to the character following
; the delimiter.  #TIB is unmodified. 		; ( 0100 0104 0107 0009 ) 
;
; The counted string returned by WORD may reside in the "free"
; dictionary area at HERE or above.  Note that the text
;"interpreter may also use this area.  See: "input stream"
;
; fig high level
;" : word   ( c -- addr )
;	blk @  if  blk @ block  else  tib @  then
;	>in @ + swap enclose here 34 blank >in +!
;	over - >r r@ here c! + here 1+ r> cmove ;
;
; blazin' high level
;" : 'stream
;	blk @ ?dup			; ( 0 | blk )
;	if  block b/buf
;	else  tib #tib @
;	then				; ( addr size )
;	>in @				; ( addr size pointer )
;	over min			; ( addr pointer )
;	>r swap				
;	r@ + swap
;	r> - ;
;" : skip
;
;" : scan
;
;" : word   ( c -- nfa )
;	>r				; ( -- ) r( c )
;	'stream
;	over swap
;	r@ skip
;	over swap
;	r> scan
;	drop over over swap -
;	>r
;	rot - 1+
;	>in +!
;	r> here
;	over over c!
;	1+ swap cmove
;	here dup count +
;	bl swap c! ;
wordlfa		.byt $de,$ad
		.byt (_word-*-1)|bit7
		.asc "WOR","D"|bit7
_word					; ( char )
#include "enter.i65"
		.word tor		; ( )
#include "page.i65"
		.word _tickstream	; ( addr size )
#include "page.i65"
		.word over		; ( addr size addr )
#include "page.i65"
		.word swap		; ( addr addr size )
#include "page.i65"
		.word rfetch		; ( addr addr size char )
#include "page.i65"
		.word skip		; ( addr addr2 size )
#include "page.i65"
		.word over		; ( addr addr2 size addr2 )
#include "page.i65"
		.word swap		; ( addr addr2 addr2 size )
#include "page.i65"
		.word rfrom		; ( addr addr2 addr2 size char )
#include "page.i65" 
		.word scan		; ( addr addr2 addr3 size )
#include "page.i65"
		.word drop		; ( addr addr2 addr3 )
#include "page.i65"
		.word _twodup		; ( addr addr2 addr3 addr2 addr3 )
#include "page.i65"
		.word swap		; ( addr addr2 addr3 addr3 addr2 )
#include "page.i65"
		.word minus		; ( addr addr2 addr3 wordsize )
#include "page.i65"
		.word tor		; ( addr addr2 addr3 )
#include "page.i65"
		.word rot		; ( addr2 addr3 addr )
#include "page.i65"
		.word minus		; ( addr2 offset )
#include "page.i65"
		.word oneplus		; ( addr2 offset )
#include "page.i65"
		.word toin		; ( addr2 offset toin )
#include "page.i65"
		.word plusstore		; ( addr2 )
#include "page.i65"
		.word rfrom		; ( addr2 size )
#include "page.i65"
		.word here		; ( addr2 size here )
#include "page.i65"
		.word _twodup		; ( addr2 size here size here )
#include "page.i65"
		.word cstore		; ( addr2 size here )
#include "page.i65"
		.word oneplus		; ( addr2 size here+1 )
#include "page.i65"
		.word swap		; ( addr2 here+1 size )
#include "page.i65"
		.word cmove		; ( )
#include "page.i65"
		.word here		; ( here )
#include "page.i65"			; the following may be unnecessary ~
		.word bl		; ( here bl )
#include "page.i65"
		.word over		; ( here bl here )
#include "page.i65"
		.word count		; ( here bl here+1 size )
#include "page.i65"
		.word plus		; ( here bl here+size+1 )
#include "page.i65"
		.word cstore		; ( here )
		.word exit

;--------------------------------------------------------------
;
;	(PUNCT?)
;
;ppunctqlfa	.byt $de,$ad
;		.byt (_ppunctq-*-1)|bit7
;		.asc "(PUNCT?",")"|bit7
_ppunctq
#include "enter.i65"
		.word clit
		.byt '.'
#include "pad.i65"
		.word eq
		.word exit

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.byt $de,$ad

		.byt (_punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
_punctq
#include "enter.i65"
		.word _ppunctq
		.word exit


;--------------------------------------------------------------
;
;	CONVERT
;
; * 83 interpreter
;
convertlfa	.byt $de,$ad
		.byt (_convert-*-1)|bit7
		.asc "CONVER","T"|bit7
_convert
#include "enter.i65"
convert01	.word oneplus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word convert03
#include "page.i65"
		.word swap
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word drop
#include "page.i65"
		.word rot
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word dplus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word convert02
#include "page.i65"
		.word one
#include "page.i65"
		.word dpl
#include "page.i65"
		.word plusstore
#include "page.i65"
convert02	.word rfrom
#include "page.i65"
		.word branch
		.word convert01
#include "page.i65"
convert03	.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	NUMBER    ( addr -- d )
;
; Convert the count and character string at addr, to a signed
; 32-bit integer, using the value of BASE .  If numeric
; conversion is not possible, an error condition exists.  The
; string may contain a preceding minus sign.
numberlfa	.byt $de,$ad
		.byt (_number-*-1)|bit7
		.asc "NUMBE","R"|bit7
_number
#include "enter.i65"
		.word true
#include "page.i65"
		.word over
#include "page.i65"
		.word count
#include "page.i65"
		.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word swap
#include "page.i65"
		.word pqdo
		.word number03
#include "pad.i65"
number01	.word i
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word number02
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word pleave
		.word number03
#include "page.i65"
number02	.word ploop
		.word number01
#include "page.i65"
number03	.word _qfind
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word rot
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word clit
		.byt '-'
#include "pad.i65"
		.word eq
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word minus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word on
#include "page.i65"
number04	.word _convert
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word _punctq
#include "page.i65"
		.word qbranch
		.word number05
#include "page.i65"
		.word dpl
#include "page.i65"
		.word off
#include "page.i65"
		.word branch
		.word number04
#include "page.i65"
number05	.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word _qfind
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word number06
#include "page.i65"
		.word dnegate
number06	.word exit

;--------------------------------------------------------------
;
;	TRYCHAIN   ( name-2 vocabptr -- addr flag )
;
;": trychain ( name vocabulary -- addr flag )
;	@ @ ?dup			( name-2 head head | name-2 0 )
;	if	(find)			( addr flag ; result of vocab search )
;	else	dup 2+ dhash		( name-2 hash1 hash2 )
;		bloom@			( name-2 hash1 flag )
;		if	dhash@ (find)	( lfa flag ; result of FORTH search )
;		else	drop false	( name-2 false ; bloom filter skip )
;		then
;	then ;
;
;trychainlfa	.byt $de,$ad
;		.byt (_trychain-*-1)|bit7
;		.asc "TRYCHAI","N"|bit7
_trychain
#include "enter.i65"
		.word fetch		; ( name-2 vocabulary )
#include "page.i65"
		.word fetch		; ( name-2 LFA|0 )
#include "page.i65"
		.word qdup		; ( name-2 LFA LFA | name-2 false )
#include "page.i65"
		.word qbranch
		.word trychain01
#include "pad.i65"			; ( name-2 LFA )
		.word pfind		; ( addr flag )
#include "page.i65"
		.word branch
		.word trychain03
#include "pad.i65"
trychain01	.word dup		; ( name-2 name-2 )
#include "page.i65"
		.word twoplus		; ( name-2 name )
#include "page.i65"
		.word dhash		; ( name-2 hash1 hash2 )
#include "page.i65"
		.word bloomfetch	; ( name-2 hash1 flag )
#include "page.i65"
		.word qbranch
		.word trychain02
#include "pad.i65"			; ( name-2 hash1 )
		.word dhashfetch	; ( name-2 LFA )
#include "page.i65"
		.word pfind		; ( addr flag )
#include "page.i65"
		.word branch
		.word trychain03
#include "pad.i65"			; ( name-2 hash1 )
trychain02	.word drop
#include "page.i65"			; ( name-2 )
		.word twoplus
#include "page.i65"
		.word false		; ( here false )
#include "page.i65"
trychain03	.word exit		; ( addr flag )

;--------------------------------------------------------------
;
;	FIND   ( addr1 -- addr2 n )
;
; * 83 interpreter
;
; addr1 is the address of a counted string.  The string
; contains a word name to be located in the currently active
; search order.  If the word is not found, addr2 is the string
; address addr1, and n is zero.  If the word is found, addr2
; is the compilation address and n is set to one of two non-
; zero values.  If the word found has the immediate attribute,
; n is set to one.  If the word is non-immediate, n is set to
; minus one (true).
;
;": find  ( name -- addr flag )
;	2- context trychain		( addr -1|1 | name false )
;	?dup 0=				( addr -1|1 false | name true )
;	if				( not found ) 
;		current			( name current )
;		dup @ context @ <>	( name current flag )
;		if	trychain	( addr flag )
;		else	drop 2+ false	( name 0 )
;		then
;	then ;
;
; the FORTH vocabulary is special.  It has 16 threads.  Other
; vocabularies are single-thread linked lists
;
; something like...
;
; ( addr1 ) 
; 0 ( still looking )
; begin  
;	context @ ( context = 0 means we're at the FORTH vocabulary ) 
;	swap 0=
;	and
; ?dup  ( context | 0 )
; while
;	search-thread
; repeat
;
findlfa		.byt $de,$ad
		.byt (_find-*-1)|bit7
		.asc "FIN","D"|bit7
_find
#include "enter.i65"			; ( name )
		.word twominus		; ( name-2 ) adjust to look like LFA
#include "page.i65"
		.word context		; ( name-2 context )
#include "page.i65"
		.word _trychain		; ( addr flag )
#include "page.i65"
		.word qdup		; ( addr flag flag | name-2 0 )
#include "page.i65"
		.word zeq		; ( addr flag false | name-2 true )
#include "page.i65"
		.word qbranch
		.word find02
#include "pad.i65"			; ( name-2 )
		.word current		; ( name-2 current )
#include "page.i65"
		.word dup		; ( name-2 current current )
#include "page.i65"
		.word fetch		; ( name-2 current vocab )
#include "page.i65"
		.word context		; ( name-2 current vocab context )
#include "page.i65"
		.word fetch		; ( name-2 current vocab vocab )
#include "page.i65"
		.word ne		; ( name-2 current flag )
#include "page.i65"
		.word qbranch
		.word find01
#include "pad.i65"			; ( name-2 current )
		.word _trychain		; ( addr flag )
#include "page.i65"
		.word branch
		.word find02
#include "pad.i65"			; ( name-2  current )
find01		.word drop
#include "page.i65"
		.word false		; ( name false )
#include "page.i65"
find02		.word exit		; ( addr flag )

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.byt $de,$ad
		.byt (_existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
_existsq
#include "enter.i65"
		.word bl		; ( c )
#include "page.i65"
		.word _word		; ( nfa )
#include "page.i65"
		.word _find		; ( nfa true | here false )
		.word exit

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.byt $de,$ad
		.byt (_iddot-*-1)|bit7
		.asc "ID","."|bit7
_iddot
#include "enter.i65"
		.word _pad
#include "page.i65"
		.word clit
		.byt 32
#include "pad.i65"
		.word clit
		.asc '*'
#include "pad.i65"
		.word fill
#include "page.i65"
		.word dup
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _pad
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word _pad
#include "page.i65"
		.word count
#include "page.i65"
		.word clit
		.byt $1f		; ~ shouldn't this use WIDTH?
#include "pad.i65"
		.word andx
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	[COMPILE]
;
; * 83 compiler
;
bcompilelfa	.byt $de,$ad
		.byt (_bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
_bcompile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _tick
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	LITERAL
;
; * 83 compiler
;
literallfa	.byt $de,$ad
		.byt (_literal-*-1)|bit7
		.asc "LITERA","L"|bit7
_literal
#include "enter.i65"
		.word dup
#include "page.i65"
		.word plit
		.word 256
#include "pad.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word literal01
#include "page.i65"
		.word _compile
		.word clit
#include "page.i65"
		.word _ccomma
#include "page.i65"
		.word branch
		.word literal02
#include "page.i65"
literal01	.word _compile
		.word plit
#include "page.i65"
		.word _comma
literal02	.word exit

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.byt $de,$ad
		.byt (_dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
_dliteral
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _literal
#include "page.i65"
		.word _literal
		.word exit

;--------------------------------------------------------------
;
;	INTERPRET
;
;
;": interpret   ( )
;	begin	?stack
;		exists?
;		if	link>
;			execute
;		else	number dpl @ 1+ 0=
;			if	drop
;			then
;		then
;		false
;		quit?
;	again ;
;
interpretlfa	.byt $de,$ad

		.byt (_interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
_interpret
#include "enter.i65"
interpret01	.word qstack		; ( )
#include "page.i65"
		.word _existsq		; ( addr flag )
#include "page.i65"
		.word qbranch
		.word interpret02
#include "page.i65"
		.word execute
#include "page.i65"
		.word branch
		.word interpret03
#include "page.i65"
interpret02	.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word interpret03
#include "page.i65"
		.word drop
#include "page.i65"
interpret03	.word false
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word interpret01
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	IMMEDIATE
;
; * 83 compiler
;
immediatelfa	.byt $de,$ad
		.byt (_immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
_immediate
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt $40
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	VOCABULARY
;
; * 83 compiler
;
; see FD-V05N3 p. 5

vocabularylfa	.byt $de,$ad
		.byt (_vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
_vocabulary
#include "enter.i65"
		.word _create
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word _comma
#include "page.i65"
		.word here
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
		.word _psemi
vocabdoes	jsr dodoes
		.word context
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	FORTH
;
; * 83 interpreter
;
; ~ maybe put a zero instead of ntop, to flag the special handling?
; ntop doesn't seem very useful, at least here
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
forthlfa	.byt $de,$ad
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jsr vocabdoes
		.word 0			; flag as root vocabulary
		.word $a081		; some magic number?
lastvoc		.word 0			; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;	DEFINITIONS
;
; * 83 interpreter
;
definitionslfa	.byt $de,$ad
		.byt (_definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
_definitions
#include "enter.i65"
		.word context
#include "page.i65"
		.word fetch
#include "page.i65"
		.word current
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(
;
; * 83 interpreter
;
lparenlfa	.byt $de,$ad
		.byt (_lparen-*-1)|bit7
		.asc "("|bit7
_lparen
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	ABORT
;
; * 83 interpreter
;
abortlfa	.byt $de,$ad
		.byt (_abort-*-1)|bit7
		.asc "ABOR","T"|bit7
_abort
#include "enter.i65"
		.word spstore
#include "page.i65"
		.word _quit
		.word exit	; make the decompiler happy

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.byt $de,$ad
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jsr docreate
		.word _abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack

ice		jsr swapzp
		bne cold		; bra
coldlfa		.byt $de,$ad
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		ldy #uarea-userarea-1
		bne warm01		; bra

warm		lda #>warm05		; ~wut? this probably isn't doing what I think it does
		sta w1+1
		lda #<warm05
		sta w1

		ldy #userwarm-userarea-1

warm01		lda userup
		sta up
		lda userup+1
		sta up+1
warm02		lda userarea,y
		sta (up),y
		dey
		bpl warm02
		cld
ml		jsr CLRCHN
		jsr CLALL
#include "toforth.i65"
		.word sw16		; set up BRK vector to Sweet16
#include "page.i65"
		.word rpstore		; and we're off
#include "page.i65"
		.word spstore
#include "page.i65"
		.word _pdq
		.byt (warm03-*-1)
		.asc	CLR,"FORTH FOR THE COMMODORE PET 2001",CR
		.asc	"HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
		.asc	"VERSION PRE-ALPHA 2014-03-31",CR
warm03
#include "pad.i65"
		.word _rethread
#include "page.i65"
warm05		.word _decimal
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word _pdq
		.byt (warm04-*-1)
		.asc	CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
		.word exit

;--------------------------------------------------------------
;
;	QUIT
;
; * 83 interpreter outer
;
quitlfa		.byt $de,$ad
		.byt (_quit-*-1)|bit7
		.asc "QUI","T"|bit7
_quit
#include "enter.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word _lbracket
#include "page.i65"
quit01		.word rpstore
#include "page.i65"
		.word cr
#include "page.i65"
		.word _query
#include "page.i65"
		.word _interpret
#include "page.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word quit02
#include "page.i65"
		.word _pdq
		.byt (quit02-*-1)
		.asc	" OK"
			;123
quit02
#include "pad.i65"
		.word branch
		.word quit01

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.byt $de,$ad
		.byt (_stod-*-1)|bit7
		.asc "S>","D"|bit7
_stod
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zlt
		.word exit

;--------------------------------------------------------------
;
;	ABS   ( n -- +n )
;
; * 83 nucleus
;
abslfa		.byt $de,$ad
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs		lda tos+1
		bpl abs01
		jmp negate
abs01		jmp next

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.byt $de,$ad
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs		lda tos+1
		bpl abs01
		jmp dnegate

;--------------------------------------------------------------
;
;	MIN
;
; * 83 nucleus
;
minlfa		.byt $de,$ad
		.byt (_min-*-1)|bit7
		.asc "MI","N"|bit7
_min
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word gt
#include "page.i65"
		.word qbranch
		.word min01
#include "pad.i65"
		.word swap
#include "page.i65"
min01		.word drop
		.word exit

;--------------------------------------------------------------
;
;	MAX
;
; * 83 nucleus
;
maxlfa	.byt $de,$ad
		.byt (_max-*-1)|bit7
		.asc "MA","X"|bit7
_max
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word max01
#include "pad.i65"
		.word swap
#include "page.i65"
max01		.word drop
		.word exit

;--------------------------------------------------------------
;
;	M*   ( n1 n2 -- d )
;
; * divstar
;
; multiply two signed words, leaving the double product on the stack
mstarlfa	.byt $de,$ad
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jsr mult
		jmp next
mult		lda stackl,x
		sta n+4
		lda stackh,x
		sta n+5
		eor tos+1
		php			; we only care about the sign bit
		bit tos+1
		bpl mult01
		jsr donegate
mult01		bit n+5
		bpl mult02
		sec
		lda #0
		sbc n+4
		sta n+4
		lda #0
		sbc n+5
		sta n+5
mult02		jsr multiply
		lda n+1
		sta stackh,x
		lda n
		sta stackl,x
		lda n+3
		sta tos+1
		lda n+2
		sta tos
		plp
		bpl mult03
		jmp dodnegate
mult03		rts

;--------------------------------------------------------------
;
;	M/   ( d n -- rem quotient )
;
mslashlfa	.byt $de,$ad
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash
		jsr domslash
		jmp next
domslash	cpx #$6f
		bcc domslash02
domslash01	ldx #bos
	;	sty stack,x
	;	sty stack+1,x
		tya
		rts
domslash02;	lda stack,x
	;	ora stack+1,x
		beq domslash01
	;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+1,x
	;	eor stack+3,x
		pha
	;	lda stack+1,x
		pha
		bpl domslash03
		jsr donegate
domslash03;	lda stack+3,x
		bpl domslash04
		inx
		inx
		jsr dnegate
		dex
		dex
domslash04	jsr divmod
		pla
		bpl domslash05
		jsr remult
domslash05	pla
		bpl domslash07
		jsr donegate
	;	lda stack+2,x
	;	ora stack+3,x
		beq domslash07
	;	lda stack,x
		bne domslash06
	;	dec stack+1,x
domslash06;	dec stack,x
		jsr remult
		clc
		pla
	;	adc stack+2,x
	;	sta stack+2,x
		pla
	;	adc stack+3,x
	;	sta stack+3,x
		rts
domslash07	pla
		pla
		rts
remult		inx
		inx
		jsr donegate
		dex
		dex
		rts

;--------------------------------------------------------------
;
;	M*/   ( n1 n2 n3 -- d )
;
; * divstar
;
; multiplies n1*n2 giving an intermediate 16-bit value, and divides
; that by n3 yielding a 16-bit quotient.  Remainder is ignored, 
; all values are signed.
;
mstarslashlfa	.byt $de,$ad
		.byt (mstarslash-*-1)|bit7
		.asc "M*","/"|bit7
mstarslash

;--------------------------------------------------------------
;
;	*   ( n1 n2 -- n1*n2 )
;
; * 83 nucleus divstar
;
; multiply two signed words
starlfa		.byt $de,$ad
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jsr mult
		jmp pops

;--------------------------------------------------------------
;
;	/MOD    ( n1 n2 -- n3 n4 )
;
; * 83 nucleus divstar
;
; n3 is the remainder and n4 the floor of the
; quotient of n1 divided by the divisor n2.  n3
; has the same sign as n2 or is zero.  An error
; condition results if the divisor is zero or if
; the quotient falls outside the range {-32,768
; ... 32,676}.
;
slashmodlfa	.byt $de,$ad
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jsr doslashmod
		jmp next
doslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+3,x
		bpl doslashmod01
		dey
doslashmod01;	sty stack,x
	;	sty stack+1,x
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		ldy #0
		jmp domslash

;--------------------------------------------------------------
;
;	/   ( n1 n2 -- n3 )
;
; * 83 nucleus divstar
;
; n3 is the floor of the quotient of n1 divided
; by the divisor n2.  An error condition results
; if the divisor is zero or if the quotient falls
; outside the range {-32,768 ... 32,767}.


slashlfa	.byt $de,$ad
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jsr doslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pops

;--------------------------------------------------------------
;
;	MOD   ( n1 n2 -- n3 )
;
; * 83 nucleus divstar
;
; n3 is the remainder after dividing n1 by the
; divisor n2.  n3 has the same sign as n2 or is
; zero.  An error condition results if the
; divisor is zero or if the quotient falls out-
; side the range {32,768...32,768}.
;
modlfa		.byt $de,$ad
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jsr doslashmod
		jmp pops

;--------------------------------------------------------------
;
;	*/MOD   ( n1 n2 n3 -- n4 n5 )
;
; * 83 nucleus divstar
;
; n1 is first multiplied by n2 producing an inter-
; mediate 32 bit result.  n4 is the remainder and
; n5 is the floor of the quotient of the inter-
; mediate 32-bit result divided by the divisor
; n3.  A 32-bit intermediate product is used for
; */ .  n4 has the same sign as n3 or is zero.
; An error condition results if the divisor is
; zero or if the quotient falls outside of the
; range {-32,768...32,767}.
;
starslashmodlfa	.byt $de,$ad
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jsr dostarslashmod
		jmp next
dostarslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
		inx
		inx
		jsr mult
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		jmp domslash

;--------------------------------------------------------------
;
;	*/   ( n1 n2 n3 -- n4 )
;
; * 83 nucleus divstar
;
; n1 is first multiplied by n2 producing an inter-
; mediate 32-bit result.  n4 is the floor of the
; quotient of the intermediate 32-bit result
; divided by the divisor n3.  The product of n1
; times n2 is maintained as an intermediate 32-
; bit result for greater precision than the other-
; wise equivalent sequence n1 n2 * n3 / .  An
; error condition results if the divisor is zero
; or if the quotient falls outside the range
; {-32,768...32,767}.
;
starslashlfa	.byt $de,$ad
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jsr dostarslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pops

;--------------------------------------------------------------
;
;	UD/MOD   ( d1 n1 -- n2 d2 )
;
; * divstar
;
; d2 is the double quotient of d1/n1.  n2 is the remainder.  All
; values are unsigned.
; ~ make this 32-bit divisor?
; ~ fix for /0
udslashmodlfa	.byt $de,$ad
		.byt (udslashmod-*-1)|bit7
		.asc "UD/MO","D"|bit7
udslashmod	ldy #2
		jsr setup		; udhi -> N0; udlo -> N1
		jsr divmod		; unsigned u32/u16 -> 32quo rem16
		dex
		lda n+2
		sta stackl,x
		lda n+3
		sta stackh,x		; remainder
		lda n+7
		sta tos+1
		lda n+6
		sta tos
		ldy n+5
		lda n+4
		jmp pushya
divmod
		lda zi+1
		pha
		lda zi
		pha
		lda zi+3
		pha
		lda zi+2
		pha
		sty zi+1
		sty zi			; zero the divisor
		sty zi+3
		sty zi+2
		sty n+5
		sty n+4
		sty n+7
		sty n+6			; zero the quotient
		ldy #33
		lda tos+1
		ora tos
		beq divmod05		; error division by zero
divmod01	lsr tos+1
		ror tos
		ror zi+1
		ror zi
		ror zi+3
		ror zi+2
		dey
		lda tos+1
		ora tos
		bne divmod01
divmod02	asl n+6
		rol n+7
		rol n+4
		rol n+5			; double the quotient here
		sec
		lda n+2
		sbc zi+2
		pha
		lda n+3
		sbc zi+3
		pha
		lda n
		sbc zi
		pha
		lda n+1
		sbc zi+1
		bcc divmod03
		sta n+1
		pla
		sta n
		pla
		sta n+3
		pla
		sta n+2
		inc n+6			; add 1 to quotient
		bcs divmod04		; bra
divmod03	pla
		pla
		pla			; discard result of subtraction
divmod04	lsr zi+1
		ror zi
		ror zi+3
		ror zi+2
		dey
		bne divmod02
		pla
		sta zi+4
		pla
		sta zi+3
		pla
		sta zi
		pla
		sta zi+1
divmod05	rts

;--------------------------------------------------------------
;
;	M/MOD   ( d n1 -- n2 n3 )
;
; * divstar
;
; n2 is the remainder and n3 is the floor of the
; quotient after dividing d by the divisor n1.
; All values and arithmetic are unsigned.  An er-
; ror condition results if the divisor is zero or
; if the quotient lies outside the range
; {-32,768...32,767}.
;
mslashmodlfa	.byt $de,$ad
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jsr setup	; udhi -> N0; udlo -> N1
		lda tos+1
		pha
		bpl mslashmod01
		jsr donegate
mslashmod01	pla
		eor n+1		; xor the sign bits
		sta n+7
		lda n+1
		sta n+6		; original sign of divisor
		bpl mslashmod02
		jsr dnegaten	; negate the double at n..n+3
mslashmod02	jsr divmod
		sty n+1
		sta n		; stash the quotient
		lda n+6
		bpl mslashmod03
		jsr donegate
mslashmod03	lda n+7
		bpl mslashmod04
		jsr dnegaten
mslashmod04	ldy n+1
		lda n
		jmp push

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	<BCQ
;
ltbcqlfa	.byt $de,$ad
		.byt (_ltbcq-*-1)|bit7
		.asc "<BC","Q"|bit7
_ltbcq
#include "enter.i65"
		.word first
#include "page.i65"
		.word numbcq
#include "page.i65"
		.word minus
		.word exit
#endif

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	BCQ>
;
bcqtolfa	.byt $de,$ad
		.byt (_bcqto-*-1)|bit7
		.asc "BCQ",">"|bit7
_bcqto
#include "enter.i65"
		.word first
#include "page.i65"
		.word twominus
		.word exit
#endif

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	>BCQ
;
tobcqlfa	.byt $de,$ad
		.byt (_tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
_tobcq
#include "enter.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word plus
		.word exit
#endif

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.byt $de,$ad
		.byt (_latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
_latestq
#include "enter.i65"
		.word offset
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word latestq01
#include "pad.i65"
		.word drop
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word false
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word drop
latestq01	.word exit
#endif

#ifdef USE_DISK
;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.byt $de,$ad
		.byt (_absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
_absentq
#include "enter.i65"
		.word _latestq
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word store
#include "page.i65"
		.word true
#include "page.i65"
		.word swap
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
absentq01	.word _twodup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word absentq02
#include "pad.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word cmove
#include "page.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word rot
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word minus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word drop
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word pleave
		.word absentq03
#include "pad.i65"
absentq02	.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word ploop
		.word absentq01
#include "pad.i65"
absentq03	.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
		.word exit
#endif

;--------------------------------------------------------------
;
;	'
;
; * 83 interpreter
;
ticklfa		.byt $de,$ad
		.byt (_tick-*-1)|bit7
		.asc "'"|bit7
_tick
#include "enter.i65"
		.word _existsq
#include "page.i65"
		.word zeq
#include "page.i65"
		.word _qfind
		.word exit

;--------------------------------------------------------------
;
;	[']
;
; * 83 compiler
;
brticklfa	.byt $de,$ad
		.byt (_brtick-*-1)|bit7
		.asc "['","]"|bit7
_brtick
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _tick
#include "page.i65"
		.word _literal
		.word exit


;--------------------------------------------------------------
;
;	?>MARK
;
;qtomarklfa	.byt $de,$ad
;		.byt (_qtomark-*-1)|bit7
;		.asc "?>MAR","K"|bit7
_qtomark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word here
#include "page.i65"
		.word swap
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	?<MARK
;
;qfrommarklfa	.byt $de,$ad
;		.byt (_qfrommark-*-1)|bit7
;		.asc "?<MAR","K"|bit7
_qfrommark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word here
#include "page.i65"
		.word zero
		.word exit

;--------------------------------------------------------------
;
;	?>RESOLVE
;
;qtoresolvelfa	.byt $de,$ad
;		.byt (_qtoresolve-*-1)|bit7
;		.asc "?>RESOLV","E"|bit7
_qtoresolve
#include "enter.i65"
qtoresolve01	.word qdup
#include "page.i65"
		.word qbranch
		.word qtoresolve02
#include "page.i65"
		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word here
#include "page.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word qtoresolve01
qtoresolve02	.word exit

;--------------------------------------------------------------
;
;	?<RESOLVE
;
;qltresolvelfa	.byt $de,$ad
;		.byt (_qltresolve-*-1)|bit7
;		.asc "?<RESOLV","E"|bit7
_qltresolve
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	ADD>MARK
;
;addtomarklfa	.byt $de,$ad
;		.byt (_addtomark-*-1)|bit7
;		.asc "ADD>MAR","K"|bit7
_addtomark
#include "enter.i65"
		.word true
#include "page.i65"
		.word tor
#include "page.i65"
addtomark01	.word one
#include "page.i65"
		.word roll
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word tor
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word addtomark01
		.word drop
#include "page.i65"
		.word _qtomark
#include "page.i65"
addtomark02	.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word true
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word addtomark02
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	BEGIN
;
; * 83 compiler
;
beginlfa	.byt $de,$ad
		.byt (_begin-*-1)|bit7
		.asc "BEGI","N"|bit7
_begin
#include "enter.i65"
		.word _qfrommark
#include "page.i65"
		.word one
		.word exit

;--------------------------------------------------------------
;
;	THEN
;
; * 83 compiler
;
thenlfa		.byt $de,$ad
		.byt (_then-*-1)|bit7
		.asc "THE","N"|bit7
_then
#include "enter.i65"
		.word abs
#include "page.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	DO
;
; * 83 compiler
;
dolfa		.byt $de,$ad
		.byt (_do-*-1)|bit7
		.asc "D","O"|bit7
_do
#include "enter.i65"
		.word _compile
#include "page.i65"
		.word pdo
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.byt $de,$ad
		.byt (_qdo-*-1)|bit7
		.asc "?D","O"|bit7
_qdo
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word pqdo
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	LOOP
;
; * 83 compiler
;
looplfa		.byt $de,$ad
		.byt (_loop-*-1)|bit7
		.asc "LOO","P"|bit7
_loop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word ploop
#include "pad.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	+LOOP
;
; * 83 compiler
;
pluslooplfa	.byt $de,$ad
		.byt (_plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
_plusloop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word pploop
#include "pad.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	LEAVE
;
; * 83 compiler
;
leavelfa	.byt $de,$ad
		.byt (_leave-*-1)|bit7
		.asc "LEAV","E"|bit7
_leave
#include "enter.i65"
		.word _compile
		.word pleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.byt $de,$ad
		.byt (_qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
_qleave
#include "enter.i65"
		.word _compile
		.word pqleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	UNTIL
;
; * 83 compiler
;
untillfa	.byt $de,$ad
		.byt (_until-*-1)|bit7
		.asc "UNTI","L"|bit7
_until
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word qbranch
#include "page.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.byt $de,$ad
		.byt (_again-*-1)|bit7
		.asc "AGAI","N"|bit7
_again
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	REPEAT
;
; * 83 compiler
;
repeatlfa	.byt $de,$ad
		.byt (_repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
_repeat
#include "enter.i65"
		.word _again
		.word exit

;--------------------------------------------------------------
;
;	IF
;
; * 83 compiler
;
iflfa		.byt $de,$ad
		.byt (_if-*-1)|bit7
		.asc "I","F"|bit7
_if
#include "enter.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word qbranch
		.word _qtomark
#include "page.i65"
		.word two
		.word exit

;--------------------------------------------------------------
;
;	ELSE
;
; * 83 compiler
;
elselfa		.byt $de,$ad
		.byt (_else-*-1)|bit7
		.asc "ELS","E"|bit7
_else
#include "enter.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word swap
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word swap
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word zero
#include "page.i65"
		.word plit
		.word -2
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	WHILE
;
; * 83 compiler
;
whilelfa	.byt $de,$ad
		.byt (_while-*-1)|bit7
		.asc "WHIL","E"|bit7
_while
#include "enter.i65"
		.word _compile
		.word qbranch
		.word one
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	SPACES
;
; * 83 device
;
spaceslfa	.byt $de,$ad
		.byt (_spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
_spaces
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _max
#include "page.i65"
		.word zero
#include "page.i65"
		.word pqdo
		.word spaces02
spaces01	.word _space
#include "page.i65"
		.word ploop
		.word spaces01
spaces02	.word exit

;--------------------------------------------------------------
;
;	<#   ( -- )
;
; * 83 interpreter
;
ltsharplfa	.byt $de,$ad
		.byt (_ltsharp-*-1)|bit7
		.asc "<","#"|bit7
_ltsharp
#include "enter.i65"
		.word _pad		; ( pad )
#include "page.i65"
		.word hld		; ( pad hld )
#include "page.i65"
		.word store		; ( ) 
		.word exit

;--------------------------------------------------------------
;
;	#>
;
; * 83 interpreter
;
sharpgtlfa	.byt $de,$ad
		.byt (_sharpgt-*-1)|bit7
		.asc "#",">"|bit7
_sharpgt
#include "enter.i65"
		.word twodrop
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _pad
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	SIGN    ( n -- )
;
; * 83 interpreter
;
; If n is negative, an ASCII "-" (minus sign) is appended to the
; pictured numeric output string.  Typically used between <# and #> .
;
signlfa		.byt $de,$ad
		.byt (_sign-*-1)|bit7
		.asc "SIG","N"|bit7
_sign
#include "enter.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word sign01
#include "pad.i65"
		.word clit
		.byt '-'
#include "pad.i65"
		.word _hold
sign01		.word exit

;--------------------------------------------------------------
;
;	#   ( +d1 -- +d2 )
;
; * 83 interpreter
;
; +d1 is divided by BASE and the quotient is
; placed onto the stack.  The remainder is con-
; verted to an ASCII character and appended to
; the output string toward lower memory ad-
; dresses.
; The remainder of +d1 divided by the value of
; BASE is converted to an ASCII character and ap-
; pended to the output string toward lower memory
; addresses.  +d2 is the quotient and is main-
; tained for further processing.  Typically used
; between <# and #> .
sharplfa	.byt $de,$ad
		.byt (_sharp-*-1)|bit7
		.asc "#"|bit7
_sharp
#include "enter.i65"
		.word base		; ( d base )
#include "page.i65"
		.word fetch		; ( d @base )
#include "page.i65"
		.word udslashmod	; ( rem d )
#include "page.i65"
		.word rot		; ( d rem )
#include "page.i65"
		.word to6502
		lda tos
		sed
		cmp #10
		adc #'0'
		cld
		sta tos			; ( d char )
#include "toforth.i65"
		.word _hold		; ( d )
		.word exit

;--------------------------------------------------------------
;
;	#S   ( d -- )
;
; * 83 interpreter
;
sharpslfa	.byt $de,$ad
		.byt (_sharps-*-1)|bit7
		.asc "#","S"|bit7
_sharps
#include "enter.i65"
sharps01	.word _sharp		; ( d )
#include "page.i65"
		.word _twodup		; ( d d )
#include "page.i65"
		.word dzeq		; ( d flag )
#include "page.i65"
		.word qbranch
		.word sharps01
		.word exit

;--------------------------------------------------------------
;
;	(U.)
;
;pudotlfa	.byt $de,$ad
;		.byt (_pudot-*-1)|bit7
;		.asc "(U.",")"|bit7
_pudot
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	U.
;
; * 83 interpreter
;
udotlfa		.byt $de,$ad
		.byt (_udot-*-1)|bit7
		.asc "U","."|bit7
_udot
#include "enter.i65"
		.word _pudot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	U.R    ( u n -- )
;
; u is converted using the value of BASE and then
; displayed as an unsigned number right-aligned
; in a field +n characters wide.  If the number
; of characters required to display u is greater
; than +n, an error condition exists.

udotrlfa	.byt $de,$ad
		.byt (_udotr-*-1)|bit7
		.asc "U.","R"|bit7
_udotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pudot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(.)   ( n -- )
;
;pdotlfa		.byt $de,$ad
;		.byt (_pdot-*-1)|bit7
;		.asc "(.",")"|bit7
_pdot
#include "enter.i65"
		.word dup		; ( n n )
#include "page.i65"
		.word abs		; ( n +n )
#include "page.i65"
		.word zero		; ( n +d )
#include "page.i65"
		.word _ltsharp		; ( n +d )
#include "page.i65"
		.word _sharps		; ( 
#include "page.i65"
		.word rot
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	.   ( n -- )
;
; * 83 interpreter
;
; The value of n is displayed in a free field for-
; mat with a leading minus sign if n is negative.
dotlfa		.byt $de,$ad
		.byt (_dot-*-1)|bit7
		.asc "."|bit7
_dot
#include "enter.i65"
		.word _pdot		; ( addr count )
#include "page.i65"
		.word type		; ( )
#include "page.i65"
		.word _space		; ( )
		.word exit

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.byt $de,$ad
		.byt (_dotr-*-1)|bit7
		.asc ".","R"|bit7
_dotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pdot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(UD.)
;
;puddotlfa	.byt $de,$ad
;		.byt (_puddot-*-1)|bit7
;		.asc "(UD.",")"|bit7
_puddot
#include "enter.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.byt $de,$ad
		.byt (_uddot-*-1)|bit7
		.asc "UD","."|bit7
_uddot
#include "enter.i65"
		.word _puddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.byt $de,$ad
		.byt (_uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
_uddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _puddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(D.)
;
;pdddotlfa	.byt $de,$ad
;		.byt (_pddot-*-1)|bit7
;		.asc "(D.",")"|bit7
_pddot
#include "enter.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word dabs
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.byt $de,$ad
		.byt (_ddot-*-1)|bit7
		.asc "D","."|bit7
_ddot
#include "enter.i65"
		.word _pddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.byt $de,$ad
		.byt (_ddotr-*-1)|bit7
		.asc "D.","R"|bit7
_ddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	?
;
questionlfa	.byt $de,$ad
		.byt (_question-*-1)|bit7
		.asc "?"|bit7
_question
#include "enter.i65"
		.word fetch
#include "page.i65"
		.word _dot
		.word exit

;--------------------------------------------------------------
;
;	PICK   ( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
;
; * 83 nucleus
;
; 0 pick = same as dup
; 1 pick = same as over
picklfa		.byt $de,$ad
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick		stx storex
		ldx tos
		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	ROLL   ( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
;
; * 83 nucleus
;
; remove the nth stack element (excluding n itself) to TOS, dropping n
;
; 2 roll = rot
; 1 roll = swap
; 0 roll has no effect
;
rolllfa		.byt $de,$ad
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		stx n
		txa
		clc
		adc tos
		tax
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
roll01		cpx n
		beq roll02
		lda stackh+$ff,x
		sta stackh,x
		lda stackl+$ff,x	; ~ probably not work!
		sta stackl,x
		dex
		bne roll01
roll02		inx
		jmp next

;--------------------------------------------------------------
;
;	DEPTH
;
; * 83 nucleus
;
depthlfa	.byt $de,$ad
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth	
		txa
		eor #$ff
		sec
		adc #<bos
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	2DUP   ( n1 n2 -- n1 n2 n1 n2 )
;
twoduplfa	.byt $de,$ad
		.byt (_twodup-*-1)|bit7
		.asc "2DU","P"|bit7
_twodup
#include "enter.i65"
		.word over
#include "page.i65"
		.word over
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	2OVER   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
;
twooverlfa	.byt $de,$ad
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		dex
		dex
		lda tos+1
		sta stackh+2,x
		lda tos
		sta stackl+2,x
		lda stackh+4,x
		sta stackh+1,x
		lda stackl+4,x
		sta stackl+1,x
		lda stackh+3,x
		sta tos+1
		lda stackl+3,x
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	2ROT   ( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )
;
; hi1 is stored in TOS, the rest in stackl/stackh ... stack+4
tworotlfa	.byt $de,$ad
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		ldy stackh+4,x
		lda stackh+2,x
		sta stackh+4,x
		lda stackh,x
		sta stackh+2,x
		sty stackh,x
		ldy stackl+4,x
		lda stackl+2,x
		sta stackl+4,x
		lda stackl,x
		sta stackl+2,x
		sty stackl,x		; done moving lo words
		ldy stackh+3,x
		lda stackh+1,x
		sta stackh+3,x
		lda tos+1
		sta stackh+1,x
		sty tos+1
		ldy stackl+3,x
		lda stackl+1,x
		sta stackl+3,x
		lda tos
		sta stackl+1,x
		sty tos			; done moving hi words
		jmp next

;--------------------------------------------------------------
;
;	2SWAP   ( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )
;
twoswaplfa	.byt $de,$ad
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		ldy tos+1
		lda stackh+1,x
		sta tos+1
		sty stackh+1,x
		ldy tos
		lda stackl+1,x
		sta tos
		sty stackl+1,x
		ldy stackh,x
		lda stackh+2,x
		sta stackh,x
		sty stackh+2,x
		ldy stackl,x
		lda stackl+2,x
		sta stackl,x
		sty stackl+2,x
		jmp next

;--------------------------------------------------------------
;
;	2!   ( hi lo addr -- )
;
twostorelfa	.byt $de,$ad
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	ldy #0
twostore01	lda stackh,x
		sta (tos),y
		iny
		lda stackl,x
		sta (tos),y
		iny
		inx
		cpy #4
		bne twostore01
		jmp pops

;--------------------------------------------------------------
;
;	2@   ( addr -- hi lo )
;
twofetchlfa	.byt $de,$ad
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	ldy #3
		dex
		lda (tos),y
		sta stackh,x
		dey
		lda (tos),y
		sta stackl,x
		dey
		lda (tos),y
		sta n
		dey
		lda (tos),y
		ldy n
		jmp put

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.byt $de,$ad
		.byt (_twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
_twoconst
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
		jsr dodoes
#include "page.i65"
		.word twofetch
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.byt $de,$ad
		.byt (_twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
_twovariable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.byt $de,$ad
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus	;	jsr dnegate
		jmp dplus+2

;--------------------------------------------------------------
;
;	D0=   ( d -- flag )
;
dzeqlfa		.byt $de,$ad
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		ldy #0
		lda tos
		ora tos+1
		ora stackl,x
		ora stackh,x
		bne dzeq01
		dey
dzeq01		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	D=   ( hi2 lo2 hi1 lo1 -- flag )
;
deqlfa		.byt $de,$ad
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		ldy #0
		lda tos
		eor stackl+1,x
		bne deq01
		lda tos+1
		eor stackh+1,x
		bne deq01
		lda stackl,x
		eor stackl+2,x
		bne deq01
		lda stackh,x
		eor stackh+2,x
		bne deq01
		dey
deq01		inx
		inx
		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.byt $de,$ad
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jsr dcmp
		bcs dult01
		dey
dult01	;	sty stack+6,x
	;	sty stack+7,x
		inx
		inx
		jmp poptwo

;--------------------------------------------------------------
;
;	D2/   ( hi lo -- hi/2 lo/2 )
;
dtwoslashlfa	.byt $de,$ad
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	lsr stackh,x
		ror stackl,x
		ror tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	D2*   ( hi lo -- hi*2 lo*2 )
;
dtwostarlfa	.byt $de,$ad
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	asl stackl,x
		rol stackh,x
		rol tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.byt $de,$ad
		.byt (_dgt-*-1)|bit7
		.asc "D",">"|bit7
_dgt
#include "enter.i65"
		.word twoswap
#include "page.i65"
		.word dlt
		.word exit

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.byt $de,$ad
		.byt (_dmin-*-1)|bit7
		.asc "DMI","N"|bit7
_dmin
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word _dgt
#include "page.i65"
		.word qbranch
		.word dmin01
#include "page.i65"
		.word twoswap
#include "page.i65"
dmin01		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.byt $de,$ad
		.byt (_dmax-*-1)|bit7
		.asc "DMA","X"|bit7
_dmax
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word dlt
#include "page.i65"
		.word qbranch
		.word dmax01
#include "pad.i65"
		.word twoswap
#include "page.i65"
dmax01		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	BRINGOUTYERDEAD   ( addr -- deadlfa|0 )
;
; scans forward in memory returning the address of the next $DE $AD
; in memory that is followed by a name
;" http://www.youtube.com/watch?v=grbSQ6O6kbs
;
; sweet16 saved 37 bytes vs. 6502
boydlfa		.byt $de,$ad
		.byt (boyd-*-1)|bit7
		.asc "BRINGOUTYERDEA","D"|bit7
boyd		brk
		.byt set  | R10
		.word $de
		.byt set  | R11
		.byt $de,$ad
		.byt set  | N0
		.word userdp-userarea
		.byt ld   | UP
		.byt add  | N0
		.byt st   | N0
		.byt ldd  | N0
		.byt st   | N0		; here
		.byt ldd  | N0
		.byt popd | N0		; restore N0
		.byt st   | N1
		.byt ld   | R11
		.byt std  | N0		; here+2 -> N0
		.byt rtn
boyd01		brk
		.byt ldi  | TOS
		.byt cpr  | R10
		.byt bnz, <(boyd01-*-1)
		.byt dcr  | TOS
		.byt ldd  | TOS
		.byt cpr  | R11
		.byt bz,  <(boyd02-*-2)
		.byt dcr  | TOS
		.byt br,  <(boyd01-*-1)
boyd02		.byt ld   | TOS
		.byt cpr  | N0		; TOS=here+2?
		.byt bnz, <(boyd03-*-2)
		.byt sub  | ACC
		.byt st   | TOS
		.byt br,  <(boyd06-*-2)
boyd03		.byt rtn		; TOS points to probable NFA
		ldy #0
		lda (tos),y
		bpl boyd01		; NFA length must be negative
		and #$1f
		tay
		lda (tos),y
		bpl boyd01		; last NFA byte must be negative
boyd04		dey
		beq boyd05
		lda (tos),y
		bpl boyd04
		bmi boyd01		; middle NFA bytes must be positive
boyd05		brk
		.byt popd | TOS		; point at the LFA
boyd06		.byt popd | N0		; back up the pointer
		.byt ld   | N1
		.byt std  | N0		; restore previous contents of here
		.byt rtn
		jmp next

;--------------------------------------------------------------
;
;	DHASH	( nfa -- hash1 hash2 )
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;dhashlfa	.byt $de,$ad
;		.byt (dhash-*-1)|bit7
;		.asc "DHAS","H"|bit7
dhash		stx storex
		ldy #0
		lda (tos),y
		and #$3f		; turn off 7 and 6, not 5 (smudge)
		sta n			; seed hash1 with length
		sty n+1			; seed hash2 with 0
		tay
		iny		;	hash2	hash1
dhash01		dey				;[2]
		beq dhash02			;[2]
		lda (tos),y			;[5]
		sec				;[2]
		sbc #$20			;[2]
		and #(pearsonx-pearson-1)	;[2]
		tax				;[2]
		lda n				;[3]
		eor pearson,x			;[4]
		sta n				;[3]
		lda (tos),y		;[5]
		and #$7f		;[2]
		clc			;[2]
		adc #$FF-('9')		;[2]
		adc #'9'-'0'+1		;[2]
		bcc dhash01			;[3]  [12]hash2 [27]hash1	
		adc n+1			; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
		sta n+1			; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1 
		jmp dhash01		; 2drop 2dup 2over 2rot 2swap 2! 2@
					; 2constant 2variable d0= d2/ d2* 
dhash02		lda n
		lsr
		lsr
		lsr
		lsr			; - - - - [ 7 6 5 4 ]
		eor n			; 7 6 5 4 [ 3 2 1 0 ]
		and #$0f		; - - - - [4bit hash]
		;jsr debug
		sta tos
		sty tos+1
		lda n+1		; sum of all digits 0..9	
		ldx storex
		jmp pushya

#ifdef DEBUG
;~debug hex dump the byte in A
debug	pha
	pha
	and #$0f
	jsr print
	pla
	lsr
	lsr
	lsr
	lsr
	;jsr print
	pla
dbout	rts
print	sed
	cmp #10
	adc #'0'
	cld
	jmp CHROUT
#endif ;/DEBUG

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieve the head of this hash thread
;
;dhashfetchlfa	.byt $de,$ad
;		.byt (dhashfetch-*-1)|bit7
;		.asc "DHASH","@"|bit7
dhashfetch	brk
		.byt set  | ACC
		.word lfalist
		.byt add  | TOS
		.byt add  | TOS
		.byt st   | TOS
		.byt ldd  | TOS
		.byt st   | TOS
		.byt rtn
		jmp next

;--------------------------------------------------------------
;
;	BLOOM!   ( hash -- )
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;bloomstorelfa	.byt $de,$ad
;		.byt (bloomstore-*-1)|bit7
;		.asc "BLOOM","!"|bit7
bloomstore	lda tos			; set bloom filter bit for hash2
		and #7
		tay
		lda power2,y
		sta n
		lda tos
		lsr
		lsr
		lsr
		and #(bloomx-bloom-1)	; don't write outside filter area
		tay
		lda n
		ora bloom,y
		sta bloom,y
		jmp pops

;--------------------------------------------------------------
;
;	BLOOM@   ( hash -- flag )
;
; test a bit in the filter
; hash indexes a single bit in the bloom2 filter
; false = it can't be in there (bit was clear)
; true = it might be in there (bit was set)
;bloomfetchlfa	.byt $de,$ad
;		.byt (bloomfetch-*-1)|bit7
;		.asc "BLOOM","@"|bit7
bloomfetch	lda tos			; read bloom filter bit for hash2
		and #7
		tay
		lda power2,y
		sta n
		lda tos
		lsr
		lsr
		lsr
		and #(bloomx-bloom-1)	; don't read outside filter area
		tay
		lda bloom,y
		ldy #0
		and n
		beq bloomfetch01
		dey
bloomfetch01	tya
		jmp put

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hash1 -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
; sweet16 saved 51 bytes vs. 6502
;dhashstorelfa	.byt $de,$ad
;		.byt (dhashstore-*-1)|bit7
;		.asc "DHASH","!"|bit7
dhashstore	ldy #1
		jsr setup		; LFAnew -> N0
		brk
		.byt set  | R11
		.word lfalist
		.byt sub  | ACC
		.byt st   | N2		; 0 -> N2
		.byt ld   | R11
		.byt add  | TOS
		.byt add  | TOS
		.byt st   | R11		; R11+hash1*2 -> R11
		.byt ldd  | R11
		.byt popd | R11		; back up the pointer
		.byt bnz, <(dhashstore01-*-2)
		.byt set  | ACC
		.word rootlfa
		.byt std  | R11
		.byt popd | R11
dhashstore01	.byt st   | N1		; head -> N1
		.byt rtn
		ldy #2
		lda (n),y
		and #$1f
		sta n+7			; length of name being inserted
dhashstore02	lda (n+2),y
		and #$1f
		sta n+6
		lda n+7
		cmp n+6			; compare lengths
		bcc dhashstore05
		bne dhashstore04
		;sec
		adc #1
		tay			; last char in names
dhashstore03	lda (n),y
		eor (n+2),y
		asl			; compare char ignoring bit7
		bne dhashstore04
		dey
		cpy #2
		bne dhashstore03	; stop at first char
		dey
		brk
		.byt set  | ACC
		.byt $de,$ad
		.byt std  | N1
		.byt rtn
dhashstore04	brk
		.byt ld   | N1
		.byt st   | N2		; keep track of where we've just been
		.byt ldd  | N1
		.byt st   | N1		; (N1) -> N1
		.byt rtn
		ldy #2
		bne dhashstore02
dhashstore05	brk
		.byt ld   | N2
		.byt bnz, <(dhashstore06-*-2)
		.byt ld   | R11		; empty list, insert at the head
		.byt st   | N2		; head -> N2
dhashstore06	.byt ld   | N0
		.byt std  | N2		; N0 -> (N2)
		.byt ld   | N1
		.byt std  | N0		; N1 -> (N0)
		.byt rtn
		jmp pops		; toss the hash

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity for the programmer.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.
; It also marks the last word in the core dictionary.
; links all LFAs
;" : rethread   ( -- )
;	lfalist 40 erase
;	0 +origin
;	begin	bringoutyerdead
;		?dup
;	while	dup dup 2+
;		dhash
;		bloom!
;		dhash!
;	until ;
;
;rethreadlfa	.byt $de,$ad
;		.byt (_rethread-*-1)|bit7
;		.asc "RETHREA","D"|bit7
_rethread
#include "enterx.i65"
		.word plit
		.word bloom
#include "pad.i65"
		.word clit
		.byt 40			; bloom filter (8) and lfalist (32)
#include "pad.i65"
		.word _erase
#include "page.i65"
		.word zero
#include "page.i65"
		.word _plusorigin
#include "page.i65"
rethread01	.word boyd		; begin boyd ?dup while ... repeat
#include "page.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word rethread02
#include "page.i65"
		.word dup		; ( lfa lfa )
#include "page.i65"
		.word dup		; ( lfa lfa lfa )
#include "page.i65"
		.word twoplus		; ( lfa lfa nfa )
#include "page.i65"
		.word dhash		; ( lfa lfa hash1 hash23 )
#include "page.i65"
		.word bloomstore	; ( lfa lfa hash1 )
#include "page.i65"
		.word dhashstore	; ( lfa )
#include "page.i65"
		.word branch
		.word rethread01
#include "pad.i65"
rethread02	.word exit

;--------------------------------------------------------------
;
;	UNTHREAD   ( -- )
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;	16 0 do				( )
;		i dhash@		( lfa1 )
;		begin
;			dup		( lfa1 lfa1 )
;			@		( lfa1 lfa2 )
;			?dup		( lfa1 lfa2 true | lfa1 false )
;		while			( lfa1 lfa2 )
;			$dead		( lfa1 lfa2 $dead )
;			rot		( lfa2 $dead lfa1 )
;~ dup 2- ( nfa ) dup c@ ( nfa len ) $80 or ( nfa len ) swap c! ( )
;			!		( lfa2 )
;		repeat
;					( lfa )
;		drop			( )
;	loop
;
;unthreadlfa	.byt $de,$ad
;		.byt (_unthread-*-1)|bit7
;		.asc "UNTHREA","D"|bit7
_unthread
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
unthread01	.word i
#include "page.i65"
		.word dhashfetch
#include "page.i65"
unthread02	.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word unthread03
#include "pad.i65"
		.word plit
		.byt $de,$ad
#include "pad.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word unthread02
#include "page.i65"
unthread03	.word drop
#include "page.i65"
		.word zero
#include "page.i65"
		.word i
#include "page.i65"
		.word dhashstore
#include "page.i65"
		.word ploop
		.word unthread01
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	FORGET
;
; * 83 interpreter
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
; ~ work this over to use pointers only (no RETHREAD/UNTHREAD)
forgetlfa	.byt $de,$ad
ntop		.byt (_forget-*-1)|bit7
		.asc "FORGE","T"|bit7
_forget
#include "enter.i65"
		.word _tick
#include "page.i65"
		.word _toname
		.word dup
#include "page.i65"
		.word fence
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ult
#if (((*&$ff)+3+23)=$ff)
	.word next

	.word next
#endif
		.word _pabortq
		.byt forget01-*-1
		.asc	"IN PROTECTED DICTIONARY"
			;123456789.123456789.123
forget01	.word tor
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
forget02	.word rfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word forget03
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word fetch
#include "page.i65"
		.word branch
		.word forget02
#include "page.i65"
forget03	.word dup
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
forget04	.word dup
#include "page.i65"
		.word twominus
#include "page.i65"
forget05	.word _ntolink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word forget05
#include "pad.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word forget04
#include "pad.i65"
		.word rfrom
#include "page.i65"
		.word dp
#include "page.i65"
		.word store
		.word exit
forgetfence
		
;==============================================================

;--------------------------------------------------------------
barlfa		.byt $de,$ad
		.byt (bar-*-1)|bit7
		.asc "BA","R"|bit7
bar		ldy #2
		sty storex
		ldy #0
bar01		lda $8000,y
		eor #$80
		sta $8000,y
		lda $8100,y
		eor #$80
		sta $8100,y
		lda $8200,y
		eor #$80
		sta $8200,y
		lda $8300,y
		eor #$80
		sta $8300,y
		iny
		bne bar01
		dec storex
		bne bar01
		jmp next


;--------------------------------------------------------------
;
;	WHEAD   ( device -- )
;
; The editor vocabulary
;
;wheadlfa	.byt $de,$ad
;		.byt (whead-*-1)|bit7
;		.asc "WHEA","D"|bit7
;whead
;		brk
;		.byt set  | R0
;		.word	blockbuf
;		.byt set  | N0
;		.word	SAL
;		.byt std  | N0
;		.byt set  | R0		; blockbuf -> SAL
;		.word	VIDRAM
;		.byt std  | N0		; VIDRAM -> EAL
;		.byt rtn
;		
;		lda #<blockbuf		; start address
;		sta STAL
;		lda #>blockbuf
;		sta 1+STAL
;		lda #<VIDRAM		; end address + 1
;		sta EAL
;		lda #>VIDRAM
;		sta 1+EAL
;
;		lda #6			; file name
;		sta FNLEN
;		lda #<pettil
;		sta FNADR
;		lda #>pettil
;		sta 1+FNADR
;
;				
;		lda #1		
;		sta FA		; current device number = tape 1
;		lda #7		; header id byte
;		jsr SAVEHEADER
;		
;		
;		lda #$69
;		sta RIPRTY	; header gap delay
;		jsr PRESSRECORD
;		jsr TAPEWRITE
;		jmp next
;
;--------------------------------------------------------------
;wblocklfa	.byt $de,$ad
;		.byt (wblock-*-1)|bit7
;		.asc "WBLOC","K"|bit7
;wblock		jsr TAPEWRITE
;		jmp next
;
;--------------------------------------------------------------

endofile

; PETTIL 
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate
bit5	= $20		; smudge

; zero page usage
stackl	= $00		; stackl = $00..$3b (60 bytes)
stackh	= $30		; stackh = $3c..$79 (60 bytes)
bos	= stackh-1	; $3b
n	= $7a
w	= $80		; w overlaps 8-byte n scratch area
tos	= $82
up	= $84

next	= $86
;0086 next	inc ip
next1	= $88
;0088 next1	inc ip
nexto	= $8a
ip	= $8b
;008a nexto	jmp ($cafe)

;$8d..$ff kernel zeropage area

outputted	= cas1buf+26		; #out
inputted	= cas1buf+42		; span
linesout	= cas1buf+54		; #line

	basic	= $0400
		.word basic+1		; PET BASIC storage starts here
*	= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc "(1040)",0		; sys $0410
basend		.word 0

		.dsb basic+$10-*,$ea
coldvector	jmp cold
warmvector	jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userarea

userntop	.word ntop				; 4..5
userup		.word cas2buf				; 6..7
usersp0		.word bos				; 8..9
userrp0		.word $01ff				; 10..11
userwidth	.word 31				; 12..13
userwarning	.word -1				; 14..15

userwarm

userfence	.word forgetfence			; 16..17
userdp		.word endofile				; 18..19
uservoclink	.word $36a2				; 20..21
userviewquery	.word 2					; 22..23
userblk		.word $1908				; 24..25

usercold

		;dictionary hash link table used by rechaining words
latestl		.dsb 16,0
latesth		.dsb 16,0

;--------------------------------------------------------------
;
;       NEXT
;
;           +IP
;           [IP]   -> PC

; this NEXT routine gets copied to $0086 by COLD.  See project
; tiddlywiki for the rationale behind this minimalist design
;
page3           inc ip
page2           inc ip+1
                jmp next

azpnext
        inc ip
        inc ip
        jmp ($cafe)
zzpnext


;--------------------------------------------------------------
;
;       EXECUTE
;
; Executes the definition found at addr.
;
;"      : execute ( cfa ---   )
;"          jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa      .word 0			; <-- last word in dictionary
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7	; length and final byte are OR $80
execute         lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1	; [SP] -> [W1]
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx             ; SP+
		lda ip
		sta w1+4
		lda ip+1
		sta w1+5        ; IP -> [W1+4]
		lda #<w1
		sta ip
		lda #>w1
		sta ip+1        ; W1 -> IP
		jmp nexto

; These three words are used by EXECUTE as a 'fragment secondary'
; (for those occasions when you just need a W register)
				; dummy value $DEAD, we wind up at $BEEF
w1		.word $dead
		.word branch
		.word $beef

;--------------------------------------------------------------
;
;       (LIT)
;
; push the word of memory following (IP)
;
plitlfa         .word $adde
		.byt (plit-*-1)|bit7
		.asc "(LIT",")"|bit7
plit            ldy #3
                lda (ip),y
                sta n+1
                dey
                lda (ip),y
                sta n
skiplit         ldy ip
                cpy #$fb
                bcc nopage
		bne l003
		iny
l003		inc ip+1
nopage		iny
		iny
		sty ip
pushn           ldy n+1
                lda n

push            sta n
                dex
                lda tos
                sta stackl,x
                lda tos+1
                sta stackh,x
                lda n
put             sty tos+1
                sta tos
                jmp next

;--------------------------------------------------------------
;
;       CLIT
;
; takes the byte of memory following and pushes it to the data stack
;
;"      : clit ( -- c )
;"         ip c@  1 ip +! ;
;
clitlfa         .word $adde
		.byt (clit-*-1)|bit7
		.asc "CLI","T"|bit7
clit            ldy #2
                lda (ip),y
		dec ip
                sta n
                lda #0
                sta n+1
                beq skiplit

;--------------------------------------------------------------
;
;       BRANCH
;
; Compiles an unconditional branch operation.
;" When used in the form:  COMPILE BRANCH
; an  unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated  by following BRANCH
; with <RESOLVE or >MARK .
;
;"      : branch ( -- )
;
branchlfa       .word $adde
		.byt (branch-*-1)|bit7
		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
; Y = 1
branch          ldy #2          ; [2]
		lda (ip),y      ; [5+]
		sta n           ; [3]
		iny             ; [2]
		lda (ip),y      ; [5+]
		sta ip+1        ; [3]
		lda n           ; [3]
		sta ip          ; [3] (IP+2) -> IP
		jmp nexto       ; [3]
				; [29/30 cycles] (runs in constant time)
;--------------------------------------------------------------
;
;       ?BRANCH   ( flag -- )
;
qbranchlfa      .word $adde
		.byt (qbranch-*-1)|bit7
		.asc "?BRANC","H"|bit7
qbranch         lda tos
		ora tos+1
		ldy stackl,x
		sty tos
		ldy stackh,x
		sty tos+1
		inx             ; drop
		tay		; to set the Z flag
		bne branch
		lda #4
nexta           clc		;[2]
		adc ip		;[3]
		sta ip		;[3]
		bcc l023	;[2]
		inc ip+1	;[5]
l023            jmp nexto	;[3]

;--------------------------------------------------------------
;
;       (LOOP)
;
plooplfa        .word $adde
		.byt (ploop-*-1)|bit7
		.asc "(LOOP",")"|bit7
ploop           jsr enter

;--------------------------------------------------------------
;
;       (+LOOP)
;
pplooplfa       .word $adde
		.byt (pploop-*-1)|bit7
		.asc "(+LOOP",")"|bit7
pploop          jsr enter

;--------------------------------------------------------------
;
;	(DO)
;
pdolfa		.word $adde
		.byt (pdo-*-1)|bit7
		.asc "(DO",")"|bit7
pdo		lda stackh,x
		pha
		lda stackl,x
		pha
		lda tos+1
		pha
		lda tos
		pha
poptwo		inx
pop		ldy stackh,x
		lda stackl,x
		inx
		jmp put

;--------------------------------------------------------------
;
;	(?DO)
;
pqdolfa		.word $adde
		.byt (pqdo-*-1)|bit7
		.asc "(?DO",")"|bit7
pqdo		jsr enter

;--------------------------------------------------------------
;
;	I
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		jsr enter

;--------------------------------------------------------------
;
;	J
;
jlfa		.word $adde
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		jsr enter

;--------------------------------------------------------------
;
;	(LEAVE)
;
pleavelfa	.word $adde
		.byt (pleave-*-1)|bit7
		.asc "(LEAVE",")"|bit7
pleave		jsr enter

;--------------------------------------------------------------
;
;	(?LEAVE)
;
pqleavelfa	.word $adde
		.byt (pqleave-*-1)|bit7
		.asc "(?LEAVE",")"|bit7
pqleave		jsr enter

;--------------------------------------------------------------
;
;	DIGIT
;
digitlfa	.word $adde
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit		jsr enter

;--------------------------------------------------------------
;
;	(FIND)
;
pfindlfa	.word $adde
		.byt (pfind-*-1)|bit7
		.asc "(FIND",")"|bit7
pfind		lda #2			; ~ mostly straight Blazin'
		jsr popnwords		; this one's going to take some work
		stx n+4			; happy golfing!  It needs to run fast.
		iny
l9		dey		; ~ ewww
		lda (n),y
		eor (n+2),y
		and #$3f
		bne l8
l6		iny
		lda (n),y
		eor (n+2),y
		asl
		bne l8
		bcc l6
		ldx n+4
		dex
		dex
		iny
		tya
		clc
		adc n
		sta stackl+1,x
		ldy #0
		tya
		adc n+1
		sta stackh+1,x
		sty tos+1
		lda (n),y
		asl
		bpl l7
		lda #1
		sta tos
		jmp next
l7		lda #$ff	;true
		pha
		jmp put
l8		sec
		lda n		; traverse the LFAs?
		sbc #2
		sta n
		lda n+1
		sbc #0
		sta n+1
		ldy #0
		lda (n),y
		tax
		iny
		lda (n),y
		sta n+1
		stx n
		ora n
		bne l9
		ldx n+4
		dex
		dex
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		lda #0		;false
		pha
		jmp push

;--------------------------------------------------------------
;
;	SKIP
;
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		lda #3			; ~ mostly Blazin'.  fixed double DEX
		jsr popnwords		; and other minor differences
l13		lda n+2
		ora n+3
		beq l10
		lda (n+4),y
		eor n
		asl
		bne l10
		inc n+4
		bne l11
		inc n+5
l11		lda n+2
		bne l12
		dec n+3
l12		dec n+2
		jmp l13
l10		dex
		lda n+4
		sta tos
		lda n+5
		sta tos+1
		ldy n+2
		lda n+3
		jmp push


;--------------------------------------------------------------
;
;	SCAN
;
scanlfa		.word $adde
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		jsr enter		; ~ straight Blazin'
		lda #3
		jsr popnwords
l16		lda n+2
		ora n+3
		beq l10
		lda (n+4),y
		eor n
		asl
		beq l10
		inc n+4
		bne l14
		inc n+5
l14		lda n+2
		bne l15
		dec n+3
l15		dec n+2
		jmp l16


;--------------------------------------------------------------
;
;	EMIT
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp emitvector
emitvector	inc outputted
		bne l130
		inc outputted+1
l130		lda tos
		jsr CHROUT
		jmp pop

;--------------------------------------------------------------
;
;	KEY
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp keyvector
keyvector	stx n
l131		jsr GETIN
		beq l131
		ldx n
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp qtermvector
qtermvector	stx n
		ldy #0
		jsr STOP
		bne l132
		dey
l132		tya
		pha
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	CR
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp crvector
crvector	lda #$0d
		jsr CHROUT
		ldy #0
		sty outputted
		sty outputted+1
		inc linesout
		bne l133
		inc linesout+1
l133		jmp next

;--------------------------------------------------------------
;
;	CMOVE
;
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		lda #3
		jsr popnwords		; maybe PETTIL should make one CMOVE
					; that is smart enough to not poop
					; on overlapping source/target?
					; or would this break compatibility
					; for FORTH-83 (or ANS or whatever)
					; code that relies on this "feature"
					; of having two CMOVEs?
		stx n+6
		ldx n+1
		beq l17
l18		lda (n+4),y
		sta (n+2),y
		iny
		bne l18
		inc n+5
		inc n+3
		dex
		bne l18
l17		ldx n
		beq l19
l20		lda (n+4),y
		sta (n+2),y
		iny
		dex
		bne l20
l19		ldx n+6
		jmp next

;--------------------------------------------------------------
;
;	CMOVE>
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		lda #3			; ~ straight from Blazin'
		jsr popnwords
		stx n+6
		lda n+1
		pha
		clc
		adc n+5
		sta n+5
		pla
		clc
		adc n+3
		sta n+3
		ldy n
		beq l21
l22		dey
		lda (n+4),y
		sta (n+2),y
		cpy #0
		bne l22
l21		ldx n+1
		beq l23
l25		dec n+5
		dec n+3
l24		dey
		lda (n+4),y
		sta (n+2),y
		cpy #0
		bne l24
		dex
		bne l25
l23		ldx n+6
		jmp next

;--------------------------------------------------------------
;
;	FILL   ( from howmany value -- )
;
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		lda #3
		jsr popnwords
		ldy #0
		lda n+2
		ora n+3
		beq l026
		lda n+4
		ldy n+2
l025		dey
		sta (n),y
		bne l025
		dec n+3
		bpl l025
l026		jmp next




	stack = 69		; ~ this line merely gets the code to assemble
				; it has nothing to do with PETTIL's stack
				; so rewrite the code that references this and
				; remove it




;--------------------------------------------------------------
;
;	UM*
;
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		jsr multiply
		jmp next
				; ~ this is straight out of blazin'
				; ! but seriously ! It won't work !
				; ! make it work with the split stack + TOS
				; ! model we're using in PETTIL
				; I seem to recall a faster general 
				; purpose multiply on 6502.org using LSR?
multiply	lda stack+2,x
		sta n
		sty stack+2,x
		lda stack+3,x
		sta n+1
l150		sty stack+3,x
		ldy #$10
l30		asl stack+2,x
		rol stack+3,x
		rol stack,x
		rol stack+1,x
		bcc l29
		clc
		lda n
		adc stack+2,x
		sta stack+2,x
		lda n+1
		adc stack+3,x
		sta stack+3,x
		bcc l29
		inc stack,x
		bne l29
		inc stack+1,x
l29		dey
		bne l30
		rts

;--------------------------------------------------------------
;
;	UM/MOD
;
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	jsr modulo
		jmp next
				; ~ this is straight out of blazin'
				; ! but seriously ! It won't work !
				; ! get the bugfix version from 6502.org
				; ! and make it work with the split stack + TOS
				; ! model we're using in PETTIL
modulo		sty n+1
		lda stack+4,x
		ldy stack+2,x
		sty stack+4,x
		asl
		sta stack+2,x
		lda stack+5,x
		ldy stack+3,x
		sty stack+5,x
		rol
		sta stack+3,x
		lda #$10
l31		sta n
l34		rol stack+4,x
		rol stack+5,x
		rol n+1
		sec
		lda stack+4,x
		sbc stack,x
		tay
		lda stack+5,x
		sbc stack+1,x
		pha
		lda n+1
		sbc #0
		bcc l32
		sta n+1
		sty stack+4,x
		pla
		sta stack+5,x
		bcs l33
l32		pla
l33		rol stack+2,x
		rol stack+3,x
		dec n
		bne l34
		inx
		inx
		ldy #0
		rts

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx            lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx             lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor             lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		txa
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	SP!
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		ldy #usersp0-userarea
		lda (up),y
		tax
		jmp next

;--------------------------------------------------------------
;
;	RP!
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		stx n
		ldy #userrp0-userarea
		lda (up),y
		tax
		txs
		ldx n
		jmp next

;--------------------------------------------------------------
;
;       EXIT
;
;           [RP+] -> IP
;           NEXT
exitlfa         .word $adde
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
exit            pla
		sta ip
		pla
		sta ip+1        ; [RP+] -> IP
		jmp next        ; NEXT

;--------------------------------------------------------------
;
;	>R   ( n -- )
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		lda tos+1
		pha
		lda tos
		pha
		jmp pop

;--------------------------------------------------------------
;
;	R>   ( -- n )
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		pla
		sta n
		pla
		tay
		lda n
		jmp push

;--------------------------------------------------------------
;
;	R@   ( -- n )
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		stx n
		tsx
		ldy $0102,x
		lda $0101,x
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	0>   ( n -- flag )
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		ldy #$ff
		bit tos+1
		bpl l022
		iny
l022		tya
		jmp put

;--------------------------------------------------------------
;
;	<>   ( n1 n2 -- flag )
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		ldy #$ff
		lda tos
		eor stackl,x
		bne l021
		lda tos+1
		eor stackh,x
		bne l021
		iny
l021		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	ON   ( addr -- )
;
; store -1 at ADDR
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		ldy #0
		sta (tos),y
		iny
		sta (tos),y
		jmp pop

;--------------------------------------------------------------
;
;	OFF
;
; store 0 at ADDR
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+
;
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;	
;       D+
;
dpluslfa	.word $adde
		.byt (dplus-*-1)|bit7
		.asc "D","+"|bit7
dplus		clc
		lda stackl,x
		adc stackl+2,x
		sta stackl+2,x
		lda stackh,x
		adc stackh+2,x
		sta stackh+2,x
		lda tos
		adc stackl+1,x
		sta stackl+1,x
		lda tos+1
		adc stackh+1,x
		sta stackh+1,x
		jmp poptwo

;--------------------------------------------------------------
;
;       D<
;
dltlfa		.word $adde
		.byt (dlt-*-1)|bit7
		.asc "D","<"|bit7
dlt		ldy #0		; false
		jsr dcmp
		bvc l43
		eor #$80
l43		bpl l44
		dey		; true
l44		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next
dcmp		sec
		lda stackl+2,x
		sbc stackl,x
		lda stackh+2,x
		sbc stackh,x
		lda stackl+1,x
		sbc tos
		lda stackh+1,x
		sbc tos+1
		rts
	
;--------------------------------------------------------------
;
;	NEGATE
;
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		jsr donegate
		jmp next
donegate	sec
neg2		lda #0
		sbc tos
		sta tos
		lda #0
		sbc tos+1
		sta tos+1
		rts

;--------------------------------------------------------------
;
;	DNEGATE
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		sec
		dey
		tya
		sbc stackl,x
		sta stackl,x
		tya
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER
;
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp push

;--------------------------------------------------------------
;
;	DROP
;
droplfa		.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pop

;--------------------------------------------------------------
;
;	SWAP
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp push

;--------------------------------------------------------------
;
;	+!   ( n addr -- )
;
; add N to the cell at ADDR
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	ldy #0
		clc
		lda stackl,x
		adc (tos),y
		sta (tos),y
		iny
		lda stackh,x
		adc (tos),y
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		lda stackl,x
		sta n
		lda stackh,x
		sta n+1
		ldy #0
		lda (n),y
		eor tos
		sta (n),y
		jmp poptwo

;--------------------------------------------------------------
;
;	@   ( addr -- n )
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #0
		lda (tos),y
		sta n
		iny
		lda (tos),y
		sta tos+1
		lda n
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	C@   ( addr -- b )
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		ldy #0
		lda (tos),y
		sta tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!   ( n addr -- )
;
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		ldy #0
		lda stackl,x
		sta (tos),y
		iny
		lda stackh,x
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!   ( b addr -- )
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		ldy #0
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;"      :   ( -- )
;	
		.word storecsp
		.word current
		.word fetch
		.word context
		.word store
		.word create
		.word smudge
		.word rbracket
		.word psemi
;--------------------------------------------------------------
;
;       ENTER
;
;           IP    -> -[RP]
;           W     -> IP
;           NEXT
enter           pla             ;[4]
                tay             ;[2]
                pla             ;[4]
                sta n+1         ;[3]
                lda ip+1        ;[3]
                pha             ;[3]
                lda ip          ;[3]
                pha             ;[3]
                lda n+1         ;[3]
                sta ip+1        ;[3]
                iny             ;[2]
                beq l001        ;[2]
l002            sty ip          ;[3]
                jmp nexto       ;[3]
l001            inc ip+1
                bne l002

;--------------------------------------------------------------
;
;       ;   ( -- )
;
semilfa		.word $adde
		.byt (semi-*-1)|bit7|bit6
		.asc ";"|bit7
semi		.word qcsp
		.word compile
		.word exit
		.word smudge
		.word lbracket
		.word exit

;--------------------------------------------------------------
;
;	CONSTANT   ( -- n )
;
constantlfa	.word $adde
		.byt (constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
constant	jsr enter
		.word create
		.word comma
		.word psemi
doconst		ldy #0
		lda (ip),y
		sta n
		iny
		lda (ip),y
		sta n+1
		jmp pushn

;--------------------------------------------------------------
; variable
variablelfa	.word $adde
		.byt (variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
variable	jsr enter
		.word create
		.word two
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	USER
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user		.word enter
		.word constant
		.word psemi
uservar         pla
		tay
		pla
		sta n+1
		iny
		bne l008
		inc n+1
l008		sty n
		jmp pushn

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		lda #0
		tay
		jmp push

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		jsr doconst
		.word 1

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jmp doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jmp doconst
		.word 3

;--------------------------------------------------------------
;
;	BL
;
bllfa		.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jsr doconst
		.word $20

;--------------------------------------------------------------
;
;	C/L
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jsr doconst
		.word 64

;--------------------------------------------------------------
;
;	FIRST
;
;~ fix this to read actual top of memory
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jsr doconst
		.word $7000

;--------------------------------------------------------------
;
;	LIMIT
;
;~ fix this to read actual top of memory
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jsr doconst
		.word $8000

;--------------------------------------------------------------
;
;	#BUF
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	#BCQ
;
;~ a BFORTH-ism
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jsr doconst
		.word 32

;--------------------------------------------------------------
;
;	B/BUF
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jsr doconst
		.word 1024

;--------------------------------------------------------------
;
;	B/SCR
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	TIB
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jsr doconst
		.word $0100

;--------------------------------------------------------------
;
;	TRUE
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		lda #$ff
		tay
		jmp push

;--------------------------------------------------------------
;
;	FALSE
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		lda #0
		tay
		jmp push

;--------------------------------------------------------------
;
;	0=
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		lda tos
		ora tos+1
		beq l031
		lda #$ff
l031		tay
		jmp put

;--------------------------------------------------------------
;
;	0<
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		ldy #0
		bit tos+1
		bpl l032
		dey
l032		tya
		jmp put

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		beq l033
		lda #$ff
l033		tay
		jmp put

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
plusorigin	jsr enter
		.word plit
		.word userarea
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (sp0-*-1)|bit7
		.asc "SP","0"|bit7
sp0		jsr uservar
		.byt usersp0-userarea

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rp0-*-1)|bit7
		.asc "RP","0"|bit7
rp0		jsr uservar
		.byt userrp0-userarea

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr uservar
		.byt userwidth-userarea

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr uservar
		.byt userwarning-userarea

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr uservar
		.byt userfence-userarea

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jsr uservar
		.byt userdp-userarea

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr uservar
		.byt uservoclink-userarea

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr uservar
		.byt 20

;--------------------------------------------------------------
;
;	BLK
;
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr uservar
		.byt 22

;--------------------------------------------------------------
;
;	>IN   ( -- addr )
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The  address of a user variable which contains the present
; character offset within  the  input stream.  See: WORD
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr uservar
		.byt 24

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr uservar
		.byt 26

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr uservar
		.byt 28

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr uservar
		.byt 30

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr uservar
		.byt 32

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr uservar
		.byt 34

;--------------------------------------------------------------
;
;	STATE
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr uservar
		.byt 36

;--------------------------------------------------------------
;
;	BASE
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr uservar
		.byt 38

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr uservar
		.byt 40

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; Returns  the  address of the user variable that
; contains the count of characters  received  and
; stored by the most recent execution of EXPECT .
; The  address    of the user variable containing
; the count of characters actually  received  and
; stored by the last execution of EXPECT .
span		jmp uservar
		.byt 42

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr uservar
		.byt 44

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr uservar
		.byt 46

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr uservar
		.byt 48

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jsr uservar
		.byt 50

;--------------------------------------------------------------
;
;	#TIB
;
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr uservar
		.byt 52

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr uservar
		.byt 54

;--------------------------------------------------------------
;
;	1+
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		inc tos
		bne l027
		inc tos+1
l027		jmp next

;--------------------------------------------------------------
;
;	1-
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	bit tos
		bne l028
		dec tos+1
l028		dec tos
		jmp next

;--------------------------------------------------------------
;
;	2+
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		clc
		lda tos
		adc #2
		sta tos
		bcc l029
		inc tos+1
l029		jmp next

;--------------------------------------------------------------
;
;	2-
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	sec
		lda tos
		sbc #2
		sta tos
		bcs l030
		dec tos+1
l030		jmp next

;--------------------------------------------------------------
;
;	2/
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	lsr tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		asl tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	HERE
;
herelfa		.word $adde
		.byt (here-*-1)|bit7
		.asc "HER","E"|bit7
here            jsr enter
		.word dp
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	ALLOT
;
allotlfa	.word $adde
		.byt (allot-*-1)|bit7
		.asc "ALLO","T"|bit7
allot		jsr enter
		.word dp
		.word plusstore
		.word exit

;--------------------------------------------------------------
;
;	,
;
commalfa	.word $adde
		.byt (comma-*-1)|bit7
		.asc ","|bit7
comma		jsr enter
		.word here
		.word store
		.word two
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (ccomma-*-1)|bit7
		.asc "C",","|bit7
ccomma		jsr enter
		.word here
		.word cstore
		.word one
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	-
;
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr donegate
		jmp plus

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		dey
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	u<
;
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
sgntst		bvc l012
		eor #bit7
l012		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc "<"|bit7
gt		dey
		sec
		lda tos
		sbc stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		ldy stackh+1,x
		lda stackh,x
		sta stackh+1,x
		lda tos+1
		sta stackh,x
		sty tos+1
		ldy stackl+1,x
		lda stackl,x
		sta stackl+1,x
		lda tos
		sta stackl,x
		sty tos
		jmp next

;--------------------------------------------------------------
;
;	SPACE
;
spacelfa	.word $adde
		.byt (space-*-1)|bit7
		.asc "SPAC","E"|bit7
space		jsr enter
		.word bl
		.word emit
		.word exit

;--------------------------------------------------------------
;
;	?DUP   ( 0 -- 0 | n -- n n )
;
; DUP if top of stack is nonzero
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		lda tos
		ora tos+1
		beq l034
		lda tos
		ldy tos+1
		jmp push
l034		jmp next

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"     SWAP
;"     BEGIN
;"         OVER +  127  OVER C@  <
;"     UNTIL
;"     SWAP DROP ;
traverselfa	.word $adde
		.byt (traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
traverse	jsr enter
		.word swap
l010		.word over
		.word plus
		.word clit
		.byt $7f
		.word over
		.word cfetch
		.word lt
		.word qbranch
		.word l010
		.word swap
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of  the  top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (latest-*-1)|bit7
		.asc "LATES","T"|bit7
latest		jsr enter
		.word current
		.word fetch
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	FORTH-83
;
forth83lfa	.word $adde
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jmp next

;--------------------------------------------------------------
;
;	>BODY
;
tobodylfa	.word $adde
		.byt (tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
tobody		jsr enter
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt 5|bit7
		.asc ">NAM","E"|bit7
toname		jsr enter
		.word oneminus
		.word true
		.word traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt 5|bit7
		.asc ">LIN","K"|bit7
tolink		jsr enter
		.word toname
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>
;
bodyfromlfa	.word $adde
		.byt (bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
bodyfrom	jsr enter
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	NAME>
;
namefromlfa	.word $adde
		.byt (namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
namefrom	jsr enter
		.word one
		.word traverse
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	LINK>
;
linkfromlfa	.word $adde
		.byt (linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
linkfrom	jsr enter
		.word twoplus
		.word namefrom
		.word exit

;--------------------------------------------------------------
;
;	N>LINK
;
ntolinklfa	.word $adde
		.byt (ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
ntolink		jsr enter
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	L>NAME
;
linktonamelfa	.word $adde
		.byt (linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
linktoname	jsr enter
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
storecsp	jsr enter
		.word spfetch
		.word csp
		.word store
		.word exit

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (where-*-1)|bit7
		.asc "WHER","E"|bit7
where		jsr enter
		.word blk
		.word fetch
		.word qbranch
		.word l58
		.word blk
		.word fetch
		.word dup
		.word scr
		.word store
		.word cr
		.word cr
		.word pdotq
		.byt s001-*-1
		.asc "SCR# "
s001		.word dup
		.word dot
		.word toin
		.word fetch
		.word bperbuf
		.word min
		.word cperl
		.word slashmod
		.word dup
		.word pdotq
		.byt s002-*-1
		.asc "LINE# "
s002		.word dot
		.word cperl
		.word star
		.word rot
		.word block
		.word plus
		.word cr
		.word cr
		.word cperl
		.word dashtrailing
		.word type
		.word toin
		.word fetch
		.word bperbuf
		.word gt
		.word plus
		.word branch
		.word l59
l58		.word toin
		.word fetch
l59		.word cr
		.word here
		.word cfetch
		.word dup
		.word tor
		.word minus
		.word oneminus
		.word spaces
		.word rfrom
		.word dup
		.word zeq
		.word minus
		.word zero
		.word pdo
l60		.word clit
		.byt $5e	; "^"
		.word emit
		.word ploop
		.word l60
		.word exit

;--------------------------------------------------------------
;
;	(ABORT")
;
pabortqlfa	.word $adde
		.byt (pabortq-*-1)|bit7
		.asc "(ABORT",'"',")"|bit7
pabortq		jsr enter
		.word qbranch
		.word l61
		.word cmdoff
		.word where
		.word cr
		.word rfetch
		.word count
		.word type
		.word startup
		.word fetch
		.word execute
		.word branch
		.word l62
l61		.word rfrom
		.word dup
		.word cfetch
		.word plus
		.word oneplus
		.word tor
l62		.word exit

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (commadollar-*-1)|bit7
		.asc ",","$"|bit7
commadollar	jsr enter
		.word swap
		.word over
		.word here
		.word twodup
		.word cstore
		.word oneplus
		.word swap
		.word cmove
		.word oneplus
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	ABORT"
;
abortqlfa	.word $adde
		.byt (abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
abortq		jsr enter
		.word compile
		.word pabortq
		.word clit
		.asc '"'
		.word qchar
		.word commadollar
		.word exit

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
qcomp		jsr enter
		.word state
		.word fetch
		.word zeq
		.word pabortq
		.byt s003-*-1
		.asc "COMPILATION ONLY, USE IN DEFINITION"
s003		.word exit

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
qfind		jsr enter
		.word pabortq
		.byt s004-*-1
		.asc "NOT IN CURRENT SEARCH ORDER"
s004		.word exit

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
qpairs		jsr enter
		.word minus
		.word pabortq
		.byt s005-*-1
		.asc "CONDITIONALS NOT PAIRED"
s005		.word exit

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
qcsp		jsr enter
		.word spfetch
		.word csp
		.word fetch
		.word ne
		.word pabortq
		.byt s006-*-1
		.asc "DEFINITION NOT FINISHED"
s006		.word exit

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
qchar		jsr enter

;--------------------------------------------------------------
;
;	COMPILE
;
compilelfa	.word $adde
		.byt (compile-*-1)|bit7
		.asc "COMPIL","E"|bit7
compile		jsr enter
		.word qcomp
		.word rfrom
		.word dup
		.word twoplus
		.word tor
		.word fetch
		.word comma
		.word exit

;--------------------------------------------------------------
;
;	[
;
lbracketlfa	.word $adde
		.byt (lbracket-*-1)|bit7
		.asc "["|bit7
lbracket	jsr enter
		.word state
		.word off
		.word exit

;--------------------------------------------------------------
;
;	]
;
rbracketlfa	.word $adde
		.byt (rbracket-*-1)|bit7
		.asc "]"|bit7
rbracket	jsr enter
		.word state
		.word on
l68		.word qstack
		.word existsq
		.word dup
		.word qbranch
		.word l64
		.word zlt
		.word qbranch
		.word l65
		.word comma
		.word branch
		.word l66
l65		.word execute
		.word branch
		.word l66
l64		.word drop
		.word number
		.word dpl
		.word fetch
		.word oneplus
		.word qbranch
		.word l67
		.word dliteral
		.word branch
		.word l66
l67		.word drop
		.word literal
l66		.word true
		.word quitq
		.word qbranch
		.word l68
		.word exit

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
smudge		jsr enter
		.word latest
		.word clit
		.byt bit5	; $20
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (hex-*-1)|bit7
		.asc "HE","X"|bit7
hex		jsr enter
		.word clit
		.byt 16
		.word base
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DECIMAL
;
decimallfa	.word $adde
		.byt (decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
decimal		jsr enter
		.word clit
		.byt 10
		.word base
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(;CODE)
;
psemilfa	.word $adde
		.byt (psemi-*-1)|bit7
		.asc "(;CODE",")"|bit7
psemi		jsr enter
		.word rfrom
		.word latest
		.word namefrom
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DOES>
;
doeslfa		.word $adde
		.byt (does-*-1)|bit7
		.asc "DOES",">"|bit7
does		jsr enter
		.word qcsp
		.word compile
		.word psemi
		.word clit
		.byt $20	; jsr instruction
		.word ccomma
		.word compile
		.word dodoes
		.word exit
dodoes		lda ip+1	; we get here by JSR
		pha
		lda ip
		pha
		clc
		lda (w),y
		adc #3
		sta ip
		iny
		lda (w),y
		adc #0
		sta ip+1
		clc
		lda w
		adc #2
		pha
		lda w+1
		adc #0
		jmp push

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; Leaves  the address,  addr2 and the character
; count +n of text  beginning at addr1.
; addr2 is addr1+1 and n1 is the  length  of  the
; counted string at addr1.  The byte at addr1 con-
; tains  the  byte  count  +n.    Range  of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		ldy #0
		lda (tos),y
		inc tos
		bne l020
		inc tos+1
l020		jmp push

;--------------------------------------------------------------
;
;	TYPE
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		clc
		lda tos
		adc outputted
		sta outputted
		lda tos+1
		adc outputted+1
		sta outputted+1
		lda #2
		jsr popnwords
l71		cpy n+2
		bne l70
		dec n+3
		bpl l70
		jmp next
l70		lda (n),y
		jsr CHROUT
		iny
		bne l71
		inc n+1
		bne l71

;--------------------------------------------------------------
;
;	-TRAILING
;
dashtrailinglfa	.word $adde
		.byt (dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
dashtrailing	jsr enter
		.word dup
		.word zero
		.word pdo
l72		.word twodup
		.word plus
		.word oneminus
		.word cfetch
		.word bl
		.word ne
		.word pqleave
		.word l73
		.word oneminus
		.word ploop
		.word l72
l73		.word exit

;--------------------------------------------------------------
;
;	(.")
;
pdotqlfa	.word $adde
		.byt (pdotq-*-1)|bit7
		.asc "(.",'"',")"|bit7
pdotq		jsr enter
		.word rfetch
		.word twoplus		; because we pre-increment?
		.word count
		.word dup
		.word oneplus
		.word rfrom
		.word plus
		.word tor
		.word type
		.word exit

;--------------------------------------------------------------
;
;	."
;
dotqlfa		.word $adde
		.byt (dotq-*-1)|bit7
		.asc ".",'"'|bit7
dotq		jsr enter
		.word compile
		.word pdotq
		.word clit
		.asc '"'
		.word qchar
		.word commadollar
		.word exit

;--------------------------------------------------------------
;
;	.(
;
dotplfa		.word $adde
		.byt (dotp-*-1)|bit7
		.asc ".","("|bit7
dotp		jsr enter
		.word clit
		.asc ')'
		.word qchar
		.word type 
		.word exit

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; Stores up to +n characters into  memory  begin-
; ning at addr.
; Receive  characters and store each into memory.
; The transfer begins at addr proceeding  towards
; higher  addresses  one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.   No  more  than  +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or  transfered  if +n is zero.   All characters
; actually received and stored into  memory  will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp expectvector
expectvector	lda #2
		jsr popnwords
		stx n+4
		ldy #$ff
l74		iny
		cpy n
		bcs l75
		jsr CHRIN
		cmp #$0d
		beq l75
		sta (n+2),y
		bne l74
l75		sty inputted		; ~ probably should do a USER dereference
		lda #0
		sta inputted+1
		ldx n+4
		jmp next

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (query-*-1)|bit7
		.asc "QUER","Y"|bit7
query		jsr enter
		.word tib
		.word clit
		.byt 80
		.word expect
		.word span
		.word fetch
		.word numtib
		.word store
		.word blk
		.word off
		.word toin
		.word off
		.word exit

;--------------------------------------------------------------
;
;	" "
;
spacenplfa	.word $adde
		.byt (spacenp-*-1)|bit7|bit6
		.asc " "|bit7
spacenp		.word enter
		.word doneq
		.word on
		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
quitq		jsr enter
		.word state
		.word fetch
		.word ne
		.word doneq
		.word fetch
		.word orx
		.word doneq
		.word off
		.word exit

;--------------------------------------------------------------
;
;	ERASE
;
eraselfa	.word $adde
		.byt (erase-*-1)|bit7
		.asc "ERAS","E"|bit7
erase		jsr enter
		.word zero
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (blank-*-1)|bit7
		.asc "BLAN","K"|bit7
blank		jsr enter
		.word bl
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	HOLD
;
holdlfa		.word $adde
		.byt (hold-*-1)|bit7
		.asc "HOL","D"|bit7
hold		jsr enter
		.word true
		.word hld
		.word plusstore
		.word hld
		.word fetch
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	PAD
;
padlfa		.word $adde
		.byt (pad-*-1)|bit7
		.asc "PA","D"|bit7
pad		jsr enter
		.word here
		.word clit
		.byt 80
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	'STREAM
;
tickstreamlfa	.word $adde
		.byt (tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
tickstream	jsr enter
		.word blk
		.word fetch
		.word qdup
		.word qbranch
		.word l76
		.word block
		.word bperbuf
		.word branch
		.word l77
l76		.word tib
		.word numtib
		.word fetch
l77		.word toin
		.word fetch
		.word over
		.word min
		.word tor
		.word swap
		.word rfetch
		.word plus
		.word swap
		.word rfrom
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	WORD
;
wordlfa		.word $adde
		.byt (word-*-1)|bit7
		.asc "WOR","D"|bit7
word		jsr enter
		.word tor
		.word tickstream
		.word over
		.word swap
		.word rfetch
		.word skip
		.word over
		.word swap
		.word rfrom
		.word scan
		.word drop
		.word over
		.word over
		.word swap
		.word minus
		.word tor
		.word rot
		.word minus
		.word oneplus
		.word toin
		.word plusstore
		.word rfrom
		.word here
		.word over
		.word over
		.word cstore
		.word oneplus
		.word swap
		.word cmove
		.word here
		.word dup
		.word count
		.word plus
		.word bl
		.word swap
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	>LOWER
;
; ~ a Blazin' thing that doesn't really fit in with case-sensitive PETTIL
tolowerlfa	.word $adde
		.byt (tolower-*-1)|bit7
		.asc ">LOWE","R"|bit7
tolower		lda #2
		jsr popnwords
l79		cpy n
		bne l78
		dec n+1
		bpl l78
		jmp next
l78		lda (n+2),y
		and #$7f
		sta (n+2),y
		iny
		bne l79
		inc n+3
		jmp l79
		jsr enter

;--------------------------------------------------------------
;
;	(PUNCT?)
;
ppunctqlfa	.word $adde
		.byt (ppunctq-*-1)|bit7
		.asc "(PUNCT?",")"|bit7
ppunctq		jsr enter
		.word clit
		.byt '.'
		.word eq
		.word exit

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
punctq		jsr enter
		.word ppunctq
		.word exit


;--------------------------------------------------------------
;
;	CONVERT
;
convertlfa	.word $adde
		.byt (convert-*-1)|bit7
		.asc "CONVER","T"|bit7
convert		jsr enter
l81		.word oneplus
		.word dup
		.word tor
		.word cfetch
		.word base
		.word fetch
		.word digit
		.word qbranch
		.word l80
		.word swap
		.word base
		.word fetch
		.word umstar
		.word drop
		.word rot
		.word base
		.word fetch
		.word umstar
		.word dplus
		.word dpl
		.word fetch
		.word oneplus
		.word qbranch
		.word l82
		.word one
		.word dpl
		.word plusstore
l82		.word rfrom
		.word branch
		.word l81
l80		.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	NUMBER
;
numberlfa	.word $adde
		.byt (number-*-1)|bit7
		.asc "NUMBE","R"|bit7
number		jsr enter
		.word true
		.word over
		.word count
		.word over
		.word plus
		.word swap
		.word pqdo
		.word l83
l84		.word i
		.word cfetch
		.word base
		.word fetch
		.word digit
		.word qbranch
		.word l87
		.word twodrop
		.word false
		.word pleave
		.word l83
l87		.word ploop
		.word l84
l83		.word qfind
		.word zero
		.word zero
		.word rot
		.word dup
		.word oneplus
		.word cfetch
		.word clit
		.byt '-'
		.word eq
		.word dup
		.word tor
		.word minus
		.word dpl
		.word on
l85		.word convert
		.word dup
		.word cfetch
		.word punctq
		.word qbranch
		.word l88
		.word dpl
		.word off
		.word branch
		.word l85
l88		.word cfetch
		.word bl
		.word ne
		.word qfind
		.word rfrom
		.word qbranch
		.word l86
		.word dnegate
l86		.word exit

;--------------------------------------------------------------
;
;	FIND
;
findlfa		.word $adde
		.byt (find-*-1)|bit7
		.asc "FIN","D"|bit7
find		jsr enter
		.word context
		.word fetch
		.word fetch
		.word pfind
		.word dup
		.word zeq
		.word qbranch
		.word l89
		.word drop
		.word latest
		.word pfind
l89		.word exit

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
existsq		jsr enter
		.word bl
		.word word
		.word dup
		.word count
		.word tolower		; ~ really?
		.word find
		.word exit

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (iddot-*-1)|bit7
		.asc "ID","."|bit7
iddot		jsr enter
		.word pad
		.word clit
		.asc ' '
		.word clit
		.asc '*'
		.word fill
		.word dup
		.word namefrom
		.word over
		.word minus
		.word pad
		.word swap
		.word cmove
		.word pad
		.word count
		.word clit
		.byt $1f
		.word andx
		.word twodup
		.word tolower		; ~ really?
		.word type
		.word exit

;--------------------------------------------------------------
;
;	CREATE
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"  @ + + u< (abort") dictionary full exists?
;"  over (lit) 6017 = (abort") name required
;"  warning @ and ?branch 41 >name cr
;"  clit 18 emit id. clit 146 emit (.") already exists
;"  branch 4 drop here dup c@
;"  over 2+ view? @ + dup >r swap 1+ cmove>
;"  r> dup c@ width @ min 1+ 2dup + clit 255
;"  and clit 255 = ?branch 25 2dup swap
;"  dup 1+ rot cmove> clit 234 c, swap 1+
;"  swap 2+ view? @ + allot dup clit 128 toggle
;"  here 1- clit 128 toggle latest over
;"  2- ! view? @ ?branch 14 blk @ over 2-
;"  2- ! 2 allot current @ ! (;code)
;".C:1b0b   18         CLC
;".C:1b0c   A5 87      LDA $87
;".C:1b0e   69 02      ADC #$02
;".C:1b10   48         PHA
;".C:1b11   98         TYA
;".C:1b12   65 88      ADC $88
;".C:1b14   4C 4A 08   JMP $084A
createlfa	.word $adde
		.byt (create-*-1)|bit7
		.asc "CREAT","E"|bit7
create		jsr enter
		.word frombcq
		.word here
		.word width
		.word fetch
		.word twoplus
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word plus
		.word ult
		.word pabortq
		.byt l013-*-1
		.asc "DICTIONARY FULL"
l013		.word existsq
		.word over
		.word plit
		.word spacenp
		.word eq
		.word pabortq
		.byt l014-*-1
		.asc "NAME REQUIRED"
l014		.word warning
		.word fetch
		.word andx
		.word qbranch
		.word l016
		.word toname
		.word cr
		.word clit
		.byt $12	; rvs
		.word emit
		.word iddot
		.word clit
		.byt $92	; off
		.word emit
		.word pdotq
		.byt l015-*-1
		.asc " ALREADY EXISTS "
l015		.word branch
		.word l017
l016		.word drop
l017		.word here
		.word dup
		.word cfetch
		.word over
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word dup
		.word tor
		.word swap
		.word oneplus
		.word cmovegt
		.word rfrom
		.word dup
		.word cfetch
		.word width
		.word fetch
		.word min
		.word oneplus
		.word twodup
		.word plus
		.word clit
		.byt $ff
		.word andx
		.word clit
		.byt $ff
		.word eq
		.word qbranch
		.word l018
		.word twodup
		.word swap
		.word dup
		.word oneplus
		.word rot
		.word cmovegt
		.word clit
		.byt $ea
		.word ccomma
		.word swap
		.word oneplus
		.word swap
l018		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word allot
		.word dup
		.word clit
		.byt $80
		.word toggle
		.word here
		.word oneminus
		.word clit
		.byt $80
		.word toggle
		.word latest
		.word over
		.word twominus
		.word store
		.word viewq
		.word fetch
		.word qbranch
		.word l019
		.word blk
		.word fetch
		.word over
		.word twominus
		.word twominus
		.word store
l019		.word two
		.word allot
		.word current
		.word fetch
		.word store
		.word psemi
docreate	pla
		tay
		pla
		sta n+1
		iny
		bne l035
		inc n+1
l035		sty n
		jmp pushn

;--------------------------------------------------------------
;
;	[COMPILE]
;
bcompilelfa	.word $adde
		.byt (bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
bcompile	jsr enter

;--------------------------------------------------------------
;
;	LITERAL
;
literallfa	.word $adde
		.byt (literal-*-1)|bit7
		.asc "LITERA","L"|bit7
literal		jsr enter

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
dliteral	jsr enter

;--------------------------------------------------------------
;
;	?STACK
;
qstacklfa	.word $adde
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		jsr enter

;--------------------------------------------------------------
;
;	INTERPRET
;
interpretlfa	.word $adde
		.byt (interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
interpret	jsr enter

;--------------------------------------------------------------
;
;	IMMEDIATE
;
immediatelfa	.word $adde
		.byt (immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
immediate	jsr enter

;--------------------------------------------------------------
;
;	VOCABULARY
;
vocabularylfa	.word $adde
		.byt (vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
vocabulary	jsr enter
		.word create
		.word current
		.word fetch
		.word twoplus
		.word comma
		.word plit
		.word $a081		; ~ what is it?
		.word comma
		.word here
		.word voclink
		.word fetch
		.word comma
		.word voclink
		.word store
		.word psemi
vocabdoes	jmp dodoes
		.word context
		.word store
		.word exit

;--------------------------------------------------------------
;
;	FORTH
;
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jmp vocabdoes
		.word ntop		; top nfa in this vocabulary
		.word 0			; last link in this vocabulary
		.word $a081		; some magic number?

;--------------------------------------------------------------
;
;	DEFINITIONS
;
definitionslfa	.word $adde
		.byt (definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
definitions	jsr enter
		.word context
		.word fetch
		.word current
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(
;
lparenlfa	.word $adde
		.byt (lparen-*-1)|bit7
		.asc "("|bit7
lparen		jsr enter
		.word clit
		.asc ')'
		.word qchar
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (run-*-1)|bit7
		.asc "RU","N"|bit7
run		jsr enter

;--------------------------------------------------------------
;
;	ABORT
;
abortlfa	.word $adde
		.byt (abort-*-1)|bit7
		.asc "ABOR","T"|bit7
abort		jsr enter
		.word spstore
		.word quit
		.word exit	; make the decompiler happy

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jmp docreate
		.word abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		sei

		lda #<warmvector
		sta errlnk
		lda #>warmvector
		sta errlnk+1

		lda userntop
		sta forth+3
		lda userntop+1
		sta forth+4
;
		ldy #zzpnext-azpnext+1
l011		lda azpnext-1,y
		sta next-1,y
		dey
		bne l011

		lda #>cold2
		sta w1+1
		lda #<cold2
		sta w1

		ldy #usercold-userarea-1
		bne l036

warm		lda #>warm2
		sta w1+1
		lda #<warm2
		sta w1

		ldy #userwarm-userarea-1

l036		lda userup
		sta up
		lda userup+1
		sta up+1
l037		lda userarea,y
		sta (up),y
		dey
		bpl l037
		cld
		cli
		jsr CLRCHN
		jsr CLALL

		lda #>(w1-2)
		sta ip+1
		lda #<(w1-2)
		sta ip

xpetp		jmp rpstore		; and we're off

cold2		jsr enter
;		.word bar
		.word spstore
		.word pdotq
		.byt s015-*-1
		.byt CLRSCR
.byt 236,239,17,157,157,234,32,41,17,157,157,157,234,247,17,157,157,252
.byt 32,32,145,145,145
.byt 236,239,251,17,157,157,157,234,17,157,234,247,17,157,157
.byt 252,247,254,145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 239,239,17,157,157,234,17,157,234,17,157
.byt 247,247,145,145,145
.byt 236,17,157,234,17,157,234,17,157,252,247,247,254
.byt 145,145,145
		.asc "6502 FORTH FOR THE"
.byt 17,17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "COMMODORE PET 2001"
.byt 17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "......... ... ...."

		.byt $0d,$0d
		.asc "HTTP:"
		.byt 47,47
		.asc "CHITSELB.COM"
		.byt $0d,$0d
s015		.word bar
		.word rethread

warm2		.word emptybuffers
		.word decimal
		.word forth
		.word definitions
		.word pdotq
		.byt s016-*-1
		.asc "WELCOME TO FORTH!"
s016		.word startup
		.word fetch
		.word execute
		.word exit



; test stuff
bar		ldy #0
		sty n
chill		dec n
		bne chill
		dey
		bne chill
		brk
		jmp next

foo		jsr enter
		.word plit
		.word 500	; ( 500 )
		.word dup	; ( 500 500 )
		.word clit	; ( 500 500 42 )
		.byt 42
		.word plus	; ( 500 542 )
		.word over	; ( 500 542 500 )
		.word plus	; ( 500 1042 )
		.word exit

;--------------------------------------------------------------
;
;	QUIT
;
; PETTIL's outer interpreter infinite loop
;
quitlfa		.word $adde
		.byt (quit-*-1)|bit7
		.asc "QUI","T"|bit7
quit		.word enter
		.word zero
		.word blk
		.word store
		.word lbracket
l007		.word rpstore
		.word cr
		.word query
		.word interpret
		.word state
		.word fetch
		.word zeq
		.word qbranch
		.word l006
		.word pdotq
		.byt (l006-*-1)
		.asc "OK"
l006		.word branch
		.word l007

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (stod-*-1)|bit7
		.asc "S>","D"|bit7
stod		jsr enter

;--------------------------------------------------------------
;
;	ABS
;
abslfa		.word $adde
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs		jsr enter

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs		jsr enter

;--------------------------------------------------------------
;
;	MIN
;
minlfa		.word $adde
		.byt (min-*-1)|bit7
		.asc "MI","N"|bit7
min		jsr enter

;--------------------------------------------------------------
;
;	MAX
;
maxlfa	.word $adde
		.byt (max-*-1)|bit7
		.asc "MA","X"|bit7
max		jsr enter

;--------------------------------------------------------------
;
;	M*
;
mstarlfa	.word $adde
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jsr enter

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash		jsr enter

;--------------------------------------------------------------
;
;	*
;
starlfa		.word $adde
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jsr enter

;--------------------------------------------------------------
;
;	/MOD
;
slashmodlfa	.word $adde
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jsr enter

;--------------------------------------------------------------
;
;	/
;
slashlfa	.word $adde
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jsr enter

;--------------------------------------------------------------
;
;	MOD
;
modlfa		.word $adde
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jsr enter

;--------------------------------------------------------------
;
;	*/MOD
;
starslashmodlfa	.word $adde
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jsr enter

;--------------------------------------------------------------
;
;	*/
;
starslashlfa	.word $adde
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jsr enter

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jsr enter

;--------------------------------------------------------------
;
;	<BCQ
;
frombcqlfa	.word $adde
		.byt (frombcq-*-1)|bit7
		.asc "<BC","Q"|bit7
frombcq		jsr enter

;--------------------------------------------------------------
;
;	BCQ>
;
bcqfromlfa	.word $adde
		.byt (bcqfrom-*-1)|bit7
		.asc "BCQ",">"|bit7
bcqfrom		jsr enter

;--------------------------------------------------------------
;
;	>BCQ
;
tobcqlfa	.word $adde
		.byt (tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
tobcq		jsr enter

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
latestq		jsr enter

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
absentq		jsr enter

;--------------------------------------------------------------
;
;	UPDATE
;
updatelfa	.word $adde
		.byt (update-*-1)|bit7
		.asc "UPDAT","E"|bit7
update		jsr enter

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (drzero-*-1)|bit7
		.asc "DR","0"|bit7
drzero		jsr enter

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (drone-*-1)|bit7
		.asc "DR","1"|bit7
drone		jsr enter

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
discard		jsr enter

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
missing		jsr enter

;--------------------------------------------------------------
;
;	BUFFER
;
bufferlfa	.word $adde
		.byt (buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
buffer		jsr enter

;--------------------------------------------------------------
;
;	BLOCK
;
blocklfa	.word $adde
		.byt (block-*-1)|bit7
		.asc "BLOC","K"|bit7
block		jsr enter

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS
;
emptybufferslfa	.word $adde
		.byt (emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
emptybuffers	jsr enter

;--------------------------------------------------------------
;
;	SAVE-BUFFERS
;
savebufferslfa	.word $adde
		.byt (savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
savebuffers	jsr enter

;--------------------------------------------------------------
;
;	FLUSH
;
flushlfa	.word $adde
		.byt (flush-*-1)|bit7
		.asc "FLUS","H"|bit7
flush		jsr enter

;--------------------------------------------------------------
;
;	LOAD
;
loadlfa		.word $adde
		.byt (load-*-1)|bit7
		.asc "LOA","D"|bit7
load		jsr enter

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
todisc		jsr enter

;--------------------------------------------------------------
;
;	(R/W)
;
prslashwlfa	.word $adde
		.byt (prslashw-*-1)|bit7
		.asc "(R/W",")"|bit7
prslashw	jsr enter

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (rslashw-*-1)|bit7
		.asc "R/","W"|bit7
rslashw		jsr enter

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
tnslfa		.word $adde
		.byt (tns-*-1)|bit7
		.asc "T&","S"|bit7
tns		jsr enter

;--------------------------------------------------------------
;
;	(OPEN)
;
popenlfa	.word $adde
		.byt (popen-*-1)|bit7
		.asc "(OPEN",")"|bit7
popen		jsr enter

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (close-*-1)|bit7
		.asc "CLOS","E"|bit7
close		jsr enter

;--------------------------------------------------------------
;
;	(CMDIN)
;
pcmdinlfa	.word $adde
		.byt (pcmdin-*-1)|bit7
		.asc "(CMDIN",")"|bit7
pcmdin		jsr enter

;--------------------------------------------------------------
;
;	(CMDOUT)
;
pcmdoutlfa	.word $adde
		.byt (pcmdout-*-1)|bit7
		.asc "(CMDOUT",")"|bit7
pcmdout		jsr enter

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff		jsr enter

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (status-*-1)|bit7
		.asc "STATU","S"|bit7
status		jsr enter

;--------------------------------------------------------------
;
;	(?DISC)
;
pqdisclfa	.word $adde
		.byt (pqdisc-*-1)|bit7
		.asc "(?DISC",")"|bit7
pqdisc		jsr enter

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
ioerr		jsr enter
		.word qdup
		.word qbranch
		.word s028
		.word dup
		.word one
		.word eq
		.word pabortq
		.byt s020-*-1
		.asc "TOO MANY OPEN FILES"
s020		.word dup
		.word two
		.word eq
		.word pabortq
		.byt s021-*-1
		.asc "FILE ALREADY OPEN"
s021		.word dup
		.word three
		.word eq
		.word pabortq
		.byt s022-*-1
		.asc "FILE NOT OPEN"
s022		.word dup
		.word clit
		.byt 4
		.word eq
		.word pabortq
		.byt s023-*-1
		.asc "FILE NOT FOUND"
s023		.word dup
		.word clit
		.byt 5
		.word eq
		.word pabortq
		.byt s024-*-1
		.asc "DEVICE NOT PRESENT"
s024		.word dup
		.word clit
		.byt 6
		.word eq
		.word pabortq
		.byt s025-*-1
		.asc "NOT INPUT FILE"
s025		.word dup
		.word clit
		.byt 7
		.word eq
		.word pabortq
		.byt s026-*-1
		.asc "NOT OUTPUT FILE"
s026		.word dup
		.word clit
		.byt 8
		.word eq
		.word pabortq
		.byt s027-*-1
		.asc "MISSING FILE NAME"
s027		.word dup
		.word clit
		.byt 9
		.word eq
		.word pabortq
		.byt s028-*-1
		.asc "ILLEGAL DEVICE NUMBER"
s028		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
dotderr		jsr enter

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (mount-*-1)|bit7
		.asc "MOUN","T"|bit7
mount		jsr enter

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
qdisc		jsr enter

;--------------------------------------------------------------
;
;	'
;
ticklfa		.word $adde
		.byt (tick-*-1)|bit7
		.asc "'"|bit7
tick		jsr enter

;--------------------------------------------------------------
;
;	[']
;
brticklfa	.word $adde
		.byt (brtick-*-1)|bit7
		.asc "['","]"|bit7
brtick		jsr enter

;--------------------------------------------------------------
;
;	?>MARK
;
qtomarklfa	.word $adde
		.byt (qtomark-*-1)|bit7
		.asc "?>MAR","K"|bit7
qtomark		jsr enter

;--------------------------------------------------------------
;
;	?<MARK
;
qfrommarklfa	.word $adde
		.byt (qfrommark-*-1)|bit7
		.asc "?<MAR","K"|bit7
qfrommark	jsr enter

;--------------------------------------------------------------
;
;	?>RESOLVE
;
qtoresolvelfa	.word $adde
		.byt (qtoresolve-*-1)|bit7
		.asc "?>RESOLV","E"|bit7
qtoresolve	jsr enter

;--------------------------------------------------------------
;
;	?<RESOLVE
;
qfromresolvelfa	.word $adde
		.byt (qfromresolve-*-1)|bit7
		.asc "?<RESOLV","E"|bit7
qfromresolve	jsr enter

;--------------------------------------------------------------
;
;	ADD>MARK
;
addtomarklfa	.word $adde
		.byt (addtomark-*-1)|bit7
		.asc "ADD>MAR","K"|bit7
addtomark	jsr enter

;--------------------------------------------------------------
;
;	BEGIN
;
beginlfa	.word $adde
		.byt (begin-*-1)|bit7
		.asc "BEGI","N"|bit7
begin		jsr enter

;--------------------------------------------------------------
;
;	THEN
;
thenlfa		.word $adde
		.byt (then-*-1)|bit7
		.asc "THE","N"|bit7
then		jsr enter

;--------------------------------------------------------------
;
;	DO
;
dolfa		.word $adde
		.byt (do-*-1)|bit7
		.asc "D","O"|bit7
do		jsr enter

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (qdo-*-1)|bit7
		.asc "?D","O"|bit7
qdo		jsr enter

;--------------------------------------------------------------
;
;	LOOP
;
looplfa		.word $adde
		.byt (loop-*-1)|bit7
		.asc "LOO","P"|bit7
loop		jsr enter

;--------------------------------------------------------------
;
;	+LOOP
;
pluslooplfa	.word $adde
		.byt (plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
plusloop	jsr enter

;--------------------------------------------------------------
;
;	LEAVE
;
leavelfa	.word $adde
		.byt (leave-*-1)|bit7
		.asc "LEAV","E"|bit7
leave		jsr enter

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
qleave		jsr enter

;--------------------------------------------------------------
;
;	UNTIL
;
untillfa	.word $adde
		.byt (until-*-1)|bit7
		.asc "UNTI","L"|bit7
until		jsr enter

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (again-*-1)|bit7
		.asc "AGAI","N"|bit7
again		jsr enter

;--------------------------------------------------------------
;
;	REPEAT
;
repeatlfa	.word $adde
		.byt (repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
repeat		jsr enter

;--------------------------------------------------------------
;
;	IF
;
iflfa		.word $adde
		.byt (if-*-1)|bit7
		.asc "I","F"|bit7
if		jsr enter

;--------------------------------------------------------------
;
;	ELSE
;
elselfa		.word $adde
		.byt (else-*-1)|bit7
		.asc "ELS","E"|bit7
else		jsr enter

;--------------------------------------------------------------
;
;	WHILE
;
whilelfa	.word $adde
		.byt (while-*-1)|bit7
		.asc "WHIL","E"|bit7
while		jsr enter

;--------------------------------------------------------------
;
;	SPACES
;
spaceslfa	.word $adde
		.byt (spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
spaces		jsr enter

;--------------------------------------------------------------
;
;	<#
;
ltsharplfa	.word $adde
		.byt (ltsharp-*-1)|bit7
		.asc "<","#"|bit7
ltsharp		jsr enter

;--------------------------------------------------------------
;
;	#>
;
sharpgtlfa	.word $adde
		.byt (sharpgt-*-1)|bit7
		.asc "#",">"|bit7
sharpgt		jsr enter

;--------------------------------------------------------------
;
;	SIGN
;
signlfa		.word $adde
		.byt (sign-*-1)|bit7
		.asc "SIG","N"|bit7
sign		jsr enter

;--------------------------------------------------------------
;
;	#
;
sharplfa	.word $adde
		.byt (sharp-*-1)|bit7
		.asc "#"|bit7
sharp		jsr enter

;--------------------------------------------------------------
;
;	#S
;
sharpslfa	.word $adde
		.byt (sharps-*-1)|bit7
		.asc "#","S"|bit7
sharps		jsr enter

;--------------------------------------------------------------
;
;	(U.)
;
pudotlfa	.word $adde
		.byt (pudot-*-1)|bit7
		.asc "(U.",")"|bit7
pudot		jsr enter

;--------------------------------------------------------------
;
;	U.
;
udotlfa		.word $adde
		.byt (udot-*-1)|bit7
		.asc "U","."|bit7
udot		jsr enter

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (udotr-*-1)|bit7
		.asc "U.","R"|bit7
udotr		jsr enter

;--------------------------------------------------------------
;
;	(.)
;
pdotlfa		.word $adde
		.byt (pdot-*-1)|bit7
		.asc "(.",")"|bit7
pdot		jsr enter

;--------------------------------------------------------------
;
;	.
;
dotlfa		.word $adde
		.byt (dot-*-1)|bit7
		.asc "."|bit7
dot		jsr enter

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (dotr-*-1)|bit7
		.asc ".","R"|bit7
dotr		jsr enter

;--------------------------------------------------------------
;
;	(UD.)
;
puddotlfa	.word $adde
		.byt (puddot-*-1)|bit7
		.asc "(UD.",")"|bit7
puddot		jsr enter

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (uddot-*-1)|bit7
		.asc "UD","."|bit7
uddot		jsr enter

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
uddotr		jsr enter

;--------------------------------------------------------------
;
;	(D.)
;
pdddotlfa	.word $adde
		.byt (pddot-*-1)|bit7
		.asc "(D.",")"|bit7
pddot		jsr enter

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (ddot-*-1)|bit7
		.asc "D","."|bit7
ddot		jsr enter

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (ddotr-*-1)|bit7
		.asc "D.","R"|bit7
ddotr		jsr enter

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (question-*-1)|bit7
		.asc "?"|bit7
question	jsr enter

;--------------------------------------------------------------
;
;	PICK
;
picklfa		.word $adde
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick		jsr enter

;--------------------------------------------------------------
;
;	ROLL
;
rolllfa		.word $adde
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		jsr enter

;--------------------------------------------------------------
;
;	DEPTH
;
depthlfa	.word $adde
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth		jsr enter

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp poptwo

;--------------------------------------------------------------
;
;	2DUP
;
twoduplfa	.word $adde
		.byt (twodup-*-1)|bit7
		.asc "2DU","P"|bit7
twodup		jsr enter

;--------------------------------------------------------------
;
;	2OVER
;
twooverlfa	.word $adde
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		jsr enter

;--------------------------------------------------------------
;
;	2ROT
;
tworotlfa	.word $adde
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		jsr enter

;--------------------------------------------------------------
;
;	2SWAP
;
twoswaplfa	.word $adde
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		jsr enter

;--------------------------------------------------------------
;
;	2!
;
twostorelfa	.word $adde
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	jsr enter

;--------------------------------------------------------------
;
;	2@
;
twofetchlfa	.word $adde
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	jsr enter

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
twoconst	jsr enter

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
twovariable	jsr enter

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus		jsr enter

;--------------------------------------------------------------
;
;	D0=
;
dzeqlfa		.word $adde
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		jsr enter

;--------------------------------------------------------------
;
;	D=
;
deqlfa		.word $adde
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		jsr enter

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jsr enter

;--------------------------------------------------------------
;
;	D2/
;
dtwoslashlfa	.word $adde
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	jsr enter

;--------------------------------------------------------------
;
;	D2*
;
dtwostarlfa	.word $adde
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	jsr enter

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (dgt-*-1)|bit7
		.asc "D",">"|bit7
dgt		jsr enter

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (dmin-*-1)|bit7
		.asc "DMI","N"|bit7
dmin		jsr enter

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (dmax-*-1)|bit7
		.asc "DMA","X"|bit7
dmax		jsr enter

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
configure	jsr enter

;--------------------------------------------------------------
;
;	FREEZE
;
freezelfa	.word $adde
		.byt (freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
freeze		jsr enter

;--------------------------------------------------------------
;
;	(BSAVE)
;
pbsavelfa	.word $adde
		.byt (pbsave-*-1)|bit7
		.asc "(BSAVE",")"|bit7
pbsave		jsr enter

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
saveforth	jsr enter

;--------------------------------------------------------------
;
;	FORGET
;
forgetlfa	.word $adde
		.byt (forget-*-1)|bit7
		.asc "FORGE","T"|bit7
forget		jsr enter





forgetfence



;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde

lastword

		.byt (thru-*-1)|bit7
		.asc "THR","U"|bit7
thru		jsr enter

;==============================================================

; hash-threaded dictionary search
; These won't remain in the final core (LOAD "*") version
; but it will be useful during development to automatically generate
; all LFAs so I can rearrange the dictionary at will without tedious
; LFA editing.
;
; Three top-level words rewrite the entire LFA chain
; 1THREAD resets the LFA chain to a traditional single-threaded linked list
; HASHTHREAD breaks the LFA chain into 16 linked lists
; DEADTHREAD resets all LFAs but the end to appear as DE AD in hex dumps
;
; Changing the LFA threading is an all-or-nothing deal.  These tools
; aren't capable of automagically re-threading everything when the
; LFA chain(s) is/are corrupt.
;
; Vector (DEFER/IS) these words
; LATEST
;
;--------------------------------------------------------------
;
;	DHASH	( addr -- hash )
;
; input is a counted string at "addr"
;
; output "hash" is a value 0..15 that points to the latest LFA
; in this word's dictionary chain
dhashlfa	.word $adde
		.byt (dhash-*-1)|bit7
		.asc "DHAS","H"|bit7
dhash		dey
		lda (tos),y		; get the length
		and #$1f		; mask off flag bits
		tay
		lda #0
l009		eor (tos),y		; xor the string together, ignore length
		dey
		bne l009
		sty tos+1		; 0 -> msb
		sta tos			; temporarily store the result byte
		lsr
		lsr
		lsr
		lsr			; get the high nybble
		eor tos			; mix it with the low nybble
		and #$0f		; mask off the high nybble
		sta tos			; hash value in the range 0..f
		jmp next

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieves the LFA of the latest word in this hash thread
;
dhashfetchlfa	.word $adde
		.byt (dhashfetch-*-1)|bit7
		.asc "DHASH","@"|bit7
dhashfetch	ldy tos
		lda latestl,y
		sta tos
		lda latesth,y
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hashkey -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
dhashstorelfa	.word $adde
		.byt (dhashstore-*-1)|bit7
		.asc "DHASH","!"|bit7
dhashstore	lda #2
		jsr popnwords		; N0 = hashkey, N1 = LFAnew
		ldy n			; get hashkey
		lda latestl,y
		sta n+4
		lda latesth,y
		sta n+5			; LFAlatest -> N2
		lda n+2
		sta latestl,y
		lda n+3
		sta latesth,y		; LFAnew -> hashtable(key)
		ldy #0
		lda n+4
		sta (n+2),y
		iny
		lda n+5
		sta (n+2),y		; LFAlatest -> [LFAnew]
		jmp next

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; links all LFAs
rethreadlfa	.word $adde
ntop		.byt (rethread-*-1)|bit7
		.asc "RETHREA","D"|bit7
rethread	jsr enter
		.word here
		.word plit
		.word 1024
		.word pdo
		.word i
		.word cfetch
		.word clit
		.byt $ad
		.word eq
		.word i
		.word oneplus
		.word cfetch
		.word clit
		.byt $de
		.word eq
		.word andx
		.word i
		.word oneminus
		.word dup
		.word cfetch
		.word clit
		.byt $80
		.word gt
		.word andx
		.word qbranch
		.word l024
		.word i
		.word oneminus
		.word plit
		.word -1
		.word traverse
		.word dup
		.word cfetch
		.word clit
		.byt $3f
		.word andx
		.word over
		.word plus
		.word i
		.word oneminus
		.word eq
		.word qbranch
		.word l024
		.word dhash
		.word i
		.word swap
		.word dhashstore
l024            .word plit
		.word -1
		.word pploop
		.word exit

; TRUE - builds a hashed LFA structure
; FALSE - resets all LFAs to DE AD
;
; dead - 
; scanning forward sequentially, we find sequences of 
;	len | $80	(A)
;	byte 1
;	byte 2
;	byte 3
;	...
;	byte len | $80	(B)
;	$DE
;	$AD
; where points (A) and (B) are len bytes apart
; LATEST returns 0
;
; hashed - 
; the dhash array has any nonzero value in it
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
; single - 
; the dhash array is filled with all zeroes
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
;"	: THREADING?  ( -- flag )
;"		LATEST
;
;	tells us whether we're threaded (true) or unthreaded (false)
;


;--------------------------------------------------------------
;
;	DEADTHREAD   ( -- )
;
; assumption -- dictionary is configured in one of the three
;		available schemes
;
;": DEADTHREAD 
;"    THREADING? ?DUP 0=  ( dead )
;"    IF  ." YOU CAN'T KILL ME!  I'M ALREADY DEAD." CR  
;"    ELSE  0<
;"        IF  ." KILLING SINGLE THREADED LINKS" CR  1KILL  THEN
;"        ELSE  ." KILLING HASH THREADED LINKS" CR  HASHKILL  THEN
;"    THEN ;



		; pops up to 4 words from the split stack to the N area
		; A = how many words to pop (valid range 1-4)
		;
		; returns
		; TOS -> N0, 2OS -> N1, 3OS -> N2, 4OS -> N3
popnwords	asl
		tay
		lda tos
		sta n-2,y
		lda tos+1
		sta n-1,y
l004		dey
		dey
		beq l005
		lda stackl,x
		sta n-2,y
		lda stackh,x
		sta n-1,y
		inx
		bne l004		; bra
l005		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx
		rts
endofile

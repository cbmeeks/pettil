; pettil.a65
;
; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
;" http://pettil.tumblr.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

#define DEBUG
#define PET_ROM4                ; target machine
#undefine HEADERS                 ; put headers in code?
                                ; PET target memory size
#define PETRAM 32

#include modules/cbm.def
#include modules/pettil.def

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================
#define basic $0400
    .word basic+1               ; this will be the load address
* = basic+1
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp ice                     ; t

;==============================================================
;==== zeropage buffer and user area                        ====
;==============================================================
;
; this is an image of PETTIL zeropage at cold start.  Swapping it
; with the BASIC zeropage makes hopping back and forth possible
;
zpbuf
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.  
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,$2002,$3003
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack

;--------------------------------------------------------------
;
;       NEXT
;
; * inner interpreter headerless
;
;               +IP
;               [IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ; 
    nop                     ; see "RANDU" for how it works
    nop                     ; 
;$86    
zpnext
    inc ip                  ; 5
    inc ip                  ; 5
;ip = *+1
    jmp ($cafe)             ; 5

                            ;15 cycles total
;$8D TIME

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

#if (* = $04a5)
    nop
#else
#echo PETTIL Build Error - Program counter is not at $04a5!
#echo Sweet16 needs to start at $04a6.  This is a problem.
#print *
#endif

#include modules/sweet16.a65

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

; xor of two vectors, to switch between Sweet16 and TIM
brktoggle       .word TIMBRK^SW16

;==============================================================
; userarea initialization data
; this gets copied to the uarea
; and is pointed to by the UP (user pointer)
userarea

userup          .word uarea                             ; WARM
usersp0         .word bos+1             ; =2            ;
userrp0         .word $01fe                             ;
userfence       .word cold                              ; COLD
userdp          .word 0                                 ;
usermemsiz      .word VIDRAM                            ;
userstartup     .word 0
usercold

usersymtab      = usercold                              ; SOFT
uservmbuf       = usercold+2                            ;
uservmsiz       = usercold+4                            ;
userbase        = usercold+6                            ;
userdpl         = usercold+8                            ;
userhld         = usercold+10                           ;
userblk         = usercold+12                           ;
usertoin        = usercold+14                           ;
userspan        = usercold+16                           ;
usertib         = usercold+18                           ;
usernumout      = usercold+20                           ;
usernumline     = usercold+22                           ;
usererrmess     = usercold+24                           ;
userscr         = usercold+26                           ;
userstate       = usercold+28                           ;
usercsp         = usercold+30                           ;
usercontext     = usercold+32                           ;
usercurrent     = usercold+34                           ;
uservocabid     = usercold+36                           ;
usernumvocab    = usercold+38                           ;

uarea           .dsb usercold-userarea+48,0

;==============================================================
;==== PETTIL dictionary                                    ====
;==============================================================
#include modules/core-subroutines.a65
#include modules/core-user.a65
#include modules/core-inner.a65
#include modules/core-nucleus.a65
#include modules/core-device.a65
#include modules/core-numword.a65
#include modules/core-double.a65
#include modules/core-string.a65

;--------------------------------------------------------------
;
;        COLD   ( -- )
;
; One-time only (then disappear) system bootstrap initialization.
; Runs once after "pettil.obj" loads, to prepare a development
; environment.  The size of COLD doesn't really matter.  As
; the final word in the core dictionary, COLD will FORGET
; itself and its address becomes the value of FENCE.
; It's a little hairy, I hope my comments will explain.
;
; the pieces at load time
; * 0400-040c   BASIC bootstrap (10 SYS 1037)
; * 040d-0410   pettillaunch (JMP ICE)
; * 0410-049c   zpbuf (partial zero page image $00-$8C)
; * 049d-04a4   power2 (01 02 04 08 10 20 40 80)
; * 04a5        unused byte
; * 04a6-065a   Sweet16
; * 065b-       slip, slide, Sweet16 extensions
; * brktoggle,  the EOR of TIM and Sweet16 entry points
; * userarea,   User variable storage
; * swapzp,     and other native 6502 code subroutines
; * core,       permanent dictionary (bodies only)
;==============================================================
; * cold,       bootstrap initialization
;
; * there,      2-byte load address of temporary dictionary
; * there+2,    2-byte size of temporary dictionary
; * there+4,    temporary dictionary, bodies only
; * tdict       outer interpreter, compiler, editor, assembler
; * symbols,    symbol table data
;
; tasks
; * set MEMSIZ from BASIC $34-35
; * set SYMTAB as an offset from MEMSIZ
; * set up the IRQ break to $E455 for WARM
; * set up the BRK vector to Sweet16 for WARM
; * call WARM to put us in Forth mode
; * copy tdict region to high memory
; * FENCE is already set to ' COLD
; * STARTUP @ W1 !
; * push W1-2 to the return stack
; * put COLD CFA on the data stack
; * call FORGET in the middle, after the input stream & FIND
; * when FORGET exits, NEXT will perform ABORT via W1
;
; what WARM does
; * swap the zero page with BASIC to zpbuf
; * restore Forth's IRQ and BRK vectors
; * reset the data stack
; * reset the return stack
;
; what FORGET does
; * when FORGET is invoked by COLD, it uses the CFA on the data stack
;   instead of scanning ahead in the input stream
;       R@ test?
;       COLD calls FORGET somewhere in the middle?
; * check FENCE   ? ABORT" 
; * set DP
; * move the symbols to PAD
; * and MOVE the symbols one by one back to SYMTAB
;
; when FORGET exits, the return stack sends us to @W1
;
; * which drops out to ABORT
;
; Dropping out to BASIC can be accomplished by typing MON
; to get to TIM, then .X to get to BASIC.  It also happens
; if cassette i/o is interrupted by the STOP key or if a
; tape read error occurs during cassette i/o.  There may be
; other ways.  WARM should always be able to bring the system
; back to a usable state.
;
; COLD expects to find the tdict size, followed by the load
; address, then the code bodies for the PETTIL development 
; environment.  This follows immediately after ICE
; itself in RAM.  This block (there) is copied to upper 
; memory.  This binary object must know where it resides,
; as no relocation is done.  In other words, a 16K PET
; requires a different build of "there" than a 32K PET.
;
; Next COLD invokes REHASH to populate the symbol table at
; user variable SYMTAB.  Symbols never require relocation,
; but FIND expects to find them in a specific order, as
; dictated by REHASH.  
;
; COLD replaces the vector to itself at pettillaunch with
; a JMP WARM instruction.
;
; ICE loads STARTUP with the CFA of COLD
;
; COLD replaces the vector (pettillaunch) to ICE with a
; JMP WARM instruction.
;
; COLD does FENCE @ DP !
;
; temporary dictionary and symbols are built separately 
; and concatenated to the PETTIL.OBJ core binary
;
; the pieces at load time
; * 0400-040c   BASIC bootstrap (10 SYS 1037)
; * 040d-0410   pettillaunch (JMP ICE)
; * 0410-049c   zpbuf (partial zero page image $00-$8C)
; * 049d-04a4   power2 (01 02 04 08 10 20 40 80)
; * 04a5        unused byte
; * 04a6-065a   Sweet16
; * 065b-       slip, slide, Sweet16 extensions
; * brktoggle,  the EOR of TIM and Sweet16 entry points
; * userarea,   User variable storage
; * swapzp,     and other native 6502 code subroutines
; * core,       permanent dictionary (bodies only)
; * fence,      everything before this is unforgettable
;
#ifdef HEADERS
coldlfa
    .byt $de,$ad
    .byt (cold-*-1)|bit7
    .asc "COL","D"|bit7
#endif
cold
    lda MEMSIZ
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1
;--------------------------------------------------------------
;
;        ICE   ( -- )
;
; ICE is the one-time initialization.  It runs once and
; only once after "pettil.obj" loads, preparing a development
; environment.  Then it disappears once everything is where 
; it belongs.  Afterward, WARM reinitializes PETTIL if the
; user drops out to BASIC.
;
; Dropping out to BASIC can be accomplished by typing MON
; to get to TIM, then .X to get to BASIC.  It also happens
; if cassette i/o is interrupted by the STOP key or if a
; tape read error occurs during cassette i/o.  There may be
; other ways.  WARM should always be able to bring the system
; back to a usable state.
;
; COLD expects to find the tdict size, followed by the load
; address, then the code bodies for the PETTIL development 
; environment.  This follows immediately after ICE
; itself in RAM.  This block (there) is copied to upper 
; memory.  This binary object must know where it resides,
; as no relocation is done.  In other words, a 16K PET
; requires a different build of "there" than a 32K PET.
;
; Next COLD invokes REHASH to populate the symbol table at
; user variable SYMTAB.  Symbols never require relocation,
; but FIND expects to find them in a specific order, as
; dictated by REHASH.  
;
; COLD replaces the vector to itself at pettillaunch with
; a JMP WARM instruction.
;
; ICE loads STARTUP with the CFA of COLD
;
; COLD replaces the vector (pettillaunch) to ICE with a
; JMP WARM instruction.
;
; COLD does FENCE @ DP !
;
; temporary dictionary and symbols are built separately 
; and concatenated to the PETTIL.OBJ core binary
;
; the pieces at load time
; * 0400-040c   BASIC bootstrap (10 SYS 1037)
; * 040d-0410   pettillaunch (JMP ICE)
; * 0410-049c   zpbuf (partial zero page image $00-$8C)
; * 049d-04a4   power2 (01 02 04 08 10 20 40 80)
; * 04a5        unused byte
; * 04a6-065a   Sweet16
; * 065b-       slip, slide, Sweet16 extensions
; * brktoggle,  the EOR of TIM and Sweet16 entry points
; * userarea,   User variable storage
; * swapzp,     and other native 6502 code subroutines
; * core,       permanent dictionary (bodies only)
; * fence,      everything before this is unforgettable
;==============================================================
; * ice,        PETTIL bootstrap initialization routine
; * there,      2-byte load address of temporary dictionary
; * there+2,    2-byte size of temporary dictionary
; * there+4,    temporary dictionary, bodies only
; * symbols,    symbol table data
;
ice
    ; use the BASIC memory move, because we don't have Forth up yet
    ; it doesn't really matter how long the ice code is, because it
    ; goes away after it runs once.
    lda #<there+6               ; bottom of area to be moved
    sta $5c
    lda #>there+6
    sta $5d
    clc
    lda there+2
    adc there+4
    sta $55
    lda there+3
    adc there+5
    sta $56                     ; top of area to be moved to + 1
    clc
    lda $5c
    adc there+2
    sta $57
    lda $5d
    adc there+3
    sta $58
    jsr $b357

    clc 
    lda #<there+8
    adc there
    sta userdp
    lda #>there+8
    adc there+1
    sta userdp+1                ; pointer to symbols (usually PAD) is in DP
    sec                         ; the wrong place, but usable
    lda userdp
    sbc there+4
    sta userdp
    sta $55
    lda userdp+1
    sbc there+5
    sta userdp+1
    sta $56

findcold
    ldy findthis         ; the length
findcold01
    lda ($55),y
    eor findthis,y
    bne findcold02      ; different? outtie fail
    dey
    bpl findcold01
    bmi findcold03      ; success!
findcold02
    ldy #0
    lda ($55),y
    and #$1f
    tay
    iny
    iny
    tya
    sec
    adc $55
    sta $55
    bcc findcold
    inc $56
    bne findcold
findcold03
    sec
    lda $55
    sbc #2
    sta $55
    bcs findcold04
    dec $56
    clc
findcold04
    iny
    lda ($55),y
    sta w1,y
    bcs findcold05
    sec
    bcs findcold04
findcold05
    jmp (w1)

    ;sec
    lda there+2
    ;sbc #0
    sta usersymtab
    clc
    lda there+3
    sbc #$0c
    sta usersymtab+1            ; set SYMTAB

    ; scan through the symbols until we find COLD.  
    ; put its CFA in STARTUP
findthis
    .byt 4, "COLD"
    
there

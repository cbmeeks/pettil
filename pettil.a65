; PETTIL 
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate (nfa len)

; zero page usage
stackl	= $00		; stackl = $00..$3b (60 bytes)
stackh	= $3c		; stackh = $3c..$79 (60 bytes)
bos	= stackh-1	; $3b
n	= $7a
w	= $80		; w overlaps 8-byte n scratch area
tos	= $82
up	= $84

next	= $86
;0086 next	inc ip
next1	= $88
;0088 next1	inc ip
nexto	= $8a
ip	= $8b
;008a nexto	jmp ($cafe)

;$8d..$ff kernel zeropage area

basic	= $0400
		.word basic+1		; PET BASIC storage starts here
*	= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc "(1040)",0		; sys $0410
basend		.word 0

		.dsb basic+$10-*,$ea
		jmp cold
warmvec         jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userup          .word tape2buf				; 6..7
usersp0         .word bos				; 8..9
userrp0         .word $01ff				; 10..11
userwidth       .word 31				; 12..13
userwarning     .word -1				; 14..15
userfence       .word $2f25				; 16..17
uservoclink     .word $650b				; 18..19
userviewquery   .word $36a2				; 20..21
userblk         .word 2					; 22..23
usertoin        .word $1908				; 24..25
userbase        .word 10				; 26..27
usercontext     .word 0					; 28..29 ~
usercsp         .word 0					; 30..31

		;dictionary hash link table used by rechaining words
latestl         .dsb 16,0
latesth         .dsb 16,0

;--------------------------------------------------------------
;
;       NEXT
;
;           +IP
;           [IP]   -> PC

; this NEXT routine gets copied to $0086 by COLD.  See the 
; tiddlywiki for the rationale behind this minimalist design
;
bnextbegin
        inc ip
        inc ip
        jmp ($cafe)
bnextend

page2           inc ip+1
		jmp next

page3           inc ip
		bne page2

;--------------------------------------------------------------
;
;       ENTER
;
;           IP    -> -[RP]
;           W     -> IP
;           NEXT
; the JSR version
enter           pla             ;[4]
                tay             ;[2]
                pla             ;[4]
                sta n+1         ;[3]
                lda ip+1        ;[3]
                pha             ;[3]
                lda ip          ;[3]
                pha             ;[3]
                lda n+1         ;[3]
                sta ip+1        ;[3]
                iny             ;[2]
                beq l1          ;[2]
l2              sty ip+1        ;[3]
                jmp nexto       ;[3]
l1              inc ip+1
                bne l2

;--------------------------------------------------------------
;
;       EXIT
;
;           [RP+] -> IP
;           NEXT
exitlfa         .word 0		; 0 LFA marks base of dictionary
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
; NEXT
exit            pla
		sta ip
		pla
		sta ip+1        ; [RP+] -> IP
		jmp next        ; NEXT

;--------------------------------------------------------------
;
;       EXECUTE
;
; Executes the definition found at addr.
;
;"      : execute ( cfa ---   )
;"          jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa      .word $adde
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7	; length and final byte are OR $80
;execute		lda tos+1
;		ldy tos
;		beq l028
;l027		pha
;		dey
;		tya
;		pha
;		rts
;l028		sec
;		sbc #1
;		bne l027

execute         lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1	; [SP] -> [W1]
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx             ; SP+
		lda ip
		sta w1+4
		lda ip+1
		sta w1+5        ; IP -> [W1+4]
		lda #<w1
		sta ip
		lda #>w1
		sta ip+1        ; W1 -> IP
		jmp nexto

; These three words are used by EXECUTE as a 'fragment secondary'
; (for those occasions when you just need a W register)
w1				; dummy value $DEAD, we wind up at $BEEF
		.word $dead
		.word branch
		.word $beef

;--------------------------------------------------------------
;
;       (LIT)
;
; push the word of memory following (IP)
;
plitlfa         .word $adde
		.byt (plit-*-1)|bit7
		.asc "(LIT",")"|bit7
plit            ldy #3
		lda (ip),y
		sta n+1
		dey
		lda (ip),y
		sta (n)
		lda #$fb
		cmp ip
		bne l001
		inc ip
		clc
l001            bcs l002
		inc ip+1
l002            inc ip
		inc ip

pushn           ldy n+1			; pushn entry - pushes n
		lda n			; n -> YA

push            sta n			; push entry - pushes YA
		dex			; copy TOS to the real stack
		lda tos
		sta stackl,x
		lda tos+1
		sta stackh,x
		lda n

put             sty tos+1
		sta tos
		jmp next

;--------------------------------------------------------------
;
;       CLIT
;
; takes the byte of memory following and pushes it to the data stack
;
;"      : clit ( -- c )
;"         ip c@  1 ip +! ;
;
clitlfa         .word $adde
		.byt (clit-*-1)|bit7
		.asc "CLI","T"|bit7
clit            ldy #2
		lda (ip),y
		sta n
		lda #$fc
		cmp ip
		bne l003
		inc ip
		clc
l003            bcs l022
		inc ip+1
l022            inc ip
		ldy #0
		sty n+1
		beq pushn

;--------------------------------------------------------------
;
;       BRANCH
;
; Compiles an unconditional branch operation.
;" When used in the form:  COMPILE BRANCH
; an  unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated  by following BRANCH
; with <RESOLVE or >MARK .
;
;"      : branch ( -- )
;
branchlfa       .word $adde
		.byt (branch-*-1)|bit7
		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
; Y = 1
branch          ldy #2          ; [2]
		lda (ip),y      ; [5+]
		sta n           ; [3]
		iny             ; [2]
		lda (ip),y      ; [5+]
		sta ip+1        ; [3]
		lda n           ; [3]
		sta ip          ; [3] (IP+2) -> IP
		jmp nexto       ; [3]
				; [29/30 cycles] (runs in constant time)
;--------------------------------------------------------------
;
;       ?BRANCH   ( flag -- )
;
qbranchlfa      .word $adde
		.byt (qbranch-*-1)|bit7
		.asc "?BRANC","H"|bit7
qbranch         bit tos
		php
		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx             ; drop
		plp
		bne branch
		lda #4
nexta           clc
		adc ip
		sta ip
		bcc l023
		inc ip+1
l023            jmp nexto

;--------------------------------------------------------------
;
;       (LOOP)
;
plooplfa        .word $adde
		.byt (ploop-*-1)|bit7
		.asc "(LOOP",")"|bit7
ploop           jsr enter

;--------------------------------------------------------------
;
;       (+LOOP)
;
pplooplfa       .word $adde
		.byt (pploop-*-1)|bit7
		.asc "(+LOOP",")"|bit7
pploop          jsr enter

;--------------------------------------------------------------
;
;	(DO)
;
pdolfa		.word $adde
		.byt (pdo-*-1)|bit7
		.asc "(DO",")"|bit7
pdo		lda stackh,x
		pha
		lda stackl,x
		pha
		lda tos+1
		pha
		lda tos
		pha
poptwo		inx
pop		lda stackh,x
		ldy stackl,x
		inx
		jmp put

;--------------------------------------------------------------
;
;	(?DO)
;
pqdolfa		.word $adde
		.byt (pqdo-*-1)|bit7
		.asc "(?DO",")"|bit7
pqdo		jsr enter

;--------------------------------------------------------------
;
;	I
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		jsr enter

;--------------------------------------------------------------
;
;	J
;
jlfa		.word $adde
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		jsr enter

;--------------------------------------------------------------
;
;	(LEAVE)
;
pleavelfa	.word $adde
		.byt (pleave-*-1)|bit7
		.asc "(LEAVE",")"|bit7
pleave		jsr enter

;--------------------------------------------------------------
;
;	(?LEAVE)
;
pqleavelfa	.word $adde
		.byt (pqleave-*-1)|bit7
		.asc "(?LEAVE",")"|bit7
pqleave		jsr enter

;--------------------------------------------------------------
;
;	DIGIT
;
digitlfa	.word $adde
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit		jsr enter

;--------------------------------------------------------------
;
;	(FIND)
;
pfindlfa	.word $adde
		.byt (pfind-*-1)|bit7
		.asc "(FIND",")"|bit7
pfind		jsr enter

;--------------------------------------------------------------
;
;	SKIP
;
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		jsr enter

;--------------------------------------------------------------
;
;	SCAN
;
scanlfa		.word $adde
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		jsr enter

;--------------------------------------------------------------
;
;	EMIT
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jsr enter

;--------------------------------------------------------------
;
;	KEY
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jsr enter

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jsr enter

;--------------------------------------------------------------
;
;	CR
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jsr enter

;--------------------------------------------------------------
;
;	CMOVE
;
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		jsr enter

;--------------------------------------------------------------
;
;	CMOVE>
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		jsr enter

;--------------------------------------------------------------
;
;	FILL
;
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		jsr enter

;--------------------------------------------------------------
;
;	UM*
;
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		jsr enter

;--------------------------------------------------------------
;
;	UM/MOD
;
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	jsr enter

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx            lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx             lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor             lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		jsr enter

;--------------------------------------------------------------
;
;	SP!
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		jsr enter

;--------------------------------------------------------------
;
;	RP!
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		jsr enter

;--------------------------------------------------------------
;
;	>R
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		jsr enter

;--------------------------------------------------------------
;
;	R>
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		jsr enter

;--------------------------------------------------------------
;
;	R@
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		jsr enter

;--------------------------------------------------------------
;
;	0>
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		jsr enter

;--------------------------------------------------------------
;
;	<>
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		jsr enter


;--------------------------------------------------------------
;
;	ON
;
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		sta (tos),y
		dey
		sta (tos),y
		jmp next

;--------------------------------------------------------------
;
;	OFF
;
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+
;
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
; d+
;--------------------------------------------------------------
; d<

;--------------------------------------------------------------
;
;	NEGATE
;
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		sec
		dey
neg2		tya
		sbc tos
		sta tos
		tya
		sbc tos+1
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	DNEGATE
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		sec
		dey
		tya
		sbc stackl,x
		sta stackl,x
		tya
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER
;
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp push

;--------------------------------------------------------------
;
;	DROP
;
droplfa		.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pop

;--------------------------------------------------------------
;
;	SWAP
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp push

;--------------------------------------------------------------
;
;	+!
;
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE
;
togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		jmp pop

;--------------------------------------------------------------
;
;	@
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #1
		lda (tos),y
		sta n
		dey
		lda (tos),y
		sta tos
		lda n
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	C@
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		lda (tos),y
		sta tos
		dey
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!
;
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		lda stackh,x
		sta (tos),y
		lda stackl,x
		dey
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		dey
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;" :
;--------------------------------------------------------------
; ;

;--------------------------------------------------------------
;
;	CONSTANT   ( -- n )
;
constantlfa	.word $adde
		.byt (constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
constant	jsr enter
		.word create
		.word comma
		.word psemi
doconst		lda (ip),y
		sta n+3
		dey
		lda (ip),y
		sta n+2
		ldy #3
		lda (n+2),y
		sta n
		iny
		lda (n),y
		sta n+1
		jmp pushn

;--------------------------------------------------------------
; variable
variablelfa	.word $adde
		.byt (variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
variable	jsr enter
		.word create
		.word two
		.word allot
		.word exit

;--------------------------------------------------------------
;
;	USER
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user		.word enter
		.word constant
		.word psemi
uservar         ldy #0
		lda (ip),y
		sta n+6
		iny
		lda (ip),y
		sta n+7
		ldy #3
		lda (n+6),y             ; byte offset into user area
		ldy up+1
		adc up
		bcc l008
		iny
l008            jmp push

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		dey
		tya
		jmp push

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		tya
		dey
		jmp push

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jmp doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jmp doconst
		.word 3

;--------------------------------------------------------------
;
;	BL
;
bllfa	.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jsr enter

;--------------------------------------------------------------
;
;	C/L
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jsr enter

;--------------------------------------------------------------
;
;	FIRST
;
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jsr enter

;--------------------------------------------------------------
;
;	LIMIT
;
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jsr enter

;--------------------------------------------------------------
;
;	#BUF
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jsr enter

;--------------------------------------------------------------
;
;	#BCQ
;
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jsr enter

;--------------------------------------------------------------
;
;	B/BUF
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jsr enter

;--------------------------------------------------------------
;
;	B/SCR
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jsr enter

;--------------------------------------------------------------
;
;	TIB
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jsr enter


;--------------------------------------------------------------
;
;	TRUE
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		ldy #$FF
		bmi false+1	; bra

;--------------------------------------------------------------
;
;	FALSE
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		dey
		tya
		jmp push

;--------------------------------------------------------------
;
;	0=
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		lda tos
		ora tos+1
		beq true
		bne false

;--------------------------------------------------------------
;
;	0<
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		bit tos+1
		bmi true
		bpl false

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		bne true
		beq false

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
plusorigin	jsr enter

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (spz-*-1)|bit7
		.asc "SP","0"|bit7
spz		jsr enter

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rpz-*-1)|bit7
		.asc "RP","0"|bit7
rpz		jsr enter

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr enter

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr enter

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr enter

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jmp uservar
		.byt 16

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr enter

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr enter

;--------------------------------------------------------------
;
;	BLK
;
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr enter

;--------------------------------------------------------------
;
;	>IN
;
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr enter

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr enter

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr enter

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr enter

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr enter

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr enter

;--------------------------------------------------------------
;
;	STATE
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr enter

;--------------------------------------------------------------
;
;	BASE
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr enter

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr enter

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; Returns  the  address of the user variable that
; contains the count of characters  received  and
; stored by the most recent execution of EXPECT .
; The  address    of the user variable containing
; the count of characters actually  received  and
; stored by the last execution of EXPECT .
span		jmp uservar
		.byt 42

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr enter

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr enter

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr enter

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jsr enter

;--------------------------------------------------------------
;
;	#TIB
;
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr enter

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr enter

;--------------------------------------------------------------
;
;	1+
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		jsr enter

;--------------------------------------------------------------
;
;	1-
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	jsr enter

;--------------------------------------------------------------
;
;	2+
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		jsr enter

;--------------------------------------------------------------
;
;	2-
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	jsr enter

;--------------------------------------------------------------
;
;	2/
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	jsr enter

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		jsr enter

;--------------------------------------------------------------
;
;	HERE
;
herelfa		.word $adde
		.byt (here-*-1)|bit7
		.asc "HER","E"|bit7
here            jsr enter
		.word dp
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	ALLOT
;
allotlfa	.word $adde
		.byt (allot-*-1)|bit7
		.asc "ALLO","T"|bit7
allot		jsr enter

;--------------------------------------------------------------
;
;	,
;
commalfa	.word $adde
		.byt (comma-*-1)|bit7
		.asc ","|bit7
comma		jsr enter

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (ccomma-*-1)|bit7
		.asc "C",","|bit7
ccomma		jsr enter

;--------------------------------------------------------------
;
;	-
;
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr enter

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		dey
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	u<
;
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		dey
		sec
		lda stackl,x
		sbc tos
		lda stackh,x
		sbc tos+1
sgntst		bvc l012
		eor #bit7
l012		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc "<"|bit7
gt		dey
		sec
		lda tos
		sbc stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		jsr enter

;--------------------------------------------------------------
;
;	SPACE
;
spacelfa	.word $adde
		.byt (space-*-1)|bit7
		.asc "SPAC","E"|bit7
space		jsr enter

;--------------------------------------------------------------
;
;	?DUP
;
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		jsr enter

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"     SWAP
;"     BEGIN
;"         OVER +  127  OVER C@  <
;"     UNTIL
;"     SWAP DROP ;
traverselfa	.word $adde
		.byt (traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
traverse	jsr enter
		.word swap
l010		.word over
		.word plus
		.word clit
		.byt $7f
		.word over
		.word cfetch
		.word lt
		.word qbranch
		.word l010
		.word swap
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of  the  top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (latest-*-1)|bit7
		.asc "LATES","T"|bit7
latest		jsr enter

;--------------------------------------------------------------
;
;	FORTH-83
;
forth83lfa	.word $adde
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jsr enter

;--------------------------------------------------------------
;
;	>BODY
;
tobodylfa	.word $adde
		.byt (tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
tobody		jsr enter


;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt 5|bit7
		.asc ">NAM","E"|bit7
toname		jsr enter
		.word oneminus
		.word true
		.word traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt 5|bit7
		.asc ">LIN","K"|bit7
tolink		jsr enter
		.word toname
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>
;
bodyfromlfa	.word $adde
		.byt (bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
bodyfrom	jsr enter

;--------------------------------------------------------------
;
;	NAME>
;
namefromlfa	.word $adde
		.byt (namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
namefrom	jsr enter

;--------------------------------------------------------------
;
;	LINK>
;
linkfromlfa	.word $adde
		.byt (linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
linkfrom	jsr enter

;--------------------------------------------------------------
;
;	N>LINK
;
ntolinklfa	.word $adde
		.byt (ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
ntolink		jsr enter


;--------------------------------------------------------------
;
;	L>NAME
;
linktonamelfa	.word $adde
		.byt (linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
linktoname	jsr enter

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
storecsp	jsr enter

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (where-*-1)|bit7
		.asc "WHER","E"|bit7
where		jsr enter

;--------------------------------------------------------------
;
;	(ABORT")
;
pabortqlfa	.word $adde
		.byt (pabortq-*-1)|bit7
		.asc "(ABORT",'"',")"|bit7
pabortq		jsr enter

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (commadollar-*-1)|bit7
		.asc ",","$"|bit7
commadollar	jsr enter

;--------------------------------------------------------------
;
;	ABORT"
;
abortqlfa	.word $adde
		.byt (abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
abortq		jsr enter

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
qcomp		jsr enter

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
qfind		jsr enter

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
qpairs		jsr enter

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
qcsp		jsr enter

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
qchar		jsr enter

;--------------------------------------------------------------
;
;	COMPILE
;
compilelfa	.word $adde
		.byt (compile-*-1)|bit7
		.asc "COMPIL","E"|bit7
compile		jsr enter

;--------------------------------------------------------------
;
;	[
;
lbracketlfa	.word $adde
		.byt (lbracket-*-1)|bit7
		.asc "["|bit7
lbracket	jsr enter

;--------------------------------------------------------------
;
;	]
;
rbracketlfa	.word $adde
		.byt (rbracket-*-1)|bit7
		.asc "]"|bit7
rbracket	jsr enter

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
smudge		jsr enter

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (hex-*-1)|bit7
		.asc "HE","X"|bit7
hex		jsr enter

;--------------------------------------------------------------
;
;	DECIMAL
;
decimallfa	.word $adde
		.byt (decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
decimal		jsr enter

;--------------------------------------------------------------
;
;	(;CODE)
psemilfa	.word $adde
		.byt (psemi-*-1)|bit7
		.asc "(;CODE",")"|bit7
psemi		jsr enter

;--------------------------------------------------------------
;
;	DOES>
;
doeslfa		.word $adde
		.byt (does-*-1)|bit7
		.asc "DOES",">"|bit7
does		jsr enter

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; Leaves  the address,  addr2 and the character
; count +n of text  beginning at addr1.
; addr2 is addr1+1 and n1 is the  length  of  the
; counted string at addr1.  The byte at addr1 con-
; tains  the  byte  count  +n.    Range  of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		dey
		lda (tos),y
		inc tos
		bne l020
		inc tos+1
l020		jmp push

;--------------------------------------------------------------
;
;	TYPE
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		jsr enter

;--------------------------------------------------------------
;
;	-TRAILING
;
dashtrailinglfa	.word $adde
		.byt (dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
dashtrailing	jsr enter

;--------------------------------------------------------------
;
;	(.")
;
pdotqlfa	.word $adde
		.byt (pdotq-*-1)|bit7
		.asc "(.",'"',")"|bit7
pdotq		jsr enter

;--------------------------------------------------------------
;
;	."
;
dotqlfa		.word $adde
		.byt (dotq-*-1)|bit7
		.asc ".",'"'|bit7
dotq		jsr enter

;--------------------------------------------------------------
;
;	.(
;
dotplfa		.word $adde
		.byt (dotp-*-1)|bit7
		.asc ".","("|bit7
dotp		jsr enter

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; Stores up to +n characters into  memory  begin-
; ning at addr.
; Receive  characters and store each into memory.
; The transfer begins at addr proceeding  towards
; higher  addresses  one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.   No  more  than  +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or  transfered  if +n is zero.   All characters
; actually received and stored into  memory  will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jsr enter

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (query-*-1)|bit7
		.asc "QUER","Y"|bit7
query		jsr enter

;--------------------------------------------------------------
;
;	" "
;
spacenplfa	.word $adde
		.byt (spacenp-*-1)|bit7|bit6
		.asc " "|bit7
spacenp		.word enter
		.word doneq
		.word on
		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
quitq		jsr enter

;--------------------------------------------------------------
;
;	ERASE
;
eraselfa	.word $adde
		.byt (erase-*-1)|bit7
		.asc "ERAS","E"|bit7
erase		jsr enter

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (blank-*-1)|bit7
		.asc "BLAN","K"|bit7
blank		jsr enter

;--------------------------------------------------------------
;
;	HOLD
;
holdlfa		.word $adde
		.byt (hold-*-1)|bit7
		.asc "HOL","D"|bit7
hold		jsr enter

;--------------------------------------------------------------
;
;	PAD
;
padlfa		.word $adde
		.byt (pad-*-1)|bit7
		.asc "PA","D"|bit7
pad		jsr enter

;--------------------------------------------------------------
;
;	'STREAM
;
tickstreamlfa	.word $adde
		.byt (tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
tickstream	jsr enter


;--------------------------------------------------------------
;
;	WORD
;
wordlfa		.word $adde
		.byt (word-*-1)|bit7
		.asc "WOR","D"|bit7
word		jsr enter

;--------------------------------------------------------------
;
;	>LOWER
;
tolowerlfa	.word $adde
		.byt (tolower-*-1)|bit7
		.asc ">LOWE","R"|bit7
tolower		jsr enter

;--------------------------------------------------------------
;
;	(PUNCT?)
;
ppunctqlfa	.word $adde
		.byt (ppunctq-*-1)|bit7
		.asc "(PUNCT?",")"|bit7
ppunctq		jsr enter

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
punctq		jsr enter

;--------------------------------------------------------------
;
;	CONVERT
;
convertlfa	.word $adde
		.byt (convert-*-1)|bit7
		.asc "CONVER","T"|bit7
convert		jsr enter

;--------------------------------------------------------------
;
;	NUMBER
;
numberlfa	.word $adde
		.byt (number-*-1)|bit7
		.asc "NUMBE","R"|bit7
number		jsr enter

;--------------------------------------------------------------
;
;	FIND
;
findlfa		.word $adde
		.byt (find-*-1)|bit7
		.asc "FIN","D"|bit7
find		jsr enter

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
existsq		jsr enter

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (iddot-*-1)|bit7
		.asc "ID","."|bit7
iddot		jsr enter

;--------------------------------------------------------------
;
;	CREATE
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"  @ + + u< (abort") dictionary full exists?
;"  over (lit) 6017 = (abort") name required
;"  warning @ and ?branch 41 >name cr
;"  clit 18 emit id. clit 146 emit (.") already exists
;"  branch 4 drop here dup c@
;"  over 2+ view? @ + dup >r swap 1+ cmove>
;"  r> dup c@ width @ min 1+ 2dup + clit 255
;"  and clit 255 = ?branch 25 2dup swap
;"  dup 1+ rot cmove> clit 234 c, swap 1+
;"  swap 2+ view? @ + allot dup clit 128 toggle
;"  here 1- clit 128 toggle latest over
;"  2- ! view? @ ?branch 14 blk @ over 2-
;"  2- ! 2 allot current @ ! (;code)
;".C:1b0b   18         CLC
;".C:1b0c   A5 87      LDA $87
;".C:1b0e   69 02      ADC #$02
;".C:1b10   48         PHA
;".C:1b11   98         TYA
;".C:1b12   65 88      ADC $88
;".C:1b14   4C 4A 08   JMP $084A
createlfa	.word $adde
		.byt (create-*-1)|bit7
		.asc "CREAT","E"|bit7
create		jsr enter
		.word frombcq
		.word here
		.word width
		.word fetch
		.word twoplus
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word plus
		.word ult
		.word pabortq
		.byt l013-*-1
		.asc "DICTIONARY FULL"
l013		.word existsq
		.word over
		.word plit
		.word spacenp
		.word eq
		.word pabortq
		.byt l014-*-1
		.asc "NAME REQUIRED"
l014		.word warning
		.word fetch
		.word andx
		.word qbranch
		.word l016
		.word toname
		.word cr
		.word clit
		.byt $12	; rvs
		.word emit
		.word iddot
		.word clit
		.byt $92	; off
		.word emit
		.word pdotq
		.byt l015-*-1
		.asc " ALREADY EXISTS "
l015		.word branch
		.word l017
l016		.word drop
l017		.word here
		.word dup
		.word cfetch
		.word over
		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word dup
		.word tor
		.word swap
		.word oneplus
		.word cmovegt
		.word rfrom
		.word dup
		.word cfetch
		.word width
		.word fetch
		.word min
		.word oneplus
		.word twodup
		.word plus
		.word clit
		.byt $ff
		.word andx
		.word clit
		.byt $ff
		.word eq
		.word qbranch
		.word l018
		.word twodup
		.word swap
		.word dup
		.word oneplus
		.word rot
		.word cmovegt
		.word clit
		.byt $ea
		.word ccomma
		.word swap
		.word oneplus
		.word swap
l018		.word twoplus
		.word viewq
		.word fetch
		.word plus
		.word allot
		.word dup
		.word clit
		.byt $80
		.word toggle
		.word here
		.word oneminus
		.word clit
		.byt $80
		.word toggle
		.word latest
		.word over
		.word twominus
		.word store
		.word viewq
		.word fetch
		.word qbranch
		.word l019
		.word blk
		.word fetch
		.word over
		.word twominus
		.word twominus
		.word store
l019		.word two
		.word allot
		.word current
		.word fetch
		.word store
		.word psemi
docreate	lda w1
		adc #3
		tay
		lda #0
		adc w1+1
		jmp push

;--------------------------------------------------------------
;
;	[COMPILE]
;
bcompilelfa	.word $adde
		.byt (bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
bcompile	jsr enter

;--------------------------------------------------------------
;
;	LITERAL
;
literallfa	.word $adde
		.byt (literal-*-1)|bit7
		.asc "LITERA","L"|bit7
literal		jsr enter

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
dliteral	jsr enter

;--------------------------------------------------------------
;
;	?STACK
;
qstacklfa	.word $adde
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		jsr enter

;--------------------------------------------------------------
;
;	INTERPRET
;
interpretlfa	.word $adde
		.byt (interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
interpret	jsr enter

;--------------------------------------------------------------
;
;	IMMEDIATE
;
immediatelfa	.word $adde
		.byt (immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
immediate	jsr enter

;--------------------------------------------------------------
;
;	VOCABULARY
;
vocabularylfa	.word $adde
		.byt (vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
vocabulary	jsr enter

;--------------------------------------------------------------
;
;	FORTH
;
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jsr enter

;--------------------------------------------------------------
;
;	DEFINITIONS
;
definitionslfa	.word $adde
		.byt (definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
definitions	jsr enter

;--------------------------------------------------------------
;
;	(
;
lparenlfa	.word $adde
		.byt (lparen-*-1)|bit7
		.asc "("|bit7
lparen		jsr enter

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (run-*-1)|bit7
		.asc "RU","N"|bit7
run		jsr enter

;--------------------------------------------------------------
;
;	ABORT
;
abortlfa	.word $adde
		.byt (abort-*-1)|bit7
		.asc "ABOR","T"|bit7
abort		jsr enter

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jmp docreate
		.word abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		sei
		cld
		ldx #$f8
		txs
		jsr CLRCHN
		jsr CLALL
		cli

		ldy #bnextend-bnextbegin+1
l011		lda bnextbegin-1,y
		sta next-1,y
		dey
		bne l011

		; initialize the data stack pointer
		ldx #bos
		; move up to high-level
		lda #>(cold2-2)
		sta ip+1
		lda #<(cold2-2)
		sta ip

xpetp   ;        lda #<bar
	;	sta w1
	;	lda #>bar
	;	sta w1+1
		lda #<bar
		sta tos
		lda #>bar
		sta tos+1
		jmp execute

cold2		.word rethread
		.word startup
		.word fetch
		.word execute

;blazin' forth cold
;		sei
;		;jsr clall
;		;jsr ramtas
;		jsr forthinit
;		lda userarea+4
;		sta forth+2
;		lda userarea+5
;		sta forth+3
;		ldy #$15
;		jsr userinit
;		lda #$1d
;		sta ip+1
;		lda #$7b
;		sta ip
;		lda #$6c	; jmp (indirect)
;		sta w-1
;		cld
;		cli
;		ldx #bos
;		jmp rpstore+2
;forthinit       lda #<warmvec
;		sta errlnk
;		lda #>warmvec
;		sta errlnk+1
;		jsr clrchn
warminit	lda #$93		; clear screen
		jsr CHROUT
		rts
;userinit	lda userarea+6
;		sta up
;		lda userarea+7
;		sta up+1
;l104		lda userarea+2,y
;		sta (up),y
;		dey
;		bpl l104
;		rts


bar             jsr enter
		.word foo
		.word exit

foo		jsr enter
		.word dup
		.word clit
		.byt 42
		.word plus
		.word over
		.word plus
		.word exit

;Warm start
;--------------------------------------------------------------
;
;	WARM
warm		jsr warminit
		ldy #$0d
;		jsr userinit
		lda #>warmhigh
		sta ip+1
		lda #<warmhigh
		sta ip
		jmp rpstore+2
warmhigh	.word decimal
		.word pdotq
		.byt s014-*-1
		.asc "<WARM START>"
s014		.word startup
		.word fetch
		.word execute
;		.word dr0
		.word emptybuffers
		.word decimal
		.word forth
		.word definitions
		.word pdotq
		.byt s015-*-1
		.asc "        BLAZIN' FORTH FOR CBM-64"
		.byt $0d,$0d
		.asc "COPYRIGHT (C) 1985 BY SCOTT BALLANTYNE"
		.byt $0d
		.asc "OK TO COPY, BUT NOT TO SELL!"
		.byt $0d,$0d
s015		.word pdotq
		.byt s016-*-1
		.asc "WELCOME TO FORTH!"
s016		.word startup
		.word fetch
		.word execute

;--------------------------------------------------------------
;
;	QUIT
;
; PETTIL's outer interpreter infinite loop
;
quitlfa		.word $adde
		.byt (quit-*-1)|bit7
		.asc "QUI","T"|bit7
quit		.word enter
		.word zero
		.word blk
		.word store
		.word lbracket
l007		.word rpstore
		.word cr
		.word query
		.word interpret
		.word state
		.word fetch
		.word zeq
		.word qbranch
		.word l006
		.word pdotq
		.byt (l006-*-1)
		.asc "OK"
l006		.word branch
		.word l007

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (stod-*-1)|bit7
		.asc "S>","D"|bit7
stod		jsr enter

;--------------------------------------------------------------
;
;	ABS
;
abslfa		.word $adde
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs		jsr enter

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs		jsr enter

;--------------------------------------------------------------
;
;	MIN
;
minlfa		.word $adde
		.byt (min-*-1)|bit7
		.asc "MI","N"|bit7
min		jsr enter

;--------------------------------------------------------------
;
;	MAX
;
maxlfa	.word $adde
		.byt (max-*-1)|bit7
		.asc "MA","X"|bit7
max		jsr enter

;--------------------------------------------------------------
;
;	M*
;
mstarlfa	.word $adde
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jsr enter

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash		jsr enter

;--------------------------------------------------------------
;
;	*
;
starlfa		.word $adde
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jsr enter

;--------------------------------------------------------------
;
;	/MOD
;
slashmodlfa	.word $adde
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jsr enter

;--------------------------------------------------------------
;
;	/
;
slashlfa	.word $adde
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jsr enter

;--------------------------------------------------------------
;
;	MOD
;
modlfa		.word $adde
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jsr enter

;--------------------------------------------------------------
;
;	*/MOD
;
starslashmodlfa	.word $adde
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jsr enter

;--------------------------------------------------------------
;
;	*/
;
starslashlfa	.word $adde
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jsr enter

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jsr enter

;--------------------------------------------------------------
;
;	<BCQ
;
frombcqlfa	.word $adde
		.byt (frombcq-*-1)|bit7
		.asc "<BC","Q"|bit7
frombcq		jsr enter

;--------------------------------------------------------------
;
;	BCQ>
;
bcqfromlfa	.word $adde
		.byt (bcqfrom-*-1)|bit7
		.asc "BCQ",">"|bit7
bcqfrom		jsr enter

;--------------------------------------------------------------
;
;	>bcq
;
tobcqlfa	.word $adde
		.byt (tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
tobcq		jsr enter

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
latestq		jsr enter

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
absentq		jsr enter

;--------------------------------------------------------------
;
;	UPDATE
;
updatelfa	.word $adde
		.byt (update-*-1)|bit7
		.asc "UPDAT","E"|bit7
update		jsr enter

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (drzero-*-1)|bit7
		.asc "DR","0"|bit7
drzero		jsr enter

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (drone-*-1)|bit7
		.asc "DR","1"|bit7
drone		jsr enter

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
discard		jsr enter

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
missing		jsr enter

;--------------------------------------------------------------
;
;	BUFFER
;
bufferlfa	.word $adde
		.byt (buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
buffer		jsr enter

;--------------------------------------------------------------
;
;	BLOCK
;
blocklfa	.word $adde
		.byt (block-*-1)|bit7
		.asc "BLOC","K"|bit7
block		jsr enter

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS
;
emptybufferslfa	.word $adde
		.byt (emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
emptybuffers	jsr enter

;--------------------------------------------------------------
;
;	SAVE-BUFFERS
;
savebufferslfa	.word $adde
		.byt (savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
savebuffers	jsr enter

;--------------------------------------------------------------
;
;	FLUSH
;
flushlfa	.word $adde
		.byt (flush-*-1)|bit7
		.asc "FLUS","H"|bit7
flush		jsr enter

;--------------------------------------------------------------
;
;	LOAD
;
loadlfa		.word $adde
		.byt (load-*-1)|bit7
		.asc "LOA","D"|bit7
load		jsr enter

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
todisc		jsr enter

;--------------------------------------------------------------
;
;	(R/W)
;
prslashwlfa	.word $adde
		.byt (prslashw-*-1)|bit7
		.asc "(R/W",")"|bit7
prslashw	jsr enter

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (rslashw-*-1)|bit7
		.asc "R/","W"|bit7
rslashw		jsr enter

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
tnslfa		.word $adde
		.byt (tns-*-1)|bit7
		.asc "T&","S"|bit7
tns		jsr enter

;--------------------------------------------------------------
;
;	(OPEN)
;
popenlfa	.word $adde
		.byt (popen-*-1)|bit7
		.asc "(OPEN",")"|bit7
popen		jsr enter

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (close-*-1)|bit7
		.asc "CLOS","E"|bit7
close		jsr enter

;--------------------------------------------------------------
;
;	(CMDIN)
;
pcmdinlfa	.word $adde
		.byt (pcmdin-*-1)|bit7
		.asc "(CMDIN",")"|bit7
pcmdin		jsr enter

;--------------------------------------------------------------
;
;	(CMDOUT)
;
pcmdoutlfa	.word $adde
		.byt (pcmdout-*-1)|bit7
		.asc "(CMDOUT",")"|bit7
pcmdout		jsr enter

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff		jsr enter

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (status-*-1)|bit7
		.asc "STATU","S"|bit7
status		jsr enter

;--------------------------------------------------------------
;
;	(?DISC)
;
pqdisclfa	.word $adde
		.byt (pqdisc-*-1)|bit7
		.asc "(?DISC",")"|bit7
pqdisc		jsr enter

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
ioerr		jsr enter
		.word qdup
		.word qbranch
		.word s028
		.word dup
		.word one
		.word eq
		.word pabortq
		.byt s020-*-1
		.asc "TOO MANY OPEN FILES"
s020		.word dup
		.word two
		.word eq
		.word pabortq
		.byt s021-*-1
		.asc "FILE ALREADY OPEN"
s021		.word dup
		.word three
		.word eq
		.word pabortq
		.byt s022-*-1
		.asc "FILE NOT OPEN"
s022		.word dup
		.word clit
		.byt 4
		.word eq
		.word pabortq
		.byt s023-*-1
		.asc "FILE NOT FOUND"
s023		.word dup
		.word clit
		.byt 5
		.word eq
		.word pabortq
		.byt s024-*-1
		.asc "DEVICE NOT PRESENT"
s024		.word dup
		.word clit
		.byt 6
		.word eq
		.word pabortq
		.byt s025-*-1
		.asc "NOT INPUT FILE"
s025		.word dup
		.word clit
		.byt 7
		.word eq
		.word pabortq
		.byt s026-*-1
		.asc "NOT OUTPUT FILE"
s026		.word dup
		.word clit
		.byt 8
		.word eq
		.word pabortq
		.byt s027-*-1
		.asc "MISSING FILE NAME"
s027		.word dup
		.word clit
		.byt 9
		.word eq
		.word pabortq
		.byt s028-*-1
		.asc "ILLEGAL DEVICE NUMBER"
s028		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
dotderr		jsr enter

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (mount-*-1)|bit7
		.asc "MOUN","T"|bit7
mount		jsr enter

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
qdisc		jsr enter

;--------------------------------------------------------------
;
;	'
;
ticklfa		.word $adde
		.byt (tick-*-1)|bit7
		.asc "'"|bit7
tick		jsr enter

;--------------------------------------------------------------
;
;	[']
;
brticklfa	.word $adde
		.byt (brtick-*-1)|bit7
		.asc "['","]"|bit7
brtick		jsr enter

;--------------------------------------------------------------
;
;	?>MARK
;
qtomarklfa	.word $adde
		.byt (qtomark-*-1)|bit7
		.asc "?>MAR","K"|bit7
qtomark		jsr enter

;--------------------------------------------------------------
;
;	?<MARK
;
qfrommarklfa	.word $adde
		.byt (qfrommark-*-1)|bit7
		.asc "?<MAR","K"|bit7
qfrommark	jsr enter

;--------------------------------------------------------------
;
;	?>RESOLVE
;
qtoresolvelfa	.word $adde
		.byt (qtoresolve-*-1)|bit7
		.asc "?>RESOLV","E"|bit7
qtoresolve	jsr enter

;--------------------------------------------------------------
;
;	?<RESOLVE
;
qfromresolvelfa	.word $adde
		.byt (qfromresolve-*-1)|bit7
		.asc "?<RESOLV","E"|bit7
qfromresolve	jsr enter

;--------------------------------------------------------------
;
;	ADD>MARK
;
addtomarklfa	.word $adde
		.byt (addtomark-*-1)|bit7
		.asc "ADD>MAR","K"|bit7
addtomark	jsr enter

;--------------------------------------------------------------
;
;	BEGIN
;
beginlfa	.word $adde
		.byt (begin-*-1)|bit7
		.asc "BEGI","N"|bit7
begin		jsr enter

;--------------------------------------------------------------
;
;	THEN
;
thenlfa		.word $adde
		.byt (then-*-1)|bit7
		.asc "THE","N"|bit7
then		jsr enter

;--------------------------------------------------------------
;
;	DO
;
dolfa		.word $adde
		.byt (do-*-1)|bit7
		.asc "D","O"|bit7
do		jsr enter

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (qdo-*-1)|bit7
		.asc "?D","O"|bit7
qdo		jsr enter

;--------------------------------------------------------------
;
;	LOOP
;
looplfa		.word $adde
		.byt (loop-*-1)|bit7
		.asc "LOO","P"|bit7
loop		jsr enter

;--------------------------------------------------------------
;
;	+LOOP
;
pluslooplfa	.word $adde
		.byt (plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
plusloop	jsr enter

;--------------------------------------------------------------
;
;	LEAVE
;
leavelfa	.word $adde
		.byt (leave-*-1)|bit7
		.asc "LEAV","E"|bit7
leave		jsr enter

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
qleave		jsr enter

;--------------------------------------------------------------
;
;	UNTIL
;
untillfa	.word $adde
		.byt (until-*-1)|bit7
		.asc "UNTI","L"|bit7
until		jsr enter

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (again-*-1)|bit7
		.asc "AGAI","N"|bit7
again		jsr enter

;--------------------------------------------------------------
;
;	REPEAT
;
repeatlfa	.word $adde
		.byt (repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
repeat		jsr enter

;--------------------------------------------------------------
;
;	IF
;
iflfa		.word $adde
		.byt (if-*-1)|bit7
		.asc "I","F"|bit7
if		jsr enter

;--------------------------------------------------------------
;
;	ELSE
;
elselfa		.word $adde
		.byt (else-*-1)|bit7
		.asc "ELS","E"|bit7
else		jsr enter

;--------------------------------------------------------------
;
;	WHILE
;
whilelfa	.word $adde
		.byt (while-*-1)|bit7
		.asc "WHIL","E"|bit7
while		jsr enter

;--------------------------------------------------------------
;
;	SPACES
;
spaceslfa	.word $adde
		.byt (spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
spaces		jsr enter

;--------------------------------------------------------------
;
;	<#
;
ltsharplfa	.word $adde
		.byt (ltsharp-*-1)|bit7
		.asc "<","#"|bit7
ltsharp		jsr enter

;--------------------------------------------------------------
;
;	#>
;
sharpgtlfa	.word $adde
		.byt (sharpgt-*-1)|bit7
		.asc "#",">"|bit7
sharpgt		jsr enter

;--------------------------------------------------------------
;
;	SIGN
;
signlfa		.word $adde
		.byt (sign-*-1)|bit7
		.asc "SIG","N"|bit7
sign		jsr enter

;--------------------------------------------------------------
;
;	#
;
sharplfa	.word $adde
		.byt (sharp-*-1)|bit7
		.asc "#"|bit7
sharp		jsr enter

;--------------------------------------------------------------
;
;	#S
;
sharpslfa	.word $adde
		.byt (sharps-*-1)|bit7
		.asc "#","S"|bit7
sharps		jsr enter

;--------------------------------------------------------------
;
;	(U.)
;
pudotlfa	.word $adde
		.byt (pudot-*-1)|bit7
		.asc "(U.",")"|bit7
pudot		jsr enter

;--------------------------------------------------------------
;
;	U.
;
udotlfa		.word $adde
		.byt (udot-*-1)|bit7
		.asc "U","."|bit7
udot		jsr enter

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (udotr-*-1)|bit7
		.asc "U.","R"|bit7
udotr		jsr enter

;--------------------------------------------------------------
;
;	(.)
;
pdotlfa		.word $adde
		.byt (pdot-*-1)|bit7
		.asc "(.",")"|bit7
pdot		jsr enter

;--------------------------------------------------------------
;
;	.
;
dotlfa		.word $adde
		.byt (dot-*-1)|bit7
		.asc "."|bit7
dot		jsr enter

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (dotr-*-1)|bit7
		.asc ".","R"|bit7
dotr		jsr enter

;--------------------------------------------------------------
;
;	(UD.)
;
puddotlfa	.word $adde
		.byt (puddot-*-1)|bit7
		.asc "(UD.",")"|bit7
puddot		jsr enter

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (uddot-*-1)|bit7
		.asc "UD","."|bit7
uddot		jsr enter

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
uddotr		jsr enter

;--------------------------------------------------------------
;
;	(D.)
;
pdddotlfa	.word $adde
		.byt (pddot-*-1)|bit7
		.asc "(D.",")"|bit7
pddot		jsr enter

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (ddot-*-1)|bit7
		.asc "D","."|bit7
ddot		jsr enter

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (ddotr-*-1)|bit7
		.asc "D.","R"|bit7
ddotr		jsr enter

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (question-*-1)|bit7
		.asc "?"|bit7
question	jsr enter

;--------------------------------------------------------------
;
;	PICK
;
picklfa		.word $adde
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick		jsr enter

;--------------------------------------------------------------
;
;	ROLL
;
rolllfa		.word $adde
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		jsr enter

;--------------------------------------------------------------
;
;	DEPTH
;
depthlfa	.word $adde
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth		jsr enter

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jsr enter

;--------------------------------------------------------------
;
;	2DUP
;
twoduplfa	.word $adde
		.byt (twodup-*-1)|bit7
		.asc "2DU","P"|bit7
twodup		jsr enter

;--------------------------------------------------------------
;
;	2OVER
;
twooverlfa	.word $adde
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		jsr enter

;--------------------------------------------------------------
;
;	2ROT
;
tworotlfa	.word $adde
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		jsr enter

;--------------------------------------------------------------
;
;	2SWAP
;
twoswaplfa	.word $adde
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		jsr enter

;--------------------------------------------------------------
;
;	2!
;
twostorelfa	.word $adde
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	jsr enter

;--------------------------------------------------------------
;
;	2@
;
twofetchlfa	.word $adde
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	jsr enter

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
twoconst	jsr enter

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
twovariable	jsr enter

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus		jsr enter

;--------------------------------------------------------------
;
;	D0=
;
dzeqlfa		.word $adde
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		jsr enter

;--------------------------------------------------------------
;
;	D=
;
deqlfa		.word $adde
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		jsr enter

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jsr enter

;--------------------------------------------------------------
;
;	D2/
;
dtwoslashlfa	.word $adde
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	jsr enter

;--------------------------------------------------------------
;
;	D2*
;
dtwostarlfa	.word $adde
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	jsr enter

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (dgt-*-1)|bit7
		.asc "D",">"|bit7
dgt		jsr enter

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (dmin-*-1)|bit7
		.asc "DMI","N"|bit7
dmin		jsr enter

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (dmax-*-1)|bit7
		.asc "DMA","X"|bit7
dmax		jsr enter

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
configure	jsr enter

;--------------------------------------------------------------
;
;	FREEZE
;
freezelfa	.word $adde
		.byt (freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
freeze		jsr enter

;--------------------------------------------------------------
;
;	(BSAVE)
;
pbsavelfa	.word $adde
		.byt (pbsave-*-1)|bit7
		.asc "(BSAVE",")"|bit7
pbsave		jsr enter

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
saveforth	jsr enter

;--------------------------------------------------------------
;
;	FORGET
;
forgetlfa	.word $adde
		.byt (forget-*-1)|bit7
		.asc "FORGE","T"|bit7
forget		jsr enter

;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde
		.byt (thru-*-1)|bit7
		.asc "THR","U"|bit7
thru		jsr enter

;==============================================================

; hash-threaded dictionary search
; These won't remain in the final core (LOAD "*") version
; but it will be useful during development to automatically generate
; all LFAs so I can rearrange the dictionary at will without tedious
; LFA editing.
;
; Three top-level words rewrite the entire LFA chain
; 1THREAD resets the LFA chain to a traditional single-threaded linked list
; HASHTHREAD breaks the LFA chain into 16 linked lists
; DEADTHREAD resets all LFAs but the end to appear as DE AD in hex dumps
;
; Changing the LFA threading is an all-or-nothing deal.  These tools
; aren't capable of automagically re-threading everything when the
; LFA chain(s) is/are corrupt.
;
; Vector (DEFER/IS) these words
; LATEST
;
;--------------------------------------------------------------
;
;	DHASH	( addr -- hash )
;
; input is a counted string at "addr"
;
; output "hash" is a value 0..15 that points to the latest LFA
; in this word's dictionary chain
dhashlfa	.word $adde
		.byt (dhash-*-1)|bit7
		.asc "DHAS","H"|bit7
dhash		dey
		lda (tos),y		; get the length
		and #$1f		; mask off flag bits
		tay
		lda #0
l009		eor (tos),y		; xor the string together, ignore length
		dey
		bne l009
		sty tos+1		; 0 -> msb
		sta tos			; temporarily store the result byte
		lsr
		lsr
		lsr
		lsr			; get the high nybble
		eor tos			; mix it with the low nybble
		and #$0f		; mask off the high nybble
		sta tos			; hash value in the range 0..f
		jmp next

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieves the LFA of the latest word in this hash thread
;
dhashfetchlfa	.word $adde
		.byt (dhashfetch-*-1)|bit7
		.asc "DHASH","@"|bit7
dhashfetch	ldy tos
		lda latestl,y
		sta tos
		lda latesth,y
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hashkey -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
dhashstorelfa	.word $adde
		.byt (dhashstore-*-1)|bit7
		.asc "DHASH","!"|bit7
dhashstore	lda #2
		jsr popnwords		; N0 = hashkey, N1 = LFAnew
		ldy n			; get hashkey
		lda latestl,y
		sta n+4
		lda latesth,y
		sta n+5			; LFAlatest -> N2
		lda n+2
		sta latestl,y
		lda n+3
		sta latesth,y		; LFAnew -> hashtable(key)
		ldy #0
		lda n+4
		sta (n+2),y
		iny
		lda n+5
		sta (n+2),y		; LFAlatest -> [LFAnew]
		jmp next

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; links all LFAs
rethreadlfa	.word $adde
		.byt (rethread-*-1)|bit7
		.asc "RETHREA","D"|bit7
rethread
		.word here
		.word plit
		.word 1024
		.word pdo
		.word i
		.word cfetch
		.word clit
		.byt $ad
		.word eq
		.word i
		.word oneplus
		.word cfetch
		.word clit
		.byt $de
		.word eq
		.word andx
		.word i
		.word oneminus
		.word dup
		.word cfetch
		.word clit
		.byt $80
		.word gt
		.word andx
		.word qbranch
		.word l024
		.word i
		.word oneminus
		.word plit
		.word -1
		.word traverse
		.word dup
		.word cfetch
		.word clit
		.byt $3f
		.word andx
		.word over
		.word plus
		.word i
		.word oneminus
		.word eq
		.word qbranch
		.word l024
		.word dhash
		.word i
		.word swap
		.word dhashstore
l024            .word plit
		.word -1
		.word pploop
		.word exit

; TRUE - builds a hashed LFA structure
; FALSE - resets all LFAs to DE AD
;
; dead - 
; scanning forward sequentially, we find sequences of 
;	len | $80	(A)
;	byte 1
;	byte 2
;	byte 3
;	...
;	byte len | $80	(B)
;	$DE
;	$AD
; where points (A) and (B) are len bytes apart
; LATEST returns 0
;
; hashed - 
; the dhash array has any nonzero value in it
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
; single - 
; the dhash array is filled with all zeroes
; LATEST returns nonzero
; following the LFA chain from LATEST leads to 00
;
;"	: THREADING?  ( -- flag )
;"		LATEST
;
;	tells us whether we're threaded (true) or unthreaded (false)
;
unthread


;--------------------------------------------------------------
;
;	DEADTHREAD   ( -- )
;
; assumption -- dictionary is configured in one of the three
;		available schemes
;
;": DEADTHREAD 
;"    THREADING? ?DUP 0=  ( dead )
;"    IF  ." YOU CAN'T KILL ME!  I'M ALREADY DEAD." CR  
;"    ELSE  0<
;"        IF  ." KILLING SINGLE THREADED LINKS" CR  1KILL  THEN
;"        ELSE  ." KILLING HASH THREADED LINKS" CR  HASHKILL  THEN
;"    THEN ;



		; pops up to 4 words from the split stack to the N area
		; A = how many words to pop (valid range 1-4)
		;
		; returns
		; TOS -> N0, 2OS -> N1, 3OS -> N2, 4OS -> N3
popnwords	asl
		tay
		lda tos
		sta n-2,y
		lda tos+1
		sta n-1,y
l004		dey
		dey
		beq l005
		lda stackl,x
		sta n-2,y
		lda stackh,x
		sta n-1,y
		inx
		bne l004		; bra
l005		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		inx
		rts


; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years. 
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate
bit5	= $20		; smudge

; zero page usage
stackl	= $00		; stackl = $00..$3b (60 bytes)
stackh	= $30		; stackh = $3c..$79 (60 bytes)
bos	= stackh-stackl	; includes TOS
up	= $76		; user area pointer
n	= $78		; scratch space
w	= $7e		; w overlaps n
tos	= $80		; top of stack
zi	= $82		; innermost DO LOOP counter/limit

next	= $86
;0086 next	inc ip
next1	= $88
;0088 next1	inc ip
nexto	= $8a
ip	= $8b
;008a nexto	jmp ($cafe)

;$8d..$ff kernel zeropage area

curindev	= $99
curoutdev	= $9a
inbuf		= $200

outputted	= cas2buf+26		; #out	~ a cleaner way to do this?
inputted	= cas2buf+42		; span
linesout	= cas2buf+54		; #line

basic		= $0400
		.word basic+1		; PET BASIC storage starts here
*		= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc "(1040)",0		; sys $0410
basend		.word 0

		.dsb basic+$10-*,$ea
coldvector	jmp cold
warmvector	jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userarea

userntop	.word ntop				; 4..5
userup		.word cas2buf				; 6..7
usersp0		.word bos				; 8..9
userrp0		.word $01ff				; 10..11
userwidth	.word 31				; 12..13
userwarning	.word -1				; 14..15

userwarm

userfence	.word forgetfence			; 16..17
userdp		.word endofile				; 18..19
uservoclink	.word lastvoc				; 20..21
userviewquery	.word 2					; 22..23
userblk		.word 0					; 24..25

usercold

lfalist		.dsb 32,0	; heads of link threads
bloom2		.dsb 32,0	; Forth vocabulary bloom filter for hash2
power2		.byt $01,$02,$04,$08,$10,$20,$40,$80
pearson		.byt 26,115,76,23,138,222,77,7
;--------------------------------------------------------------
;
;	NEXT
;
; * inner interpreter headerless
;
;		+IP
;		[IP] -> PC
;
; this NEXT routine gets copied to $0086 by COLD.  See project
; tiddlywiki for the rationale behind this minimalist design
;
; Page boundary crossing within a secondary is handled by the compiler 
; inserting 'page' when the DP gets to $xxFD or $xxFE.  DP having a value
; of $xxFF is not supposed to happen, and indicates an error in the compiler.
;
; the next three instructions get copied to zeropage by COLD
zpnext	inc ip
	inc ip
	jmp ($cafe)
page		lda #0
		sta ip
		inc ip+1
		jmp nexto

rootlfa		.word 0
		.byt 31			; longest word in the dictionary
		
;--------------------------------------------------------------
;
;	EXECUTE
;
; * 83 nucleus
;
; Executes the definition found at addr.
;
;"	: execute ( cfa --- )
;"		jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa	.word $adde		; <-- link field address
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7
execute		lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1		; [SP] -> [W1]
		lda ip+1
		pha
		lda ip
		pha
		lda #<(w1-2)
		sta ip
		lda #>(w1-2)
		sta ip+1
		jmp pop
w1		.word $dead		; (for when you just need a W register)
		.word exit		; 'fragment secondary' used by EXECUTE

;--------------------------------------------------------------
;
;	(LIT)
;
; * inner interpreter headerless
;
; push the word of memory following (IP)
;
;plitlfa	.word $adde
;		.byt (plit-*-1)|bit7
;		.asc "(LIT",")"|bit7
plit		ldy #3
		lda (ip),y
		sta n+1
		dey
		lda (ip),y
		sta n
skiplit		ldy ip
		cpy #$fb
		bcc nopage
		bne l003
		iny
l003		inc ip+1
nopage		iny
		iny
		sty ip
pushn		ldy n+1
		lda n

push		sta n
		dex
		lda tos+1
		sta stackh,x
		lda tos
		sta stackl,x
		lda n
put		sty tos+1
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	CLIT
;
; * inner interpreter headerless
;
; takes the byte of memory following and pushes it to the data stack
;
;clitlfa	.word $adde
;		.byt (clit-*-1)|bit7
;		.asc "CLI","T"|bit7
clit		ldy #2
		lda (ip),y
		sta n
		lda #0
		sta n+1
		ldy ip
		cpy #$fc
		dey
		bcc nopage
		sta ip
		bcs pushn

;--------------------------------------------------------------
;
;	?BRANCH   ( flag -- )
;
; * inner interpreter control headerless
;
;qbranchlfa	.word $adde
;		.byt (qbranch-*-1)|bit7
;		.asc "?BRANC","H"|bit7
qbranch		lda tos
		ora tos+1
		ldy stackl,x
		sty tos
		ldy stackh,x
		sty tos+1
		inx		; drop
		tay		; to set the Z flag
		beq branch
bump		lda #4
nexta		clc		;[2]
		adc ip		;[3]
		sta ip		;[3]
		bcc l023	;[2]
		inc ip+1	;[5]
l023		jmp nexto	;[3]

;--------------------------------------------------------------
;
;	BRANCH   ( -- )
;
; * inner interpreter control headerless
;
; Compiles an unconditional branch operation.
;" When used in the form: COMPILE BRANCH
; an unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated by following BRANCH
; with <RESOLVE or >MARK .
;
;"	: branch ( -- )
;
;branchlfa	.word $adde
;		.byt (branch-*-1)|bit7
;		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
; Y = 1
branch		ldy #2		; [2]
		lda (ip),y	; [5+]
		sta n		; [3]
		iny		; [2]
		lda (ip),y	; [5+]
		sta ip+1	; [3]
		lda n		; [3]
		sta ip		; [3] (IP+2) -> IP
		jmp nexto	; [3]
				; [29/30 cycles] (runs in constant time)

;--------------------------------------------------------------
;
;	(+LOOP)   ( n -- )
;
; * inner interpreter control headerless
;
; add n to inner loop index.  If loop index exceeds loop limit,
; then iterate to the (do), otherwise skip past the branch and
; proceed
;pplooplfa	.word $adde
;		.byt (pploop-*-1)|bit7
;		.asc "(+LOOP",")"|bit7
pploop		clc
		lda tos
		adc zi
		sta zi
		lda tos+1
		adc zi+1
		sta zi+1
		lda zi+2
		cmp zi
		lda zi+3
		sbc zi+1
		ldy tos+1
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx
		tay
		bcc l043
		eor #$80
l043		bmi branch
		bpl bump

;--------------------------------------------------------------
;
;	(LOOP)
;
; * inner interpreter control headerless
;
;plooplfa	.word $adde
;		.byt (ploop-*-1)|bit7
;		.asc "(LOOP",")"|bit7
ploop		inc zi
		bne pl1
		inc zi+1
pl1		lda zi+2
		eor zi
		bne branch
		lda zi+3
		eor zi+1
		bne branch
		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp bump

;--------------------------------------------------------------
;
;	(DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; loops from 'begin' to 'end'
;pdolfa		.word $adde
;		.byt (pdo-*-1)|bit7
;		.asc "(DO",")"|bit7
pdo		lda zi+3
		pha
		lda zi+2
		pha
		lda zi+1
		pha
		lda zi
		pha
		lda stackh,x
		sta zi+3
		lda stackl,x
		sta zi+2
		lda tos+1
		sta zi+1
		lda tos
		sta zi
poptwo		inx
pop		ldy stackh,x
		lda stackl,x
		inx
		jmp put

;--------------------------------------------------------------
;
;	(?DO)
;
; * inner interpreter control headerless
;
;pqdolfa	.word $adde
;		.byt (pqdo-*-1)|bit7
;		.asc "(?DO",")"|bit7
pqdo	;	lda stack,x
	;	cmp stack+2,x
		bne pqdo1
	;	lda stack+1,x
	;	cmp stack+3,x
		beq pqdo3
pqdo1		clc
		lda ip
		adc #2
		sta ip
		bcc pqdo2
		inc ip+1
pqdo2		jmp pdo+2
pqdo3		inx
		inx
		inx
		inx
		jmp branch+2

;--------------------------------------------------------------
;
;	I
;
; * 83 nucleus
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		lda zi
		ldy zi+1
		jmp push

;--------------------------------------------------------------
;
;	J
;
; * 83 nucleus
;
jlfa		.word $adde
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		stx n
		tsx
		inx
		inx
		inx
		inx
		jmp push

;--------------------------------------------------------------
;
;	(LEAVE)
;
; * inner interpreter control headerless
;
;pleavelfa	.word $adde
;		.byt (pleave-*-1)|bit7
;		.asc "(LEAVE",")"|bit7
pleave		pla
		pla
		pla
		pla
		jmp branch+2

;--------------------------------------------------------------
;
;	(?LEAVE)
;
; * inner interpreter control headerless
;
;pqleavelfa	.word $adde
;		.byt (pqleave-*-1)|bit7
;		.asc "(?LEAVE",")"|bit7
pqleave		inx
		inx
	;	lda stack+254,x
	;	ora stack+255,x
		bne pleave+2
		jmp bump

;--------------------------------------------------------------
;
;	DIGIT
;
digitlfa	.word $adde
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit
		sec
	;	lda stack+2,x
		sbc #$30
		bmi nonum
		cmp #$0a
		bmi isnum
		sec
		sbc #7
		cmp #$0a
		bmi nonum
isnum	;	cmp stack,x
		bpl nonum
	;	sta stack+2,x
		dey
		tya
		pha
		jmp put
nonum		tya
		pha
		inx
		inx
		jmp put

;--------------------------------------------------------------
;
;	(FIND)   ( addr1 addr2 flag -- addr flag )
;
; * outer interpreter headerless
;
; addr1 is the address of a counted string we are searching for.
; addr2 is the LFA at the head of a chain of LFAs
; flag is true if the words in this chain are ordered by ascending length
; returns ( NFA true ) if found, ( addr1 false ) if not found
;
;pfindlfa	.word $adde
;		.byt (pfind-*-1)|bit7
;		.asc "(FIND",")"|bit7
pfind		lda tos
		sta n
		lda tos+1
		sta n+1
		lda stackl,x
		sta n+2
		lda stackh,x
		sta n+3
		ldy #1
l9		dey
		lda (n),y
		eor (n+2),y
		and #($100-bit7-bit6)
		bne l8
l6		iny
		lda (n),y
		eor (n+2),y
		asl
		bne l8
		bcc l6
		dex
		dex
		iny
		tya
		clc
		adc n
		sta stackl+1,x
		ldy #0
		tya
		adc n+1
		sta stackh+1,x
		sty tos+1
		lda (n),y
		asl
		bpl l7		; branch if non-immediate
		lda #1		; immediate
		sta tos
		jmp next
l7		lda #$ff	;true
		tya
		jmp put

l8		sec
		lda n		; traverse the LFAs?
		sbc #2
		sta n
		lda n+1
		sbc #0
		sta n+1
		ldy #0
		lda (n),y
		tax
		iny
		lda (n),y
		sta n+1
		stx n
		ora n
		bne l9
		ldx n+4
		dex
		dex
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		lda #0		;false
		pha
		jmp push

;--------------------------------------------------------------
		; pops up to 4 words from the split stack to N area
		; A = how many words to pop (valid range 1-4)
		; returns
		; Y = 0
		; TOS unchanged
		; 2OS -> N0, 3OS -> N1, 4OS -> N2, 5OS -> N3
		;      1          2          3          4
setup		asl
		tay
l045		lda stackl,x
		sta n-2,y
		lda stackh,x
		sta n-1,y
		inx
		dey
		dey
		bne l045
l046		rts

;--------------------------------------------------------------
;
;	SKIP   ( addr1 count1 char -- addr2 count2 )
;
; * headerless selfmodifying
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		lda #$d0		; BNE intruction
		sta l14
skipscan	lda #2
		jsr setup		; count1 -> N0; addr1 -> N1
		stx n+4
		ldx n+2
l13		txa
		ora n+3
		beq l10
		lda (n),y
		eor tos
		asl
l14		bne l10
		iny
		bne l11
		inc n+1
l11		txa
		bne l12
		dec n+3
l12		dex
		jmp l13
l10		stx n+2
		ldx n+4
		clc
		tya
		adc n
		sta tos
		ldy n+1
		bcc l16
		iny
l16		sty tos+1
		ldy n+3
		lda n+2
		jmp push

;--------------------------------------------------------------
;
;	SCAN   ( addr count char -- addr count )
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scanlfa		.word $adde
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		lda #$f0		; BNE intruction
		sta l14
		jmp skipscan

;--------------------------------------------------------------
;
;	EMIT
;
; * 83 device
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp emitvector
emitvector	inc outputted
		bne l130
		inc outputted+1
l130		lda tos
		jsr CHROUT
		jmp pop

;--------------------------------------------------------------
;
;	KEY
;
; * 83 device
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp keyvector
keyvector	stx n
l131		jsr GETIN
		beq l131
		ldx n
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp qtermvector
qtermvector	stx n
		ldy #0
		jsr STOP
		bne l132
		dey
l132		tya
		pha
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	CR
;
; * 83 device
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp crvector
crvector	lda #$0d
		jsr CHROUT
		ldy #0
		sty outputted
		sty outputted+1
		inc linesout
		bne l133
		inc linesout+1
l133		jmp next

;--------------------------------------------------------------
;
;	CMOVE   ( from to howmany -- )
;
; * 83 nucleus
;
;"~ see http://6502.org/source/general/memory_move.html
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		lda #2
		jsr setup	; from -> N0; to -> N1
		stx n+4
		inc tos+1
		ldx tos
		beq l17
l18		lda (n),y
		sta (n+2),y
		iny
		bne l15
		inc n+1
		inc n+3
l15		dex
		bne l18
l17		dec tos+1
		bne l18
		ldx n+4
		jmp pop

;--------------------------------------------------------------
;
;	CMOVE>   ( from to howmany -- )
;
; * 83 nucleus
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		lda #2
		jsr setup
		stx n+7
		lda tos+1
		pha
		clc
		adc n+3
		sta n+3
		pla
		clc
		adc n+1
		sta n+1
		ldy tos
		beq l21
l22		dey
		lda (n+2),y
		sta (n),y
		cpy #0
		bne l22
l21		ldx tos+1
		beq l23
l25		dec n+3
		dec n+1
l24		dey
		lda (n+2),y
		sta (n),y
		cpy #0
		bne l24
		dex
		bne l25
l23		ldx n+7
		jmp pop

;--------------------------------------------------------------
;
;	FILL   ( addr howmany value -- )
;
; * 83 nucleus
;
; 09/15/10 cah
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		lda #2
		jsr setup	; addr -> N0; howmany -> N1
		lda n+2
		ora n+3
		beq l026	; leave if howmany = 0
		lda tos
		ldy n+2
l025		dey
		sta (n),y
		bne l025
		dec n+3
		bpl l025
l026		jmp next

;"~ check http://6502.org/source/ for multiply and divide and stuff
;--------------------------------------------------------------
;
;	UM*   ( u1 u2 -- ud )
;
; * 83 nucleus
;
; multiply u1 times u2 returning the double length product ud.
; All values and arithmetic are unsigned.
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		lda stackl,x
		sta n+4
		lda stackh,x		;multiplicand in tos
		sta n+5			;multiplier in N2
		jsr multiply		;16 bit unsigned multiply
		lda n
		sta stackl,x
		lda n+1
		sta stackh,x
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		jmp next

multiply	lda #0			; unsigned multiply tos*N2 destroys tos
		sta n+2			;clear upper half of product
		sta n+3
		ldy #16
rshift		lsr tos+1
		ror tos
		bcc rrot		;Go rotate right if c = 0
		clc			; and add multiplicand to
		lda n+2			;Get upper half of product
		adc n+4			; it
		sta n+2
		lda n+3
		adc n+5
rrot		ror			;shift partial product right
		sta n+3
		ror n+2
		ror n+1
		ror n
		dey			;Decrement bit count and
		bne rshift
		rts

;--------------------------------------------------------------
;
;	UM/MOD   ( ud u -- rem quot )
;
; * 83 nucleus
;
;	~ needs a lot of work
;"	http://6502.org/source/integers/ummodfix/ummodfix.htm
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	lda #2
		jsr setup	; udhi -> N0; udlo -> N1
modulo		sec
		lda n+2		; Subtract hi cell of dividend by
		sbc n		; divisor to see if there's an overflow condition.
		lda n+3
		sbc n+1
		bcs l039	; Branch if /0 or overflow.
		;clc
		txa
		pha		; preserve data stack pointer
		ldx #16		; loop 16x
l038		rol n+4		; Rotate dividend lo cell left one bit.
		rol n+5
		dex		; loop counter
		bmi l040
		rol n+2
		rol n+3
		lda #0
		sta n+6
		rol n+6
		sec
		lda n+2
		sbc n
		sta n+7
		lda n+3
		sbc n+1
		tay
		lda n+6
		sbc #0
		bcc l038
		lda n+7
		sta n+2
		sty n+3
		bcs l038	; bra
l039		lda #$ff
		sta n+2
		sta n+3
		sta n+4
		sta n+5
l040		pla
		tax
		jmp swap	; more to do here... put stuff back on the stack

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
; * 83 nucleus
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx		lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
; * 83 nucleus
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx		lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
; * 83 nucleus
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor		lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT
;
; * 83 nucleus
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		txa
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	SP!
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		ldy #usersp0-userarea
		lda (up),y
		tax
		jmp next

;--------------------------------------------------------------
;
;	RP!
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		stx n
		ldy #userrp0-userarea
		lda (up),y
		tax
		txs
		ldx n
		jmp next

;--------------------------------------------------------------
;
;	EXIT
;
; * 83 nucleus
;
;		[RP+] -> IP
;		NEXT
; 09/15/10 cah
exitlfa		.word $adde
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
exit		pla
		sta ip
		pla
		sta ip+1	; [RP+] -> IP
		jmp next	; NEXT

;--------------------------------------------------------------
;
;	>R   ( n -- )
;
; * 83 nucleus
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		lda tos+1
		pha
		lda tos
		pha
		jmp pop

;--------------------------------------------------------------
;
;	R>   ( -- n )
;
; * 83 nucleus
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		pla
		sta n
		pla
		tay
		lda n
		jmp push

;--------------------------------------------------------------
;
;	R@   ( -- n )
;
; * 83 nucleus
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		stx n
		tsx
		ldy $0102,x
		lda $0101,x
		ldx n
		jmp push

;--------------------------------------------------------------
;
;	0>   ( n -- flag )
;
; * 83 nucleus
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		ldy #$ff
		bit tos+1
		bpl l022
		iny
l022		tya
		jmp put

;--------------------------------------------------------------
;
;	<>   ( n1 n2 -- flag )
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		ldy #$ff		; assume inequality
		lda tos
		eor stackl,x
		bne l021
		lda tos+1
		eor stackh,x
		bne l021
		iny			; they're equal
l021		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	ON   ( addr -- )
;
; store -1 at ADDR
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		ldy #0
		sta (tos),y
		iny
		sta (tos),y
		jmp pop

;--------------------------------------------------------------
;
;	OFF
;
; store 0 at ADDR
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+
;
; * 83 nucleus
;
; 09/15/10 cah
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;	
;	D+
;
; * 83 nucleus
;
dpluslfa	.word $adde
		.byt (dplus-*-1)|bit7
		.asc "D","+"|bit7
dplus		clc
		lda stackl,x
		adc stackl+2,x
		sta stackl+2,x
		lda stackh,x
		adc stackh+2,x
		sta stackh+2,x
		lda tos
		adc stackl+1,x
		sta stackl+1,x
		lda tos+1
		adc stackh+1,x
		sta stackh+1,x
		jmp poptwo

;--------------------------------------------------------------
;
;	D<
;
; * 83 nucleus
;
dltlfa		.word $adde
		.byt (dlt-*-1)|bit7
		.asc "D","<"|bit7
dlt		ldy #0		; false
		jsr dcmp
		bvc l43
		eor #$80
l43		bpl l44
		dey		; true
l44		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next
dcmp		sec
		lda stackl+2,x
		sbc stackl,x
		lda stackh+2,x
		sbc stackh,x
		lda stackl+1,x
		sbc tos
		lda stackh+1,x
		sbc tos+1
		rts
	
;--------------------------------------------------------------
;
;	NEGATE
;
; * 83 nucleus
;
; 09/15/10 cah
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		jsr donegate
		jmp next
donegate	sec
neg2		lda #0
		sbc tos
		sta tos
		lda #0
		sbc tos+1
		sta tos+1
		rts

;--------------------------------------------------------------
;
;	DNEGATE   ( d -- -d )
;
; * 83 nucleus
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		jsr dodnegate
		jmp next
dodnegate	sec
		lda #0
		sbc stackl,x
		sta stackl,x
		lda #0
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER
;
; * 83 nucleus
;
; 09/15/10 cah
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp push

;--------------------------------------------------------------
;
;	DROP
;
; * 83 nucleus
;
droplfa		.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pop

;--------------------------------------------------------------
;
;	SWAP
;
; * 83 nucleus
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP
;
; * 83 nucleus
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp push

;--------------------------------------------------------------
;
;	+!   ( n addr -- )
;
; * 83 nucleus
;
; add N to the cell at ADDR
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	ldy #0
		clc
		lda stackl,x
		adc (tos),y
		sta (tos),y
		iny
		lda stackh,x
		adc (tos),y
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		lda stackl,x
		sta n
		lda stackh,x
		sta n+1
		ldy #0
		lda (n),y
		eor tos
		sta (n),y
		jmp poptwo

;--------------------------------------------------------------
;
;	@   ( addr -- n )
;
; * 83 nucleus
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #0
		lda (tos),y
		sta n
		iny
		lda (tos),y
		sta tos+1
		lda n
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	C@   ( addr -- 8b )
;
; * 83 nucleus
;
; "c-fetch" 
; 8b is the contents of the byte at addr.
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		ldy #0
		lda (tos),y
		sta tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!   ( 16b addr -- )
;
; * 83 nucleus
;
; "store" 
; 16b is stored at addr.
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		ldy #0
		lda stackl,x
		sta (tos),y
		iny
		lda stackh,x
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!   ( 16b addr -- )
;
; * 83 nucleus
;
; "c-store"
; The least-significant 8 bits of 16b are stored into the byte
; at addr.
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		ldy #0
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;"	:   ( -- sys )
;
; * 83 compiler
;
; "colon"
;" A defining word executed in the form: 
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed. 
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
colonlfa	.word $adde
		.byt (_colon-*-1)|bit7
		.asc ":"|bit7
_colon		.word _storecsp
		.word current
		.word fetch
		.word context
		.word store
		.word _create
		.word _smudge
		.word _rbracket
		.word _psemi
;--------------------------------------------------------------
;
;	ENTER
;
;		IP -> -[RP]
;		W -> IP
;		NEXT
;
enter		pla		;[4]
		tay		;[2]
		pla		;[4]
		sta n+1		;[3]
		lda ip+1	;[3]
		pha		;[3]
		lda ip		;[3]
		pha		;[3]
		lda n+1		;[3]
		sta ip+1	;[3]
		iny		;[2]
		beq l001	;[2]
l002		sty ip		;[3]
		jmp nexto	;[3]
l001		inc ip+1
		bne l002

;--------------------------------------------------------------
;
;	;   ( -- )
;
; * 83 compiler
;
semilfa		.word $adde
		.byt (semi-*-1)|bit7|bit6
		.asc ";"|bit7
semi
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word exit
#include "page.i65"
		.word _smudge
#include "page.i65"
		.word _lbracket
		.word exit

;--------------------------------------------------------------
;
;	CONSTANT   ( -- n )
;
; * 83 compiler
;
constantlfa	.word $adde
		.byt (_constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
_constant
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
; 09/15/10 cah
doconst		pla
		sta n
		pla
		sta n+1
		ldy #2
		lda (n),y
		sta n+2		; high byte
		dey
		lda (n),y	; low byte
		ldy n+2
		jmp push

;--------------------------------------------------------------
;
;	VARIABLE
;
; * 83 compiler
;
variablelfa	.word $adde
		.byt (_variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
_variable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	USER
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user
#include "enter.i65"
		.word _constant
#include "page.i65"
		.word _psemi
uservar		pla
		tay
		pla
		sta n+1
		iny
		bne l008
		inc n+1
l008		sty n
		ldy #0
		clc
		lda up
		adc (n),y
		sta n
		lda up+1
		adc #0
		tay
		lda n
		jmp push

;--------------------------------------------------------------
;
;	-1   ( -- -1 )
;
minusonelfa	.word $adde
		.byt (minusone-*-1)|bit7
		.asc "-","1"|bit7
minusone	jmp true

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		jmp false

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		jsr doconst
		.word 1

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jsr doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jsr doconst
		.word 3

;--------------------------------------------------------------
;
;	BL
;
bllfa		.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jsr doconst
		.word $20

;--------------------------------------------------------------
;
;	C/L
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jsr doconst
		.word 64

;--------------------------------------------------------------
;
;	FIRST
;
;~ fix this to read actual top of memory
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jsr doconst
		.word $7000

;--------------------------------------------------------------
;
;	LIMIT
;
;~ fix this to read actual top of memory
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jsr doconst
		.word $8000

;--------------------------------------------------------------
;
;	#BUF
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	#BCQ
;
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jsr doconst
		.word 32

;--------------------------------------------------------------
;
;	B/BUF
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jsr doconst
		.word 1024

;--------------------------------------------------------------
;
;	B/SCR
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	TIB
;
; * 83 interpreter
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jsr doconst
		.word $0100

;--------------------------------------------------------------
;
;	TRUE
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		lda #$ff
		tay
		jmp push

;--------------------------------------------------------------
;
;	FALSE
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		lda #0
		tay
		jmp push

;--------------------------------------------------------------
;
;	0=
;
; * 83 nucleus
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		ldy #$ff
		lda tos
		ora tos+1
		beq l031
		iny
l031		tya
		jmp put

;--------------------------------------------------------------
;
;	0<
;
; * 83 nucleus
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		ldy #0
		bit tos+1
		bpl l032
		dey
l032		tya
		jmp put

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		beq l033
		lda #$ff
l033		tay
			jmp put

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (_plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
_plusorigin	
#include "enter.i65"
		.word plit
		.word userarea
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (sp0-*-1)|bit7
		.asc "SP","0"|bit7
sp0		jsr uservar
		.byt usersp0-userarea

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rp0-*-1)|bit7
		.asc "RP","0"|bit7
rp0		jsr uservar
		.byt userrp0-userarea

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr uservar
		.byt userwidth-userarea

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr uservar
		.byt userwarning-userarea

; ^ warm
; |
;  >  user variables pre-initialized from the dictionary
; |
; v cold

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr uservar
		.byt userfence-userarea

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jsr uservar
		.byt userdp-userarea

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr uservar
		.byt uservoclink-userarea

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr uservar
		.byt userviewquery-userarea

;--------------------------------------------------------------
;
;	BLK   ( -- addr )
;
; * 83 interpreter
;
; The address of a variable containing the number of the mass
; storage block being interpreted as the input stream.  If the
; value of BLK is zero the input stream is taken from the text
; input buffer.  {{0..the number of blocks available -1}}
; -1 = cassette tape 1 ~
; -2 = cassette tape 2 ~
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr uservar
		.byt userblk-userarea

; ^ cold
; |
;  >  user variables pre-initialized from the dictionary
; |
; v soft
;
; user variables beyond this point are not pre-initialized from the dictionary
;

;--------------------------------------------------------------
;
;	>IN   ( -- addr )
;
; * 83 interpreter
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The address of a user variable which contains the present
; character offset within the input stream.  See: WORD
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr uservar
		.byt 24

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr uservar
		.byt 26

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr uservar
		.byt 28

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr uservar
		.byt 30

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr uservar
		.byt 32

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr uservar
		.byt 34

;--------------------------------------------------------------
;
;	STATE
;
; * 83 compiler
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr uservar
		.byt 36

;--------------------------------------------------------------
;
;	BASE
;
; * 83 interpreter
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr uservar
		.byt 38

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr uservar
		.byt 40

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; * 83 interpreter
;
; Returns the address of the user variable that
; contains the count of characters received and
; stored by the most recent execution of EXPECT .
span		jsr uservar
		.byt 42

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr uservar
		.byt 44

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr uservar
		.byt 46

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr uservar
		.byt 48

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jsr uservar
		.byt 50

;--------------------------------------------------------------
;
;	#TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}  See:  "input stream"
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr uservar
		.byt 52

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr uservar
		.byt 54

;--------------------------------------------------------------
;
;	1+
;
; * 83 nucleus
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		inc tos
		bne l027
		inc tos+1
l027		jmp next

;--------------------------------------------------------------

;
;	1-
;
; * 83 nucleus
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	bit tos
		bne l028
		dec tos+1
l028		dec tos
		jmp next

;--------------------------------------------------------------
;
;	2+
;
; * 83 nucleus
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		clc
		lda tos
		adc #2
		sta tos
		bcc l029
		inc tos+1
l029		jmp next

;--------------------------------------------------------------
;
;	2-
;
; * 83 nucleus
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	sec
		lda tos
		sbc #2
		sta tos
		bcs l030
		dec tos+1
l030		jmp next

;--------------------------------------------------------------
;
;	2/
;
; * 83 nucleus
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	lsr tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		asl tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	HERE
;
; * 83 interpreter
;
herelfa		.word $adde
		.byt (_here-*-1)|bit7
		.asc "HER","E"|bit7
_here		ldy #(userdp-userarea)
		lda (up),y
		pha
		iny
		lda (up),y
		tay
		pla
		jmp push

;--------------------------------------------------------------
;
;	ALLOT
;
; * 83 compiler
;
allotlfa	.word $adde
		.byt (_allot-*-1)|bit7
		.asc "ALLO","T"|bit7
_allot
#include "enter.i65"
		.word dp
#include "page.i65"
		.word plusstore
		.word exit

;--------------------------------------------------------------
;
;	,
;
; * 83 compiler
;
commalfa	.word $adde
		.byt (_comma-*-1)|bit7
		.asc ","|bit7
_comma
#include "enter.i65"
		.word _here
#include "page.i65"
		.word store
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (_ccomma-*-1)|bit7
		.asc "C",","|bit7
_ccomma
#include "enter.i65"
		.word _here
#include "page.i65"
		.word cstore
#include "page.i65"
		.word one
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	-
;
; * 83 nucleus
;
; 09/15/10 cah
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr donegate
		jmp plus

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
; * 83 nucleus
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		ldy #0
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	U<
;
; * 83 nucleus
;
;09/16/10 cah
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
; * 83 nucleus
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
sgntst		bvc l012
		eor #bit7
l012		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
; * 83 nucleus
;
; V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc ">"|bit7
gt		ldy #0
		lda tos
		cmp stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT   ( a b c -- b c a )
;
; * 83 nucleus
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		ldy stackh+1,x
		lda stackh,x
		sta stackh+1,x
		lda tos+1
		sta stackh,x
		sty tos+1
		ldy stackl+1,x
		lda stackl,x
		sta stackl+1,x
		lda tos
		sta stackl,x
		sty tos
		jmp next

;--------------------------------------------------------------
;
;	LROT   ( a b c -- c a b )
;
lrotlfa		.word $adde
		.byt (lrot-*-1)|bit7
		.asc "LRO","T"|bit7
lrot		ldy tos+1	; c
		lda stackh,x
		sta tos+1	; b -> tos
		lda stackh+1,x
		sta stackh,x	; a -> 2os
		sty stackh+1,x	; c -> 3os
		ldy tos
		lda stackl,x
		sta tos
		lda stackl+1,x
		sta stackl,x
		sty stackl+1,x
		jmp next

;--------------------------------------------------------------
;
;	SPACE
;
; * 83 device
;
spacelfa	.word $adde
		.byt (_space-*-1)|bit7
		.asc "SPAC","E"|bit7
_space
#include "enter.i65"
		.word bl
#include "page.i65"
		.word emit
		.word exit

;--------------------------------------------------------------
;
;	?DUP   ( 0 -- 0 | n -- n n )
;
; * 83 nucleus
;
; DUP if top of stack is nonzero
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		lda tos
		ora tos+1
		beq l034
		lda tos
		ldy tos+1
		jmp push
l034		jmp next

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; * dictionary
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE	( addr n -- addr )
;"	SWAP
;"	BEGIN
;"		OVER +  127  OVER C@  <
;"	UNTIL
;"	SWAP DROP ;
traverselfa	.word $adde
		.byt (_traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
_traverse
#include "enter.i65"
		.word swap
#include "page.i65"
l010		.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $7f
#include "pad.i65"
		.word over
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l010
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (_latest-*-1)|bit7
		.asc "LATES","T"|bit7
_latest
#include "enter.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	FORTH-83
;
; * 83 interpreter
;
; ~ make sure it's really Forth-83 compliant before making this word available
;
forth83lfa	.word $adde
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jmp next

; ~ better to follow ANS-Forth standard for this group?
;--------------------------------------------------------------
;
;	>BODY   ( cfa -- pfa )
;
; * 83 interpreter
;
; convert the compilation address (CFA) to the address of the parameter field.
tobodylfa	.word $adde
		.byt (_tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
_tobody
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt (_toname-*-1)|bit7
		.asc ">NAM","E"|bit7
_toname
#include "enter.i65"
		.word oneminus
#include "page.i65"
		.word minusone
#include "page.i65"
		.word _traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt (_tolink-*-1)|bit7
		.asc ">LIN","K"|bit7
_tolink
#include "enter.i65"
		.word _toname
#include "page.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>   ( PFA -- CFA )
;
bodyfromlfa	.word $adde			; ~ Blazin
		.byt (_bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
_bodyfrom
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	NAME>   ( nfa -- cfa )
;
namefromlfa	.word $adde
		.byt (_namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
_namefrom
#include "enter.i65"
		.word one
#include "page.i65"
		.word _traverse
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	LINK>   ( lfa -- cfa )
;
linkfromlfa	.word $adde
		.byt (_linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
_linkfrom
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word _namefrom
		.word exit

;--------------------------------------------------------------
;
;	N>LINK   ( nfa -- lfa )
;
ntolinklfa	.word $adde
		.byt (_ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
_ntolink
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	L>NAME   ( lfa -- nfa )
;
linktonamelfa	.word $adde
		.byt (_linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
_linktoname
#include "enter.i65"
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (_storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
_storecsp
#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (_where-*-1)|bit7
		.asc "WHER","E"|bit7
_where
#include "enter.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l58
#include "page.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word scr
#include "page.i65"
		.word store
#include "page.i65"
		.word cr
#include "page.i65"
		.word cr
#include "page.i65"
#if ((* & $ff) = 253-5)
	.word next
#endif
		.word _pdotq
		.byt s001-*-1
		.asc	"SCR# "
			;12345
s001
#include "page.i65"
		.word dup
#include "page.i65"
		.word _dot
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word _min
#include "page.i65"
		.word cperl
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word dup
#include "page.i65"
#if ((* & $ff) = 253-6)
	.word next
#endif
		.word _pdotq
		.byt s002-*-1
		.asc	"LINE# "
			;123456
s002
#include "page.i65"
		.word _dot
#include "page.i65"
		.word cperl
#include "page.i65"
		.word star
#include "page.i65"
		.word rot
#include "page.i65"
		.word _block
#include "page.i65"
		.word plus
#include "page.i65"
		.word cr
#include "page.i65"
		.word cr
#include "page.i65"
		.word cperl
#include "page.i65"
		.word _dashtrailing
#include "page.i65"
		.word type
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word gt
#include "page.i65"
		.word plus
#include "page.i65"
		.word branch
		.word l59
#include "page.i65"
l58		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
l59		.word cr
#include "page.i65"
		.word _here
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word minus
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word minus
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l60		.word clit
		.asc '^'
#include "pad.i65"
		.word emit
#include "page.i65"
		.word ploop
		.word l60
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	(ABORT")
;
; * outer interpreter headerless
;
;pabortqlfa	.word $adde
;		.byt (_pabortq-*-1)|bit7
;		.asc "(ABORT",'"',")"|bit7
_pabortq
#include "enter.i65"
		.word qbranch
		.word l61
#include "page.i65"
		.word cmdoff
#include "page.i65"
		.word _where
#include "page.i65"
		.word cr
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word count
#include "page.i65"
		.word type
#include "page.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
#include "page.i65"
		.word branch
		.word l62
#include "page.i65"
l61		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word tor
l62		.word exit

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (_commadollar-*-1)|bit7
		.asc ",","$"|bit7
_commadollar
#include "enter.i65"
		.word swap
#include "page.i65"
		.word over
#include "page.i65"
		.word _here
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word cstore
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	ABORT"
;
; * 83 compiler
;
; ~ handle page boundary crossings
abortqlfa	.word $adde
		.byt (_abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
_abortq
#include "enter.i65"
		.word _compile
		.word _pabortq
#include "page.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (_qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
_qcomp
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
#if ((* & $ff) = 253-35)
	.word next
#endif
		.word _pabortq
		.byt s003-*-1
		.asc	"COMPILATION ONLY, USE IN DEFINITION"
			;123456789.123456789.123456789.12345
s003		.word exit

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (_qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
_qfind
#include "enterx.i65"
#if ((* & $ff) = 253-27)
	.word next
#endif
		.word _pabortq
		.byt s004-*-1
		.asc	"NOT IN CURRENT SEARCH ORDER"
			;123456789.123456789.1234567
s004		.word exit

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (_qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
_qpairs
#include "enter.i65"
		.word minus
#include "page.i65"
#if ((* & $ff) = 253-23)
	.word next
#endif
		.word _pabortq
		.byt s005-*-1
		.asc	"CONDITIONALS NOT PAIRED"
			;123456789.123456789.123
s005		.word exit

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (_qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
_qcsp
#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
#if ((* & $ff) = 253-23)
	.word next
#endif
		.word _pabortq
		.byt s006-*-1
		.asc	"DEFINITION NOT FINISHED"
			;123456789.123456789.123
s006		.word exit

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (_qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
_qchar
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _tickstream
#include "page.i65"
		.word over
#include "page.i65"
		.word swap
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word scan
#include "page.i65"
		.word drop
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word tor
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word toin
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word l63
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word cr
#include "page.i65"
		.word emit
#include "page.i65"
#if ((* & $ff) = 253-9)
	.word next
#endif
		.word _pdotq
		.byt s017-*-1
		.asc	" MISSING "
			;123456789
s017		.word spstore
#include "page.i65"
		.word _quit
#include "page.i65"
l63		.word rfrom
#include "page.i65"
		.word drop
		.word exit


;--------------------------------------------------------------
;
;	COMPILE
;
; * 83 compiler
;
compilelfa	.word $adde
		.byt (_compile-*-1)|bit7
		.asc "COMPIL","E"|bit7

_compile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word tor
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	[
;
; * 83 compiler
;
lbracketlfa	.word $adde
		.byt (_lbracket-*-1)|bit7
		.asc "["|bit7
_lbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	]
;
; * 83 compiler
;
rbracketlfa	.word $adde
		.byt (_rbracket-*-1)|bit7
		.asc "]"|bit7
_rbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word on
#include "page.i65"
l68		.word qstack
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word dup
#include "page.i65"
		.word qbranch
		.word l64
#include "pad.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word l65
#include "pad.i65"
		.word _comma
#include "page.i65"
		.word branch
		.word l66
#include "pad.i65"
l65		.word execute
#include "page.i65"
		.word branch
		.word l66
#include "pad.i65"
l64		.word drop
#include "page.i65"
		.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word l67
#include "pad.i65"
		.word _dliteral
#include "page.i65"
		.word branch
		.word l66
#include "pad.i65"
l67		.word drop
#include "page.i65"
		.word _literal
#include "page.i65"
l66		.word true
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word l68
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (_smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
_smudge
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt bit5	; $20
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (_hex-*-1)|bit7
		.asc "HE","X"|bit7
_hex
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DECIMAL
;
; * 83 interpreter
;
decimallfa	.word $adde
		.byt (_decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
_decimal
#include "enter.i65"
		.word clit
		.byt 10
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(;CODE)
;
;psemilfa	.word $adde
;		.byt (_psemi-*-1)|bit7
;		.asc "(;CODE",")"|bit7
_psemi
#include "enter.i65"
		.word rfrom
#include "page.i65"
		.word _latest
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DOES>
;
; * 83 compiler
;
doeslfa		.word $adde
		.byt (_does-*-1)|bit7
		.asc "DOES",">"|bit7
_does
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word _psemi
#include "pad.i65"
		.word clit
		.byt $20	; jsr instruction
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word _compile	; ~ fix paging here
		.word dodoes
#include "pad.i65"
		.word exit
; I've got a pretzel in my brain!
dodoes		pla
		sta n
		pla
		sta n+1
		pla
		sta n+2
		pla
		sta n+3
		lda ip+1
		pha
		lda ip
		pha
		ldy n
		bne l067
		dec n+1
l067		dey
		sty ip
		lda n+1
		sta ip+1
		ldy n+3
		inc n+2
		bne l068
		iny
l068		lda n+2
		jmp push

;--------------------------------------------------------------
;
;	-TRAILING
;
; * 83 interpreter
;
dashtrailinglfa	.word $adde
		.byt (_dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
_dashtrailing
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l72		.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word pqleave
		.word l73
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word ploop
		.word l72
l73		.word exit

;--------------------------------------------------------------
;
;	(.")
;
; * headerless
;
;pdotqlfa	.word $adde
;		.byt (_pdotq-*-1)|bit7
;		.asc "(.",'"',")"|bit7
_pdotq
#include "enter.i65"
		.word rfetch
#include "page.i65"
		.word twoplus		; because we pre-increment?
#include "page.i65"
		.word count
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
#include "page.i65"
		.word tor
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; * 83 nucleus
;
; Leaves the address, addr2 and the character
; count +n of text beginning at addr1.
; addr2 is addr1+1 and n1 is the length of the
; counted string at addr1.  The byte at addr1 con-
; tains the byte count +n.  Range of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		ldy #0
		lda (tos),y
		inc tos
		bne l020
		inc tos+1
l020		jmp push

;--------------------------------------------------------------
;
;	TYPE   ( addr count -- )
;
; * 83 device
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		lda #1
		jsr setup
		clc
		lda tos
		adc outputted
		sta outputted
		lda tos+1
		adc outputted+1
		sta outputted+1
l041		cpy tos
		bne l042
		dec tos+1
		bpl l042
		jmp pop
l042		lda (n),y
		jsr CHROUT
		iny
		bne l041
		inc n+1
		bne l041

;--------------------------------------------------------------
;
;	."   ( -- )
;
; * 83 compiler
;
dotqlfa		.word $adde
		.byt (_dotq-*-1)|bit7
		.asc ".",'"'|bit7
_dotq
#include "enter.i65"
		.word _compile
		.word _pdotq
#include "pad.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	.(
;
; * 83 interpreter
;
dotplfa		.word $adde
		.byt (_dotp-*-1)|bit7
		.asc ".","("|bit7
_dotp
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word type 
		.word exit

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp expectvector
expectvector	lda #1
		jsr setup
		sty inputted+1
		stx n+7
		dey
l74		iny
		cpy tos
		bcs l75
		jsr CHRIN
		cmp #$0d
		beq l75
		sta (n),y
		bne l74
l75		sty inputted		; ~ direct uarea ref breaks multitasking
		ldx n+7
		jmp pop

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (_query-*-1)|bit7
		.asc "QUER","Y"|bit7
_query
#include "enter.i65"
		.word tib
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word expect
#include "page.i65"
		.word span
#include "page.i65"
		.word fetch
#include "page.i65"
		.word numtib
#include "page.i65"
		.word store
#include "page.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word toin
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	" "
;
;spacenplfa	.word $adde
;		.byt (_spacenp-*-1)|bit7|bit6
;		.asc " "|bit7
;_spacenp
;#include "enter.i65"
;		.word doneq
;#include "page.i65"
;		.word on
;		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (_quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
_quitq
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word doneq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word orx
#include "page.i65"
		.word doneq
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	ERASE
;
; 09/15/10 cah
eraselfa	.word $adde
		.byt (_erase-*-1)|bit7
		.asc "ERAS","E"|bit7
_erase
#include "enter.i65"
		.word zero
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (_blank-*-1)|bit7
		.asc "BLAN","K"|bit7
_blank
#include "enter.i65"
		.word bl
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	HOLD
;
; * 83 interpreter
;
holdlfa		.word $adde
		.byt (_hold-*-1)|bit7
		.asc "HOL","D"|bit7
_hold
#include "enter.i65"
		.word true
#include "page.i65"
		.word hld
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	PAD
;
; * 83 interpreter
;
padlfa		.word $adde
		.byt (_pad-*-1)|bit7
		.asc "PA","D"|bit7
_pad
#include "enter.i65"
		.word _here
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	'STREAM   ( -- 
;
;" : 'stream
;	blk @ ?dup
;	if	block b/buf
;	else	tib #tib @
;	then
;	>in @ over min >r swap r@ + swap r> - ;
tickstreamlfa	.word $adde
		.byt (_tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
_tickstream
#include "enter.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup		; ( 0 | blk blk )
#include "page.i65"
		.word qbranch		; if
		.word l76
#include "page.i65"
		.word _block		; ( addr )
#include "page.i65"
		.word bperbuf		; ( addr b/buf )
#include "page.i65"
		.word branch		; else
		.word l77
#include "page.i65"
l76		.word tib		; ( tib )
#include "page.i65"
		.word numtib
#include "page.i65"
		.word fetch		; ( tib #tib )
#include "page.i65"			; then
l77		.word toin		; ( addr size >in )
#include "page.i65"
		.word fetch		; ( addr size ptr )
#include "page.i65"
		.word over		; ( addr size ptr size )
#include "page.i65"
		.word _min		; ( addr size ptr )
#include "page.i65"
		.word tor		; ( addr size )
#include "page.i65"
		.word swap		; ( size addr )
#include "page.i65"
		.word rfetch		; ( size addr ptr )
#include "page.i65"
		.word plus		; ( size addr )
#include "page.i65"
		.word swap		; ( addr size )
#include "page.i65"
		.word rfrom		; ( addr size ptr )
#include "page.i65"
		.word minus		; ( addr remaining )
		.word exit

;--------------------------------------------------------------
;
;	WORD   ( char -- addr )
;
; * 83 interpreter
;
; Generates a counted string by non-destructively accepting
; characters from the input stream until the delimiting
; character char is encountered or the input stream is
; exhausted.  Leading delimiters are ignored.  The entire
; character string is stored in memory beginning at addr as a
; sequence of bytes.  The string is followed by a blank which
; is not included in the count.  The first byte of the string
; is the number of characters {0..255}.  If the string is
; longer than 255 characters, the count is unspecified.  If
; the input stream is already exhausted as WORD is called,
; then a zero length character string will result.
;
; If the delimiter is not found the value of >IN is the size
; of the input stream.  If the delimiter is found >IN is
; adjusted to indicate the offset to the character following
; the delimiter.  #TIB is unmodified. 		; ( 0100 0104 0107 0009 ) 
;
; The counted string returned by WORD may reside in the "free"
; dictionary area at HERE or above.  Note that the text
;"interpreter may also use this area.  See: "input stream"
;
; fig high level
;" : word   ( c -- addr )
;	blk @  if  blk @ block  else  tib @  then
;	>in @ + swap enclose here 34 blank >in +!
;	over - >r r@ here c! + here 1+ r> cmove ;
;
; blazin' high level
;" : 'stream
;	blk @ ?dup			; ( 0 | blk )
;	if  block b/buf
;	else  tib #tib fetch
;	then				; ( addr size )
;	>in fetch			; ( addr size pointer )
;	over min			; ( addr pointer )
;	>r swap				
;	r@ + swap
;	r> - ;
;" : skip
;
;" : scan
;
;" : word   ( c -- nfa )
;	>r				; ( -- ) r( c )
;	'stream
;	over swap
;	r@ skip
;	over swap
;	r> scan
;	drop over over swap -
;	>r
;	rot - 1+
;	>in +!
;	r> here
;	over over c!
;	1+ swap cmove
;	here dup count +
;	bl swap c! ;
wordlfa		.word $adde
		.byt (_word-*-1)|bit7
		.asc "WOR","D"|bit7
_word
#include "enter.i65"
		.word tor		; ( addr )
#include "page.i65"
		.word _tickstream	; ( addr addr size )
#include "page.i65"
		.word over		; ( addr addr size addr )
#include "page.i65"
		.word swap		; ( addr addr addr size )
#include "page.i65"
		.word rfetch		; ( addr addr addr size char )
#include "page.i65"
		.word skip		; ( addr addr size )
#include "page.i65"
		.word over		; ( addr addr size addr )
#include "page.i65"
		.word swap		; ( addr addr addr size )
#include "page.i65"
		.word rfrom		; ( addr addr addr size char )
#include "page.i65" 
		.word scan		; ( addr addr size )
#include "page.i65"		; ( 0100 0104 0107 0009 ) ~
		.word drop		; ( addr addr )
#include "page.i65"
		.word over
#include "page.i65"
		.word over		; 
#include "page.i65"
		.word swap
#include "page.i65"
		.word minus
#include "page.i65"
		.word tor
#include "page.i65"
		.word rot
#include "page.i65"
		.word minus
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word toin
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word _here
#include "page.i65"
		.word over
#include "page.i65"
		.word over
#include "page.i65"
		.word cstore
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word _here
#include "page.i65"
		.word dup
#include "page.i65"
		.word count
#include "page.i65"
		.word plus
#include "page.i65"
		.word bl
#include "page.i65"
		.word swap
#include "page.i65"
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	(PUNCT?)
;
;ppunctqlfa	.word $adde
;		.byt (_ppunctq-*-1)|bit7
;		.asc "(PUNCT?",")"|bit7
_ppunctq
#include "enter.i65"
		.word clit
		.byt '.'
#include "pad.i65"
		.word eq
		.word exit

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (_punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
_punctq
#include "enter.i65"
		.word _ppunctq
		.word exit


;--------------------------------------------------------------
;
;	CONVERT
;
; * 83 interpreter
;
convertlfa	.word $adde
		.byt (_convert-*-1)|bit7
		.asc "CONVER","T"|bit7
_convert
#include "enter.i65"
l81		.word oneplus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word l80
#include "page.i65"
		.word swap
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word drop
#include "page.i65"
		.word rot
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word dplus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word l82
#include "page.i65"
		.word one
#include "page.i65"
		.word dpl
#include "page.i65"
		.word plusstore
#include "page.i65"
l82		.word rfrom
#include "page.i65"
		.word branch
		.word l81
#include "page.i65"
l80		.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	NUMBER
;
numberlfa	.word $adde
		.byt (_number-*-1)|bit7
		.asc "NUMBE","R"|bit7
_number
#include "enter.i65"
		.word true
#include "page.i65"
		.word over
#include "page.i65"
		.word count
#include "page.i65"
		.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word swap
#include "page.i65"
		.word pqdo
		.word l83
#include "page.i65"
l84		.word i
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word l87
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word pleave
		.word l83
#include "page.i65"
l87		.word ploop
		.word l84
#include "page.i65"
l83		.word _qfind
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word rot
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word clit
		.byt '-'
#include "pad.i65"
		.word eq
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word minus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word on
#include "page.i65"
l85		.word _convert
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word _punctq
#include "page.i65"
		.word qbranch
		.word l88
#include "page.i65"
		.word dpl
#include "page.i65"
		.word off
#include "page.i65"
		.word branch
		.word l85
#include "page.i65"
l88		.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word _qfind
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word l86
#include "page.i65"
		.word dnegate
l86		.word exit

;--------------------------------------------------------------
;
;	FIND   ( addr1 -- addr2 n )
;
; * 83 interpreter
;
; addr1 is the address of a counted string.  The string
; contains a word name to be located in the currently active
; search order.  If the word is not found, addr2 is the string
; address addr1, and n is zero.  If the word is found, addr2
; is the compilation address and n is set to one of two non-
; zero values.  If the word found has the immediate attribute,
; n is set to one.  If the word is non-immediate, n is set to
; minus one (true).
;
findlfa		.word $adde
		.byt (_find-*-1)|bit7
		.asc "FIN","D"|bit7
_find
#include "enter.i65"
		.word context
#include "page.i65"
		.word fetch
; ~ determine here whether we're in FORTH
; something like  FORTH?  IF  DHASH@  THEN 

#include "page.i65"
		.word fetch
#include "page.i65"
		.word pfind
#include "page.i65"
		.word dup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word l89
#include "page.i65"
		.word drop
#include "page.i65"
		.word _latest
#include "page.i65"
		.word pfind
l89		.word exit

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (_existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
_existsq
#include "enter.i65"
		.word bl		; ( c )
#include "page.i65"
		.word _word		; ( nfa )
#include "page.i65"
		.word _find		; ( nfa true | here false )
		.word exit

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (_iddot-*-1)|bit7
		.asc "ID","."|bit7
_iddot
#include "enter.i65"
		.word _pad
#include "page.i65"
		.word clit
		.byt 32
#include "pad.i65"
		.word clit
		.asc '*'
#include "pad.i65"
		.word fill
#include "page.i65"
		.word dup
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _pad
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word _pad
#include "page.i65"
		.word count
#include "page.i65"
		.word clit
		.byt $1f		; ~ shouldn't this use WIDTH?
#include "pad.i65"
		.word andx
;#include "page.i65"
;		.word _twodup
;#include "page.i65"
;		.word tolower		; ~ really?
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	CREATE
;
; * 83 compiler
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"	@ + + u< (abort") dictionary full exists?
;"	over (lit) 6017 = (abort") name required
;"	warning @ and ?branch 41 >name cr
;"	18 emit id. 146 emit (.") already exists
;"	branch 4 drop here dup c@
;"	over 2+ view? @ + dup >r swap 1+ cmove>
;"	r> dup c@ width @ min 1+ 2dup + 255
;"	and 255 = ?branch 25 2dup swap
;"	dup 1+ rot cmove> 234 c, swap 1+
;"	swap 2+ view? @ + allot dup 128 toggle
;"	here 1- 128 toggle latest over
;"	2- ! view? @ ?branch 14 blk @ over 2-
;"	2- ! 2 allot current @ ! (;code)
;".C:1b0b	18		CLC
;".C:1b0c	A5 87		LDA $87
;".C:1b0e	69 02		ADC #$02
;".C:1b10	48		PHA
;".C:1b11	98		TYA
;".C:1b12	65 88		ADC $88
;".C:1b14	4C 4A 08	JMP $084A
;
createlfa	.word $adde
		.byt (_create-*-1)|bit7
		.asc "CREAT","E"|bit7
_create
#include "enter.i65"
		.word _ltbcq
#include "page.i65"
		.word _here
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word plus
#include "page.i65"
		.word ult
#include "page.i65"
#if ((* & $ff) = 253-15)
	.word next
#endif
		.word _pabortq
		.byt l013-*-1
		.asc	"DICTIONARY FULL"
			;123456789.12345
l013
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word over
#include "page.i65"
;		.word plit
;		.word _spacenp		; ~ remove this?
;#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-13)
	.word next
#endif
		.word _pabortq
		.byt l014-*-1
		.asc	"NAME REQUIRED"
			;123456789.123
l014
#include "page.i65"
		.word warning
#include "page.i65"
		.word fetch
#include "page.i65"
		.word andx
#include "page.i65"
		.word qbranch
		.word l016
#include "page.i65"
		.word _toname
#include "page.i65"
		.word cr
#include "page.i65"
		.word clit
		.byt $12	; rvs
#include "pad.i65"
		.word emit
#include "page.i65"
		.word _iddot
#include "page.i65"
		.word clit
		.byt $92	; off
#include "pad.i65"
		.word emit
#include "page.i65"
#if ((* & $ff) = 253-15)
	.word next
#endif
		.word _pdotq
		.byt l015-*-1
		.asc	" ALREADY EXISTS "
			;1234567869.12345
l015
#include "page.i65"
		.word branch
		.word l017
#include "page.i65"
l016		.word drop
#include "page.i65"
l017		.word _here
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _min
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word andx
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word l018
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word swap
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word rot
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word clit
		.byt $ea
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
l018		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word _allot
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word _here
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word _latest
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l019
#include "page.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
l019		.word two
#include "page.i65"
		.word _allot
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word store
		.word _psemi
docreate	pla
		clc
		adc #1
		sta n
		pla
		tay
		bcc l035
		iny
l035		lda n
		jmp push

;--------------------------------------------------------------
;
;	[COMPILE]
;
; * 83 compiler
;
bcompilelfa	.word $adde
		.byt (_bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
_bcompile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _tick
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	LITERAL
;
; * 83 compiler
;
literallfa	.word $adde
		.byt (_literal-*-1)|bit7
		.asc "LITERA","L"|bit7
_literal
#include "enter.i65"
		.word dup
#include "page.i65"
		.word plit
		.word 256
#include "pad.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word l94
#include "page.i65"
		.word _compile
		.word clit
#include "page.i65"
		.word _ccomma
#include "page.i65"
		.word branch
		.word l95
#include "page.i65"
l94		.word _compile
		.word plit
#include "page.i65"
		.word _comma
l95		.word exit

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (_dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
_dliteral
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _literal
#include "page.i65"
		.word _literal
		.word exit

;--------------------------------------------------------------
;
;	?STACK
;
; inspect data stack pointer for sanity, halt with a message if trouble
; a hybrid primitive that jumps up to high-level Forth to invoke ABORT"
qstacklfa	.word $adde
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		txa
		bmi l070	; stack overflow
		ldy #usersp0-userarea
		cmp (up),y
		bcc l069	; things are just fine
		beq l069	; SP@ = bos, not a problem either
		ldy #>(qstackempty-2)	; stack underflow error
		lda #<(qstackempty-2)
		bcs l071	; bra
l070		ldy #>(qstackfull-2)	; stack overflow error
		lda #<(qstackfull-2)
l071		sty ip+1
		sta ip
l069		jmp next
#include "pad.i65"
qstackempty	.word _pabortq		; qstack might transfer control here
		.byt qstackfull-*-1	; no need for an exit because we're
		.asc	"STACK EMPTY "	; not coming back from ABORT"
			;123456789.12
#if ((* & $ff) = $ff)
	.asc " "		; pad with a space (more printable than NOP)
#endif
qstackfull	.word _pabortq
		.byt s012-*-1
		.asc	"STACK OVERFLOW "
			;123456789.12345
s012

;--------------------------------------------------------------
;
;	INTERPRET
;
;
interpretlfa	.word $adde
		.byt (_interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
_interpret
#include "enter.i65"
l99		.word qstack
#include "page.i65"
		.word _existsq		; ( addr flag )
#include "page.i65"
		.word qbranch
		.word l96
#include "page.i65"
		.word execute
#include "page.i65"
		.word branch
		.word l98
#include "page.i65"
l96		.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word zeq
#include "page.i65"
l97		.word qbranch
		.word l98
#include "page.i65"
		.word drop
#include "page.i65"
l98		.word false
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word l99
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	IMMEDIATE
;
; * 83 compiler
;
immediatelfa	.word $adde
		.byt (_immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
_immediate
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt $40
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	VOCABULARY
;
; * 83 compiler
;
; see FD-V05N3 p. 5

vocabularylfa	.word $adde
		.byt (_vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
_vocabulary
#include "enter.i65"
		.word _create
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word _comma
#include "page.i65"
		.word plit
		.word $a081
#include "pad.i65"
		.word _comma
#include "page.i65"
		.word _here
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
		.word _psemi
vocabdoes	jsr dodoes
		.word context
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	FORTH
;
; * 83 interpreter
;
; ~ maybe put a zero instead of ntop, to flag the special handling?
; ntop doesn't seem very useful, at least here
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jsr vocabdoes
		.word ntop		; last nfa in this vocabulary
		.word $a081		; some magic number?
lastvoc		.word 0			; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;	DEFINITIONS
;
; * 83 interpreter
;
definitionslfa	.word $adde
		.byt (_definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
_definitions
#include "enter.i65"
		.word context
#include "page.i65"
		.word fetch
#include "page.i65"
		.word current
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(
;
; * 83 interpreter
;
lparenlfa	.word $adde
		.byt (_lparen-*-1)|bit7
		.asc "("|bit7
_lparen
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (_run-*-1)|bit7
		.asc "RU","N"|bit7
_run
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l100
#include "page.i65"
		.word _rbracket
#include "page.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word not
#include "page.i65"
		.word qbranch
		.word l101
#include "page.i65"
		.word _interpret
#include "page.i65"
		.word branch
		.word l101
#include "page.i65"
l100		.word _interpret
l101		.word exit


;--------------------------------------------------------------
;
;	ABORT
;
; * 83 interpreter
;
abortlfa	.word $adde
		.byt (_abort-*-1)|bit7
		.asc "ABOR","T"|bit7
_abort
#include "enter.i65"
		.word spstore
#include "page.i65"
		.word _quit
		.word exit	; make the decompiler happy

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jsr docreate
		.word _abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
cold		sei
;~debug - leave patterns to make things easier in the debugger
	ldy #<next
	lda #$3e
d000	sta $FFFF,y
	dey
	bne d000

	ldy #bos-1
d001	lda #$bb
	sta stackl,y
	lda #$aa
	sta stackh,y
	dey
	bpl d001

	lda #$cc
	ldy #$07
d002	sta n,y
	dey
	bpl d002

	lda #$dd
	ldy #$03
d003	sta zi,y
	dey
	bpl d003

	lda #$ba
	sta tos+1
	lda #$ab
	sta tos
;~debug
; copy NEXT code to zeropage
		ldy #page-zpnext
l011		lda zpnext-1,y
		sta next-1,y
		dey
		bne l011

		lda #<warmvector
		sta errlnk
		lda #>warmvector
		sta errlnk+1

		lda userntop
		sta forth+3
		lda userntop+1
		sta forth+4
		lda #>_cold2
		sta w1+1
		lda #<_cold2
		sta w1

		ldy #usercold-userarea-1
		bne l036

warm		lda #>_warm2
		sta w1+1
		lda #<_warm2
		sta w1

		ldy #userwarm-userarea-1

l036		lda userup
		sta up
		lda userup+1
		sta up+1
l037		lda userarea,y
		sta (up),y
		dey
		bpl l037
		cld
		cli
		jsr CLRCHN
		jsr CLALL

		lda #>(w1-2)
		sta ip+1
		lda #<(w1-2)
		sta ip

		jmp rpstore		; and we're off
_cold2
#include "enter.i65"
		.word spstore
#include "page.i65"
#if ((* & $ff) = 253-$ee)
	.word next
#endif
		.word _pdotq
		.byt s015-*-1
		.byt CLRSCR
.byt 236,239,17,157,157,234,32,41,17,157,157,157,234,247,17,157,157,252
.byt 32,32,145,145,145
.byt 236,239,251,17,157,157,157,234,17,157,234,247,17,157,157
.byt 252,247,254,145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 239,239,17,157,157,234,17,157,234,17,157
.byt 247,247,145,145,145
.byt 236,17,157,234,17,157,234,17,157,252,247,247,254
.byt 145,145,145
		.asc "6502 FORTH FOR THE"
.byt 17,17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
.byt 157,157,157
		.asc "COMMODORE PET 2001"
.byt 17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "......... ... ...."

		.byt $0d,$0d
		.asc "HTTP:"
		.byt 47,47
		.asc "CHITSELB.COM 2010"
		.byt $0d,$0d
s015
#include "page.i65"
		.word _rethread
#include "page.i65"
_warm2		.word _emptybuffers
#include "page.i65"
		.word _decimal
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
#if ((* & $ff) = 253-19)
	.word next
#endif
		.word _pdotq
		.byt s016-*-1
		.asc	$0d,"WELCOME TO PETTIL!"
			    ;123456789.12345678
s016
#include "page.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
		.word exit

;--------------------------------------------------------------
;
;	QUIT
;
; * 83 interpreter outer
;
quitlfa		.word $adde
		.byt (_quit-*-1)|bit7
		.asc "QUI","T"|bit7
_quit
#include "enter.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word _lbracket
#include "page.i65"
l007		.word rpstore
#include "page.i65"
		.word cr
#include "page.i65"
		.word _query
#include "page.i65"
		.word _interpret
#include "page.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word l006
#include "page.i65"
#if ((* & $ff) = 253-2)
	.word next
#endif
		.word _pdotq
		.byt (l006-*-1)
		.asc	"OK"
			;12
l006
#include "page.i65"
		.word branch
		.word l007

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (_stod-*-1)|bit7
		.asc "S>","D"|bit7
_stod
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zlt
		.word exit

;--------------------------------------------------------------
;
;	ABS
;
; * 83 nucleus
;
abslfa		.word $adde
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs	;	lda stack+1,x
		bpl l106
		jmp negate+2
l106		jmp next

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs	;	lda stack+1,x
		bpl l106
		jmp dnegate+2

;--------------------------------------------------------------
;
;	MIN
;
; * 83 nucleus
;
minlfa		.word $adde
		.byt (_min-*-1)|bit7
		.asc "MI","N"|bit7
_min
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word gt
#include "page.i65"
		.word qbranch
		.word l107
#include "pad.i65"
		.word swap
#include "page.i65"
l107		.word drop
		.word exit

;--------------------------------------------------------------
;
;	MAX
;
; * 83 nucleus
;
maxlfa	.word $adde
		.byt (_max-*-1)|bit7
		.asc "MA","X"|bit7
_max
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l108
#include "pad.i65"
		.word swap
#include "page.i65"
l108		.word drop
		.word exit

;--------------------------------------------------------------
;
;	M*   ( n1 n2 -- d )
;
; multiply two signed words, leaving the double product on the stack
mstarlfa	.word $adde
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jsr mult
		jmp next
mult		lda stackl,x
		sta n+4
		lda stackh,x
		sta n+5
		eor tos+1
		php			; we only care about the sign bit
		bit tos+1
		bpl l064
		jsr donegate
l064		bit n+5
		bpl l065
		sec
		lda #0
		sbc n+4
		sta n+4
		lda #0
		sbc n+5
		sta n+5
l065		jsr multiply
		lda n+1
		sta stackh,x
		lda n
		sta stackl,x
		lda n+3
		sta tos+1
		lda n+2
		sta tos
		plp
		bpl l066
		jmp dodnegate
l066		rts

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash
		jsr domslash
		jmp next
domslash	cpx #$6f
		bcc l112
l113		ldx #bos
	;	sty stack,x
	;	sty stack+1,x
		tya
		rts
l112	;	lda stack,x
	;	ora stack+1,x
		beq l113
	;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+1,x
	;	eor stack+3,x
		pha
	;	lda stack+1,x
		pha
		bpl l114
		jsr donegate
l114	;	lda stack+3,x
		bpl l115
		inx
		inx
		jsr dnegate
		dex
		dex
l115		jsr modulo
		pla
		bpl l116
		jsr remult
l116		pla
		bpl l117
		jsr donegate
	;	lda stack+2,x
	;	ora stack+3,x
		beq l117
	;	lda stack,x
		bne l118
	;	dec stack+1,x
l118	;	dec stack,x
		jsr remult
		clc
		pla
	;	adc stack+2,x
	;	sta stack+2,x
		pla
	;	adc stack+3,x
	;	sta stack+3,x
		rts
l117		pla
		pla
		rts
remult		inx
		inx
		jsr donegate
		dex
		dex
		rts

;--------------------------------------------------------------
;
;	*   ( n1 n2 -- n1*n2 )
;
; * 83 nucleus
;
; multiply two signed words
starlfa		.word $adde
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jsr mult
		jmp pop

;--------------------------------------------------------------
;
;	/MOD
;
; * 83 nucleus
;
slashmodlfa	.word $adde
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jsr doslashmod
		jmp next
doslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+3,x
		bpl l119
		dey
l119	;	sty stack,x
	;	sty stack+1,x
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		ldy #0
		jmp domslash

;--------------------------------------------------------------
;
;	/
;
; * 83 nucleus
;
slashlfa	.word $adde
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jsr doslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pop

;--------------------------------------------------------------
;
;	MOD
;
; * 83 nucleus
;
modlfa		.word $adde
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jsr doslashmod
		jmp pop

;--------------------------------------------------------------
;
;	*/MOD
;
; * 83 nucleus
;
starslashmodlfa	.word $adde
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jsr dostarslashmod
		jmp next
dostarslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
		inx
		inx
		jsr mult
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		jmp domslash

;--------------------------------------------------------------
;
;	*/
;
; * 83 nucleus
;
starslashlfa	.word $adde
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jsr dostarslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pop

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jsr domslashmod
		jmp next
domslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	sty stack,x
	;	sty stack+1,x
		dex
		dex
		pla
		tay
	;	sta stack,x
		pla
	;	sta stack+1,x
		pha
		tya
		pha
		ldy #0
		jsr modulo
	;	lda stack+1,x
		sta n+1
	;	lda stack,x
		tay
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		lda n+1
		pha
		tya
		pha
		ldy #0
		jsr modulo
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		rts

;--------------------------------------------------------------
;
;	<BCQ
;
ltbcqlfa	.word $adde
		.byt (_ltbcq-*-1)|bit7
		.asc "<BC","Q"|bit7
_ltbcq
#include "enter.i65"
		.word first
#include "page.i65"
		.word numbcq
#include "page.i65"
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	BCQ>
;
bcqtolfa	.word $adde
		.byt (_bcqto-*-1)|bit7
		.asc "BCQ",">"|bit7
_bcqto
#include "enter.i65"
		.word first
#include "page.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	>BCQ
;
tobcqlfa	.word $adde
		.byt (_tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
_tobcq
#include "enter.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (_latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
_latestq
#include "enter.i65"
		.word offset
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word l120
#include "pad.i65"
		.word drop
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word false
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word drop
l120		.word exit

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (_absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
_absentq
#include "enter.i65"
		.word _latestq
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word store
#include "page.i65"
		.word true
#include "page.i65"
		.word swap
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l123		.word _twodup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word l121
#include "pad.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word cmove
#include "page.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word rot
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word minus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word drop
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word pleave
		.word l122
#include "pad.i65"
l121		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word ploop
		.word l123
#include "pad.i65"
l122		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
		.word exit

;--------------------------------------------------------------
;
;	UPDATE
;
; * 83 device
;
updatelfa	.word $adde
		.byt (_update-*-1)|bit7
		.asc "UPDAT","E"|bit7
_update
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word on
		.word exit

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (_drzero-*-1)|bit7
		.asc "DR","0"|bit7
_drzero
#include "enter.i65"
		.word offset
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (_drone-*-1)|bit7
		.asc "DR","1"|bit7
_drone
#include "enter.i65"
		.word plit
		.word 166
#include "pad.i65"
		.word offset
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (_discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
_discard
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (_missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
_missing
#include "enter.i65"
		.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l124
#include "pad.i65"
		.word _bcqto
#include "page.i65"
		.word dup
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word minus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zero
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word off
#include "page.i65"
l124		.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word store
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word cmovegt
		.word exit

;--------------------------------------------------------------
;
;	BUFFER
;
; * 83 device
;
bufferlfa	.word $adde
		.byt (_buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
_buffer
#include "enter.i65"
		.word _absentq
#include "page.i65"
		.word qbranch
		.word l125
#include "pad.i65"
		.word drop
#include "page.i65"
		.word _missing
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
l125		.word exit

;--------------------------------------------------------------
;
;	BLOCK   ( u -- addr )
;
; * 83 device
;
; addr is the address of the assigned buffer of the first byte
; of block u.  If the block occupying that buffer is not block
; u and has been UPDATEed it is transferred to mass storage
; before assigning the buffer.  If block u is not already in
; memory, it is transferred from mass storage into an assigned
; block buffer.  A block may not be assigned to more than one
; buffer.  If u is not an available block number, an error
; condition exists.  Only data within the last buffer
; referenced by BLOCK or BUFFER is valid.  The contents of a
; block buffer must not be changed unless the change may be
; transferred to mass storage.
blocklfa	.word $adde
		.byt (_block-*-1)|bit7
		.asc "BLOC","K"|bit7
_block
#include "enter.i65"
		.word _absentq
#include "page.i65"
		.word qbranch
		.word l126
#include "pad.i65"
		.word drop
#include "page.i65"
		.word _missing
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word fetch
#include "page.i65"
		.word one
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
l126		.word exit

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS   ( -- )
;
; 09/16/10 cah
emptybufferslfa	.word $adde
		.byt (_emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
_emptybuffers
#include "enter.i65"
		.word first
#include "page.i65"
		.word limit
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _erase
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word _erase
#include "page.i65"
		.word first
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l105		.word plit
		.word -1
#include "pad.i65"
		.word over
#include "page.i65"
		.word store
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word store
#include "page.i65"
		.word swap
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word plus
#include "page.i65"
		.word swap
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word ploop
		.word l105
#include "pad.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	SAVE-BUFFERS   ( -- )
;
; * 83 device
;
; The contents of all block buffers marked as UPDATEed are
; written to their corresponding mass storage blocks.  All
; buffers are marked as no longer being modified, but may
; remain assigned.
savebufferslfa	.word $adde
		.byt (_savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
_savebuffers
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l129		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word l127
#include "pad.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l128
#include "pad.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word over
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zero
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
#include "page.i65"
l128		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
l127		.word ploop
		.word l129
#include "pad.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	FLUSH
;
; * 83 device
;
flushlfa	.word $adde
		.byt (_flush-*-1)|bit7
		.asc "FLUS","H"|bit7
_flush
#include "enter.i65"
		.word _savebuffers
#include "page.i65"
		.word _emptybuffers
		.word exit

;--------------------------------------------------------------
;
;	LOAD
;
; * 83 interpreter
;
loadlfa		.word $adde
		.byt (_load-*-1)|bit7
		.asc "LOA","D"|bit7
_load
#include "enter.i65"
		.word qdup
#include "page.i65"
		.word zeq
#if ((* & $ff) = 253-17)
	.word next
#endif
		.word _pabortq
		.byt s017x-*-1
		.asc	"CAN'T LOAD SCR# 0"
			;123456789.1234567
s017x		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word tor
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word tor
#include "page.i65"
		.word toin
#include "page.i65"
		.word off
#include "page.i65"
		.word blk
#include "page.i65"
		.word store
#include "page.i65"
		.word _run
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word toin
#include "page.i65"
		.word store
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word blk
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
todisc		lda curindev
		sta n+6
		lda curoutdev
		sta n+7
	;	stx storex
		tsx
		stx n+4
		jsr CLRCHN
	;	ldx storex
	;	lsr stack,x
		bcs l134
		jsr l136
		ldx #<ldr1
		lda #>ldr1
		jsr l137
		jmp l138
l134		ldx #<ldr0
		lda #>ldr0
		jsr l137
		jsr l135
l138		lda #0
		pha
		ldx n+6
		jsr CHKIN
		ldx n+7
		jsr CHKOUT
		pla
		ldx n+4
		txs
	;	ldx storex
	;	sta stack+8,x
	;	sta stack+9,x
		inx
		inx
		inx
		inx
		jmp poptwo
l137		stx n
		sta n+1
		ldx #15
		jsr CHKOUT
		ldx n
		lda n+1
		jsr l139
	;	ldx storex
	;	lda stack+2,x
		jsr l140
		lda #','
		jsr CHROUT
	;	lda stack+4,x
		jsr l140
		lda #','
		jsr CHROUT
	;	lda stack+6,x
		jsr l140
		lda #$0d
		jsr CHROUT
		jsr CLRCHN
		jmp l146
l144		ldx #15
		jsr CHKOUT
		ldx #<discstring
		lda #>discstring
		jsr l139
		jsr CLRCHN
		jmp l146
l135	;	ldx storex
	;	lda stack+8,x
		sta n+2
	;	lda stack+9,x
		sta n+3
		jsr l144
		ldx #$0d
		jsr CHKIN
		ldy #0
l145		jsr GETIN
		sta (n+2),y
		iny
		bne l145
		jsr CLRCHN
		jmp l146
l140		ldy #$ff
		sec
l147		iny
		sbc #10
		bcs l147
		adc #10
		pha
		tya
		ora #'0'
		jsr CHROUT
		pla
		ora #'0'
		jmp CHROUT
l146		ldx #15
		jsr CHKIN
		ldy #$ff
l148		iny
		jsr GETIN
		sta inbuf+1,y
		cmp #$0d
		bne l148
		sty inbuf
		jsr CLRCHN
		lda inbuf+1
		cmp #'0'
		bne l149
		rts
l149		lda #$ff
	;	jmp l150
l136	;	ldx storex
	;	lda stack+8,x
		sta n+2
	;	lda stack+9,x
		sta n+3
		jsr l144
		ldx #$0d
		jsr CHKOUT
		ldy #0
l151		lda (n+2),y
		jsr CHROUT
		iny
		bne l151
		jsr CLRCHN
		jmp l146
l139		stx n
		sta n+1
		ldy #0
l153		lda (n),y
		cmp #0
		beq l152
		jsr CHROUT
		iny
		bne l153
l152		rts
discstring	.asc "B-P13,0"
		.byt $0d
		.byt 0
ldr0		.asc "U1:13,"
		.byt 0
ldr1		.asc "U2:13,"
		.byt 0

;--------------------------------------------------------------
;
;	(R/W)
;
;prslashwlfa	.word $adde
;		.byt (_prslashw-*-1)|bit7
;		.asc "(R/W",")"|bit7
_prslashw
#include "enter.i65"
		.word _qdisc
#include "page.i65"
		.word _tns
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l141		.word clit
		.byt 5
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l142		.word clit
		.byt 4
#include "pad.i65"
		.word pick
#include "page.i65"
		.word ploop
		.word l142
#include "pad.i65"
		.word todisc
#include "page.i65"
		.word qbranch
		.word l143
#include "pad.i65"
		.word _dotderr
#include "page.i65"
l143		.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word plit
		.word $0100	; rstack
#include "pad.i65"
		.word plus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word two
#include "page.i65"
		.word pick
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
v		.word rfrom
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word ploop
		.word l141
#include "pad.i65"
		.word twodrop
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (_rslashw-*-1)|bit7
		.asc "R/","W"|bit7
_rslashw
#include "enter.i65"
		.word _prslashw
		.word exit

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
;tnslfa		.word $adde
;		.byt (_tns-*-1)|bit7
;		.asc "T&","S"|bit7
_tns
#include "enter.i65"
		.word tor
#include "page.i65"
		.word plit
		.word 332	 ;~	max disc size
#include "pad.i65"
		.word over
#include "page.i65"
		.word ult
#include "page.i65"
#if ((* & $ff) = 253-22)
	.word next
#endif
		.word _pabortq
		.byt s018-*-1
		.asc	"SCREEN DOES NOT EXIST "
			;123456789.123456789.12
#include "pad.i65"
s018		.word clit
		.byt 166
#include "pad.i65"
		.word slashmod
#include "page.i65"
		.word tor
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 88
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l154
#include "pad.i65"
		.word clit
		.byt 21
#include "pad.i65"
		.word one
#include "page.i65"
		.word tor
#include "page.i65"
		.word branch
		.word l256a
#include "pad.i65"
l154		.word dup
#include "page.i65"
		.word clit
		.byt 92
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l2525
#include "pad.i65"
		.word twoplus
#include "page.i65"
		.word clit
		.byt 21
#include "pad.i65"
		.word one
#include "page.i65"
		.word tor
#include "page.i65"
		.word branch
		.word l256a
#include "pad.i65"
l2525		.word dup
#include "page.i65"
		.word clit
		.byt 120
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l2541
#include "pad.i65"
		.word clit
		.byt 92
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 19
#include "pad.i65"
		.word clit
		.byt 19
#include "pad.i65"
		.word tor
#include "page.i65"
		.word branch
		.word l256a
#include "pad.i65"
l2541		.word dup
#include "page.i65"
		.word clit
		.byt 146
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word l255d
#include "pad.i65"
		.word clit
		.byt 120
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 18
#include "pad.i65"
		.word clit
		.byt 25
#include "pad.i65"
		.word tor
#include "page.i65"
		.word branch
		.word l256a
#include "pad.i65"
l255d		.word clit
		.byt 146
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 17
#include "pad.i65"
		.word clit
		.byt 31
#include "pad.i65"
		.word tor
#include "page.i65"
l256a		.word rot
#include "page.i65"
		.word rot
#include "page.i65"
		.word dup
#include "page.i65"
		.word two
#include "page.i65"
		.word mod
#include "page.i65"
		.word swap
#include "page.i65"
		.word over
#include "page.i65"
		.word minus

#include "page.i65"
		.word twostar
#include "page.i65"
		.word twostar
#include "page.i65"
		.word plus
#include "page.i65"
		.word two
#include "page.i65"
		.word pick
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	(OPEN)
;
;popenlfa	.word $adde
;		.byt (popen-*-1)|bit7
;		.asc "(OPEN",")"|bit7
popen	;	stx storex
	;	lda stack,x
		pha
	;	ldy stack+3,x
	;	lda stack+2,x
		tax
		pla
	;	jsr SETNAM
	;	ldx storex
	;	ldy stack+4,x
	;	lda stack+8,x
		pha
	;	lda stack+6,x
		tax
		pla
	;	jsr SETLFS
		jsr OPEN
		bcs l155
	;	jsr READST
		and #$80
		beq l156
		lda #5
		.byt $2c	; bit xxxx instruction
l156		lda #0
l155		pha
	;	lda storex
		clc
		adc #10
		tax
		pla
		jmp push

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (close-*-1)|bit7
		.asc "CLOS","E"|bit7
close		stx n
		;lda stack,x
		jsr close
		ldx n
		jmp pop

;--------------------------------------------------------------
;
;	(CMDIN)
;
;pcmdinlfa	.word $adde
;		.byt (_pcmdin-*-1)|bit7
;		.asc "(CMDIN",")"|bit7
_pcmdin
#include "enter.i65"

;--------------------------------------------------------------
;
;	(CMDOUT)
;
;pcmdoutlfa	.word $adde
;		.byt (pcmdout-*-1)|bit7
;		.asc "(CMDOUT",")"|bit7
pcmdout;	stx storex
	;	lda stack,x
		tax
		jsr CHKOUT
		bcc l158
l157		pha
		jsr CLRCHN
		pla
	;	ldx storex
		inx
		inx
		jmp push
l158	;	jsr READST
		and #$80
	;	beq l159
		lda #5
		bne l157

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff	;	stx storex
		jsr CLRCHN
	;	ldx storex
		jmp next

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (_status-*-1)|bit7
		.asc "STATU","S"|bit7
_status
#include "enter.i65"

;--------------------------------------------------------------
;
;	(?DISC)
;
;pqdisclfa	.word $adde
;		.byt (_pqdisc-*-1)|bit7
;		.asc "(?DISC",")"|bit7
_pqdisc
#include "enter.i65"

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (_ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
_ioerr
#include "enter.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word s028
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-19)
	.word next
#endif
		.word _pabortq
		.byt s020-*-1
		.asc	"TOO MANY OPEN FILES"
			;123456789.123456789
s020
#include "page.i65"
		.word dup
#include "page.i65"
		.word two
#include "page.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-17)
	.word next
#endif
		.word _pabortq
		.byt s021-*-1
		.asc	"FILE ALREADY OPEN"
			;123456789.1234567
s021
#include "page.i65"
		.word dup
#include "page.i65"
		.word three
#include "page.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-13)
	.word next
#endif
		.word _pabortq
		.byt s022-*-1
		.asc	"FILE NOT OPEN"
			;123456789.123
s022
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-14)
	.word next
#endif
		.word _pabortq
		.byt s023-*-1
		.asc	"FILE NOT FOUND"
			;123456789.1234
s023
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 5
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-18)
	.word next
#endif
		.word _pabortq
		.byt s024-*-1
		.asc	"DEVICE NOT PRESENT"
			;123456789.12345678
s024
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-14)
	.word next
#endif
		.word _pabortq
		.byt s025-*-1
		.asc	"NOT INPUT FILE"
			;123456789.1234
s025
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 7
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-15)
	.word next
#endif
		.word _pabortq
		.byt s026-*-1
		.asc	"NOT OUTPUT FILE"
			;123456789.12345
s026
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-17)
	.word next
#endif
		.word _pabortq
		.byt s027-*-1
		.asc	"MISSING FILE NAME"
			;123456789.1234567
s027
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 9
#include "pad.i65"
		.word eq
#include "page.i65"
#if ((* & $ff) = 253-21)
	.word next
#endif
		.word _pabortq
		.byt s028-*-1
		.asc	"ILLEGAL DEVICE NUMBER"
			;123456789.123456789.1
s028		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (_dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
_dotderr
#include "enter.i65"
		.word cmdoff
#include "page.i65"
#if ((* & $ff) = 253-12)
	.word next
#endif
		.word _pdotq
		.byt s033-*-1
		.asc	"DISK ERROR: "
			;123456789.12
s033		.word plit
		.word inbuf
#include "pad.i65"
		.word count
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (_mount-*-1)|bit7
		.asc "MOUN","T"|bit7
_mount
#include "enter.i65"
		.word clit
		.byt 13
#include "pad.i65"
		.word close
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word close
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word popen
#include "page.i65"
		.word _ioerr
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word pcmdout
#include "page.i65"
		.word _ioerr
#include "page.i65"
#if ((* & $ff) = 253-2)
	.word next
#endif
		.word _pdotq
		.byt s031-*-1
		.asc	"I1"
			;12
s031		.word cmdoff
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word pcmdout
#include "page.i65"
		.word _ioerr
#include "page.i65"
#if ((* & $ff) = 253-2)
	.word next
#endif
		.word _pdotq
		.byt s032-*-1
		.asc	"I0"
			;12
s032		.word cmdoff
#include "page.i65"
		.word clit
		.byt 13
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word plit
		.word 10253	; ~
#include "pad.i65"
		.word one
#include "page.i65"
		.word popen
#include "page.i65"
		.word _ioerr
#include "page.i65"
		.word _qdisc
		.word exit

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (_qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
_qdisc
#include "enter.i65"
		.word _pqdisc
#include "page.i65"
		.word qbranch
		.word *+8
		.word _dotderr
#include "page.i65"
		.word spstore
#include "page.i65"
		.word _quit
		.word exit

;--------------------------------------------------------------
;
;	'
;
; * 83 interpreter
;
ticklfa		.word $adde
		.byt (_tick-*-1)|bit7
		.asc "'"|bit7
_tick
#include "enter.i65"
		.word _existsq
#include "page.i65"
		.word zeq
#include "page.i65"
		.word _qfind
		.word exit

;--------------------------------------------------------------
;
;	[']
;
; * 83 compiler
;
brticklfa	.word $adde
		.byt (_brtick-*-1)|bit7
		.asc "['","]"|bit7
_brtick
#include "enter.i65"
		.word _qcomp
		.word _tick
#include "page.i65"
		.word _literal
		.word exit


;--------------------------------------------------------------
;
;	?>MARK
;
qtomarklfa	.word $adde
		.byt (_qtomark-*-1)|bit7
		.asc "?>MAR","K"|bit7
_qtomark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _here
#include "page.i65"
		.word swap
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	?<MARK
;
qfrommarklfa	.word $adde
		.byt (_qfrommark-*-1)|bit7
		.asc "?<MAR","K"|bit7
_qfrommark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _here
#include "page.i65"
		.word zero
		.word exit

;--------------------------------------------------------------
;
;	?>RESOLVE
;
qtoresolvelfa	.word $adde
		.byt (_qtoresolve-*-1)|bit7
		.asc "?>RESOLV","E"|bit7
_qtoresolve
#include "enter.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word *+16
#include "page.i65"
		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _here
#include "page.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word *-18
		.word exit

;--------------------------------------------------------------
;
;	?<RESOLVE
;
qfromresolvelfa	.word $adde
		.byt (_qfromresolve-*-1)|bit7
		.asc "?<RESOLV","E"|bit7
_qfromresolve
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	ADD>MARK
;
addtomarklfa	.word $adde
		.byt (_addtomark-*-1)|bit7
		.asc "ADD>MAR","K"|bit7
_addtomark
#include "enter.i65"
		.word true
#include "page.i65"
		.word tor
#include "page.i65"
		.word one
#include "page.i65"
		.word roll
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word tor
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word *-12
		.word drop
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word true
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word *-10
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	BEGIN
;
; * 83 compiler
;
beginlfa	.word $adde
		.byt (_begin-*-1)|bit7
		.asc "BEGI","N"|bit7
_begin
#include "enter.i65"
		.word _qfrommark
#include "page.i65"
		.word one
		.word exit

;--------------------------------------------------------------
;
;	THEN
;
; * 83 compiler
;
thenlfa		.word $adde
		.byt (_then-*-1)|bit7
		.asc "THE","N"|bit7
_then
#include "enter.i65"
		.word abs
#include "page.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	DO
;
; * 83 compiler
;
dolfa		.word $adde
		.byt (_do-*-1)|bit7
		.asc "D","O"|bit7
_do
#include "enter.i65"
		.word _compile
#include "page.i65"
		.word pdo
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (_qdo-*-1)|bit7
		.asc "?D","O"|bit7
_qdo
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word pqdo
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	LOOP
;
; * 83 compiler
;
looplfa		.word $adde
		.byt (_loop-*-1)|bit7
		.asc "LOO","P"|bit7
_loop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word ploop
#include "page.i65"
		.word _qfromresolve
		.word exit

;--------------------------------------------------------------
;
;	+LOOP
;
; * 83 compiler
;
pluslooplfa	.word $adde
		.byt (_plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
_plusloop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word pploop
		.word _qfromresolve
		.word exit

;--------------------------------------------------------------
;
;	LEAVE
;
; * 83 compiler
;
leavelfa	.word $adde
		.byt (_leave-*-1)|bit7
		.asc "LEAV","E"|bit7
_leave
#include "enter.i65"
		.word _compile
		.word pleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (_qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
_qleave
#include "enter.i65"
		.word _compile
		.word pqleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	UNTIL
;
; * 83 compiler
;
untillfa	.word $adde
		.byt (_until-*-1)|bit7
		.asc "UNTI","L"|bit7
_until
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word qbranch
#include "page.i65"
		.word _qfromresolve
		.word exit

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (_again-*-1)|bit7
		.asc "AGAI","N"|bit7
_again
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word _qfromresolve
		.word exit

;--------------------------------------------------------------
;
;	REPEAT
;
; * 83 compiler
;
repeatlfa	.word $adde
		.byt (_repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
_repeat
#include "enter.i65"
		.word _again
		.word exit

;--------------------------------------------------------------
;
;	IF
;
; * 83 compiler
;
iflfa		.word $adde
		.byt (_if-*-1)|bit7
		.asc "I","F"|bit7
_if
#include "enter.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word qbranch
		.word _qtomark
#include "page.i65"
		.word two
		.word exit

;--------------------------------------------------------------
;
;	ELSE
;
; * 83 compiler
;
elselfa		.word $adde
		.byt (_else-*-1)|bit7
		.asc "ELS","E"|bit7
_else
#include "enter.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word swap
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word swap
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word zero
#include "page.i65"
		.word plit
		.word -2
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	WHILE
;
; * 83 compiler
;
whilelfa	.word $adde
		.byt (_while-*-1)|bit7
		.asc "WHIL","E"|bit7
_while
#include "enter.i65"
		.word _compile
		.word qbranch
		.word one
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	SPACES
;
; * 83 device
;
spaceslfa	.word $adde
		.byt (_spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
_spaces
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _max
#include "page.i65"
		.word zero
#include "page.i65"
		.word pqdo
		.word *+8
		.word _space
#include "page.i65"
		.word ploop
		.word *-4
		.word exit

;--------------------------------------------------------------
;
;	<#
;
; * 83 interpreter
;
ltsharplfa	.word $adde
		.byt (_ltsharp-*-1)|bit7
		.asc "<","#"|bit7
_ltsharp
#include "enter.i65"
		.word _pad
#include "page.i65"
		.word hld
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	#>
;
; * 83 interpreter
;
sharpgtlfa	.word $adde
		.byt (_sharpgt-*-1)|bit7
		.asc "#",">"|bit7
_sharpgt
#include "enter.i65"
		.word twodrop
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _pad
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	SIGN
;
; * 83 interpreter
;
signlfa		.word $adde
		.byt (_sign-*-1)|bit7
		.asc "SIG","N"|bit7
_sign
#include "enter.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word *+7
		.word clit
		.byt '-'
#include "pad.i65"
		.word _hold
		.word exit

;--------------------------------------------------------------
;
;	#
;
; * 83 interpreter
;
sharplfa	.word $adde
		.byt (_sharp-*-1)|bit7
		.asc "#"|bit7
_sharp
#include "enter.i65"
		.word base

#include "page.i65"
		.word fetch
#include "page.i65"
		.word mslashmod
#include "page.i65"
		.word rot
#include "page.i65"
		.word clit
		.byt 9
#include "pad.i65"
		.word over
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word *+7
		.word clit
		.byt 7
#include "pad.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt '0'
#include "pad.i65"
		.word plus
#include "page.i65"
		.word _hold
		.word exit

;--------------------------------------------------------------
;
;	#S
;
; * 83 interpreter
;
sharpslfa	.word $adde
		.byt (_sharps-*-1)|bit7
		.asc "#","S"|bit7
_sharps
#include "enter.i65"
		.word _sharp
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word orx
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word *-10
		.word exit

;--------------------------------------------------------------
;
;	(U.)
;
;pudotlfa	.word $adde
;		.byt (_pudot-*-1)|bit7
;		.asc "(U.",")"|bit7
_pudot
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	U.
;
; * 83 interpreter
;
udotlfa		.word $adde
		.byt (_udot-*-1)|bit7
		.asc "U","."|bit7
_udot
#include "enter.i65"
		.word _pudot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (_udotr-*-1)|bit7
		.asc "U.","R"|bit7
_udotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pudot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(.)
;
;pdotlfa		.word $adde
;		.byt (_pdot-*-1)|bit7
;		.asc "(.",")"|bit7
_pdot
#include "enter.i65"
		.word dup
#include "page.i65"
		.word abs
#include "page.i65"
		.word zero
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word rot
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	.
;
; * 83 interpreter
;
dotlfa		.word $adde
		.byt (_dot-*-1)|bit7
		.asc "."|bit7
_dot
#include "enter.i65"
		.word _pdot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (_dotr-*-1)|bit7
		.asc ".","R"|bit7
_dotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pdot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(UD.)
;
;puddotlfa	.word $adde
;		.byt (_puddot-*-1)|bit7
;		.asc "(UD.",")"|bit7
_puddot
#include "enter.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (_uddot-*-1)|bit7
		.asc "UD","."|bit7
_uddot
#include "enter.i65"
		.word _puddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (_uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
_uddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _puddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(D.)
;
;pdddotlfa	.word $adde
;		.byt (_pddot-*-1)|bit7
;		.asc "(D.",")"|bit7
_pddot
#include "enter.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word dabs
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (_ddot-*-1)|bit7
		.asc "D","."|bit7
_ddot
#include "enter.i65"
		.word _pddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (_ddotr-*-1)|bit7
		.asc "D.","R"|bit7
_ddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (_question-*-1)|bit7
		.asc "?"|bit7
_question
#include "enter.i65"
		.word fetch
#include "page.i65"
		.word _dot
		.word exit

;--------------------------------------------------------------
;
;	PICK
;
; * 83 nucleus
;
; 0 pick = same as dup
; 1 pick = same as over
picklfa		.word $adde
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick	;	inc stack,x
	;	lda stack,x
		asl
		sta n
		sty n+1
		txa
		tay
		lda (n),y
		pha
		iny
		lda (n),y
		jmp put

;--------------------------------------------------------------
;
;	ROLL   ( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
;
; * 83 nucleus
;
; remove the nth stack element (excluding n itself) to TOS, dropping n
;
; 2 roll = rot
; 1 roll = swap
; 0 roll has no effect
;
rolllfa		.word $adde
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		stx n
		txa
		clc
		adc tos
		tax
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
l056		cpx n
		beq l057
		lda stackh+$ff,x
		sta stackh,x
		lda stackl+$ff,x	; ~ probably not work!
		sta stackl,x
		dex
		bne l056
l057		inx
		jmp next

;--------------------------------------------------------------
;
;	DEPTH
;
; * 83 nucleus
;
depthlfa	.word $adde
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth		stx n
		lda #<bos
		sec
		sbc n
		ldy #0
		jmp push

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp poptwo

;--------------------------------------------------------------
;
;	2DUP   ( n1 n2 -- n1 n2 n1 n2 )
;
twoduplfa	.word $adde
		.byt (_twodup-*-1)|bit7
		.asc "2DU","P"|bit7
_twodup		dex
		dex
		lda tos+1
		sta stackh+1,x
		lda tos
		sta stackl+1,x
		lda stackh+2,x
		sta stackh,x
		lda stackl+2,x
		sta stackl,x
		jmp next

;--------------------------------------------------------------
;
;	2OVER   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
;
twooverlfa	.word $adde
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		dex
		dex
		lda tos+1
		sta stackh+2,x
		lda tos
		sta stackl+2,x
		lda stackh+4,x
		sta stackh+1,x
		lda stackl+4,x
		sta stackl+1,x
		lda stackh+3,x
		sta tos+1
		lda stackl+3,x
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	2ROT   ( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )
;
; hi1 is stored in TOS, the rest in stackl/stackh ... stack+4
tworotlfa	.word $adde
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		ldy stackh+4,x
		lda stackh+2,x
		sta stackh+4,x
		lda stackh,x
		sta stackh+2,x
		sty stackh,x
		ldy stackl+4,x
		lda stackl+2,x
		sta stackl+4,x
		lda stackl,x
		sta stackl+2,x
		sty stackl,x		; done moving lo words
		ldy stackh+3,x
		lda stackh+1,x
		sta stackh+3,x
		lda tos+1
		sta stackh+1,x
		sty tos+1
		ldy stackl+3,x
		lda stackl+1,x
		sta stackl+3,x
		lda tos
		sta stackl+1,x
		sty tos			; done moving hi words
		jmp next

;--------------------------------------------------------------
;
;	2SWAP   ( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )
;
twoswaplfa	.word $adde
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		ldy tos+1
		lda stackh+1,x
		sta tos+1
		sty stackh+1,x
		ldy tos
		lda stackl+1,x
		sta tos
		sty stackl+1,x
		ldy stackh,x
		lda stackh+2,x
		sta stackh,x
		sty stackh+2,x
		ldy stackl,x
		lda stackl+2,x
		sta stackl,x
		sty stackl+2,x
		jmp next

;--------------------------------------------------------------
;
;	2!   ( hi lo addr -- )
;
twostorelfa	.word $adde
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	ldy #0
l055		lda stackh,x
		sta (tos),y
		iny
		lda stackl,x
		sta (tos),y
		iny
		inx
		cpy #4
		bne l055
		jmp pop

;--------------------------------------------------------------
;
;	2@   ( addr -- hi lo )
;
twofetchlfa	.word $adde
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	ldy #3
		dex
		lda (tos),y
		sta stackh,x
		dey
		lda (tos),y
		sta stackl,x
		dey
		lda (tos),y
		sta n
		dey
		lda (tos),y
		ldy n
		jmp put

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (_twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
_twoconst
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
		jsr dodoes
#include "page.i65"
		.word twofetch
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (_twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
_twovariable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus	;	jsr dnegate
		jmp dplus+2

;--------------------------------------------------------------
;
;	D0=   ( hi lo -- flag )
;
dzeqlfa		.word $adde
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		ldy #0
		lda tos
		ora tos+1
		ora stackl,x
		ora stackh,x
		bne *+3
		dey
		inx
		sty tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	D=   ( hi2 lo2 hi1 lo1 -- flag )
;
deqlfa		.word $adde
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		ldy #0
		lda tos
		eor stackl+1,x
		bne l054
		lda tos+1
		eor stackh+1,x
		bne l054
		lda stackl,x
		eor stackl+2,x
		bne l054
		lda stackh,x
		eor stackh+2,x
		bne l054
		dey
l054		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jsr dcmp
		bcs *+3
		dey
	;	sty stack+6,x
	;	sty stack+7,x
		inx
		inx
		jmp poptwo

;--------------------------------------------------------------
;
;	D2/   ( hi lo -- hi/2 lo/2 )
;
dtwoslashlfa	.word $adde
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	lsr stackh,x
		ror stackl,x
		ror tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	D2*   ( hi lo -- hi*2 lo*2 )
;
dtwostarlfa	.word $adde
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	asl stackl,x
		rol stackh,x
		rol tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (_dgt-*-1)|bit7
		.asc "D",">"|bit7
_dgt
#include "enter.i65"
		.word twoswap
#include "page.i65"
		.word dlt
		.word exit

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (_dmin-*-1)|bit7
		.asc "DMI","N"|bit7
_dmin
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word _dgt
#include "page.i65"
		.word qbranch
		.word *+4
#include "page.i65"
		.word twoswap
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (_dmax-*-1)|bit7
		.asc "DMA","X"|bit7
_dmax
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word dlt
#include "page.i65"
		.word qbranch
		.word *+4
#include "pad.i65"
		.word twoswap
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (_configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
_configure
#include "enter.i65"
		.word limit
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word star
#include "page.i65"
		.word minus
#include "page.i65"
		.word plit
		.word $fee		; ~
#include "pad.i65"
		.word store
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word plit
		.word $1010		; ~
#include "pad.i65"
		.word store
		.word cold

;--------------------------------------------------------------
;
;	FREEZE
;
freezelfa	.word $adde
		.byt (_freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
_freeze
#include "enter.i65"
		.word plit
		.word forth+2
#include "pad.i65"
		.word fetch
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word _plusorigin
#include "page.i65"
		.word store
#include "page.i65"
		.word width
#include "page.i65"
		.word clit
		.byt 12
#include "pad.i65"
		.word _plusorigin
#include "page.i65"
		.word clit
		.byt 12
#include "pad.i65"
		.word cmove
		.word exit

;--------------------------------------------------------------
;
;	(BSAVE)
;
;pbsavelfa	.word $adde
;		.byt (pbsave-*-1)|bit7
;		.asc "(BSAVE",")"|bit7
pbsave		lda #3
		jsr setup
		stx tos
		lda #<basic+1
		ldx #>basic+1
		tay
		;jsr SETLFS
		lda n
		ldx n+2
		ldy n+3
		;jsr SETNAM
		ldx n+4
		ldy n+5
		lda #$82
		jsr SAVE
		ldx tos
		jmp next

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (_saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
_saveforth
#include "enter.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word _freeze
#include "page.i65"
		.word cr
#if ((* & $ff) = 253-10)
	.word next
#endif
		.word _pdotq
		.byt s030-*-1
		.asc	"FILENAME? "
			;123456789.
s030		.word _pad
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 18
#include "pad.i65"
		.word expect
#include "page.i65"
		.word span
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _pad
#include "page.i65"
		.word cstore
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word popen
#include "page.i65"
		.word drop
#include "page.i65"
		.word plit
		.word basic+1
#include "pad.i65"
		.word _here
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _pad
#include "page.i65"
		.word count
#include "page.i65"
		.word pbsave
#include "page.i65"
		.word _qdisc
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word close
		.word exit

;--------------------------------------------------------------
;
;	BRINGOUTYERDEAD   ( addr -- deadlfa|0 )
;
; scans forward in memory returning the address of the next $DE $AD
; in memory that is followed by a name
;" http://www.youtube.com/watch?v=grbSQ6O6kbs
;
;boydlfa		.word $adde
;		.byt (boyd-*-1)|bit7
;		.asc "BRINGOUTYERDEA","D"|bit7
boyd		ldy #userdp-userarea
		lda (up),y
		sta n+2
		iny
		lda (up),y
		sta n+3
		ldy #0

		lda (n+2),y
		sta n+5
		lda #$DE
		sta (n+2),y
		iny
		lda (n+2),y
		sta n+4
		lda #$AD
		sta (n+2),y
l061		lda #$DE
l049		cmp (tos),y
		beq l050
		iny
		bne l049
		inc tos+1
		bpl l049
		brk		; we're not supposed to ever get here
l050		clc
		tya
		adc tos
		sta tos		; move TOS to point where DE AD was found
		bcc l058
		inc tos+1
l058		ldy #1
		lda #$AD
		cmp (tos),y	; really DE AD?  Or just DE?
		bne l061
		lda tos
		cmp n+2
		bne l062
		lda tos+1
		cmp n+3
		beq l063	; are we HERE yet?
l062		iny
		lda (tos),y	; get the length byte
		bpl l061	; length should have bit7 set
		and #$1f
		clc
		adc #2		; LFA to NFA offset
		tay
		lda (tos),y	; last character should have bit7 set (> $80)
		bpl l061
l059		dey		; in-between characters should be < $80
		cpy #2
		beq l060
		lda (tos),y
		bpl l059
		bmi l061
l063		lda #0
		sta tos
		sta tos+1
l060		ldy #1		; put things back at HERE
		lda n+5
		sta (n+2),y
		dey
		lda n+4
		sta (n+2),y
		jmp next

;--------------------------------------------------------------
;
;	DHASH	( nfa -- hash1 hash2 )
;
; input is NFA or address of a counted string. Output is two hashcodes
;
;dhashlfa	.word $adde
;		.byt (dhash-*-1)|bit7
;		.asc "DHAS","H"|bit7
dhash		stx n+7
		ldy #0
		lda (tos),y
		and #$3f		; turn off 7 and 6, not 5 (smudge)
		sta n			; seed hash1 with length
		sty n+1			; seed hash2 with 0
		tay
		iny
				;	hash2	hash1
l009		dey				;[2]
		beq l047			;[2]
		lda (tos),y			;[5]
		sec				;[2]
		sbc #$20			;[2]
		and #(zpnext-pearson-1)		;[2]
		tax				;[2]
		lda n				;[3]
		eor pearson,x			;[4]
		sta n				;[3]
		lda (tos),y		;[5]
		clc			;[2]
		adc #$FF-('9')		;[2]		; things are doubled
		adc #'9'-'0'+1		;[2]		; due to ASL above
		bcc l009			;[3]  [12]hash2 [27]hash1	
		adc n+1			; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
		sta n+1			; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1 
		jmp l009		; 2drop 2dup 2over 2rot 2swap 2! 2@
					; 2constant 2variable d0= d2/ d2* 
l047		lda n
		lsr
		lsr
		lsr
		lsr			; - - - - [ 7 6 5 4 ]
		eor n			; 7 6 5 4 [ 3 2 1 0 ]
		and #$0f		; - - - - [4bit hash]
		;jsr debug
		sta tos
		sty tos+1
		lda n+1		; sum of all digits 0..9	
		ldx n+7
		jmp push

;~debug hex dump the byte in A
debug	pha
	pha
	and #$0f
	jsr print
	pla
	lsr
	lsr
	lsr
	lsr
	;jsr print
	pla
dbout	rts
print	sed
	cmp #10
	adc #'0'
	cld
	jmp CHROUT

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieve the head of this hash thread
;
;dhashfetchlfa	.word $adde
;		.byt (dhashfetch-*-1)|bit7
;		.asc "DHASH","@"|bit7
dhashfetch	lda tos
		asl
		tay
		lda lfalist,y
		sta tos
		lda lfalist+1,y
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	BLOOM!   ( hash -- )
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;bloomstorelfa	.word $adde
;		.byt (bloomstore-*-1)|bit7
;		.asc "BLOOM","!"|bit7
bloomstore	lda tos			; set bloom filter bit for hash2
		and #7
		tay
		lda power2,y
		sta n
		lda tos
		lsr
		lsr
		lsr
		tay
		lda n
		ora bloom2,y
		sta bloom2,y
		jmp pop

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hash1 -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
;dhashstorelfa	.word $adde
;		.byt (dhashstore-*-1)|bit7
;		.asc "DHASH","!"|bit7
dhashstore	lda #1
		jsr setup
		sty n+4
		sty n+5
;	lda stackh,x
;	sta n+3
;	lda stackl,x
;	sta n+2
;	lda #0
;	sta n
;	sta n+1
		lda tos
		asl
		tay
		lda lfalist+1,y
		bne notempty
		lda #<rootlfa
		sta lfalist,y
		lda #>rootlfa
		sta lfalist+1,y
notempty	sta n+3
		lda lfalist,y
		sta n+2
		ldy #2
		lda (n),y
		and #$1f
		sta n+7			; length of name being inserted
loop		lda (n+2),y
		and #$1f
		sta n+6
		lda n+7
		cmp n+6			; compare lengths
		bcc insert
		bne hop
		;sec
		adc #1
		tay			; last char in names
strcmp		lda (n),y
		eor (n+2),y
		asl			; compare char ignoring bit7
		bne hop
		dey
		cpy #2
		bne strcmp		; stop at first char
		dey
		lda #$AD
		sta (n+2),y
		dey
		lda #$DE
		sta (n+2),y		; mark existing duplicate DE AD
hop		lda n+3
		sta n+5
		lda n+2
		sta n+4			; keep track of where we've just been
		ldy #0
		lda (n+2),y
		pha
		iny
		lda (n+2),y
		sta n+3
		pla
		sta n+2			; (N1) -> N1
		iny			; Y=2
		bne loop		; bra
insert		bit n+5			; check if list is empty
		bne linkin
head		lda tos			; which list?
		asl
		adc #<lfalist
		sta n+4
		lda #>lfalist
		adc #0
		sta n+5			; head -> N2
linkin		ldy #0
		lda n
		sta (n+4),y		; N0 -> (N2)
		lda n+2
		sta (n),y		; N1 -> (N0)
		iny
		lda n+1
		sta (n+4),y
		lda n+3
		sta (n),y
outtie		jmp pop			; toss the hash

;--------------------------------------------------------------
;
;	UNTHREAD   ( -- )
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;	16 0 do				( )
;		i dhash@		( lfa1 )
;		begin
;			dup		( lfa1 lfa1 )
;			@		( lfa1 lfa2 )
;			?dup		( lfa1 lfa2 true | lfa1 false )
;		while			( lfa1 lfa2 )
;			$dead		( lfa1 lfa2 $dead )
;			rot		( lfa2 $dead lfa1 )
;~ dup 2- ( nfa ) dup c@ ( nfa len ) $80 or ( nfa len ) swap c! ( ) 
;			!		( lfa2 )
;		repeat
;					( lfa )
;		drop			( )
;	loop
;
;unthreadlfa	.word $adde
;		.byt (_unthread-*-1)|bit7
;		.asc "UNTHREA","D"|bit7
_unthread
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
l051		.word i
#include "page.i65"
		.word dhashfetch
#include "page.i65"
l052		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word l053
#include "pad.i65"
		.word plit
		.word $adde
#include "pad.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word l052
#include "page.i65"
l053		.word drop
#include "page.i65"
		.word zero
#include "page.i65"
		.word i
#include "page.i65"
		.word dhashstore
#include "page.i65"
		.word ploop
		.word l051
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity for the programmer.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.
; It also marks the last word in the core dictionary.
; links all LFAs
; ~ make it turn off bit7 on redefinitions
;rethreadlfa	.word $adde
;		.byt (_rethread-*-1)|bit7
;		.asc "RETHREA","D"|bit7
_rethread
#include "enterx.i65"
		.word plit
		.word lfalist
#include "pad.i65"
		.word clit
		.byt <(power2-lfalist)	; all list heads and bloom filters
#include "pad.i65"
		.word _erase
#include "page.i65"
		.word zero
#include "page.i65"
		.word _plusorigin
#include "page.i65"
l044		.word boyd		; begin boyd ?dup while ... repeat
#include "page.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word l024
#include "page.i65"
		.word dup		; ( lfa lfa )
#include "page.i65"
		.word dup		; ( lfa lfa lfa )
#include "page.i65"
		.word twoplus		; ( lfa lfa nfa )
#include "page.i65"
		.word dhash		; ( lfa lfa hash1 hash23 )
#include "page.i65"
		.word bloomstore	; ( lfa lfa hash1 )
#include "page.i65"
		.word dhashstore	; ( lfa )
#include "page.i65"
		.word branch
		.word l044
#include "pad.i65"
l024		.word exit


;--------------------------------------------------------------
;
;	MON   ( -- )
;
; perform a BRK instruction to get to the TIM machine language monitor
monlfa		.word $adde
		.byt (mon-*-1)|bit7
		.asc "MO","N"|bit7
mon		brk
		jmp next

;--------------------------------------------------------------
;
;	FORGET
;
; * 83 interpreter
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
forgetlfa	.word $adde
ntop		.byt (_forget-*-1)|bit7
		.asc "FORGE","T"|bit7
_forget
#include "enter.i65"
		.word _tick
#include "page.i65"
		.word _toname
		.word dup
#include "page.i65"
		.word fence
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ult
#if ((* & $ff) = 253-23)
	.word next
#endif
		.word _pabortq
		.byt s029-*-1
		.asc	"IN PROTECTED DICTIONARY"
			;123456789.123456789.123
s029		.word tor
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
l162		.word rfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word l163
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word fetch
#include "page.i65"
		.word branch
		.word l162
#include "page.i65"
l163		.word dup
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
l165		.word dup
#include "page.i65"
		.word twominus
#include "page.i65"
l164		.word _ntolink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word l164
#include "pad.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word l165
#include "pad.i65"
		.word rfrom
#include "page.i65"
		.word dp
#include "page.i65"
		.word store
		.word exit

forgetfence

;==============================================================

;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde
		.byt (_thru-*-1)|bit7
		.asc "THR","U"|bit7
_thru
#include "enter.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word pdo
#include "page.i65"
l160		.word i
#include "page.i65"
		.word _udot
#include "page.i65"
		.word i
#include "page.i65"
		.word _load
#include "page.i65"
		.word qterminal
#include "page.i65"
		.word pqleave
		.word l161
#include "pad.i65"
		.word ploop
		.word l160
#include "pad.i65"
l161		.word exit

;foolfa		.word $adde
;		.byt (_foo-*-1)|bit7
;		.asc "FO","O"|bit7
_foo
#include "enterx.i65"
		.word exit
;barlfa		.word $adde
;		.byt (_bar-*-1)|bit7
;		.asc "BA","R"|bit7
_bar
#include "enterx.i65"
		.word exit

endofile

; words that use psemi
;"	:		jsr	enter
;	constant	jsr	doconst
;	user		jsr	uservar
;	does>		jsr	dodoes
;	create		jsr	docreate
;	vocabulary	jsr	vocabdoes
;
; words that might page
; 	page
;	plit
;	clit
;	branch
;	pdotq
;
; from the forth-83 standards doc
;"http://forth.sourceforge.net/standard/fst83/FORTH-83.PRN
;
;	Nucleus layer
;
;		!  *  */  */MOD  +  +!  -  /  /MOD  0<  0=  0>  1+  1-  2+
;		2-  2/  <  =  >  >R  ?DUP  @  ABS  AND  C!  C@  CMOVE
;		CMOVE>  COUNT  D+  D<  DEPTH  DNEGATE  DROP  DUP  EXECUTE
;		EXIT  FILL  I  J  MAX  MIN  MOD  NEGATE  NOT  OR  OVER  PICK
;		R>  R@  ROLL  ROT  SWAP  U<  UM*  UM/MOD  XOR
;
;
;	Device layer
;
;		BLOCK  BUFFER  CR  EMIT  EXPECT  FLUSH  KEY  SAVE-BUFFERS
;		SPACE  SPACES  TYPE  UPDATE
;
;
;	Interpreter layer
;
;		#  #>  #S  #TIB  '  (  -TRAILING  .  .(  <#  >BODY  >IN
;		ABORT  BASE  BLK  CONVERT  DECIMAL  DEFINITIONS  FIND
;		FORGET  FORTH  FORTH-83  HERE  HOLD  LOAD  PAD  QUIT  SIGN
;		SPAN  TIB  U.  WORD
;
;
;	Compiler layer
;
;"		+LOOP  ,  ."  :  ;  ABORT"  ALLOT  BEGIN  COMPILE  CONSTANT
;		CREATE  DO  DOES>  ELSE  IF  IMMEDIATE  LEAVE  LITERAL  LOOP
;		REPEAT  STATE  THEN  UNTIL  VARIABLE  VOCABULARY  WHILE  [
;		[']  [COMPILE]  ]


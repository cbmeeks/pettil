; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word BPERBUF

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word BPERSCR

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #1)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab memsiz  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    ldy usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    ldy usermemsiz+1            ; okay use memsize in core mode
blkbuf02
    dey
    dey
    dey
    dey                         ; -1K (1024 bytes aka `b/buf`)
    lda #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive,nosymbol

 Reads a portion of the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!!pronounced: "wrap-above"
#endif
wrapabove
    stx z                       ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos                     ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2                     ; are we there yet?
    beq wrapabove03             ; leave if done
    lda $e0,x
    asl                         ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1                     ; append the next high bit to the double
    beq wrapabove02             ; this should always take the branch
wrapabove03
    lda n
    ldy n+1                     ; high half of the double is going on the stack
    ldx z                       ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- uncompressed? targend )
tags=vm,sweet16
This works a lot like `cmove` with its `from to howmany` stack signature, but
the target is a `packet` of `virtual memory` that can be permanently stored
to cassette tape.  The other difference is the two return values provided by
`rlencode`.

* `targend` End of the compressed|stored output
* `uncompressed?` Flag reveals whether RLE compression was used.

encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; r11   size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | R11               ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt sub | ACC
    .byt st | TOS
    .byt ld | N2                ; targ (out)
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt set | ACC
    .word $4000
    .byt st | TOS
    .byt ld | R11               ; return original `size`
    .byt add | N7               ; +pristine targ
    .byt push
    .byt ld | N0                ; from
    .byt push
    .byt ld | N7                ; to
    .byt push
    .byt ld | R11               ; howmany
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( -- packet size )
tags=vm,nosymbol
Returns the current `pkt` address and `size` of the packet in `n8`


```
: pkt.size   ( -- pkt size )
    <n8 dup @ $7ff and ;

    jsr slip
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    pha
    jmp rfrom
```
pronounced: "packet-size"
~#packrat
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N8
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PSIZE
stack=( pkt.header -- pkt.size )
tags=vm,ext
Return just the size of the `pkt.header` on the stack

~#packrat
#endif
psize
;    lda #>(next-1)
;    pha
;    lda #<(next-1)
;    pha
psizes
    lda tos+1
    and #$07
    sta tos+1
;    rts
    jmp next

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- pkt )
tags=vm,ext
Return the `pkt` address of block `n`, sets `n8`

~ return a 0 if there are less than `n` packets?

```
: >pkt   ( n -- pkt )
    brk
    .byt set | N0
    .word usersymtab
    .byt ldd | N0
    .byt set | N1
    .word 1024
    .byt sub | N1

    .byt st | N0
topkt01
    .byt popd | N0
    .byt ext
    .word psizes
    .byt bz , <(topkt02-*-2)
    .byt ld | TOS
    .byt sub | N0

    .byt st | N1
    .byt ld | TOS
    .byt sub | N1
    .byt inr | ACC
    .byt inr | ACC
    .byt st | TOS
    .byt dcr | N0
    .byt bnz , <(topkt01-*-2)
topkt02

    ] 2-


    blkbuf 2-
    begin
        over
    while
        1-under
        @+ psize - 2-
    repeat
    nip >n8 ;

    .byt set
    .word

```
~#packrat
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
#include "page.i65"
    .word over
#include "pass.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "page.i65"
    .word oneminusunder
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word psize
#include "page.i65"
    .word minus
#include "page.i65"
    .word twominus
#include "pass.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "page.i65"
topktb02
    .word nip
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.INFO
stack=( packet -- floor length uncompressed? isscr? )
tags=vm,nosymbol
Returns the floor, length and flags from a packet header.  [[SCRPKT]]
is $8000 for screen packets, 0 for data packets.  the `uncompressed?`
value is $4000 for uncompressed packets, 0 for [[RLENCODE]]d packets.
The term `size` also includes the 2 byte packet header, while a
packet's `length` is just the contents (`size-2`)

pronounced: "packet-info"

```
: pkt.info   ( block -- floor length uncompressed? isscr? )
    >pkt dup>r pkt.size 2- dup>r -
    r> r> @ dup>r $4000 and r> vidram and scrpkt ! ;
```
~#packrat
#endif
#include "align.i65"
pktinfo
    jsr enter
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "pass.i65"
    .word plit
    .word $4000
#include "page.i65"
    .word andx
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word vidram
#include "page.i65"
    .word andx
#include "page.i65"
    .word scrpkt                ; ~#packrat
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting
    ldy userediting+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the [[SCRPKT]] user variable, which describes whether the current
packet type is screen (true) or data (false)   ~wut? calculate this instead

```
: isscr?   ( -- flag )
    scrpkt @ ;
```
~#packrat
#endif
isscrq
    lda userscrpkt+1            ; check bit 15
    jmp uncompressedq01

;--------------------------------------------------------------
#if 0
name=UNCOMPRESSED?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the packet is simply stored by `cmove` or
`false` when the packet is runlength-encoded

```
: uncompressed?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
~#packrat
#endif
uncompressedq
    ldy #1
    lda (ACC+2*N8),y            ; packet header msb
    asl
uncompressedq01
    asl                         ; normalize `flag`
    jmp pushc

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( addr size -- floor )
tags=vm,ext,nosymbol
inserts a new packet at address.

```
: pkt+   ( addr size -- floor )
    >r vmbuf @ over 1+
    r@ negate  dup vmbuf +!  +move
    r@ over !
    r> - 2+ ;
```
~#packrat
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word negate
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKPKTS
stack=( n -- )
tags=vm,ext,nosymbol
concatenates `n+1` new packets at the tail of the [[VMBUF]] area

```
: mkpkts   ( n -- )
    begin
        #blk 1+!  vmbuf @  editing?
        if
            dup>r 5 pkt+ dup on 1+ on vidram r> +!
        else
            2 pkt+ drop
        then
        1- 0<
    until drop ;

mkpkts01
    .word numblk
    .word dup
    .word oneplusstore
    .word fetch
    .word _topkt
    .word drop
    .word editingq
    .word qbranch
    .byt <(mkpkts02-*+1)
    .word duptor
    .word five
;    .word _pktplusxxz
    .word dup
    .word on
    .word oneplus
    .word on
    .word vidram
    .word rfrom
    .word plusstore
    .word branch
    .byt <(mkpkts03-*+1)
mkpkts02
    .word two
;    .word _pktplusxxz
    .word drop
mkpkts03
    .word oneminus
    .word dup
    .word zlt
    .word qbranch
    .byt <(mkpkts01-*+1)
    .word drop
    .word exit
```
~#packrat
#endif
#include "align.i65"
_mkpktsxzz

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=?MKPKTS
stack=( blk -- )
tags=vm,ext,nosymbol
Used by [[BLOCK]] to create empty packets.  If `blk` references a packet
higher than  [[#BLK]], generates new packets at the tail of the buffer
(screen or data, based on [[EDITING]])

```
: ?mkpkts   ( blk -- )
    #blk @ - dup 0<
    ?: drop mkpkts ;

: ?mkpkts   ( blk -- )
    #blk
    begin
        2dup @  1+ <
     while
        dup 1+!
        pkt+
    repeat drop ;


    vmbuf
    -5 +!
    $ffffff
    vmbuf
    3c!



```
~#packrat
#endif
#include "align.i65"
_qmkpkts
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
qmkpkts01
    .word twodup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word lt
#include "pass.i65"
    .word qbranch
    .byt <(qmkpkts02-*+1)
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word pktplus
#include "pass.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "page.i65"
qmkpkts02
    .word threedrop
#include "pass.i65"
    .word exit

#include "align.i65"
pktplus
    jsr enter
#include "page.i65"
    .word namefrom              ; a trick, relies on `vmbuf` preceding `#blk`
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word mkscr
    .word mkdata
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word xyzzy

#include "pass.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "page.i65"
    .word threedrop
#include "pass.i65"
    .word exit

mkscr
    .byt 5, $FF, $FF, $FF, $05, $80
mkdata
    .byt 2, $02, $40

;--------------------------------------------------------------
#if 0
name=WRAP@
stack=( -- wrapd  )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapfetch
    jsr slip
    dex
    ldy #LPERSCR-1              ; 24 lines (1-25)
wrapfetch01
    lda LDTB1,y                 ;$E0 = 0, always $80  $E1-$F8
    asl
    ror tos
    ror stackh,x
    ror stackl,x
    dey
    bne wrapfetch01
    sty tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapstore
    jsr harvests2
    txa
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    tax                         ; restore stack pointer
    jmp drop

;--------------------------------------------------------------
#if 0
name=SCR0
stack=( -- )
tags=vm,nosymbol
Reset [[SCR]] and [[BLK]] to screen/block 0.

```
: scr0   ( -- )
    blk off  scr off ;
```
#endif
#include "align.i65"
_scr0
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm,nosymbol
Reset virtual memory user variables for `LOAD-BUFFERS` or `EMPTY-BUFFERS`

~ It should also validate flags and max-lengths, error out on corrupt VMBUF
~wut?  throw a `bad vm packet` error if a length/flag is off the reservation
```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

```
~#packrat
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word off
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "pass.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "page.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol,magic-number
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx stashforth01
    jsr aufwiedersehen
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    rts
stashforth01 .byt 0             ; temp storage for X register during tape I/O

;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Restore Forth stack after BASIC system call

#endif
restoreforth
    jsr aloha2
    ldx stashforth01            ; this messes up BASIC's USR() function
    jmp exit

;--------------------------------------------------------------
#if 0
name=DOTAPEIO
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Perform a ROM call framed between calls to `aloha`. This is
needed in particular for tape I/O, which might error out to a
Commodore BASIC `ready.` prompt.

Like `execute` and the Sweet-16 interpreter, this word
uses the machine stack ($0100-$01ff) and RTS trick to transfer
control from one subroutine to the next, so that code executes
in this order:

~wut?  this is a little crashy returning from hitting the [[STOP]] key

```
stashforth
RTS
caller's ROM routine
RTS
restoreforth
EXIT
```
#endif
#include "align.i65"
_dotapeio
    jsr enter
#include "pass.i65"
    .word plit
    .word restoreforth-1
#include "page.i65"
    .word caller
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word stashforth

;--------------------------------------------------------------
#if 0
name=(SAVEPRG)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
psaveprg
    jsr _dotapeio
    .word SAVEPRG

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr _dotapeio
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr _dotapeio
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
Current filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    jsr docreate
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Called at start of tape or disk i/o, sets up zero page variables.
Retrieves DRV# SA# and FILENAME uservariables and stores them
in zero page locations FA SA FNLEN FNADR.

Relies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea

|zero page|<|value|set by|description|h
|^STATUS|^96|^0|rom|^i/o status byte|
|^VERCK|^9d|^0|(file)|^0=load; 1=verify|
|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|
|^SAL|^c7-c8|^||^start address|
|^EAL|^c9-ca|^||^end address|
|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|
|^LA|^d2|^0|(file)|^logical file #|
|^SA|^d3|^SA#|(prg-file)|Secondary address|
|^FA|^d4|^DRV#|(file)|Device number|
|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|
|^STAL|^fb-fc|^||^start address|

|save|load|verify|open|name|address|description|h
|^?|^?|^?|^?|^FNLEN|^d1|^Length of current file name|
|^?|^?|^?|^?|^FNADR|^da-db|^File name address|
|^&nbsp;|<|<|<|<|<|<|
|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|
|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|
|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|
|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|
|^?|^?|^?|^?|^LA|^d2|^Current logical file number|
|^?|^?|^?|^?|^SA|^d3|^Current secondary address|
|^?|^?|^?|^?|^FA|^d4|^First address (device number)|
|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|
|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|
|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f

#endif
pfile
    brk
    .byt set | N0
    .word userfilename
    .byt ldd | N0               ; FILENAME
    .byt st | N2                ; pointer to FILENAME[0] or 0
    .byt bz , <(pfile01-*-2)
    .byt ldi | N2
pfile01
    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET
    .word FNLEN
    .byt sti | N1               ; set FNLEN ($d1)

;    .byt set | N1
;    .word LA
    .byt sub | ACC              ; 0
    .byt sti | N1               ; set LA ($d2)

;    .byt set | N1
;    .word SA
    .byt ldd | N0               ; get SA#
    .byt sti | N1               ; set SA ($d3)

;    .byt set | N1
;    .word FA
    .byt ldd | N0               ; DRV#
    .byt sti | N1               ; set FA ($d4)

    .byt set | N1
    .word FNADR
    .byt ld | N2
    .byt std | N1               ; set FNADR ($da)
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(PRG-FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Turn off SA# and set up for PRG file tape i/o

* sets SA# = 0
* sets TAPEID = 1
* invoke [[(FILE)]]
** copy `SA#` to SA
** copy `DRV#` to FA
** copy `FILENAME` to FNADR, FNLEN
** set TAPEID to $01 (PRG)
** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)

```
: (prg-file)   ( -- )
    sa# off  1 TAPEID c!  (file) ;
```
#endif
#include "align.i65"
_pprgfile
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word one
#include "pass.i65"
    .word clit                  ; ~ can remove this if using $f619
    .byt TAPEID
#include "page.i65"
    .word cstore
#include "page.i65"
    .word pfile
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(VMBUF)
stack=( -- from to )
tags=vm,kernel,nosymbol
Returns the end and start of the virtual memory buffer

```
: (vmbuf)   ( -- vmbuf blkbuf )
    vmbuf @  blkbuf ;
```
#endif
#include "align.i65"
_pvmbuf
    jsr enter
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word blkbuf
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CASBUF)
stack=( -- 027a|033a )
tags=vm,kernel,nosymbol
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

```
: (casbuf)   ( -- 027a|033a )
    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;
```
#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area between [[VMBUF]] and [[BLKBUF]] out
to a PRG file on cassette or disk

Also called by STOP-S in the editor

```
: save-buffers   ( -- )
    (prg-file)
    (vmbuf) next-1
    >r 2>r
    [ SETEALSTAL , ]
    (saveprg) ;
```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word _pprgfile             ; set up z.p. device, secondary, filename
#include "page.i65"
    .word _pvmbuf
#include "pass.i65"
    .word clit
    .byt <(next-1)              ; stupid stack tricks
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor
#include "page.i65"
    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT
#include "page.i65"
    .word psaveprg
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "pass.i65"
    .word clit
    .byt VERCK
#include "page.i65"
    .word cstore
#include "page.i65"
    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to [[VMBUF]]

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
#include "page.i65"
    .word zero                  ; LOAD
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm
Verifies the [[VMBUF]] area following a write

called by STOP-V in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one                   ; VERIFY
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pass.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pass.i65"
verifybuffers05
    .word exit

;--------------------------------------------------------------
#if 0
name=SRCTARG
stack=( -- var buffer size char  )
tags=vm,ext,nosymbol
[[BLOCK]] packs from or unpacks to [[VIDRAM]] or [[BLKBUF]], based on [[EDITING?]] and [[SCRPKT?]]

~ horrible name

```
: srctarg   ( -- scr|blk vidram|blkbuf b/scr|b/buf bl|0 )
    editing? ?: scr blk
    editing? ?: vidram blkbuf
    scrpkt? ?: b/scr b/buf
    scrpkt? ?: bl 0 ;
```
~#packrat
#endif
#include "align.i65"
_srctarg
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word scr
    .word blk
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word vidram                ; screens only, 1000 bytes
    .word blkbuf               ; block buffer, 1024 bytes
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word bperscr
    .word bperbuf
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word bl
    .word zero
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCREDIDX
stack=( -- var buffer size char  )
tags=vm,ext,nosymbol
return `scrpkt` + `editing` -> { 0 2 4 6 }

~#packrat
#endif
scredidx
    lda userscrpkt+1
    rol
    lda userediting
    rol
    asl
    and #$06
    jmp push0a

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Retrieves and decompresses a screen or data block from the [[VMBUF]]
[[region|PETTIL system memory map]]. This is PETTIL's top of the food
chain for reading packets, the antonym of [[UPDATE]] (which writes
packets).

The table below summarizes how `BLOCK` functions based on whether the
user is in the editor or not, and whether the packet is screen or data.

|^[[EDITING?]] |<|packet# sets [[SCR]]<br>returns [[VIDRAM]]|
|>|^ [[SCRPKT?]]|[[VIDRAM]] initialized to spaces<br>linewrap stored to zero page<br>write 1000-byte packet to [[VIDRAM]]|
|>|^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not [[SCRPKT?]]|[[VIDRAM]] initialized to nulls<br>zero page linewrap table set to all 40-column<br>displays first 1000 characters of data block|
||<|<|
|^not [[EDITING?]] |<|packet# sets [[BLK]]<br>returns [[BLKBUF]]|
|>|^ [[SCRPKT?]]|[[BLKBUF]] initialized to spaces<br>linewrap stored in first three bytes of [[BLKBUF]]<br>followed by 1000-bytes of screencodes|
|>|^ not [[SCRPKT?]]|[[BLKBUF]] initialized to nulls<br>1024 bytes of data expanded to [[BLKBUF]]|

```
: block   ( u -- addr )
    dup ?mkpkts     \ create packets if they don't exist yet
    dup pkt.info    \ ( blk floor len uncompressed? )
    rot srctarg 3dup nip
    b/buf swap fill 2drop 2>r r@ scrpkt?
    if              \ ( blk len uncompressed? floor
                    \ vidram|blkbuf scrpkt?
                    \ R; vidram|blkbuf scr|blk )
        drop rot 3- -rot 3+ dup 3- 3c@ editing?
        if
            wrap! r@
        else
            r@ 3C! r@ 3+
        then
    then
    2swap  ?: cmove rldecode
    2r> -rot ! ;

: block   ( u -- addr )
    dup ?mkpkts  dup blk !
    >pkt scredidx  >dodispatch
        blkclassic ,
        blkdatavid ,
        blkscrbuf ,
        blkscrvid ,
        [ latest @ unsmudge

blkdatabuf:

blkdatavid:
    ;

blkscrbuf:

blkscrvid:
    vidram b/scr blank  pkt.size 2- dup>r
    - vidram r> 3-
    uncompressed?  ?: cmove rldecode
    <n0 dup 3c@ wrap! 3+ ;

```
~#packrat
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
   .word _qmkpkts
#include "page.i65"
    .word dup
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _topkt
#include "page.i65"
   .word scredidx
#include "pass.i65"
    .word _dodispatch
    .word 0
    .word 2
    .word 4
    .word blkscrvid-2

#include "pass.i65"
blkscrvid
    .word drop
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N0
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word vidram
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UPD1)
stack=( -- )
tags=nosymbol

~#packrat
#endif
pupd1
    brk
    .byt ext
    .word harvests4
    .byt ldd | TOS              ; @
    .byt st | N3                ; vmbuf 'from' for cmoveq
    .byt ld | N8                ; pkt
    .byt sub | N1               ; - b/buf
    .byt st | N2                ; pkt.floor
    .byt ld | N8                ; pkt
    .byt sub | N0               ; - size
    .byt sub | N3               ; - vmbuf
    .byt inr | ACC              ; + 2
    .byt inr | ACC
    .byt st | TOS               ; 'howmany'
    .byt ld | N3                ; vmbuf
    .byt sub | N1               ; - b/buf
    .byt add | N0               ; + size
    .byt dcr | ACC              ; - 2
    .byt dcr | ACC
    .byt st | N0                ; 'to' for cmove
    .byt ld | N3
    .byt st | N1
    .byt ld | N0
    .byt st | N3
    .byt ext
    .word plants8
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD2)
stack=( wrapd )
tags=nosymbol
#endif
pupd2
    brk
    .byt ext
    .word harvests6
    .byt ldd | TOS              ; scrpkt
    .byt add | N1               ; targend+3
    .byt sub | N7               ; - floor
    .byt add | N2               ; + uncompressed?
    .byt inr | ACC
    .byt inr | ACC
    .byt std | N8               ; write updated packet header
    .byt popd | N8
    .byt ld | N2                ; targend
    .byt sub | N0               ; - vmbuf'
    .byt st | TOS               ; 'howmany'
    .byt ld | N0
    .byt st | N1                ; 'from'
    .byt ld | N8
    .byt sub | TOS
    .byt st | N0                ; 'to'
    .byt ext
    .word plants4
    .byt nxt

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies and compresses the current block buffer to the [[virtual memory
packet buffer|PETTIL system memory map]].  Analogous to `block` which
reads packets, this is PETTIL's single point of responsibility for
writing packets in the `vmbuf` region.

```
: update   ( -- )
\ are there any blocks?  ?exit
    #blk @ 0= ?exit
\ editing? choose vidram blkbuf
    blkbuf
    editing?
    if
\ early exit if editing data packet
\ scenario A (update packet from VIDRAM)
        drop
\ editing & isscr? choose vidram as source
\ editing & !isscr? do not modify this data packet
        isscr?
        ?: vidram exit
    then
    vmbuf b/buf
\ use the packet in `blk`   or `scr`
\ use               `b/buf` or `b/scr`
               b/buf blk
    isscr?
    if
        2drop  b/scr scr
    then
\ spread out the packet by moving everything below it down 1K
    @ >pkt
    (upd1)
    cmove
\ stash 24-bit line wrap info at the front of the packet
    l/scr wrap^
\ set the `scrpkt` bit in the new packet header
    scrpkt
\ shorten the buffer with `-trailing`
    ?: -trailing -nulls
\ attempt to rlencode what is left
    nip rlencode
\ write new packet header
\ squeeze out unused space in new packet, move `vmbuf` to top of packet
    +move
\ recount packets
    #blk! ;

: update   ( -- )
    scredidx 'updatetable dispatch

updatescrvid:
    scr @ >pkt pkt.size b/buf
    2nip vmbuf (upd1) cmove
    vidram tuck b/scr -trailing nip
    rlencode dup>r 3+ wrap@ 3c! scrpkt
    (upd2) cmove> #blk! ;
```
~#packrat
#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word scredidx              ; 0, 2, 4, 6 based from `editing` `scrpkt`
#include "pass.i65"
    .word _dodispatch
    .word updatedata-2
    .word exit-2
    .word updatescrbuf-2
    .word updatescrvid-2

#include "pass.i65"
updatedata
    .word exit

#include "pass.i65"
updatescrvid
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word twonip
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word pupd1
#include "page.i65"
    .word cmove
#include "page.i65"
    .word vidram
#include "page.i65"
    .word tuck
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word _dashtrailing
#include "page.i65"
    .word nip
#include "page.i65"
    .word rlencode              ; ( uncompressed? targend )
#include "page.i65"
    .word duptor
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word wrapfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word scrpkt                ; ( uncompressed? targend scrpkt )
#include "page.i65"
    .word pupd2
#include "page.i65"
    .word cmovegt
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

#include "pass.i65"
updatescrbuf
    .word exit

#print (*-bperbuf)

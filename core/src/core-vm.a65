; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #1)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab memsiz  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    ldy usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    ldy usermemsiz+1            ; okay use memsize in core mode
blkbuf02
    dey
    dey
    dey
    dey                         ; -1K (1024 bytes)
    lda #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive

 Reads a portion of the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!!pronounced: "wrap-above"
#endif
wrapabove
    stx z                       ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos                     ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2                     ; are we there yet?
    beq wrapabove03             ; leave if done
    lda $e0,x
    asl                         ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1                     ; append the next high bit to the double
    beq wrapabove02             ; this should always take the branch
wrapabove03
    lda n
    ldy n+1                     ; high half of the double is going on the stack
    ldx z                       ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- targend uncompressed? )
tags=vm,sweet16
This works a lot like `cmove` with its `from to howmany` stack signature, but
the target is a `packet` of `virtual memory` that can be permanently stored
to cassette tape.  The other difference is the two return values provided by
`rlencode`.

* `targend` End of the compressed|stored output
* `uncompressed?` Flag reveals whether RLE compression was used.

encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; n8    size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | N8                ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt ld | N2                ; targ (out)
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | N8                ; size
    .byt add | N7               ; +pristine targ
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt ld | N0
    .byt push
    .byt ld | N7
    .byt push
    .byt ld | N8
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=NEXT>R
stack=( -- R; next-1 )
tags=inner
Pushes the address `next-1` to the return stack so invoking
a subroutine afterward will `rts` to `next`.  Effectively
converts a subroutine to a Forth primitive.

pronounced: "next to R""

```
: next>r   ( -- R; next-1 )
    [ 'next 1- ] cliteral r> 2>r ;
```
#endif
#include "align.i65"
_nexttor
    jsr enter
#include "pass.i65"
    .word clit
    .byt <(next-1)
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( packet -- packet size )
tags=vm
Returns the packet length from a packet header.  The term `size` includes the 2
byte packet header, where a packet's `length` is just the contents (`size-2`).  The subroutine mode replaces the packet address at
`tos` with the length.  When called as a Forth word, `PKT.SIZE`
pushes the length to `tos` leaving the packet address unchanged
at `2os`.

pronounced: "packet-size"

```
: pkt.size   ( packet -- packet size )
    dup @ $7ff and ;
```
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "pass.i65"
    .word plit
    .word $07ff
#include "page.i65"
    .word andx
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- packet )
tags=vm,ext
Return the packet address of block N

```
: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over
    while
        pkt.size
        - -1 +under
    repeat
    nip ;
```
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
    .word over
#include "pass.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word minus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word plusunder
#include "pass.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "page.i65"
topktb02
    .word nip
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.INFO
stack=( packet -- floor length uncompressed? isscr? )
tags=vm,nosymbol
Returns the floor, length and flags from a packet header.  [[SCRPKT]]
is $8000 for screen packets, 0 for data packets.  the `uncompressed?`
value is $4000 for uncompressed packets, 0 for [[RLENCODE]]d packets.
The term `size` also includes the 2 byte packet header, while a
packet's `length` is just the contents (`size-2`)

pronounced: "packet-info"

```
: pkt.info   ( block -- floor length uncompressed? isscr? )
    >pkt dup>r pkt.size 2- dup>r -
    r> r> @ dup>r $4000 and r> vidram and scrpkt ! ;
```
#endif
#include "align.i65"
pktinfo
    jsr enter
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "pass.i65"
    .word plit
    .word $4000
#include "page.i65"
    .word andx
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word vidram
#include "page.i65"
    .word andx
#include "page.i65"
    .word scrpkt
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting
    ldy userediting+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext
Retrieves the [[SCRPKT]] user variable, which describes whether the current
packet type is screen (true) or data (false)   ~wut? calculate this instead

```
: isscr?   ( -- flag )
    scrpkt @ ;
```
#endif
isscrq
    lda userscrpkt
    ldy userscrpkt+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( addr size -- floor )
tags=vm,ext,nosymbol
inserts a new packet at address.

```
: pkt+   ( addr size -- floor )
    >r vmbuf @ over 1+
    r@ negate  dup vmbuf +!  +move
    r@ over !
    r> - 2+ ;
```
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word negate
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLE+
stack=( pkt -- floor )
tags=vm,ext,nosymbol
Converts the given packet into a maximum-sized packet so it may be used
as a temporary buffer by [[RLENCODE]]. This is a design-around to avoid
adding a second [[BLKBUF]] block buffer to the system.  Returns the
address of the beginning of the 1K temporary buffer.

```
: rle+   ( pkt -- floor )
    dup>r  b/buf dup 2+ r@ pkt.len
    >r 2- over r> - pkt+ drop
    r> ! - ;
```
#endif
#include "align.i65"
_rleplus
    jsr enter
#include "page.i65"
    .word duptor
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word tor
#include "page.i65"
    .word twominus
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word minus
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKPKTS
stack=( n -- )
tags=vm,ext,nosymbol
concatenates `n+1` new packets at the tail of the [[VMBUF]] area

```
: mkpkts   ( n -- )
    begin
        #blk 1+!  vmbuf @  editing?
        if
            dup>r 5 pkt+ dup on 1+ on vidram r> +!
        else
            2 pkt+ drop
        then
        1- 0<
    until drop ;
```
#endif
#include "align.i65"
_mkpkts
    jsr enter
#include "page.i65"
mkpkts01
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(mkpkts02-*+1)
#include "page.i65"
    .word duptor
#include "page.i65"
    .word five
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word on
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word on
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plusstore
#include "pass.i65"
    .word branch
    .byt <(mkpkts03-*+1)
#include "page.i65"
mkpkts02
    .word two
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word drop
#include "page.i65"
mkpkts03
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "pass.i65"
    .word qbranch
    .byt <(mkpkts01-*+1)
#include "page.i65"
    .word drop
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MKPKTS
stack=( blk -- )
tags=vm,ext,nosymbol
Used by [[BLOCK]] to create empty packets.  If `blk` references a packet
higher than  [[#BLK]], generates new packets at the tail of the buffer
(screen or data, based on [[EDITING]])

```
: ?mkpkts   ( blk -- )
    #blk @ - dup 0<
    ?: drop mkpkts ;
```
#endif
#include "align.i65"
_qmkpkts
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "pass.i65"
    .word pquerycolon
    .word drop
    .word _mkpkts
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapstore
    jsr harvests2
    stx z
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx z
    jmp drop

;--------------------------------------------------------------
#if 0
name=SCR0
stack=( -- )
tags=vm,nosymbol
Reset [[SCR]] and [[BLK]] to screen/block 0.

```
: scr0   ( -- )
    blk off  scr off ;
```
#endif
#include "align.i65"
_scr0
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm
Reset virtual memory user variables for `LOAD-BUFFERS` or `EMPTY-BUFFERS`

~ It should also validate flags and max-lengths, error out on corrupt VMBUF

```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

```
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word off
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word _pktsize
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "pass.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "page.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit


stashforth01 .byt 0             ; temp storage for X register during tape I/O

;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol,magic-number
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx 2                       ; $FF (z) gets messed up by save!  Use $02
    jsr aloha2
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    rts
;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Restore Forth stack after BASIC system call

#endif
restoreforth
    jsr aloha2
    ldx 2                       ; this messes up BASIC's USR() function
    jmp exit

;--------------------------------------------------------------
#if 0
name=DOTAPEIO
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Perform a ROM call framed between calls to [[Aloha]]. This is
needed in particular for tape I/O, which might error out to a
Commodore BASIC `ready.` prompt.

Like [[EXECUTE]] and the Sweet-16 interpreter, this word
uses the machine stack ($0100-$01ff) and RTS trick to transfer
control from one subroutine to the next, so that code executes
in this order:

todo: this is a little crashy returning from hitting the [[STOP]] key

```
stashforth
RTS
caller's ROM routine
RTS
restoreforth
EXIT
```
#endif
#include "align.i65"
_dotapeio
    jsr enter
#include "pass.i65"
    .word plit
    .word restoreforth-1
#include "page.i65"
    .word caller
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word stashforth

;--------------------------------------------------------------
#if 0
name=(SAVEPRG)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
psaveprg
    jsr _dotapeio
    .word SAVEPRG

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr _dotapeio
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr _dotapeio
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
Current filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Called at start of tape or disk i/o, sets up zero page variables.
Retrieves DRV# SA# and FILENAME uservariables and stores them
in zero page locations FA SA FNLEN FNADR.

Relies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea

|zero page|<|value|set by|description|h
|^STATUS|^96|^0|rom|^i/o status byte|
|^VERCK|^9d|^0|(file)|^0=load; 1=verify|
|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|
|^SAL|^c7-c8|^||^start address|
|^EAL|^c9-ca|^||^end address|
|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|
|^LA|^d2|^0|(file)|^logical file #|
|^SA|^d3|^SA#|(prg-file)|Secondary address|
|^FA|^d4|^DRV#|(file)|Device number|
|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|
|^STAL|^fb-fc|^||^start address|

|save|load|verify|open|name|address|description|h
|^?|^?|^?|^?|^FNLEN|^d1|^Length of current file name|
|^?|^?|^?|^?|^FNADR|^da-db|^File name address|
|^&nbsp;|<|<|<|<|<|<|
|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|
|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|
|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|
|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|
|^?|^?|^?|^?|^LA|^d2|^Current logical file number|
|^?|^?|^?|^?|^SA|^d3|^Current secondary address|
|^?|^?|^?|^?|^FA|^d4|^First address (device number)|
|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|
|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|
|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f

#endif
pfile
    brk
    .byt set | N0
    .word userfilename
    .byt ldd | N0               ; FILENAME
    .byt st | N2                ; pointer to FILENAME[0] or 0
    .byt bz , <(pfile01-*-2)
    .byt ldi | N2
pfile01
    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET
    .word FNLEN
    .byt sti | N1               ; set FNLEN ($d1)

;    .byt set | N1
;    .word LA
    .byt sub | ACC              ; 0
    .byt sti | N1               ; set LA ($d2)

;    .byt set | N1
;    .word SA
    .byt ldd | N0               ; get SA#
    .byt sti | N1               ; set SA ($d3)

;    .byt set | N1
;    .word FA
    .byt ldd | N0               ; DRV#
    .byt sti | N1               ; set FA ($d4)

    .byt set | N1
    .word FNADR
    .byt ld | N2
    .byt std | N1               ; set FNADR ($da)
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(PRG-FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Turn off SA# and set up for PRG file tape i/o

* sets SA# = 0
* sets TAPEID = 1
* invoke [[(FILE)]]
** copy `SA#` to SA
** copy `DRV#` to FA
** copy `FILENAME` to FNADR, FNLEN
** set TAPEID to $01 (PRG)
** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)

```
: (prg-file)   ( -- )
    sa# off  1 TAPEID c!  (file) ;
```
#endif
#include "align.i65"
_pprgfile
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word one
#include "pass.i65"
    .word clit                  ; ~ can remove this if using $f619
    .byt TAPEID
#include "page.i65"
    .word cstore
#include "page.i65"
    .word pfile
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(VMBUF)
stack=( -- from to )
tags=vm,kernel,nosymbol
Returns the end and start of the virtual memory buffer

```
: (vmbuf)   ( -- vmbuf blkbuf )
    vmbuf @  blkbuf ;
```
#endif
#include "align.i65"
_pvmbuf
    jsr enter
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word blkbuf
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CASBUF)
stack=( -- 027a|033a )
tags=vm,kernel,nosymbol
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

```
: (casbuf)   ( -- 027a|033a )
    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;
```
#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area between [[VMBUF]] and [[BLKBUF]] out
to a PRG file on cassette or disk

Also called by STOP-S in the editor

```
: save-buffers   ( -- )
    (prg-file)
    (vmbuf) next-1
    >r 2>r
    [ SETEALSTAL , ]
    (saveprg) ;
```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word _pprgfile             ; set up z.p. device, secondary, filename
#include "page.i65"
    .word _pvmbuf
#include "pass.i65"
    .word clit
    .byt <(next-1)              ; stupid stack tricks
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor
#include "page.i65"
    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT
#include "page.i65"
    .word psaveprg
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "pass.i65"
    .word clit
    .byt VERCK
#include "page.i65"
    .word cstore
#include "page.i65"
    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to [[VMBUF]]

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
#include "page.i65"
    .word zero                  ; LOAD
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm
Verifies the [[VMBUF]] area following a write

called by STOP-V in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one                   ; VERIFY
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pass.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pass.i65"
verifybuffers05
    .word exit

;--------------------------------------------------------------
#if 0
name=SRCTARG
stack=( -- var buffer size char  )
tags=vm,ext,nosymbol
[[BLOCK]] packs from or unpacks to [[VIDRAM]] or [[BLKBUF]], based on [[EDITING?]] and [[SCRPKT?]]

~ horrible name

```
: srctarg   ( -- scr|blk vidram|blkbuf b/scr|b/buf bl|0 )
    editing? ?: scr blk
    editing? ?: vidram blkbuf
    scrpkt? ?: b/scr b/buf
    scrpkt? ?: bl 0 ;
```
#endif
#include "align.i65"
_srctarg
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word scr
    .word blk
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word vidram                ; screens only, 1000 bytes
    .word blkbuf               ; block buffer, 1024 bytes
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word bperscr
    .word bperbuf
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word bl
    .word zero
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Retrieves and decompresses a screen or data block from the [[VMBUF]]
[[region|PETTIL system memory map]]. This is PETTIL's top of the food
chain for reading packets, the antonym of [[UPDATE]] (which writes
packets).

The table below summarizes how `BLOCK` functions based on whether the
user is in the editor or not, and whether the packet is screen or data.

|^[[EDITING?]] |<|packet# sets [[SCR]]<br>returns [[VIDRAM]]|
|>|^ [[SCRPKT?]]|[[VIDRAM]] initialized to spaces<br>linewrap stored to zero page<br>write 1000-byte packet to [[VIDRAM]]|
|>|^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not [[SCRPKT?]]|[[VIDRAM]] initialized to nulls<br>zero page linewrap table set to all 40-column<br>displays first 1000 characters of data block|
||<|<|
|^not [[EDITING?]] |<|packet# sets [[BLK]]<br>returns [[BLKBUF]]|
|>|^ [[SCRPKT?]]|[[BLKBUF]] initialized to spaces<br>linewrap stored in first three bytes of [[BLKBUF]]<br>followed by 1000-bytes of screencodes|
|>|^ not [[SCRPKT?]]|[[BLKBUF]] initialized to nulls<br>1024 bytes of data expanded to [[BLKBUF]]|

```
: block
    dup ?mkpkts     \ create packets if they don't exist yet
    dup pkt.info    \ ( blk floor len uncompressed? )
    rot srctarg 3dup nip
    b/buf swap fill 2drop 2>r r@ scrpkt?
    if              \ ( blk len uncompressed? floor
                    \ vidram|blkbuf scrpkt?
                    \ R; vidram|blkbuf scr|blk )
        drop rot 3- -rot 3+ dup 3- 3c@ editing?
        if
            wrap! r@
        else
            r@ 3c! r@ 3+
        then
    then
    2swap  ?: cmove rldecode
    2r> -rot ! ;
```
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
   .word _qmkpkts
#include "page.i65"
    .word dup
#include "page.i65"
    .word pktinfo
#include "page.i65"
    .word rot
#include "page.i65"
    .word _srctarg
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word nip
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word swap
#include "page.i65"
    .word fill
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word twotor
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(block02-*+1)
#include "page.i65"
    .word drop
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(block01-*+1)
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word rfetch
#include "pass.i65"
    .word branch
    .byt <(block02-*+1)
#include "page.i65"
block01
    .word rfetch
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word threeplus
#include "page.i65"
block02
    .word twoswap
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UPD1)
stack=( from to howmany char -- )
tags=vm,nosymbol
Reorganize the stack from some raw, disorganized pointers and
values.  Returns enough to open up a 1024 byte hole in the
VM buffer and trim trailing blanks/nulls from the source buffer,
along with a couple values that are required later.

( src srcbufsiz pkt vmbuf maxbufsiz 0 )

||^data|^editing<br/>screen|<|h
|TOS|0|<|<|
|N0|blkbuf|vidram|src|
|N1|b/buf|b/scr|srcbufsiz|
|N2|pkt|<|dst|
|N3|pktsize|<||
|N4|vmbuf|<|bottom|
|N5|b/buf|<|maxbufsiz|
( bottom pkt floor / src dest src srcbufsiz / vmbuf vmbuf-b/buf pkt-vmbuf )

#endif
#include "align.i65"
pupd1
    jsr harvests10
    brk
    .byt ldd | N1               ; vmbuf @
    .byt st | N5                ; save for later
    .byt sub | N2               ; vmbuf-1024
    .byt add | TOS              ; vmbuf-1024+size
    .byt dcr | ACC
    .byt dcr | ACC              ; vmbuf-1024+size-2
    .byt st | N6                ; save for later
    ; things we'll need for CMOVE+
    .byt st | TOS               ; =bottom
    .byt ld | N4                ; pkt
    .byt push                   ; =pkt
    .byt sub | N2               ; pkt-1024
    .byt st | N7                ; save for later
    .byt push                   ; =floor
    ; things we'll need for RLENCODE
    .byt push                   ; =dest
    .byt ld | N0                ; blkbuf|vidram
    .byt push                   ; =src
    .byt ld | N3                ; b/buf|b/scr
    .byt push                   ; =srcbufsiz
    ; things we'll need for CMOVE
    .byt ld | N5
    .byt push                   ; =from
    .byt ld | N6
    .byt push                   ; =bottom
    .byt ld | N7
    .byt sub | N6
    .byt push                   ; =howmany
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD2)
stack=( source floor actualsize wrapd 'scrpkt -- )
tags=vm,nosymbol
Sets up the linewrap bits in the output buffer (if needed) and
gets ready for RLENCODE and squeezing out unused space

||^data|^editing<br/>screen|<|h
|TOS|'scrpkt|<|<|
|N0|floor|<|<|
|N1|blkbuf|vidram|src|
|N2|b/buf|b/scr|srcbufsiz|
|N3|wrapdlo|<|<|
|N4|wrapdhi|<|<|

need 3C@ and 3C! for linewrap

#endif
pupd2
    jsr harvests10
    lda n+7                     ; N3+1
    sta n+12                    ; N6
    brk
    .byt ldd | TOS              ; isscr?
    .byt st | N5                ; save for later
    .byt bz , <(pupd2b-*-2)
    .byt ldd | TOS              ; editing?
    .byt bnz , <(pupd2a-*-2)
    .byt ldd | N1
    .byt std | N0
    .byt ldi | N1
    .byt sti | N0               ; use linewrap from blkbuf
    .byt br , <(pupd2b-*-2)
pupd2a
    .byt ld | N4
    .byt sti | N0
    .byt ld | N6
    .byt sti | N0
    .byt ld | N3
    .byt sti | N0
;    .byt ld | N3
;    .byt sti | N0
;    .byt ld | N6
;    .byt sti | N0
;    .byt ld | N4
;    .byt sti | N0              ; write linewrap to output
pupd2b
    ; setup for RLENCODE
    .byt ld | N1                ; from
    .byt st | TOS
    .byt ld | N0                ; to
    .byt push
    ; setup for -TRAILING or -NULLS
    .byt ld | N1                ; source
    .byt push
    .byt ld | N2                ; actual size
    .byt push
    .byt ld | N5                ; isscr?
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD3)
stack=( )
tags=vm,nosymbol

||^data|^editing<br/>screen|<|h
|TOS|0|<|<|
|N0|blkbuf|vidram|src|
|N1|b/buf|b/scr|srcbufsiz|
|N2|pkt|<|dst|
|N3|vmbuf|<|bottom|
|N4|b/buf|<|maxbufsiz|

( bottom targend-1 pkt-targend )
+move #blk! ;

#endif
pupd3
    lda tos+1                   ; SCRPKT flag bit to Carry
    ora stackh,x                ; UNCOMPRESSED? flag
    and #$c0
    sta tos+1
    jsr harvests8
    sty tos                     ; low byte of packet flags
    brk
    .byt ld | N2
    .byt sub | N1
    .byt add | TOS
    .byt st | N3                ; packet header
    .byt ldd | N3               ; +2
    .byt ld | N2
    .byt st | TOS
    .byt ld | N0
    .byt sub | TOS
    .byt dcr | TOS              ; =targend-1
    .byt push                   ; =pkt-targend
    .byt ld | N3
    .byt std | N0
    .byt nxt

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies and compresses the current block buffer to the [[virtual memory
packet buffer|PETTIL system memory map]].  Analogous to [[BLOCK]] which
reads packets, this is PETTIL's single point of responsibility for
writing packets in the [[VMBUF]] region.

```
: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;
```
#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(update01-*+1)
#include "page.i65"
    .word drop
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word vidram
    .word exit
#include "page.i65"
update01
    .word vmbuf
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word blk
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(update02-*+1)
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word scr
#include "page.i65"
update02
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word pupd1
#include "page.i65"
    .word cmove
#include "page.i65"
    .word lperscr               ; 25
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word scrpkt
#include "page.i65"
    .word pupd2
#include "pass.i65"
    .word pquerycolon
    .word dashtrailing
    .word dashnulls
#include "page.i65"
    .word nip
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word isscrq
#include "page.i65"
    .word pupd3
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

#print (*-bperbuf)

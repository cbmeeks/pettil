; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word BPERBUF

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word BPERSCR

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab memsiz  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    ldy usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    ldy usermemsiz+1            ; okay use memsize in core mode
blkbuf02
    dey
    dey
    dey
    dey                         ; -1K (1024 bytes aka `b/buf`)
    lda #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting
    ldy userediting+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the current packet is a screen
`false` when the packet is a data block

```
: isscr?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
~#packrat
#endif
isscrq
    sec
    .byt $29                    ; AND imm
    ;fall through
;--------------------------------------------------------------
#if 0
name=UNCOMPRESSED?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the packet is simply stored by `cmove` or
`false` when the packet is runlength-encoded

```
: uncompressed?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
~#packrat
#endif
uncompressedq
    clc
    ldy #1
    lda (ACC+2*N8),y            ; packet header msb
    bcs uncompressedq01
    asl
uncompressedq01
    asl                         ; normalize `flag`
    jmp pushc

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #1)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=(CASBUF)
stack=( -- 027a|033a )
tags=vm,kernel,nosymbol
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

```
: (casbuf)   ( -- 027a|033a )
    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;
```
#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive,nosymbol

 Reads a portion of the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!!pronounced: "wrap-above"
#endif
wrapabove
    stx z                       ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos                     ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2                     ; are we there yet?
    beq wrapabove03             ; leave if done
    lda $e0,x
    asl                         ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1                     ; append the next high bit to the double
    beq wrapabove02             ; this should always take the branch
wrapabove03
    lda n
    ldy n+1                     ; high half of the double is going on the stack
    ldx z                       ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- uncompressed? targend )
tags=vm,sweet16
This works a lot like `cmove` with its `from to howmany` stack signature, but
the target is a `packet` of `virtual memory` that can be permanently stored
to cassette tape.  The other difference is the two return values provided by
`rlencode`.

* `targend` End of the compressed|stored output
* `uncompressed?` Flag reveals whether RLE compression was used.

encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; r11   size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | R11               ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt sub | ACC
    .byt st | TOS
    .byt ld | N2                ; targ (out)
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt set | ACC
    .word $4000
    .byt st | TOS
    .byt ld | R11               ; return original `size`
    .byt add | N7               ; +pristine targ
    .byt push
    .byt ld | N0                ; from
    .byt push
    .byt ld | N7                ; to
    .byt push
    .byt ld | R11               ; howmany
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( -- packet size )
tags=vm,nosymbol
Returns the current `pkt` address and `size` of the packet in `n8`


```
: pkt.size   ( -- pkt size )
    <n8 dup @ $7ff and ;

    jsr slip
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    pha
    jmp rfrom
```
pronounced: "packet-size"
~#packrat
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N8
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PSIZE
stack=( pkt.header -- pkt.size )
tags=vm,ext
Return just the size of the `pkt.header` on the stack

~#packrat
#endif
psize
;    lda #>(next-1)
;    pha
;    lda #<(next-1)
;    pha
;psizes
    lda tos+1
    and #$07
    sta tos+1
;    rts
    jmp next

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- pkt )
tags=vm,ext
Return the `pkt` address of block `n`, sets `n8`

~ return a 0 if there are less than `n` packets?

```
: >pkt   ( n -- pkt )
    brk
    .byt set | N0
    .word usersymtab
    .byt ldd | N0
    .byt set | N1
    .word 1024
    .byt sub | N1

    .byt st | N0
topkt01
    .byt popd | N0
    .byt ext
    .word psizes
    .byt bz , <(topkt02-*-2)
    .byt ld | TOS
    .byt sub | N0

    .byt st | N1
    .byt ld | TOS
    .byt sub | N1
    .byt inr | ACC
    .byt inr | ACC
    .byt st | TOS
    .byt dcr | N0
    .byt bnz , <(topkt01-*-2)
topkt02

    ] 2-


    blkbuf 2-
    begin
        over
    while
        1-under
        @+ psize - 2-
    repeat
    nip >n8 ;

    .byt set
    .word

```
~#packrat
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
#include "page.i65"
    .word over
#include "pass.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "page.i65"
    .word oneminusunder
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word psize
#include "page.i65"
    .word minus
#include "page.i65"
    .word twominus
#include "pass.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "page.i65"
topktb02
    .word nip
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=WRAP@
stack=( -- wrapd  )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapfetch
    jsr slip
    dex
    ldy #LPERSCR-1              ; 24 lines (1-25)
wrapfetch01
    lda LDTB1,y                 ;$E0 = 0, always $80  $E1-$F8
    asl
    ror tos
    ror stackh,x
    ror stackl,x
    dey
    bne wrapfetch01
    sty tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapstore
    jsr harvests2
    txa
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    tax                         ; restore stack pointer
    jmp drop

;--------------------------------------------------------------
#if 0
name=NOWRAP
stack=( -- )
tags=editor,nosymbol

 reset the linewrap table and force this block to be a screen
 even if it was a data packet

~#packrat
#endif
#include "align.i65"
_nowrap
    jsr enter
#include "page.i65"
    .word true
#include "page.i65"
    .word true
#include "page.i65"
    .word wrapstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCR0
stack=( -- )
tags=vm,nosymbol
Reset [[SCR]] and [[BLK]] to screen/block 0.

```
: scr0   ( -- )
    blk off  scr off ;
```
#endif
#include "align.i65"
_scr0
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm,nosymbol
Reset virtual memory user variables for `LOAD-BUFFERS` or `EMPTY-BUFFERS`

~ It should also validate flags and max-lengths, error out on corrupt VMBUF
~wut?  throw a `bad vm packet` error if a length/flag is off the reservation
```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

```
~#packrat
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word off
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "pass.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "page.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKSCR
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkscr
    jsr docreate
    .byt 5, $FF, $FF, $FF, $05, $80

;--------------------------------------------------------------
#if 0
name=MKDATA
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkdata
    jsr docreate
    .byt 2, $02, $40

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( -- )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

* adds a new data or screen packet (per `editing`)
* sets `scr` to point to it (also per `editing`) ( `^` likes this )
* moves `vmbuf` down by 2 or 5
* increments `#blk`

```
: pkt+   ( -- )
    editing? ?: mkscr mkdata
    count (pkt+)
    1+! swap cmove ;



```
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word mkscr
    .word mkdata
#include "page.i65"
    .word count
#include "page.i65"
    .word ppktplus
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "pass.i65"
    .word exit

ppktplus
    brk
    .byt set | N0
    .word usernumblk
    .byt popd | N0              ; `vmbuf`
    .byt st | N8                ; `pkt`
    .byt sub | TOS              ; `pkt` - `size`
    .byt std | N0               ; set `vmbuf`
    .byt push
    .byt sub | ACC
    .byt std | TOS
    .byt ld | N0                ; #blk
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SCREDIDX
stack=( -- index  )
tags=vm,ext,nosymbol
return `index`:
0 quitmode; data
2 quitmode; scr
4 editmode; data
6 editmode; scr

~#packrat
#endif
scredidx
    ldy #1
    lda (ACC+2*N8),y
    asl
    tya
    and userediting
    rol
    asl
    jmp push0a

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Retrieves and decompresses a screen or data block from the [[VMBUF]]
[[region|PETTIL system memory map]]. This is PETTIL's top of the food
chain for reading packets, the antonym of [[UPDATE]] (which writes
packets).

The table below summarizes how `BLOCK` functions based on whether the
user is in the editor or not, and whether the packet is screen or data.

|^[[EDITING?]] |<|packet# sets [[SCR]]<br>returns [[VIDRAM]]|
|>|^ [[SCRPKT?]]|[[VIDRAM]] initialized to spaces<br>linewrap stored to zero page<br>write 1000-byte packet to [[VIDRAM]]|
|>|^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not [[SCRPKT?]]|[[VIDRAM]] initialized to nulls<br>zero page linewrap table set to all 40-column<br>displays first 1000 characters of data block|
||<|<|
|^not [[EDITING?]] |<|packet# sets [[BLK]]<br>returns [[BLKBUF]]|
|>|^ [[SCRPKT?]]|[[BLKBUF]] initialized to spaces<br>linewrap stored in first three bytes of [[BLKBUF]]<br>followed by 1000-bytes of screencodes|
|>|^ not [[SCRPKT?]]|[[BLKBUF]] initialized to nulls<br>1024 bytes of data expanded to [[BLKBUF]]|

```
: block   ( u -- addr )
    dup
    begin                       \ make packets loop
        #blk @ over 1+ <
     while
        pkt+
    repeat
    blk !                       \ `blk` <- `u`
    >pkt scredidx  >dodispatch
        blkclassic ,
        blkdatavid ,
        blkscrbuf ,
        blkscrvid ,
        [ latest @ unsmudge

blkdatabuf:

blkdatavid:
    ;

blkscrbuf:

blkscrvid:
    vidram b/scr blank  pkt.size 2- dup>r
    - vidram r> 3-
    uncompressed?  ?: cmove rldecode
    <n0 dup 3c@ wrap! 3+ ;

```
~#packrat
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
qmkpkts01
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word lt
#include "pass.i65"
    .word qbranch
    .byt <(qmkpkts02-*+1)
#include "page.i65"
    .word _pktplus
#include "pass.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "page.i65"
qmkpkts02
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _topkt
#include "page.i65"
   .word scredidx
#include "pass.i65"
    .word _dodispatch
    .word blkdatabuf-2
    .word blkscrbuf-2
    .word blkdatavid-2
    .word blkscrvid-2

;~wut? consolidate this code some more
;~wut? test blkdatabuf does `cmove`
#include "pass.i65"
blkdatabuf
    .word blkbuf
#include "page.i65"
    .word tuck
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _erase
#include "page.i65"
    .word over
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "pass.i65"
    .word exit

#include "pass.i65"
blkscrbuf
    .word threeminus
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word twodup
#include "page.i65"
    .word _blank
#include "page.i65"
    .word plus
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word tuck
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "pass.i65"
    .word exit

#include "pass.i65"
blkdatavid
    .word vidram
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word nip
#include "page.i65"
    .word twominus
#include "page.i65"
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode

#include "pass.i65"
blkscrvid
    .word drop
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N0
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word vidram
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UPD1)
stack=( source size b/buf vmbuf -- source vmbuf' floor from to howmany )
tags=nosymbol

~#packrat
#endif
pupd1
    brk
    .byt ext
    .word harvests4
    .byt ldd | TOS              ; vmbuf @
    .byt st | N3                ; vmbuf 'from' for cmoveq
    .byt ld | N8                ; pkt
    .byt sub | N1               ; - b/buf
    .byt st | N2                ; pkt.floor
    .byt ld | N8                ; pkt
    .byt sub | N0               ; - size
    .byt sub | N3               ; - vmbuf
    .byt inr | ACC              ; + 2
    .byt inr | ACC
    .byt st | TOS               ; 'howmany'
    .byt ld | N3                ; vmbuf
    .byt sub | N1               ; - b/buf
    .byt add | N0               ; + size
    .byt dcr | ACC              ; - 2
    .byt dcr | ACC
    .byt st | N0                ; 'to' for cmove
    .byt ld | N3
    .byt st | N1                ; 'from' for cmove
    .byt ld | N0
    .byt st | N3                ; new `vmbuf`
    .byt ext
    .word plants8
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD2)
stack=( -- )
tags=nosymbol
#endif
pupd2
    brk
    .byt ext
    .word harvests6
    .byt ld | TOS               ; isscr?
    .byt add | N1               ; targend+3
    .byt sub | N7               ; - floor
    .byt add | N2               ; + uncompressed?
    .byt inr | ACC
    .byt inr | ACC
    .byt std | N8               ; write updated packet header
    .byt popd | N8
    .byt ld | N2                ; targend
    .byt sub | N0               ; - vmbuf'
    .byt st | TOS               ; 'howmany'
    .byt ld | N0
    .byt st | N1                ; 'from'
    .byt ld | N8
    .byt sub | TOS
    .byt st | N0                ; 'to'
    .byt st | N2                ; `vmbuf`
    .byt ext
    .word plants6
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SUP
stack=( vidram|blkbuf scr|blk -- )
tags=forth-83,vm,nosymbol

```
\ sprog of update
: sup ( vidram|blkbuf -- )
    @ >pkt pkt.size b/buf 2nip vmbuf
    (upd1) cmove
    rlencode
    set up pkt.floor
    (upd1)
    cmove
    isscr?  ?: -trailing -nulls nip
    rlencode
    editing? vidram and
    (upd2)
    uncompressed?  ?: cmove rlencode ;
#endif
#include "align.i65"
_sup
    jsr enter
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word bperbuf               ; open up a space this big in the packet
#include "page.i65"
    .word twonip
#include "page.i65"
    .word vmbuf
#include "page.i65"
                                ;( source size b/buf vmbuf )
    .word pupd1
                                ;( source from to howmany )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word third        ; ~ third?
#include "page.i65"
    .word tuck
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word bperscr
    .word bperbuf
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word _dashtrailing
    .word dashnulls
#include "page.i65"
    .word nip
#include "page.i65"
    .word rlencode              ; ( uncompressed? targend )
#include "page.i65"
    .word editingq
#include "page.i65"
    .word vidram
#include "page.i65"
    .word andx
#include "page.i65"
    .word pupd2
#include "page.i65"
    .word cmovegt               ; move the bottom of `vmbuf` back up
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store                 ; set `vmbuf`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies and compresses the current block buffer to the [[virtual memory
packet buffer|PETTIL system memory map]].  Analogous to `block` which
reads packets, this is PETTIL's single point of responsibility for
writing packets in the `vmbuf` region.

tests:
~\ empty block
~\ fill blkbuf half with deadbeef
~\ fill blkbuf all with deadbeef
~\ fill blkbuf half with '!'
~\ fill blkbuf all with '!'

```

updatescrvid:
    scr @ >pkt pkt.size b/buf
    2nip vmbuf (upd1) cmove
    vidram tuck b/scr -trailing nip
    rlencode dup>r 3+ wrap@ 3c! scrpkt?
    (upd2) cmove> #blk! ;

updscrvid
    .word scr
    .word fetch
    .word _topkt
    .word _pktsize
    .word bperbuf
    .word twonip
    .word vmbuf
    .word pupd1
    .word cmove
    .word vidram
    .word tuck
    .word bperscr
    .word _dashtrailing
    .word nip
    .word rlencode              ; ( uncompressed? targend )
    .word duptor
    .word threeplus
    .word wrapfetch
    .word rfrom
    .word threecstore
    .word editingq
    .word vidram
    .word andx
    .word pupd2
    .word cmovegt
    .word vmbuf
    .word store
    .word exit

: update   ( -- )
    \ source is either `vidram` or `blkbuf`
    \ target is always pkt.floor
    editing?
    if
        isscr?
        if
            vidram sup
            wrap@ rot 3c!
        then
    else
upd01
        blkbuf sup
        isscr?
        if
            blkbuf 1000 + 3c@
            rot 3c!
        then
    then
upd02
;
```
~#packrat
#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(upd01-*+1)
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd02-*+1)
#include "page.i65"
    .word vidram
#include "page.i65"
    .word scr
#include "page.i65"
    .word _sup
#include "page.i65"
    .word wrapfetch
#include "page.i65"
    .word rot
#include "page.i65"
    .word threecstore
#include "pass.i65"
    .word branch
    .byt <(upd02-*+1)
#include "page.i65"
upd01
    .word blkbuf
#include "page.i65"
    .word blk
#include "page.i65"
    .word _sup
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd02-*+1)
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word plus
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word rot
#include "page.i65"
    .word threecstore
#include "pass.i65"
upd02
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol,magic-number
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx stashforth01
    jsr aufwiedersehen
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    rts
stashforth01 .byt 0             ; temp storage for X register during tape I/O

;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Restore Forth stack after BASIC system call

#endif
restoreforth
    jsr aloha2
    ldx stashforth01            ; this messes up BASIC's USR() function
    jmp exit

;--------------------------------------------------------------
#if 0
name=DOTAPEIO
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Perform a ROM call framed between calls to `aloha`. This is
needed in particular for tape I/O, which might error out to a
Commodore BASIC `ready.` prompt.

Like `execute` and the Sweet-16 interpreter, this word
uses the machine stack ($0100-$01ff) and RTS trick to transfer
control from one subroutine to the next, so that code executes
in this order:

~wut?  this is a little crashy returning from hitting the [[STOP]] key

```
stashforth
RTS
caller's ROM routine
RTS
restoreforth
EXIT
```
#endif
#include "align.i65"
_dotapeio
    jsr enter
#include "pass.i65"
    .word plit
    .word restoreforth-1
#include "page.i65"
    .word caller
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word stashforth

;--------------------------------------------------------------
#if 0
name=(SAVEPRG)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
psaveprg
    jsr _dotapeio
    .word SAVEPRG

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr _dotapeio
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr _dotapeio
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
Current filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    jsr docreate
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Called at start of tape or disk i/o, sets up zero page variables.
Retrieves DRV# SA# and FILENAME uservariables and stores them
in zero page locations FA SA FNLEN FNADR.

Relies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea

|zero page|<|value|set by|description|h
|^STATUS|^96|^0|rom|^i/o status byte|
|^VERCK|^9d|^0|(file)|^0=load; 1=verify|
|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|
|^SAL|^c7-c8|^||^start address|
|^EAL|^c9-ca|^||^end address|
|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|
|^LA|^d2|^0|(file)|^logical file #|
|^SA|^d3|^SA#|(prg-file)|Secondary address|
|^FA|^d4|^DRV#|(file)|Device number|
|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|
|^STAL|^fb-fc|^||^start address|

|save|load|verify|open|name|address|description|h
|^?|^?|^?|^?|^FNLEN|^d1|^Length of current file name|
|^?|^?|^?|^?|^FNADR|^da-db|^File name address|
|^&nbsp;|<|<|<|<|<|<|
|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|
|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|
|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|
|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|
|^?|^?|^?|^?|^LA|^d2|^Current logical file number|
|^?|^?|^?|^?|^SA|^d3|^Current secondary address|
|^?|^?|^?|^?|^FA|^d4|^First address (device number)|
|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|
|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|
|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f

#endif
pfile
    brk
    .byt set | N0
    .word userfilename
    .byt ldd | N0               ; FILENAME
    .byt st | N2                ; pointer to FILENAME[0] or 0
    .byt bz , <(pfile01-*-2)
    .byt ldi | N2
pfile01
    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET
    .word FNLEN
    .byt sti | N1               ; set FNLEN ($d1)

;    .byt set | N1
;    .word LA
    .byt sub | ACC              ; 0
    .byt sti | N1               ; set LA ($d2)

;    .byt set | N1
;    .word SA
    .byt ldd | N0               ; get SA#
    .byt sti | N1               ; set SA ($d3)

;    .byt set | N1
;    .word FA
    .byt ldd | N0               ; DRV#
    .byt sti | N1               ; set FA ($d4)

    .byt set | N1
    .word FNADR
    .byt ld | N2
    .byt std | N1               ; set FNADR ($da)
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(PRG-FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Turn off SA# and set up for PRG file tape i/o

* sets SA# = 0
* sets TAPEID = 1
* invoke [[(FILE)]]
** copy `SA#` to SA
** copy `DRV#` to FA
** copy `FILENAME` to FNADR, FNLEN
** set TAPEID to $01 (PRG)
** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)

```
: (prg-file)   ( -- )
    sa# off  1 TAPEID c!  (file) ;
```
#endif
#include "align.i65"
_pprgfile
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word one
#include "pass.i65"
    .word clit                  ; ~ can remove this if using $f619
    .byt TAPEID
#include "page.i65"
    .word cstore
#include "page.i65"
    .word pfile
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area between [[VMBUF]] and [[BLKBUF]] out
to a PRG file on cassette or disk

Also called by STOP-S in the editor

```
: save-buffers   ( -- )
    (prg-file)
    (vmbuf) next-1
    >r 2>r
    [ SETEALSTAL , ]
    (saveprg) ;
```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word _pprgfile             ; set up z.p. device, secondary, filename
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word blkbuf
#include "pass.i65"
    .word clit
    .byt <(next-1)              ; stupid stack tricks
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor
#include "page.i65"
    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT
#include "page.i65"
    .word psaveprg
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "pass.i65"
    .word clit
    .byt VERCK
#include "page.i65"
    .word cstore
#include "page.i65"
    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to [[VMBUF]]

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
#include "page.i65"
    .word zero                  ; LOAD
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm
Verifies the [[VMBUF]] area following a write

called by STOP-V in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one                   ; VERIFY
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pass.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pass.i65"
verifybuffers05
    .word exit

#print (*-bperbuf)

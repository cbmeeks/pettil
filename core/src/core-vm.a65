; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word BPERBUF

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word BPERSCR

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab memsiz  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    ldy usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    ldy usermemsiz+1            ; okay use memsize in core mode
blkbuf02
    dey
    dey
    dey
    dey                         ; -1K (1024 bytes aka `b/buf`)
    lda #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting+1
    jmp uncompressedq01

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when `pkt` type is screen
`false` when the `pkt` type is data

```
: isscr?   ( -- flag )
    <n8 @ $4000 and ;
```
~#packrat
#endif
isscrq
    sec
    .byt $29                    ; AND imm
    ;fall through
;--------------------------------------------------------------
#if 0
name=UNCOMPRESSED?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the packet is simply stored by `cmove` or
`false` when the packet is runlength-encoded

```
: uncompressed?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
~#packrat
#endif
uncompressedq
    clc
    ldy #1
    lda (ACC+2*N8),y            ; packet header msb
    bcs uncompressedq01
    asl
uncompressedq01
    asl                         ; normalize `flag`
    jmp pushc

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #1)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=(CASBUF)
stack=( -- 027a|033a )
tags=vm,kernel,nosymbol
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

```
: (casbuf)   ( -- 027a|033a )
    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;
```
#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive,nosymbol

 Reads a portion of the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!!pronounced: "wrap-above"
#endif
wrapabove
    stx z                       ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos                     ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2                     ; are we there yet?
    beq wrapabove03             ; leave if done
    lda $e0,x
    asl                         ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1                     ; append the next high bit to the double
    beq wrapabove02             ; this should always take the branch
wrapabove03
    lda n
    ldy n+1                     ; high half of the double is going on the stack
    ldx z                       ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- targend uncompressed? )
tags=vm,sweet16
This works a lot like `cmove` with its `from to howmany` stack signature, but
the target is a `packet` of `virtual memory` that can be permanently stored
to cassette tape.  The other difference is the two return values provided by
`rlencode`.

* `targend` End of the compressed|stored output
* `uncompressed?` Flag reveals whether RLE compression was used.

encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; r11   size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | R11               ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt ld | N2                ; targ (out)
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | R11               ; return original `size`
    .byt add | N7               ; +pristine targ
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt ld | N0                ; from
    .byt push
    .byt ld | N7                ; to
    .byt push
    .byt ld | R11               ; howmany
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( -- packet size )
tags=vm,nosymbol
Return `pkt` address and `size` of the packet in `n8`

```
: pkt.size   ( -- pkt size )
    <n8 dup @ $7ff and ;

    jsr slip
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    pha
    jmp rfrom
```
pronounced: "packet-size"
~#packrat
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N8
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PSIZE
stack=( pkt.header -- pkt.size )
tags=vm,ext
Return just the size of the `pkt.header` on the stack

~#packrat
#endif
psize
;    lda #>(next-1)
;    pha
;    lda #<(next-1)
;    pha
;psizes
    lda tos+1
    and #$07
    sta tos+1
;    rts
    jmp next

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( u -- pkt )
tags=vm,ext
Return the `pkt` address of block `u`,
* set `n8` to `pkt`
* set `prev` to `u`

~wut? return a 0 if there are less than `n` packets?

```
    blkbuf 2-
    begin
        over
    while
        1-under
        @+ psize - 2-
    repeat
    nip >n8 ;

    .byt set
    .word
```
~#packrat
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word prev
#include "page.i65"
    .word store
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
#include "page.i65"
    .word over
#include "pass.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "page.i65"
    .word oneminusunder
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word psize
#include "page.i65"
    .word minus
#include "page.i65"
    .word twominus
#include "pass.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "page.i65"
topktb02
    .word nip
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=WRAP@
stack=( -- wrapd  )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapfetch
    jsr slip
    dex
    ldy #LPERSCR-1              ; 24 lines (1-25)
wrapfetch01
    lda LDTB1,y                 ;$E0 = 0, always $80  $E1-$F8
    asl
    ror tos
    ror stackh,x
    ror stackl,x
    dey
    bne wrapfetch01
    sty tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=nosymbol

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapstore
    jsr harvests2
    txa
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    tax                         ; restore stack pointer
    jmp drop

;--------------------------------------------------------------
#if 0
name=NOWRAP
stack=( -- )
tags=editor,nosymbol

 reset the linewrap table and force this block to be a screen
 even if it was a data packet

~#packrat
#endif
#include "align.i65"
_nowrap
    jsr enter
#include "page.i65"
    .word true
#include "page.i65"
    .word true
#include "page.i65"
    .word wrapstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCR0
stack=( -- )
tags=vm,nosymbol
Reset [[SCR]] and [[BLK]] to screen/block 0.

```
: scr0   ( -- )
    blk off  scr off ;
```
#endif
#include "align.i65"
_scr0
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word four
#include "page.i65"
    .word erase
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm,nosymbol
Reset virtual memory user variables for `LOAD-BUFFERS` or `EMPTY-BUFFERS`

~ It should also validate flags and max-lengths, error out on corrupt VMBUF
~wut?  throw a `bad vm packet` error if a length/flag is off the reservation
```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

```
~#packrat
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word off
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "pass.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "page.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKSCR
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkscr
    jsr docreate
    .byt 5, $FF, $FF, $FF, $05, $80

;--------------------------------------------------------------
#if 0
name=MKDATA
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkdata
    jsr docreate
    .byt 2, $02, $40

;--------------------------------------------------------------
#if 0
name=(PKT+)
stack=( size -- size floor #blk )
tags=compiler,nosymbol

#endif
ppktplus
    brk
    .byt set | N0
    .word usernumblk
    .byt popd | N0              ; `vmbuf`
    .byt st | N8                ; `pkt`
    .byt sub | TOS              ; `pkt` - `size`
    .byt std | N0               ; set `vmbuf`
    .byt push
    .byt sub | ACC
    .byt std | TOS              ; `vmbuf off`
    .byt ld | N0                ; #blk
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( -- )
tags=compiler,nosymbol
Append a new data or screen packet (per `editing`) to `vmbuf` tail

```
: pkt+   ( -- )
    editing? ?: mkscr mkdata
    count (pkt+)
    1+! swap cmove ;
```
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word mkscr
    .word mkdata
#include "page.i65"
    .word count
#include "page.i65"
    .word ppktplus
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCREDIDX
stack=( -- index  )
tags=vm,ext,nosymbol
return `index`:
0 quitmode; data
2 quitmode; scr
4 editmode; data
6 editmode; scr

~#packrat
#endif
scredidx
    ldy #1
    lda (ACC+2*N8),y
    asl
    tya
    and userediting
    rol
    asl
    jmp push0a

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Retrieves and decompresses a screen or data block from the [[VMBUF]]
[[region|PETTIL system memory map]]. This is PETTIL's top of the food
chain for reading packets, the antonym of [[UPDATE]] (which writes
packets).

The table below summarizes how `BLOCK` functions based on whether the
user is in the editor or not, and whether the packet is screen or data.

|^[[EDITING?]] |<|packet# sets [[SCR]]<br>returns [[VIDRAM]]|
|>|^ [[SCRPKT?]]|[[VIDRAM]] initialized to spaces<br>linewrap stored to zero page<br>write 1000-byte packet to [[VIDRAM]]|
|>|^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not [[SCRPKT?]]|[[VIDRAM]] initialized to nulls<br>zero page linewrap table set to all 40-column<br>displays first 1000 characters of data block|
||<|<|
|^not [[EDITING?]] |<|packet# sets [[BLK]]<br>returns [[BLKBUF]]|
|>|^ [[SCRPKT?]]|[[BLKBUF]] initialized to spaces<br>linewrap stored in first three bytes of [[BLKBUF]]<br>followed by 1000-bytes of screencodes|
|>|^ not [[SCRPKT?]]|[[BLKBUF]] initialized to nulls<br>1024 bytes of data expanded to [[BLKBUF]]|

```
: block   ( u -- addr )
    begin                       \ make packets loop
        #blk @ over 1+ <
     while
        pkt+
    repeat
    >pkt
    editing?  ?: vidram blkbuf
    dup b/buf isscr?
    ?: blank erase
    editing?  ?: vidram blkbuf
    nip dup pkt.size 2- tuck -
    isscr?
    if
        3-under <n8 3- 3c@
        edting?
        if
            wrap!
        else
            blkbuf b/scr + 3c!
        then
    then
    -rot
    uncompressed? ?: cmove rldecode ;
```
~#packrat
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
qmkpkts01
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word lt
#include "pass.i65"
    .word qbranch
    .byt <(qmkpkts02-*+1)
#include "page.i65"
    .word _pktplus
#include "pass.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "page.i65"
qmkpkts02
    .word _topkt
#include "page.i65"
   .word editingq
#include "pass.i65"
   .word pquerycolon
   .word vidram
   .word blkbuf
#include "page.i65"
   .word dup
#include "page.i65"
   .word bperbuf
#include "page.i65"
   .word isscrq
#include "pass.i65"
   .word pquerycolon
   .word blank
   .word erase
#include "page.i65"
   .word nip
#include "page.i65"
   .word dup
#include "page.i65"
   .word _pktsize
#include "page.i65"
   .word twominus
#include "page.i65"
   .word tuck
#include "page.i65"
   .word minus
#include "page.i65"
   .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(blk02-*+1)
#include "page.i65"
   .word threeminusunder
#include "pass.i65"
   .word zpfrom
   .byt ACC+2*N8
#include "page.i65"
   .word threeminus
#include "page.i65"
   .word threecfetch
#include "page.i65"
   .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(blk01-*+1)
#include "page.i65"
   .word wrapstore
#include "pass.i65"
    .word branch
    .byt <(blk02-*+1)
#include "page.i65"
blk01
   .word blkbuf
#include "page.i65"
   .word bperscr
#include "page.i65"
   .word plus
#include "page.i65"
   .word threecstore
#include "page.i65"
blk02
   .word dashrot
#include "page.i65"
   .word uncompressedq
#include "pass.i65"
   .word pquerycolon
   .word cmove
   .word rldecode
#include "pass.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=(UPD1)
stack=( source size b/buf vmbuf -- source vmbuf' floor from to howmany )
tags=nosymbol
First, `update` creates

* calculate `floor`
* calculate new `vmbuf`
* set up for `cmove`

~#packrat
#endif
pupd1
    brk
    .byt ext
    .word harvests4
    .byt ld | N8                ; `pkt`
    .byt sub | N1               ; `- 1024`
    .byt st | N2                ; `floor`
    .byt ldd | TOS              ; vmbuf @
    .byt sub | N1               ; `- 1024`
    .byt add | N0               ; `+ size`
    .byt st | N3                ; `vmbuf'`
    .byt st | N0                ; `to`
    .byt popd | TOS             ; vmbuf
    .byt st | N1
    .byt ld | N2                ; `floor`
    .byt sub | N0               ; `- vmbuf'`
    .byt st | TOS               ; `howmany`
    .byt ext
    .word plants8
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD2)
stack=( vmbuf' targend mask -- vmbuf' from to howmany )
tags=nosymbol
* set packet header
* close gap at end of new packet
* set `vmbuf`
#endif
pupd2
    brk
    .byt ext
    .word harvests4
    .byt ld | N1                ; targend+3
    .byt sub | N7               ; - floor
    .byt st | N2
    .byt add | TOS
    .byt std | N8               ; write updated packet header
    .byt ld | N1
    .byt sub | N0
    .byt st | TOS               ; `howmany`
    .byt ld | N0
    .byt st | N1
    .byt ld | N8
    .byt sub | TOS
    .byt st | N0
    .byt st | N2
    .byt popd | N8              ; leave `pkt` undisturbed
    .byt ext
    .word plants6
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SUP
stack=( vidram|blkbuf scr|blk -- )
tags=forth-83,vm,nosymbol

```
\ sprog of update
: sup ( vidram|blkbuf -- )
    @ >pkt pkt.size b/buf 2nip vmbuf
    (upd1) cmove                ;( source vmbuf floor )
    rot tuck
    isscr?
    if
        b/scr -trailing
    else
        b/buf -nulls
    then
    nip rlencode
          ?: b/scr b/buf
    isscr?  ?: -trailing -nulls nip
    rlencode
    isscr?
    if
( wrapd vmbuf' uncompressed? targend )
        >r twoswap r@ 3c! r> 3+
    then


    rlencode
    editing? vidram and
    (upd2)
    uncompressed?  ?: cmove rlencode ;
#endif
#include "align.i65"
_sup
    jsr enter
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word twominus
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word twonip
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word pupd1
#include "page.i65"
    .word cmove                 ; temporarily allocate 1K space in the packet
#include "page.i65"
    .word rot
#include "page.i65"
    .word tuck
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(sup01-*+1)
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
#include "pass.i65"
    .word branch
    .byt <(sup02-*+1)
#include "page.i65"
sup01
    .word bperbuf
#include "page.i65"
    .word dashnulls
#include "page.i65"
sup02
    .word nip
#include "page.i65"
    .word rlencode              ; attempt to run-length encode the buffer
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(sup03-*+1)
#include "page.i65"
    .word vidram
#include "page.i65"
    .word orx
#include "page.i65"
    .word tor
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word third
#include "page.i65"
    .word threecstore           ; append linewrap
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rfrom
#include "page.i65"
sup03
    .word twoplusunder
#include "page.i65"
    .word pupd2
#include "page.i65"
    .word twominus
#include "page.i65"
    .word cmovegt               ; move the bottom of `vmbuf` back up
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store                 ; set `vmbuf`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies and compresses from either the `vidram` or `blkbuf` into a
[[virtual memory packet buffer|PETTIL system memory map]].  `update`
is the antonym of `block` (which retrieves from `vmbuf`).

tests:
~\ block 0
~\ nonzero block numbers
~\ empty block
~\ blank block
~\ screen 1000+3 in blkbuf
~\ for all combinations of `isscr?` and `editing?`
~\ for both packet types
~\ with and without compression
~\ fill blkbuf half with $DEADBEEF
~\ fill blkbuf all with $DEADBEEF
~\ fill blkbuf half with '!'
~\ fill blkbuf all with '!'
~\ fill screen with 80-column uncompressable ($555555 wrap)
~\ fill screen with normal source code
~\ fill screen half with '!'
~\ fill blkbuf all with '!'
~\ fill blkbuf all with '!'

```
: update   ( -- )
    \ source is either `vidram` or `blkbuf`
    \ target is always pkt.floor
    editing? ?: scr blk
    @ >pkt drop
    editing?
    if
        isscr?
        if
            wrap@
            vidram scr sup
        \ else
        \   nothing to do -- vidram can't hold data block
        then
    else
upd01
        isscr?
        if
            blkbuf 1000 + 3c@
        then
        blkbuf prev sup
    then
upd02
;
```
~#packrat
#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word scr
    .word prev
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word drop
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(upd01-*+1)
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd02-*+1)
#include "page.i65"
    .word wrapfetch
#include "page.i65"
    .word vidram
#include "page.i65"
    .word scr
#include "page.i65"
    .word _sup
#include "pass.i65"
    .word branch
    .byt <(upd02-*+1)
#include "page.i65"
upd01
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd03-*+1)
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word plus
#include "page.i65"
    .word threecfetch
#include "page.i65"
upd03
    .word blkbuf
#include "page.i65"
    .word prev
#include "page.i65"
    .word _sup
#include "pass.i65"
upd02
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol,magic-number
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx stashforth01
    jsr aufwiedersehen
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    rts
stashforth01 .byt 0             ; temp storage for X register during tape I/O

;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Restore Forth stack after BASIC system call

#endif
restoreforth
    jsr aloha2
    ldx stashforth01            ; this messes up BASIC's USR() function
    jmp exit

;--------------------------------------------------------------
#if 0
name=DOTAPEIO
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Perform a ROM call framed between calls to `aloha`. This is
needed in particular for tape I/O, which might error out to a
Commodore BASIC `ready.` prompt.

Like `execute` and the Sweet-16 interpreter, this word
uses the machine stack ($0100-$01ff) and RTS trick to transfer
control from one subroutine to the next, so that code executes
in this order:

~wut?  this is a little crashy returning from hitting the [[STOP]] key

```
stashforth
RTS
caller's ROM routine
RTS
restoreforth
EXIT
```
#endif
#include "align.i65"
_dotapeio
    jsr enter
#include "pass.i65"
    .word plit
    .word restoreforth-1
#include "page.i65"
    .word caller
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word stashforth

;--------------------------------------------------------------
#if 0
name=(SAVEPRG)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
psaveprg
    jsr _dotapeio
    .word SAVEPRG

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr _dotapeio
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr _dotapeio
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    jsr docreate
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Called at start of tape or disk i/o, sets up zero page variables.
Retrieves DRV# SA# and FILENAME uservariables and stores them
in zero page locations FA SA FNLEN FNADR.

Relies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea

|zero page|<|value|set by|description|h
|^STATUS|^96|^0|rom|^i/o status byte|
|^VERCK|^9d|^0|(file)|^0=load; 1=verify|
|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|
|^SAL|^c7-c8|^||^start address|
|^EAL|^c9-ca|^||^end address|
|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|
|^LA|^d2|^0|(file)|^logical file #|
|^SA|^d3|^SA#|(prg-file)|Secondary address|
|^FA|^d4|^DRV#|(file)|Device number|
|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|
|^STAL|^fb-fc|^||^start address|

|save|load|verify|open|name|address|description|h
|^?|^?|^?|^?|^FNLEN|^d1|^Length of file name|
|^?|^?|^?|^?|^FNADR|^da-db|^File name address|
|^&nbsp;|<|<|<|<|<|<|
|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|
|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|
|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|
|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|
|^?|^?|^?|^?|^LA|^d2|^logical file number|
|^?|^?|^?|^?|^SA|^d3|^secondary address|
|^?|^?|^?|^?|^FA|^d4|^First address (device number)|
|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|
|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|
|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f

#endif
pfile
    brk
    .byt set | N0
    .word userfilename
    .byt ldd | N0               ; FILENAME
    .byt st | N2                ; pointer to FILENAME[0] or 0
    .byt bz , <(pfile01-*-2)
    .byt ldi | N2
pfile01
    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET
    .word FNLEN
    .byt sti | N1               ; set FNLEN ($d1)

;    .byt set | N1
;    .word LA
    .byt sub | ACC              ; 0
    .byt sti | N1               ; set LA ($d2)

;    .byt set | N1
;    .word SA
    .byt ldd | N0               ; get SA#
    .byt sti | N1               ; set SA ($d3)

;    .byt set | N1
;    .word FA
    .byt ldd | N0               ; DRV#
    .byt sti | N1               ; set FA ($d4)

    .byt set | N1
    .word FNADR
    .byt ld | N2
    .byt std | N1               ; set FNADR ($da)
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(PRG-FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Turn off SA# and set up for PRG file tape i/o

* sets SA# = 0
* sets TAPEID = 1
* invoke [[(FILE)]]
** copy `SA#` to SA
** copy `DRV#` to FA
** copy `FILENAME` to FNADR, FNLEN
** set TAPEID to $01 (PRG)
** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)

```
: (prg-file)   ( -- )
    sa# off  1 TAPEID c!  (file) ;
```
#endif
#include "align.i65"
_pprgfile
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word one
#include "pass.i65"
    .word clit                  ; ~ can remove this if using $f619
    .byt TAPEID
#include "page.i65"
    .word cstore
#include "page.i65"
    .word pfile
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area between [[VMBUF]] and [[BLKBUF]] out
to a PRG file on cassette or disk

Also called by STOP-S in the editor

```
: save-buffers   ( -- )
    (prg-file)
    (vmbuf) next-1
    >r 2>r
    [ SETEALSTAL , ]
    (saveprg) ;
```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word _pprgfile             ; set up z.p. device, secondary, filename
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word blkbuf
#include "pass.i65"
    .word clit
    .byt <(next-1)              ; stupid stack tricks
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor
#include "page.i65"
    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT
#include "page.i65"
    .word psaveprg
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "pass.i65"
    .word clit
    .byt VERCK
#include "page.i65"
    .word cstore
#include "page.i65"
    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _scr0
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to [[VMBUF]]

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
#include "page.i65"
    .word zero                  ; LOAD
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm
Verifies the [[VMBUF]] area following a write

called by STOP-V in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one                   ; VERIFY
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pass.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pass.i65"
verifybuffers05
    .word exit

#print (*-bperbuf)

; core-locals.a65
#echo .       core-locals.a65           Local variables N0..N8 R0..R15 etc

;--------------------------------------------------------------
#if 0
name=HARVESTS10
tags=nosymbol
Sets up five locals in the N area

#endif
harvests10
    ldy #10
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=HARVESTS8
tags=nosymbol
Sets up four locals in the N area

#endif
harvests8
    ldy #8
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=HARVESTS6
tags=nosymbol
Sets up three locals in the N area

#endif
harvests6
    ldy #6
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=HARVESTS4
tags=nosymbol
Sets up two locals in the N area

#endif
harvests4
    ldy #4
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=HARVESTS2
tags=nosymbol
Sets up one local in the N area

#endif
harvests2
    ldy #2
    ; fall through
;--------------------------------------------------------------
#if 0
name=HARVESTS
tags=nosymbol,subroutine
Pops cells from the split stack to N area, working backwards.
Used for setting up primitives that consume multiple arguments

Input

* Y = how many words *2 to pop from the stack, e.g. Y=6 pops 3 words

Returns

* Y = 0
* TOS unchanged
* Z flag set
* C flag unchanged

|^Y|R1<br>TOS|R2<br>N0|R3<br>N1|R4<br>N2|R5<br>N3|R6<br>N4|R7<br>N5|R8<br>N6|R9<br>N7|R10<br>N8|h
|1|TOS|2OS|||||||||
|2|TOS|3OS|2OS||||||||
|3|TOS|4OS|3OS|2OS|||||||
|4|TOS|5OS|4OS|3OS|2OS||||||
|5|TOS|6OS|5OS|4OS|3OS|2OS|||||
|6|TOS|7OS|6OS|5OS|4OS|3OS|2OS||||
|7|TOS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|||
|8|TOS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS||
|9|TOS|10OS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|
|>|>|>|>|>|>|>| stack area and N area order is inverted |<|<|<|f

|Y: 0|Z: set|TOS: unchanged|C: unchanged|
#endif
harvests
    lda stackh,x        ; {4}
    dey                 ; {2}
    sta n,y             ; {5}
    lda stackl,x        ; {4}
    inx                 ; {2}
    dey                 ; {2}
    sta n,y             ; {5}
    bne harvests        ; {3|2 on last}
    rts                 ; {6}               {17}+{27y}

;--------------------------------------------------------------
#if 0
name=HARVEST
stack=( ... c -- )
tags=extra,locals
Removes `c` bytes from the split stack area
`c` must be even
stores them in the `n` area
Another way to restack Y/2 things


argsxxxx
    lda tos
    asl
    tay
    jsr harvests
    jmp drop


#endif
harvest
    ldy tos
    sec
    .byt $29                    ; AND # opcode skips `clc`
    ;fall through
;--------------------------------------------------------------
#if 0
name=PLANT
stack=( c -- ... )
tags=extra,locals
Antonym of `harvest` to push things back underneath `tos`
Think of this as a supertuck. Another way to restack Y/2 things

#endif
plant
    clc
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
    bcs harvests
    ldy tos
    .byt $2c                    ; BIT abs opcode
    ;fall through
;--------------------------------------------------------------
#if 0
name=PLANTS10
tags=nosymbol
puts 5 locals underneath `tos`

#endif
plants10
    ldy #10
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=PLANTS8
tags=nosymbol
puts 4 locals underneath `tos`

#endif
plants8
    ldy #8
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=PLANTS6
tags=nosymbol
puts 3 locals underneath `tos`

#endif
plants6
    ldy #6
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=PLANTS4
tags=nosymbol
Sets up two locals in the N area

#endif
plants4
    ldy #4
    .byt $2c                    ; BIT abs opcode
    ; fall through
;--------------------------------------------------------------
#if 0
name=PLANTS2
tags=nosymbol
Sets up two locals in the N area

#endif
plants2
    ldy #2
    ; fall through
;--------------------------------------------------------------
#if 0
name=PLANTS
tags=nosymbol,subroutine
Pushes N area back onto stack ~ untested

Input

* Y = how many words *2 to push to the stack, e.g. Y=6 pushes 3 words

Returns

* Y = 0
* TOS unchanged
* Z flag set
* C flag unchanged

|Y: 0|Z: set|TOS: unchanged|C: unchanged|
#endif
plants
    dex
    lda n-1,y
    sta stackh,x
    lda n-2,y
    sta stackl,x
    dey
    dey
    bne plants
    rts

;--------------------------------------------------------------
#if 0
name=>ZP
stack=( n -- n )
tags=nosymbol
Copy `tos` to an inline zero page address.  Does not affect `tos`

~#comfortablynumber
#endif
tozp
    ldy #2
    lda (ip),y                  ; inline zp address
    tay
tozp01
    lda tos+1
    sta 1,y
    lda tos
    sta 0,y
    jmp pad3

;--------------------------------------------------------------
#if 0
name=<ZP
stack=( <n == ; -- @n )
tags=nosymbol
Replaces TOS with 16-bit fetch from inline z.p. address

~#comfortablynumber
#endif
zpfrom
    ldy #2                      ; Squeaky's little sister, Zeepy
    lda (ip),y
zpfrom01                        ; pass A
    tay                         ; Y = the actual address
zpfrom02                        ; pass Y
    jsr slip
    lda 1,y
    sta tos+1
    lda 0,y
    sta tos                     ; we'd like 16 bits, please
    jmp pad3

;--------------------------------------------------------------
#if 0
name==ZP
stack=( x -- @n )
tags=nosymbol
Exchange `tos` with (16-bit) word at inline z.p. address

~wut? write this
~#comfortablynumber
#endif
zpex
    lda tos
    pha
    lda tos+1
    pha
    ldy #0
    sty tos+1
    ldy #2
    lda (ip),y                  ; inline zp-addr
    sta tos
zpex01
    pla
    dey
    sta (tos),y
    bpl zpex01
    jmp pad3

;--------------------------------------------------------------
#if 0
name=PICK
stack=( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
tags=forth-83,nucleus


 0 pick = same as dup
 1 pick = same as over
#endif
pick
    txa
    clc
    adc tos
    tay
    lda stackh,y
    sta tos+1
    lda stackl,y
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=ROLL
stack=( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
tags=forth-83,nucleus
Remove the nth stack element (excluding n itself) to TOS, dropping n

 2 roll = rot
 1 roll = swap
 0 roll has no effect


```
alternative code:
r2d2
    stx z
    txa
    clc
    adc tos
    tax
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
r2d201
    cpx z
    beq r2d202
    lda stackh-1,x
    sta stackh,x
    lda stackl-1,x
    sta stackl,x
    dex
    bne r2d201
r2d202
    inx
    jmp next
```
#endif
roll
    txa
    clc
    adc tos
    tax
    lda stackh,x
    pha
    lda stackl,x
    pha
roll01
    inx
    dec tos
    bmi rput
    dex
    lda stackh-1,x
    sta stackh,x
    lda stackl-1,x
    sta stackl,x
    dex
    bne roll01          ; bra

;--------------------------------------------------------------
#if 0
name=2@
stack=( addr -- hi lo )
tags=double,primitive,ext,memory,forth-83
Retrieve the double stored at "addr" to the stack
#endif
twofetch
    ldy #3
twofetch01
    lda (tos),y
    pha
    dey
    bpl twofetch01
    jsr slide
    ; fall through
;--------------------------------------------------------------
#if 0
name=2R>
stack=( -- x1 x2 ) ( R; x1 x2 -- )
tags=double,stack,ext

Transfer cell pair x1 x2 from the return stack. Semantically equivalent to `R> R> SWAP`
#endif
tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next

;--------------------------------------------------------------
#if 0
name=R>
stack=( -- n ) ( R; n -- )
tags=forth-83,nucleus,stack
Remove the top value from the return stack and leave it on the
        computation stack. See >R and R@

!!! pronounced: "r-from"

#endif
rfrom
    jsr slip
rput
    pla
    tay
    pla
putay
    sta tos+1
    sty tos
    jmp next


#print (*-tozp)




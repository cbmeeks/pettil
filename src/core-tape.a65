; core-tape.a65
#echo .       core-tape.a65              Cassette Tape

;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Subroutine to swap PETTIL back in after exiting out to BASIC
for tape I/O
#endif
restoreforth
    jsr aloha2
    ldx n
    jmp next

;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx n                       ; $ff (xsave) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    rts

;--------------------------------------------------------------
#if 0
name=(IOSETUP)
stack=( -- )
tags=vm,kernel,nosymbol
Initializes FA, STATUS, VERCK prior to tape I/O
#endif
#include "align.i65"
piosetup
    lda uarea+userdrvnum-userarea
    sta FA                      ; First Address (current device number)
    lda #0
    sta STATUS
    sta VERCK
    jmp next

;--------------------------------------------------------------
#if 0
name=SETNAM
stack=( -- )
tags=vm,i/o,kernel
Sets up filename parameters before tape and disk I/O

```
: setnam   ( -- )
    filename @ dup
    if  count swap FNADR ( $da ) !  then
    FNLEN ( $d1 ) c!  drv# @ FA ( $d4 ) c! ;
```
#endif
#include "align.i65"
_setnam
    jsr enter
#include "page.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(setnam01-*+1)
#include "pad.i65"
    .word count
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt FNADR              ; file name address
#include "pad.i65"
    .word store
#include "page.i65"
setnam01
    .word clit
    .byt FNLEN              ; Length of Current File Name
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word exit










;--------------------------------------------------------------
#if 0
name=(SAVEBUF)
stack=( -- )
tags=vm,forth-83,i/o,kernel,nosymbol

~ modify this to fake the header to appear as though [[VMBUF]]
is based on [[SYMTAB]] == [[MEMSIZ]]
#endif
psavebuf
    jsr stashforth
    jsr PERFORMSAVE             ; save
    jmp restoreforth

;--------------------------------------------------------------
#if 0
name=RELOCATE
stack=( from to flag -- start end )
tags=vm,i/o,kernel
The `from` and `to` values are both adjusted, leaving `start`
and `end`.

|flag|in|out|h
|true|relocated|actual|
|false|actual|relocated|

```
: relocate
    memsiz @ symtab @ -
    swap if negate then
    dup>r +under r> + ;

vmbuf @ blkbuf .s    51fe 5200  ok
false relocate .s    7bfe 7c00  ok
true relocate .s     51fe 5200  ok
```
#endif
#include "align.i65"
_relocate
    jsr enter
#include "page.i65"
    .word memsiz
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(relocate01-*+1)
#include "pad.i65"
    .word negate
#include "page.i65"
relocate01
    .word duptor
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;relocate
;    ldy #4
;    jsr locals          ; N0 = from, N1 = to, TOS = flag
;    brk
;    .byt set | N2
;    .word uarea+usersymtab-userarea
;    .byt ldd | N2
;    .byt st | N3
;    .byt set | N2
;    .word uarea+usermemsiz-userarea
;    .byt ldd | N2
;    .byt sub | N3
;    .byt st | N3
;    .byt ld | TOS
;    .byt bnz , <(relocate02-*-2)
;    .byt sub | N3
;    .byt st | N3
;relocate02
;    .byt ld | N3
;    .byt add | N0
;    .byt st | TOS
;    .byt ld | N3
;    .byt add | N1
;    .byt push
;    .byt nxt

;--------------------------------------------------------------
#if 0
name=(LOADVERB)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
ploadverb
    jsr stashforth
    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; verify
    jmp restoreforth

;--------------------------------------------------------------
#if 0
name=(VMBUFPTR)
stack=( flag -- from to start end )
tags=vm,kernel,nosymbol
Returns the start and end of the virtual memory buffer, and
the relocated values

```
: (vmbuf)   ( flag -- from to start end )
    >r vmbuf @ blkbuf 2dup
    r> relocate ;
```
#endif
#include "align.i65"
_pvmbufptr
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twodup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _relocate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SETUPIO)
stack=( -- )
tags=vm,kernel,nosymbol
Set up various zero page locations prior to [[LOAD]]/[[VERIFY]]/[[SAVE]].  Look at $F50D (PET4) for an idea of what to initialize here.

| save |<| load |<| verify |<|^z.p.|^description|h
|^header<br/>F62A|^data<br/>|^header<br/>|^data<br/>|^header<br/>|^data<br/>|~|~|h
|^0<br/>''F50D''|^|^|^|^|^|^D1|^FNLEN Length of current file name|
|^?<br/>''F50D''|^|^|^|^|^|^DA<br/>DB|^FNADR File name address|
|^&nbsp;|<|<|<|<|<|<|<|
|^BLKBUF|^|^|^|^|^|^C9<br/>CA|^EAL Tape end address|
|^VMBUF|^|^|^|^|^|^FB<br/>FC|^STAL I/O start address|
|^&nbsp;|<|<|<|<|<|<|<|
|^00<br/>''F50D''|^|^00|^|^00|^|^96|^STATUS Status byte ST|
|^00|^|^00|^|^01|^|^9D|^VERCK Load/Verify flag (0,1)|
|^01|^|^|^|^|^|^B4|^TAPEID Tape file type<br/>01=PRG 05=EOT|
|^|^|^|^|^|^|^D2|^LA Current logical file number|
|^0<br/>''F50D''|^|^|^|^|^|^D3|^SA Current secondary address|
|^1<br/>''F50D''|^|^|^|^|^|^D4|^FA First address (device number)|
|^//F695//|^|^|^|^|^|^D6|^TAPE1 Pointer - start of tape buffer|
|^|^|^|^|^|^|^DE|^FSBLK Cassette read/write block count|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|<|f

```
: (setupio)   ( count -- )
    $c9 !  $fb ! ;
```
#endif
#include "align.i65"
setupio
    brk
    .byt set | N0
    .word setupiozp
    .byt set | N1
    .word setupiovalue
setupio01
    .byt ldi | N0
    .byt st | N2
    .byt ldd | N1
    .byt st | N3
    .byt ldi | N3
    .byt sti | N2
    .byt dcr | TOS
    .byt bnz, <(setupio01-*-2)
    .byt nxt
setupiozp
    .byt  STATUS        ; $96
    .byt  VERCK         ; $9d
    .byt  FNLEN         ; $d1
    .byt  FA            ; $d4
    .byt  SA            ; $d3
    .byt  LA            ; $d2
setupiovalue
    .word setupio       ; contains a 0
    .word setupio       ; contains a 0
    .word setupio       ; contains a 0
    .word uarea+userdrvnum-userarea
    .word setupio       ; contains a 0
    .word setupio
;--------------------------------------------------------------
#if 0
name=(SETIOPTR)
stack=( from to -- )
tags=vm,kernel,nosymbol
Set zero page load/save pointers

```
: (setioptr)   ( from to -- )
    $c9 !  $fb ! ;
```
#endif
#include "align.i65"
_setioptr
    jsr enter
#include "page.i65"
    .word clit
    .byt EAL            ; i/o end address
#include "pad.i65"
    .word store
#include "page.i65"
    .word clit
    .byt STAL           ; i/o start address
#include "pad.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(TAPEPARAMS)
stack=( -- )
tags=vm,forth-83,i/o,kernel,nosymbol
non-reentrant subroutine to set tape start and end addresses
SEC = write
CLC = read
~ save some room by doing this with the C flag
#endif
tapeparams
    pla
    tax
    pla
    tay                         ; preserve return address
    pla
    sta $c9
    pla
    sta $ca
    pla
    sta $fb
    pla
    sta $fc
    tya
    pha
    txa
    pha                         ; restore return address
    bcs psave01
    bcc ploadver01

;--------------------------------------------------------------
#if 0
name=(SAVE)
stack=( ; return c9 fb -- )
tags=vm,forth-83,i/o,kernel,nosymbol

* Set up zero page
|B4|01 (PRG)|
|FB-FC|start address (MEMSIZ-(|
|C9-CA|end address (always MEMSIZ-$0400)|
|D1|FNLEN filename length|
|D4|FA current device number|
|^D6-D7|^pointer to tape buffer<br/>~ what about disk?|
|DA-DB|FNADR file name address|
** B4 = 01 (PRG)

* write header
* do stuff
* write data

fb-fc
c9-ca
d6-d7 = tape buffer
f61e    write header



f62a? maybe this entry point after setting up return stack
return stack:
psave02-1   ; save part 2
fb-fc       ; STAL
c9-ca       ; EAL
$f629       ; (f62a)
    jsr stashforth
    pla
    pla         ; discard return address
    jmp $f695   ; get buffer address
psave02
    
    
~ could this use $F6CC instead?
#endif
psave
    jsr stashforth
    jsr $f619               ; SAVEHEAD
    sec
    bcs tapeparams
psave01
    jsr $f8d3               ; SAVEMEM
    pla
    tax
    pla
    tay
    pla
    sta $c9
    pla
    sta $ca
    pla
    sta $fb
    pla
    sta $fc
    tya
    pha
    txa
    pha
    jsr $f8ce
    jmp restoreforth

;--------------------------------------------------------------
#if 0
name=(LOADVER)
stack=( -- )
tags=vm,forth-83,i/o,kernel,nosymbol

~ modify this to fake the header to appear as though [[VMBUF]]
is based on [[SYMTAB]] == [[MEMSIZ]]
#endif
ploadver
    jsr stashforth
    jsr $f4d3               ; READHEAD
    sec
    bcs tapeparams
ploadver01
    jsr $f3f8               ; READMEM
    jmp restoreforth

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area, from VMBUF to BLKBUF, out to a PRG file on cassette or disk

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name
fb = to
(c9) = to

This is called by STOP-S in the editor
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word piosetup              ; pre-I/O housekeeping
#include "page.i65"
    .word _setnam               ; 
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word true
#include "page.i65"
    .word _pvmbufptr            ; ( hi-from hi-to from to )
#include "page.i65"
    .word zero                  ; some return address
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor                ; loads to this address
#include "page.i65"
    .word _setioptr             ; set up tape header
#include "page.i65"
    .word psave
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to VMBUF, replacing
what existed there before

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name

called by STOP-L in the editor

```
: load-buffers   ( -- )
    (vmbufptr) 2dup 2>r [ VERCK ] cliteral c!
    (loadvera) [ EAL ] cliteral dup>r @
    [ STAL ] cliteral dup>r @ - pad dup r> !
    2dup + r> ! (ploadverb) blkbuf third - dup
    vmbuf ! rot cmove #vmpkt ! ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
    .word _pvmbufptr
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
;    .word ploadvera
#include "page.i65"
    .word clit
    .byt EAL
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt STAL
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word ploadverb
    ; pad blkbuf-size size cmove
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _numvmpktstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm,i/o,kernel,~wut?
Verifies the virtual memory area following a write, from VMBUF to BLKBUF

* DRV# is the device number
* FILENAME is the filename

todo: change magic number to labels in cbm.def
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word _setnam
#include "page.i65"
;    .word preadheader
#include "page.i65"
    .word _pvmbufptr
#include "page.i65"
    .word true
#include "page.i65"
    .word _relocate
#include "page.i65"
    .word _setioptr
#include "page.i65"
    .word ploadver
#include "page.i65"
    .word clit
    .byt STATUS
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pad.i65"
    .word pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pad.i65"
verifybuffers05
    .word exit

;--------------------------------------------------------------
#if 0
name=vestigialcode
stack=( -- )
tags=vm,i/o,kernel,nosymbol

```
ploadvera
    jsr stashforth
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
ploadvera01
    lda $d1
    beq ploadvera03
    jsr $f4d3                   ; search for a named tape header block
    bne ploadvera04
ploadvera02
    brk
    ;file not found
ploadvera03
    jsr $f5e5                   ; load next tape header
    beq ploadvera02
ploadvera04
    cpx #1
    bne ploadvera01
    jsr $f67b                   ; (fb)=start; (c9)=end
```
#endif
vestigialcode

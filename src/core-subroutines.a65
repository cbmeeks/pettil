; core-subroutines.a65
#echo .       core-subroutines.a65      Native 6502 support routines

;--------------------------------------------------------------
#if 0
name=slip
stack=( n -- n n )
tags=nosymbol
Push TOS to the stack (DUP)
#endif
slip
    dex                         ; slip something onto the stack
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    rts

;--------------------------------------------------------------
#if 0
name=slide
stack=( n -- )
tags=nosymbol
!!!Subroutine
Drop the top stack item
#endif
slide
    lda stackh,x                ; slide something off of the stack
    sta tos+1
    lda stackl,x
    sta tos
    inx
    rts

;--------------------------------------------------------------
#if 0
name=push6502
stack=( -- n )
tags=nosymbol
!!!Subroutine
Push YA to TOS and return

* Y = high addr
* A = low addr
#endif
push6502
    pha
    jsr slip
    pla
    sty tos+1
    sta tos
    rts

;--------------------------------------------------------------
#if 0
name=padjust
stack=( -- )
tags=nosymbol
!!!Subroutine
Called by primitives to adjust `IP` and properly cross a
page boundary.  This routine exists so words like [[."]] and [[?:]] 
can function outside the normal [[pad|DOPAGE]]/[[page|DOPAGE]] routines.

|IP+A lo|IP lo|IP hi|
| C set| IP+A| +1|
||||
| < FD| IP+A| IP+A|
| FD| FE| +1|
| FE| FE| +1|
| FF| FE| +1|

There is probably a worst-case scenario where it is possible to 
cross two page boundaries, e.g. with [[(.")]] printing a 255-byte 
string, where the [[(.")]] was compiled at the very top of the page.

|$42FC-$42FD| [[(.")]] cfa |
|$42FE| $FF(length) |
|$42FF-$43FE| the string |
|$43FF| `NOP` |

In this worst-case scenarios, `IP` would be set after `padjust` to 
$44FE and the next execution of [[NEXT|Zero page buffer and NEXT routine]]
would use $4400 as the address of the following instruction.
#endif
padjust
    clc                     ; pass A = offset to be added to IP
    adc ip
    bcc padjust01
    inc ip+1                ; cross the page
padjust01
    cmp #$fd
    bcc padjust02
    inc ip+1                ; cross the page
    lda #$fe
padjust02
    sta ip
    rts

;--------------------------------------------------------------
#if 0
name=perform
stack=( -- )
tags=nosymbol
Perform the word at YA

Arguments
* Y = high addr
* A = low addr

Returns
* Z = clear
#endif
perform
    jsr push6502
    lda ip+1
    pha
    lda ip
    pha                         ; preserve mainline IP
#include "toforth.i65"
    .word execute               ; perform one of the branches
#include "page.i65"
    .word to6502
    pla
    sta ip
    pla
    sta ip+1                    ; restore mainline IP
    rts

;--------------------------------------------------------------
; using ROM tape I/O drops to BASIC if there's a problem.
; we'd like the user to be able to type RUN and pick up
; more or less at the dropping off point if this happens.
; this subroutine performs that BASIC/PETTIL zp switch
; between $00-$8C inclusive.
;
swapzp
    stx xsave       ; preserve Forth data stack pointer
    ldx #TIME       ; everything below the jiffy clock
swapzp01
    lda $ff,x
    ldy zpbuf-1,x
    sty $ff,x
    sta zpbuf-1,x
    dex
    bne swapzp01
    ldx xsave       ; restore Forth data stack pointer
    rts

;--------------------------------------------------------------
#if 0
name=Aloha
tags=nosymbol
Flips back and forth between BASIC and PETTIL modes.
performs swapzp, toggleirq and togglesw16

#endif
aloha
    cld                         ; clear decimal mode
    jsr CLRCHN                  ; restore default I/O channels
    jsr CLALL                   ; close all open files
aloha2
    jsr swapzp                  ; swap bottom of zero page with zpbuf
;    jsr toggleirq               ; set the IRQ vector
; fall through                  ; set the BRK vector
;--------------------------------------------------------------
#if 0
name=Sweet16 toggle
tags=nosymbol
Toggle the BRK vector between Sweet16 <--> TIM

#endif
togglesw16
    ldy #2
togglesw16a
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne togglesw16a
    rts

brktoggle
    .word SW16^TIMBRK

;--------------------------------------------------------------
#if 0
name=IRQ toggle
tags=nosymbol
Toggle the IRQ vector between two targets based on an XOR constant
#endif
toggleirq
    sei
    ldy #2
toggleirq01
    lda tos-1,y
    eor CINV-1,y
    sta CINV-1,y
    dey
    bne toggleirq01
    cli
    rts

;--------------------------------------------------------------
#if 0
name=locals
tags=nosymbol
Pops cells from the split stack to N area, working backwards.
Used for setting up primitives that consume multiple arguments

Input

* Y = how many words to pop from the stack

Returns

* Y = 0
* C = clear
* TOS unchanged

|^Y|R1<br>TOS|R2<br>N0|R3<br>N1|R4<br>N2|R5<br>N3|R6<br>N4|R7<br>N5|R8<br>N6|R9<br>N7|R10<br>N8|h
|1|TOS|2OS|||||||||
|2|TOS|3OS|2OS||||||||
|3|TOS|4OS|3OS|2OS|||||||
|4|TOS|5OS|4OS|3OS|2OS||||||
|5|TOS|6OS|5OS|4OS|3OS|2OS|||||
|6|TOS|7OS|6OS|5OS|4OS|3OS|2OS||||
|7|TOS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|||
|8|TOS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS||
|9|TOS|10OS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|
|>|>|>|>|>|>|>| stack area and N area order is inverted |<|<|<|f
#endif
locals
    tya                 ; [2]
    asl                 ; [2] ; turn #args into #bytes, also clc
    tay                 ; [2]
locals01
    lda stackh,x        ; [4]
    dey                 ; [2]
    sta n,y             ; [5]
    lda stackl,x        ; [4]
    inx                 ; [2]
    dey                 ; [2]
    sta n,y             ; [5]
    bne locals01        ; [3]
                        ; [-1] on last iteration
    rts                 ; [6]               [17]+[27y]

;--------------------------------------------------------------
#if 0
name=tos2plus
stack=( n -- n+2 )
tags=nosymbol
!!!Subroutine
increments the top of stack twice
#endif
tos2plus
    jsr inctos                  ; fall through
;--------------------------------------------------------------
#if 0
name=inctos
stack=( n -- n+1 )
tags=nosymbol
increment TOS; sets the Z flag
#endif
inctos
    inc tos
    bne inctos01
    inc tos+1
inctos01
    rts

;--------------------------------------------------------------
#if 0
name=tos2minus
stack=( n -- n-2 )
tags=nosymbol
!!!Subroutine
decrements the top of stack twice
#endif
tos2minus
    jsr dectos                  ; fall through
;--------------------------------------------------------------
#if 0
name=dectos
tags=nosymbol
decrement TOS
#endif
dectos
    lda tos
    bne dectos01
    dec tos+1
dectos01
    dec tos
    rts

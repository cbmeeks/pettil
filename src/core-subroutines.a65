; core-subroutines.a65
#echo .       core-subroutines.a65      Native 6502 support routines

;--------------------------------------------------------------
#if 0
name=slide
stack=( n -- )
tags=nosymbol
!!!Subroutine
Drop the top stack item

Always clears Z flag on return
#endif
slide
    lda stackh,x                ; slide something off of the stack
    sta tos+1
    lda stackl,x
    sta tos
    inx                         ; stack pointer is never 0
    rts

;--------------------------------------------------------------
; using ROM tape I/O drops to BASIC if there's a problem.
; we'd like the user to be able to type RUN and pick up
; more or less at the dropping off point if this happens.
; this subroutine performs that BASIC/PETTIL zp switch
; between $00-$8C inclusive.
;
swapzp
    stx z           ; preserve Forth data stack pointer
    ldx #TIME       ; everything below the jiffy clock
swapzp01
    lda $ff,x
    ldy zpbuf-1,x
    sty $ff,x
    sta zpbuf-1,x
    dex
    bne swapzp01
    ldx z           ; restore Forth data stack pointer
    rts

;--------------------------------------------------------------
#if 0
name=Aloha
tags=nosymbol
Flips back and forth between BASIC and PETTIL modes.
performs swapzp, toggleirq and togglesw16

#endif
aloha
    cld                         ; clear decimal mode
    jsr CLRCHN                  ; restore default I/O channels
    jsr CLALL                   ; close all open files
aloha2
    jsr swapzp                  ; swap bottom of zero page with zpbuf
;    jsr toggleirq               ; set the IRQ vector
; fall through                  ; set the BRK vector
;--------------------------------------------------------------
#if 0
name=~ Sweet16 toggle
tags=nosymbol
Toggle the BRK vector between Sweet16 <--> TIM

#endif
togglesw16
    ldy #2
togglesw16a
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne togglesw16a
    rts

brktoggle
    .word SW16^TIMBRK

;--------------------------------------------------------------
#if 0
name=~ IRQ toggle
tags=nosymbol
Toggle the IRQ vector between two targets based on an XOR constant
#endif
toggleirq
    sei
    ldy #2
toggleirq01
    lda tos-1,y
    eor CINV-1,y
    sta CINV-1,y
    dey
    bne toggleirq01
    cli
    rts

;--------------------------------------------------------------
#if 0
name=locals10
tags=nosymbol
Sets up five locals in the N area

#endif
locals10
    ldy #10
    .byt $2c                ; BIT abs instruction
    ; fall through
;--------------------------------------------------------------
#if 0
name=locals8
tags=nosymbol
Sets up four locals in the N area

#endif
locals8
    ldy #8
    .byt $2c                ; BIT abs instruction
    ; fall through
;--------------------------------------------------------------
#if 0
name=locals6
tags=nosymbol
Sets up three locals in the N area

#endif
locals6
    ldy #6
    .byt $2c                ; BIT abs instruction
    ; fall through
;--------------------------------------------------------------
#if 0
name=locals4
tags=nosymbol
Sets up two locals in the N area

#endif
locals4
    ldy #4
    .byt $2c                ; BIT abs instruction
    ; fall through
;--------------------------------------------------------------
#if 0
name=locals2
tags=nosymbol
Sets up one local in the N area

#endif
locals2
    ldy #2
    ; fall through
;--------------------------------------------------------------
#if 0
name=locals
tags=nosymbol
Pops cells from the split stack to N area, working backwards.
Used for setting up primitives that consume multiple arguments

Input

* Y = how many words *2 to pop from the stack

Returns

* Y = 0
* TOS unchanged
* Z flag set
* C flag unchanged

|^Y|R1<br>TOS|R2<br>N0|R3<br>N1|R4<br>N2|R5<br>N3|R6<br>N4|R7<br>N5|R8<br>N6|R9<br>N7|R10<br>N8|h
|1|TOS|2OS|||||||||
|2|TOS|3OS|2OS||||||||
|3|TOS|4OS|3OS|2OS|||||||
|4|TOS|5OS|4OS|3OS|2OS||||||
|5|TOS|6OS|5OS|4OS|3OS|2OS|||||
|6|TOS|7OS|6OS|5OS|4OS|3OS|2OS||||
|7|TOS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|||
|8|TOS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS||
|9|TOS|10OS|9OS|8OS|7OS|6OS|5OS|4OS|3OS|2OS|
|>|>|>|>|>|>|>| stack area and N area order is inverted |<|<|<|f
#endif
locals
    lda stackh,x        ; [4]
    dey                 ; [2]
    sta n,y             ; [5]
    lda stackl,x        ; [4]
    inx                 ; [2]
    dey                 ; [2]
    sta n,y             ; [5]
    bne locals          ; [3]
                        ; [-1] on last iteration
    rts                 ; [6]               [17]+[27y]

;--------------------------------------------------------------
#if 0
name=tos2minus
stack=( n -- n-2 )
tags=nosymbol
!!!Subroutine
decrements the top of stack twice
#endif
tos2minus
    jsr dectos                  ; fall through
;--------------------------------------------------------------
#if 0
name=dectos
tags=nosymbol
decrement TOS
#endif
dectos
    lda tos
    bne dectos01
    dec tos+1
dectos01
    dec tos
    rts

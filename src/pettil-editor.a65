; pettil-editor.a65
#echo .       pettil-editor.a65         EDITOR Vocabulary (1)

;--------------------------------------------------------------
#if 0
name=CLRSCR
stack=( -- )
tags=editor
Clear the screen
#endif
_clrscr
#include "enter.i65"
    .word clit
    .byt CLR
#include "pad.i65"
    .word emit
#include "page.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=FLIPSCR
stack=( -- )
tags=editor

 invert the entire screen

#endif
flipscr
    ldy #0
flipscr01
    lda VIDRAM,y            ; [4]
    eor #$80                ; [2]
    sta VIDRAM,y            ; [5]
    lda VIDRAM+$100,y
    eor #$80
    sta VIDRAM+$100,y
    lda VIDRAM+$200,y
    eor #$80
    sta VIDRAM+$200,y
    lda VIDRAM+$300,y
    eor #$80
    sta VIDRAM+$300,y
    iny                     ; [2]
    bne flipscr01           ; [3] 49 * 256 = 12544 clocks
    jmp next

;--------------------------------------------------------------
#if 0
name=WRAP
stack=( -- addr )
tags=editor
Double variable, stores 25 bits of line wrap info for screen
#endif
wrap
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=PWRAP
stack=( -- addr )
tags=editor
Double variable, stores 25 bits of line wrap info for paste buffer
#endif
pwrap
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=PASTE
stack=( -- addr )
tags=editor
Paste buffer pointer, starts at [[PAD]]
#endif
paste
    jsr docreate
    .word 0

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( d -- )
tags=editor

 Updates the linewrap table at $E0-F8 to reflect the bits
 in "d".  Since line 0 ($e0) is never a continuation
 line, (always $80) it is not written to.  Only 24 bits are
 written to $E1-$F8, not 25.  Although unused, the most
 significant (2^24) bit will always be set, as a framing bit
 used to detect when the wrap double is full.

#endif
wrapstore
    ldy #1
    jsr locals
    stx storex
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
#if 0
name=WRAP*
stack=( d1 d2 -- d )
tags=editor

Combines two linewrap tables into one.  It is expected that 

* "d2" contains the top of the screen
* "d1" contains the remainder of the screen
* There are at least 25 "1" (40-column) and "10" (80-column) bits available

#endif
wrapstar
    ldy #3
    jsr locals                  ; TOS = D2H; N0 = D1L; N1 = D1H; N2 = D2L
    stx storex
    lda tos+1
    bne wrapstar03              ; done already?
wrapstar01
    sec                         ; make sure we stop eventually
    ldy #4
    jsr wrapstar04
    bit n+3
    bpl wrapstar01              ; 0000 0000 0000 0000 0110 1011 1111   1111 1111 1111 1110 1111 0000 0000 0000 
wrapstar02                      ; 0001 1111 1111 1101 1111 1010 1111
    clc
    ldy #6
    jsr wrapstar04
    rol tos
    rol tos+1
    beq wrapstar02
wrapstar03
    ldx storex
    dex
    lda n+4
    sta stackl,x
    lda n+5
    sta stackh,x
    jmp next

wrapstar04
    ldx #0
wrapstar05
    rol n,x
    inx
    dey
    bne wrapstar05
    rts

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive

 Reads a portion of the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!!pronounced: "wrap-above"
#endif
wrapabove
    stx storex      ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos         ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2         ; are we there yet?
    beq wrapabove03 ; leave if done
    lda $e0,x
    asl             ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1         ; append the next high bit to the double
    beq wrapabove02 ; this should always take the branch
wrapabove03
    lda n
    ldy n+1         ; high half of the double is going on the stack
    ldx storex      ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP+
stack=( d columns -- d' flag )
tags=editor,primitive
Append bits to the linewrap double `d` based on whether `columns`
is 40 or 80.  For 80, a '10' bit pair is appended,  and for 40 a
single '1' bit.  The return `flag` is zero if there are not yet 25
bits of linewrap in `d'`

!!!pronounced: "wrap-plus"
#endif
wrapplus
    sec                         ; always shift in a 1
wrapplus01
    ldy stackh,x                ; check msb 25.  full?
    bne wrapplus03
    rol stackl+1,x              ; shift in a single bit
    rol stackh+1,x
    rol stackl,x
    rol stackh,x
    lda #40
    cmp tos
    sta tos                     ; so we only do this once
    bcc wrapplus01              ; maybe shift in a 0 (if 80-column)
    ldy stackh,x
wrapplus03
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=WRAPROLL
stack=( logline 40|80 -- )
tags=editor
Rolls the screen linewrap table up one or two lines
#endif
wraproll
    stx storex
    lda stackl,x
    tax
    asl LDTB1,x
wraproll02
    cpx #24
    bcs wraproll03
    asl LDTB1+1,x
    ror LDTB1,x
    inx
    bne wraproll02
wraproll03
    sec
    ror LDTB1,x
    ldx storex
    ;clc
    lda tos
    sbc #40
    sta tos
    bpl wraproll
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=LINEINFO
stack=( logline -- addr 40|80 )
tags=editor,nosymbol,primitive

Returns the start address and length of the logical line.
 `logline` is a physical screen line that is assumed to
 point to the upper physical line if the line is 80 columns.

#endif
lineinfo
    stx storex
    ldx tos
    lda WRAPLO,x
    sta tos
    lda LDTB1,x
    sta tos+1
    lda #40
    cpx #24
    beq lineinfo01
    ldy LDTB1+1,x
    bmi lineinfo01
    asl                     ; 80 char
lineinfo01
    ldy #0
    ldx storex
    jmp pushya

lineinfob
    stx storex
    ldx tos
    
;--------------------------------------------------------------
#if 0
name=LOGLINE
stack=( -- logline )
tags=editor,nosymbol,primitive
 Returns the physical line number of the logical line where the
 PET cursor is currently located.  The `logline` value returned
 is the first/top/upper line if the logical line has 80 characters.

 From this position, [[leapfrogging forward|LOGLINE+]] down the
 screen will always return logical line addresses (with
 wraptable bit7 set), never continuation lines.
#endif
logline
    stx storex
    ldx TBLX        ; $d8 = Current Cursor Physical Line Number
    inx
logline01
    dex
    ldy LDTB1,x     ; $e0 = 25-byte screen wrap table
    bpl logline01
    txa
    ldy #0
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=LOGLINE+
stack=( logline -- logline+|0 )
tags=editor

 Return the next logical line number or 0 after bottom of screen

!!!pronounced "log-line-plus"
#endif
loglineplus
    stx storex
    lda #0
    ldx tos
loglineplus01
    cpx #24
    beq loglineplus02
    inx
    ldy LDTB1,x
    bpl loglineplus01
    txa
loglineplus02
    ldy #0
    ldx storex
    jmp put

;--------------------------------------------------------------
#if 0
name=PKT>SCR
stack=( scr -- )
tags=editor

 Locate (or create) the packet for "scr" and open it in the editor

```
: pkt>scr   ( scr -- )
    dup scr ! (block) drop
                              ( blkbuf )
    writable? @
                              ( blkbuf editable? )
    if
                              ( blkbuf )
        dup 3c@ wrap!
                              ( blkbuf )
        3+
                              ( blkbuf+3 )
    then
                              ( blkbuf|blkbuf+3 )
    vidram b/scr
                              ( blkbuf $8000 1000 )
    cmove ;
```
#endif
_pkttoscr
#include "enter.i65"
    .word dup
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pkttoscr01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word threeplus
#include "page.i65"
pkttoscr01
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKPKT
stack=( blkbuf -- size )
tags=editor,nosymbol

 Builds an editable packet at `BLKBUF` from the current screen.
 The first three bytes of the packet are the linewrap bits for
 lines 1..24.  This is followed by 1000 screen code bytes,
 RLE-encoded unless storing them occupies less room.  The last
 two bytes of the packet are the packet header, containing the
 11-bit total packet length, in the range 5..1026, and the
 packet flags

 * $8000 = editable?  //true for editor screens, false for data blocks//

 * $4000 = uncompressed?

!!! pronounced: "make-packet"

```
: mkpkt   ( blkbuf -- size )
    >r 25 wrap^ r@ 3c!        \ retrieve linewrap from screen
( ) ( R; blkbuf )
    vidram b/scr -trailing    \ squeeze trailing spaces from screen
( vidram vidsize ) ( R; blkbuf )
    r@ 3+ swap rlencode       \ rlencode it
( targend uncompressed? ) ( R; blkbuf )
    $4000 and vidram or       \ editable, uncompressed flags
( targend pktflags ) ( R; blkbuf )
    over r> - 2+ dup>r
( targend pktflags size ) ( R; size )
    or swap !
( ) ( R; size )
    r>  prev on ;
( size )
```
#endif
_mkpkt
#include "enter.i65"
    .word tor
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word wrapabove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word plit
    .word $4000
#include "pad.i65"
    .word andx
#include "page.i65"
    .word vidram
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word orx
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word prev
#include "page.i65"
    .word on
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCR>PKT
stack=( scr -- )
tags=editor,nosymbol
Stores the current screen into the packet buffer as screen `scr`.
If screen `scr` is read-only, nothing is written to the buffer

pronounced: "s-c-r-to-packet"

```
: scr>pkt   ( scr -- )
    writable? @
 ( scr flag )
    if
 ( scr )
        dup>r prev !  blkbuf dup mkpkt
 ( blkbuf newsize ) ( R; scr )
        r@ >pkt dup @ $7ff and
 ( blkbuf newsize packet oldsize )
        vmbuf @
 ( blkbuf newsize packet oldsize vmbuf )
        true
 ( blkbuf newsize packet oldsize vmbuf true )
        >6502
  ldy #5
  jsr locals
    ...   \ TOS=-1; N0=blkbuf; N1=newsize; N2=oldsize; N3=vmbuf R9=packet
    jsr toforth
 ( scr blkbuf newtail newsize vmbuf oldtail delta newvmbuf ) ( R; scr )
        vmbuf !
 ( scr blkbuf newtail newsize vmbuf oldtail delta ) ( R; scr )
        +move
 ( scr blkbuf newtail newsize ) ( R; scr )
        cmove r>
    then
 ( scr )
    drop ;
```
#endif
_scrtopkt
#include "enter.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(scrtopkt01-*+1)
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word prev
#include "page.i65"
    .word store
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word true          ; TOS=junk, Sweet-16 restacks the stack
#include "page.i65"
;  ( blkbuf newsize packet oldsize vmbuf true )
    .word to6502
    ldy #5
    jsr locals
;     ...   \ TOS=true; N0=blkbuf; N1=newsize; N2=packet; N3=oldsize N4=vmbuf
    brk
    .byt ld | N0
    .byt st | TOS               ; blkbuf
    .byt ld | N2
    .byt sub | N1
    .byt push                   ; newtail
    .byt ldd | TOS              ; 2+
    .byt ld | N1
    .byt push                   ; newsize
    .byt ld | N4
    .byt push                   ; vmbuf
    .byt ld | N2
    .byt sub | N3
    .byt push                   ; oldtail
    .byt ldi | TOS              ; 1+
    .byt ld | N3
    .byt sub | N1
    .byt push                   ; delta
    .byt add | N4
    .byt push                   ; newvmbuf
    .byt rtn
#include "toforth.i65"
;  ( blkbuf newtail newsize vmbuf oldtail delta newvmbuf ) ( R; scr )
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
scrtopkt01                      ; THEN
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCRDEL
stack=( scr -- packet )
tags=editor,nosymbol
~STOP-DEL Delete Screen

Deletes the current screen from the packet buffer.  The edit
screen is replaced by the first available of:

* The next screen in the packet buffer, if it already exists

* The previous screen in the packet buffer

* Screen 0 is blanked and written to the packet buffer

```
: scrdel   ( scr -- packet )
    >pkt
    dup @
    vmbuf @ 2dup +
    dup
    vmbuf ! rot
    cmove
    #vmpkt 1-! ;
```
#endif
_scrdel
#include "enter.i65"
    .word _topkt
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneminusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITCOPY
stack=( -- )
tags=editor,nosymbol
~STOP-C Copy Line

Appends a copy of the current logical screen line to the paste buffer

```
: editcopy
   paste logline lineinfo
   (>paste) cmove 2drop ;
: editcopy   ( -- )
    logline lineinfo >r paste @  r@ cmove
    paste r@ +!
    pwrap 2@ r> 40/mod nip wrap+ pwrap 2! ;
```
#endif
_editcopy
#include "enter.i65"
    .word logline
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word tor
#include "page.i65"
    .word paste
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word paste
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word wrapplus
#include "page.i65"
    .word drop
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word twostore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITDEL
stack=( -- )
tags=editor,nosymbol
~STOP-D Delete Line

Append the current logical screen line and delete it from the
screen

```
: editdel   ( -- )
    editcopy  logline dup lineinfo >r >r
    logline+ ?dup
    if
        lineinfo drop r> 33768 third -
        2dup + >r cmove
    then
    r> r@ blank logline r> wraproll ;

: editdel   ( -- )
    editcopy logline dup lineinfo >r >r
    logline+ lineinfo drop r> 33768 third -
    2dup + >r cmove r> r@ blank logline r> wraproll ;
```
#endif
_editdel
#include "enter.i65"
    .word _editcopy             ; ( )
#include "page.i65"
    .word logline
#include "page.i65"
    .word dup
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
    .word loglineplus
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(editdel01-*+1)
#include "pad.i65"
    .word lineinfo
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word cmove
#include "page.i65"
editdel01
    .word rfrom
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _blank
#include "page.i65"
    .word logline
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word wraproll
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITPASTE
stack=( -- )
tags=editor,nosymbol

~STOP-P

Insert the paste buffer above the current logical line

```
: editpaste   ( -- )
    paste @  logline 
    dup lineinfo drop over eos third - cmove
    pwrap 2@ logline
    begin
        dup>r
        lineinfo nip
        wrap+ drop
        r> logline+ dup 0=
    until drop
    logline wrap^ 2swap
    wrap* wrap!
    pad logline lineinfo eos over - cmove
    paste ! ;    
```
#endif
_editpaste
#include "enter.i65"
    .word paste
#include "page.i65"
    .word fetch
#include "page.i65"
    .word logline
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word drop
#include "page.i65"
    .word over
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word logline
#include "page.i65"
editpaste01
    .word duptor
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word nip
#include "page.i65"
    .word wrapplus
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word loglineplus
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(editpaste01-*+1)
#include "pad.i65"
    .word logline
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word wrapstar
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word _pad
#include "page.i65"
    .word logline
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word drop
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word paste
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITZILCH
stack=( -- )
tags=editor,nosymbol

 STOP-Z   Zilch the paste buffer

```
: editzilch   ( -- )
     pad paste !  pwrap 4 erase ;
```
#endif
_editzilch
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word paste
#include "page.i65"
    .word store
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITNOWRAP
stack=( -- )
tags=editor,nosymbol

 reset the linewrap table and make this screen writable

#endif
_editnowrap
    stx storex
    ldx #24
editnowrap01
    asl $e0,x
    sec
    ror $e0,x
    dex
    bpl editnowrap01
    stx uarea+userwritableq-userarea
    stx uarea+userwritableq-userarea+1
    ldx storex
    jmp exit

;--------------------------------------------------------------
#if 0
name=>EDIT
stack=( toscr -- )
tags=editor,nosymbol

 Save current editor screen in packet buffer
 Set "toscr" as the current SCR and edit it

```
: >edit
     scr @ scr!
     0 max scr@ ;

```
#endif
_toedit
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _scrtopkt
#include "page.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=_
stack=( -- )
tags=editor
A shortcut to get back into the editor. On the PET keyboard, there is no
underscore, it's the left-arrow character.

```
: _   ( -- )
    scr @ edit ;
```
!!!pronounced: "back"
#endif
_back
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _edit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITTOPSCR
stack=( -- )
tags=editor,nosymbol

 from the top (first) screen

#endif
_edittopscr
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITNEXTSCR
stack=( -- )
tags=editor,nosymbol

 restore from the next screen or append a blank one

```
: editnextscr   ( -- )
   scr @ 1+ editto ;

```
#endif
_editnextscr
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITPREVSCR
stack=( -- )
tags=editor,nosymbol

 restore from the previous screen or insert a blank one

```
: editprevscr   ( -- )
   scr @ 1- editto ;
```
#endif
_editprevscr
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITUPDATE
tags=nosymbol
Copy the current screen to the packet buffer
#endif
_editupdate
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _scrtopkt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITQUIT
stack=( -- )
tags=editor,nosymbol
STOP-Q   Quit the editor
#endif
_editquit
#include "enter.i65"
    .word _editupdate
#include "page.i65"
    .word editingq
#include "page.i65"
    .word off
#include "page.i65"
    .word rfrom         ; discard returns
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word drop          ; we won't be needing these
#include "page.i65"
    .word exit          ; exiting from EDIT

;--------------------------------------------------------------
#if 0
name=EDITINDEX
stack=( -- )
tags=editor,nosymbol,unimplemented

 STOP-I   Present an index screen and let the user select one to edit

#endif
editindex
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITSAVE
stack=( -- )
tags=editor,nosymbol

 STOP-S   Save all buffers to a PRG file

#endif
_editsave
#include "enter.i65"
    .word _editupdate
#include "page.i65"
    .word _clrscr
#include "page.i65"
    .word _savebuffers
#include "page.i65"
    .word _editrestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITLOAD
stack=( -- )
tags=editor,nosymbol

 STOP-L   Load a group of buffers from a PRG file

#endif
_editload
#include "enter.i65"
    .word _clrscr
#include "page.i65"
    .word _loadbuffers
#include "page.i65"
    .word scr
#include "page.i65"
    .word off
#include "page.i65"
    .word _editrestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITVERIFY
stack=( -- )
tags=editor,nosymbol

 STOP-V   Verify a buffer file vs. memory

#endif
editverify
#include "enter.i65"
    .word _clrscr
#include "page.i65"
    .word _verifybuffers
#include "page.i65"
    .word _anykey
#include "page.i65"
    .word _editrestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITRESTORE
stack=( -- )
tags=editor,nosymbol

 STOP-R   Restore the current screen from the buffer

#endif
_editrestore
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ID.L
stack=( nfa w -- )
tags=ext
Right-justified output of a name field

#endif
_iddotl
#include "enter.i65"
    .word tuck
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
iddotl01
    .word rfetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(iddotl01-*+1)
#include "pad.i65"
    .word _spaces
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME.L10
stack=( cfa -- )
tags=ext

#endif
_tonamedotl10
#include "enter.i65"
    .word _toname
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _iddotl
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INFO
stack=( -- )
tags=editor
Updates the buffer and displays an info page of various editor and
memory system parameters
#endif
_info
#include "enter.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
info02
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word execute
#include "page.i65"
    .word fetch
#include "page.i65"
    .word four
#include "page.i65"
    .word _udotr
#include "page.i65"
    .word cr
#include "page.i65"
    .word ploop
    .byt <(info02-*+1)
#include "pad.i65"
    .word plit
    .word filename
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word startup
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word cr
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

info05
    .byt 13
    .word scr
    .word blk
    .word prev
    .word writableq
    .word numvmpkt
    .word vmbuf
    .word symtab
    .word symnew
    .word symtail
    .word tdict
    .word memsiz
    .word dp
    .word drvnum

;--------------------------------------------------------------
#if 0
name=EDITDELSCR
stack=( -- )
tags=editor,nosymbol

 delete the current screen.  restore from next, then prev, then blank

#endif
editdelscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITINFO
stack=( -- )
tags=editor,nosymbol
Show the user an info screen
#endif
_editinfo
#include "enter.i65"
    .word _editupdate
#include "page.i65"
    .word _clrscr
#include "page.i65"
    .word _info
#include "page.i65"
    .word _anykey
#include "page.i65"
    .word _editrestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITINSSCR
stack=( -- )
tags=editor,nosymbol

 insert a new, blank screen

#endif
editinsscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITINIT
stack=( scr -- )
tags=editor,nosymbol

 prepare before we drop into the editor infinite loop

```
: editinit   ( scr -- )
     scr@ editzilch ;

```
#endif
_editinit
#include "enter.i65"
    .word editingq
#include "page.i65"
    .word on
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word _editzilch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITMENU
stack=( -- addr )
tags=editor,nosymbol

 returns the address of a counted string of menu commands

#endif
editmenu
     jsr docreate
     .byt editmenu01-*-1        ; number of menu items = 16
     .asc "QISLVZRDCP?"         ; command keys
     .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenu01
     .word _editquit             ; CFA of corresponding Forth word
     .word editindex
     .word _editsave
     .word _editload
     .word editverify
     .word _editzilch
     .word _editrestore
     .word _editdel
     .word _editcopy
     .word _editpaste
     .word _editinfo
     .word editdelscr
     .word editinsscr
     .word _edittopscr
     .word _editnowrap
     .word _editnextscr
     .word _editprevscr

;--------------------------------------------------------------
#if 0
name=$INDEX
stack=( addr char -- index|0 )
tags=string,ext,primitive
returns the position of char within the counted string at addr
otherwise returns 0
#endif
dolindex
    ldy #1
    jsr locals
    lda (n),y
    tay             ; Y = length of string
dolindex01
    lda (n),y
    eor tos
    beq dolindex02
    dey
    bne dolindex01
dolindex02
    sty tos
    ;ldy #0         ; we started with a char at tos
    ;sty tos+1      ; so high byte is already 0
    jmp next

;--------------------------------------------------------------
#if 0
name=EDITCMD
stack=( -- )
tags=editor,nosymbol

 get a key and perform that command

#endif
_editcmd
#include "enter.i65"
    .word editmenu              ; ( editmenu )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex              ; ( index|0 )
#include "page.i65"
    .word qdup                  ; ( index index | 0 )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editcmd01-*+1)
#include "pad.i65"
    .word twostar               ; ( 2*index )
#include "page.i65"
    .word editmenu              ; ( 2*index editmenu )
#include "page.i65"
    .word dup                   ; ( 2*index editmenu editmenu )
#include "page.i65"
    .word cfetch                ; ( 2*index editmenu #items )
#include "page.i65"
    .word plus                  ; ( 2*index editmenu+#items )
#include "page.i65"
    .word plus                  ; ( 2*index+editmenu+#items )
#include "page.i65"
    .word oneminus              ; ( 2*index+editmenu+#items-1 )
#include "page.i65"
    .word fetch                 ; ( editcmdcfa )
#include "page.i65"
    .word execute               ; ( )
#include "page.i65"
editcmd01                       ; THEN
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITIRQTOGGLE
stack=( -- )
tags=editor,nosymbol

 Enable or disable the IRQ handler within EDIT that checks for
 the STOP key in the screen editor.

```
: editirqtoggle   ( -- )
     MAINIRQ^edit02  irq^ ;

```
#endif
_editirqtoggle
#include "enter.i65"
    .word plit
    .word (MAINIRQ^edit02)
#include "pad.i65"
    .word irqcaret
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDIT
stack=( scr -- )
tags=editor
#endif
_edit
#include "enter.i65"
    .word _editinit
#include "page.i65"
edit00              ; reentry to editor here
    .word _editirqtoggle   ; enable STOP key trap
#include "page.i65"
    .word to6502
    stx storex      ; preserve Forth data stack pointer
    tsx
    stx n           ; preserve machine stack frame pointer

edit01              ; PET screen editor forever loop
    jsr CHRIN       ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #$0d        ; don't just leave the cursor two characters past end of line
    jsr CHROUT      ; Kernel - so echo the carriage return
    jmp edit01      ; ... do this forever

edit02              ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda $9b         ; copy of contents of PIA1 Port B for testing STOP key, etc...
    cmp #$ef        ; test STOP key
    bne edit03
                    ; looks like someone pressed STOP. Exit the editor
                    ; but not so fast!  Are we in quotes or inserts?
    lda $cd         ; nonzero is quotes mode
    ora $dc         ; number of inserts pending
    beq edit04
edit03
    jmp MAINIRQ     ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
edit04
    jsr UDTIM       ; keep the clock running even if someone leans on STOP
    ;sec            ; because f7a1 debounce loop always sets carry
    inc $a7         ; turn off cursor
    lda $a9         ; true character at cursor position
    jsr FIX_CHR     ; ROM $E606 on 40-column BASIC4 PET
    ldx n
    txs             ; reset stack frame
    ldx storex      ; restore Forth stack pointer
#include "toforth.i65"
    .word _editirqtoggle        ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd  ; get and perform editor command
#include "page.i65"
    .word branch
    .byt <(edit00-*+1)
#include "pad.i65" ; this never executes. editquit breaks out by dropping returns
    .word exit

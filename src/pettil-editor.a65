; pettil-editor.a65
#echo .       pettil-editor.a65         EDITOR Vocabulary (1)

;--------------------------------------------------------------
#if 0
name=FLIPSCR
stack=( -- )
tags=editor

 invert the entire screen

#endif
flipscr
    ldy #0
flipscr01
    lda VIDRAM,y            ; [4]
    eor #$80                ; [2]
    sta VIDRAM,y            ; [5]
    lda VIDRAM+$100,y
    eor #$80
    sta VIDRAM+$100,y
    lda VIDRAM+$200,y
    eor #$80
    sta VIDRAM+$200,y
    lda VIDRAM+$300,y
    eor #$80
    sta VIDRAM+$300,y
    iny                     ; [2]
    bne flipscr01           ; [3] 49 * 256 = 12544 clocks
    jmp next

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( d -- )
tags=editor

 Updates the linewrap table at $E0-F8 to reflect the bits
 stored in d.  Since line 0 ($e0) is never a continuation
 line, (always $80) it is not written to.  Only 24 bits are
 written to $E1-$F8, not 25.  Although unused, the most
 significant (2^24) bit will always be set, as a framing bit
 used to detect when the wrap double is full.

#endif
wrapstore
    ldy #1
    jsr locals
    stx storex
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
#if 0
name=WRAP^
stack=( logline -- d )
tags=editor,primitive

 Reads (a portion of) the linewrap table above the requested
 `logline`, up to but not including `logline`.

 Returns a right-aligned double with a copy of those high bit values

!!! pronounced: "wrap-above"
#endif
wrapabove
    stx storex      ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos         ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2         ; are we there yet?
    beq wrapabove03 ; leave if done
    lda $e0,x
    asl             ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1         ; append the next high bit to the double
    beq wrapabove02 ; this should always take the branch
wrapabove03
    lda n
    ldy n+1         ; high half of the double is going on the stack
    ldx storex      ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP+
stack=( d columns -- d' flag )
tags=editor,primitive
Append bits to the linewrap double `d` based on whether `columns`
is 40 or 80.  For 80, a '10' bit pair is appended,  and for 40 a
single '1' bit.  The return `flag` is zero if there are not yet 25
bits of linewrap in `d'`

!!! pronounced: "wrap-plus"
#endif
wrapplus
    sec                         ; always shift in a 1
wrapplus01
    ldy stackh,x                ; check msb 25.  full?
    bne wrapplus03
    rol stackl+1,x              ; shift in a single bit
    rol stackh+1,x
    rol stackl,x
    rol stackh,x
    lda #40
    cmp tos
    sta tos                     ; so we only do this once
    bcc wrapplus01              ; maybe shift in a 0 (if 80-column)
    ldy stackh,x
wrapplus03
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=LINEINFO
stack=( logline -- addr 40|80 )
tags=editor,nosymbol,primitive

Returns the start address and length of the logical line.
 `logline` is a physical screen line that is assumed to
 point to the upper physical line if the line is 80 columns.

#endif
lineinfo
    stx storex
    ldx tos
    lda WRAPLO,x
    sta tos
    lda LDTB1,x
    sta tos+1
    lda #40
    cpx #24
    beq lineinfo01
    ldy LDTB1+1,x
    bmi lineinfo01
    asl                     ; 80 char
lineinfo01
    ldy #0
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=LOGLINE
stack=( -- logline )
tags=editor,nosymbol,primitive
 Returns the physical line number of the logical line where the
 PET cursor is currently located.  The `logline` value returned
 is the first/top/upper line if the logical line has 80 characters.

 From this position, [[leapfrogging forward|LOGLINE+]] down the
 screen will always return logical line addresses (with
 wraptable bit7 set), never continuation lines.
#endif
logline
    stx storex
    ldx TBLX        ; $d8 = Current Cursor Physical Line Number
    inx
logline01
    dex
    ldy LDTB1,x     ; $e0 = 25-byte screen wrap table
    bpl logline01
    txa
    ldy #0
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=LOGLINE+
stack=( logline -- logline+|0 )
tags=editor

 Return the next logical line number or 0 after bottom of screen

#endif
loglineplus
    stx storex
    lda #0
    ldx tos
loglineplus01
    cpx #24
    beq loglineplus02
    inx
    ldy LDTB1,x
    bpl loglineplus01
    txa
loglineplus02
    ldy #0
    ldx storex
    jmp put

;--------------------------------------------------------------
#if 0
name=PASTE
stack=( -- addr )
tags=editor

 Return the tail of the paste buffer, marked by 0

 The paste buffer begins at PAD and consists of zero or more
 screen lines, stored as a length (40|80) followed by that many
 screen codes.  Each record is 41 or 81 bytes long.


```
: paste
   pad                     ( pad )
   begin
       dup                 ( addr addr )
       c@                  ( addr len )
       ?dup                ( addr 0 | addr len len )
   while                   ( addr len )
       +                   ( len+addr )
       1+                  ( newaddr )
   repeat ; [19]           ( addr )

```
#endif
_paste
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word to6502
    brk
paste01
    .byt ldi | TOS
    .byt bz , <(paste02-*-2)
    .byt add | TOS
    .byt st | TOS
    .byt br , <(paste01-*-2)
paste02
    .byt nxt    ; [16]

;--------------------------------------------------------------
#if 0
name=(>PASTE)
stack=( paste screen 40|80 -- paste+len+1 screen+len screen paste+1 len )
tags=editor,nosymbol

 set up the stack to append the line on the screen to the paste buffer with cmove

```
: (>paste)
    >r swap r@ over c!   ( screen paste ; 40|80 )
    1+ 2dup r@ cmove   ( screen paste+1 )
    r@ + dup off swap r> + ; [37]

```
#endif
ptopaste
    ldy #2
    jsr locals
    brk                         ; TOS = len; N0 = paste; N1 = screen
    .byt ld | TOS
    .byt sti | N0               ; len paste c! paste 1+!
    .byt st | N2                ; copy of len
    .byt add | N0
    .byt st | TOS               ; paste+len+1
    .byt st | N3
    .byt sub | R0
    .byt std | N3               ; off
    .byt ld | N1
    .byt add | N2
    .byt push                   ; screen+len
    .byt ld | N1
    .byt push                   ; screen
    .byt ld | N0
    .byt push                   ; paste+1
    .byt ld | N2
    .byt push                   ; len
    .byt nxt                    ; [27]

;--------------------------------------------------------------
#if 0
name=EOS>PASTE
stack=( paste logline -- )
tags=editor,nosymbol

 append every line from the logical line passed in (expected to be
 nonzero ) to the end of screen to the paste buffer.


```
: eos>paste   ( paste logline -- )
    begin
        ?dup
    while
        dup logline+ >r       ( paste logline ) ( R; logline+ )
        lineinfo              ( paste screen 40|80 ) ( R; logline+ )
        >paste drop           ( paste+ ) ( R; logline+ )
        r>
    repeat
    drop ;

```
#endif
_eostopaste
#include "enter.i65"
eostopaste01                    ; BEGIN
    .word qdup
#include "page.i65"
    .word qbranch               ; WHILE
    .byt <(eostopaste02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word loglineplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word ptopaste              ; ( paste+ screen+ screen paste+1 len )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word branch                ; REPEAT
    .byt <(eostopaste01-*+1)
#include "pad.i65"
eostopaste02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WRAPPASTE
stack=( -- dwrap )
tags=editor,nosymbol

 Leave a double of screenwrap bits on the stack, treating the
 current cursor position as the target of a paste (above from
 linewrap table $E0-F8, at and below from paste buffer)

```
: wrappaste   ( -- dwrap )
    wrap^   ( dwrap )
    pad >r
    true
    begin
        r@ c@ dup   ( dwrap len len )
        r> + 1+ >r
        and
    while
        wrap+ 0=
    repeat
    r> drop ;   ( d )

```
#endif
_wrappaste
#include "enter.i65"
    .word wrapabove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word tor
#include "page.i65"
wrappaste01
    .word rfetch
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word qbranch
    .byt <(wrappaste02-*+1)
#include "pad.i65"
    .word wrapplus
#include "page.i65"
    .word branch
    .byt <(wrappaste01-*+1)
#include "pad.i65"
wrappaste02
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TEST25
stack=( screenaddr offset -- screenaddr offset|40 )
tags=editor,nosymbol

 Adjusts the offset from anything to 40 if offset+screenaddr is
 beyond the end of the screen

   a) to prevent overflowing the screen

   b) for use as a flag


```
: test25   ( offset screenaddr -- offset' screenaddr )
    2dup + 33767 >
    if
        drop 40
    then ;

```
~wut? this is awful
#endif
_test25
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(test2501-*+1)        ; IF
#include "pad.i65"
    .word drop
#include "page.i65"
    .word clit
    .byt 40
#include "pad.i65"
test2501                        ; THEN
    .word exit

;--------------------------------------------------------------
#if 0
name=FLAGAB
stack=( paste screen -- flagab )
tags=editor,nosymbol
 true if we've hit exit condition A or B

#endif
_flagab
#include "enter.i65"
    .word zero                  ; ( paste screen 0 )
#include "page.i65"
    .word _test25               ; ( paste screen 0|40 )
#include "page.i65"
    .word rot                   ; ( screen flagb paste )
#include "page.i65"
    .word cfetch                ; ( screen flagb len )
#include "page.i65"
    .word zeq                   ; ( screen flagb flaga )
#include "page.i65"
    .word orx                   ; ( screen flagab )
#include "page.i65"
    .word swap                  ; ( flagab screen )
#include "page.i65"
    .word drop                  ; ( flagab )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASTE>
stack=( paste screen -- d paste+ screen+ )
tags=editor,nosymbol

 copy logical lines from the paste buffer to screen until

   a) we exhaust the paste buffer

   b) we run past the bottom of the screen

   c) we fill up the linewrap table

 returns a double with the linewrap bits from line 0 until
 PASTE> reaches an exit condition, also the next paste
 buffer source address and next screen target address


```
: paste>
    logline ?dup
    if
        wrap^             ( paste screen d )
    else
        1 0
    then
    2swap
    begin
        2dup flagab dup >r 0= ( d paste screen !flagab ) ( R; flagab )
        if
            over c@           ( d paste screen len ) ( R; flagab )
            swap over test25  ( d paste len screen len' ) ( R; flagab )
            2dup + >r         ( d paste len screen len' ) ( R; flagab screen' )
            2over + 1+ >r     ( d paste len screen len' ) ( R; flagab screen' paste' )
            2swap swap 1+     ( d screen len' len paste+1 ) ( R; flagab screen' paste' )
            2swap cmove       ( d len ) ( R; flagab screen' paste' )
            wrapfill          ( d flag ) ( R; flagab screen' paste' )
            r> r> rot r>      ( d flag paste' screen' flagc flagab ) ( R; )
            or >r             ( d paste' screen' ) ( R; flagabc )
        then
        r>
    until ;

```
#endif
_pastefrom
#include "enter.i65"
    .word logline               ; ( paste screen logline )
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pastefrom01-*+1)
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word branch                ; ELSE
    .byt <(pastefrom02-*+1)
#include "page.i65"
pastefrom01
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
pastefrom02                     ; THEN
#include "page.i65"
    .word twoswap               ; ( d paste screen )
#include "page.i65"
pastefrom03
    .word twodup               ; ( d paste screen paste screen )
#include "page.i65"
    .word _flagab               ; ( d paste screen flagab )
#include "page.i65"
    .word dup                   ; ( d paste screen flagab flagab )
#include "page.i65"
    .word tor                   ; ( d paste screen flagab ) ( R; flagab )
#include "page.i65"
    .word zeq                   ; ( d paste screen !flagab ) ( R; flagab )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pastefrom04-*+1)
#include "pad.i65"
    .word over                  ; ( d paste screen paste ) ( R; flagab )
#include "page.i65"
    .word cfetch                ; ( d paste screen len ) ( R; flagab )
#include "page.i65"
    .word swap                  ; ( d paste len screen ) ( R; flagab )
#include "page.i65"
    .word over                  ; ( d paste len screen len ) ( R; flagab )
#include "page.i65"
    .word _test25               ; ( d paste len screen len' ) ( R; flagab )
#include "page.i65"
    .word twodup               ; ( d paste len screen len' screen len' ) ( R; flagab )
#include "page.i65"
    .word plus                  ; ( d paste len screen len' screen' ) ( R; flagab )
#include "page.i65"
    .word tor                   ; ( d paste len screen len' ) ( R; flagab screen' )
#include "page.i65"
    .word twoover               ; ( d paste len screen len' paste len ) ( R; flagab screen' )
#include "page.i65"
    .word plus                  ; ( d paste len screen len' paste+len ) ( R; flagab screen' )
#include "page.i65"
    .word oneplus               ; ( d paste len screen len' paste' ) ( R; flagab screen' )
#include "page.i65"
    .word tor                   ; ( d paste len screen len' ) ( R; flagab screen' paste' )
#include "page.i65"
    .word twoswap               ; ( d screen len' paste len ) ( R; flagab screen' paste' )
#include "page.i65"
    .word swap                  ; ( d screen len' len paste ) ( R; flagab screen' paste' )
#include "page.i65"
    .word oneplus               ; ( d screen len' len paste+1 ) ( R; flagab screen' paste' )
#include "page.i65"
    .word twoswap               ; ( d len paste+1 screen len' ) ( R; flagab screen' paste' )
#include "page.i65"
    .word cmove                 ; ( d len ) ( R; flagab screen' paste' )
#include "page.i65"
    .word wrapplus              ; ( d flagc ) ( R; flagab screen' paste' )
#include "page.i65"
    .word rfrom                 ; ( d flagc paste' ) ( R; flagab screen' )
#include "page.i65"
    .word rfrom                 ; ( d flagc paste' screen' ) ( R; flagab )
#include "page.i65"
    .word rot                   ; ( d paste' screen' flagc ) ( R; flagab )
#include "page.i65"
    .word rfrom                 ; ( d paste' screen' flagc flagab ) ( R; )
#include "page.i65"
    .word orx                   ; ( d paste' screen' flagabc ) ( R; )
#include "page.i65"
    .word tor                   ; ( d paste' screen' ) ( R; flagabc )
#include "page.i65"
pastefrom04                     ; THEN
    .word rfrom
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pastefrom03-*+1)
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT>SCR
stack=( scr -- )
tags=editor

 Locate (or create) the packet for "scr" and open it in the editor

```
: pkt>scr   ( scr -- )
    dup scr ! (block) drop
                              ( blkbuf )
    writable? @
                              ( blkbuf editable? )
    if
                              ( blkbuf )
        dup 3c@ wrap!
                              ( blkbuf )
        3+
                              ( blkbuf+3 )
    then
                              ( blkbuf|blkbuf+3 )
    vidram b/scr
                              ( blkbuf $8000 1000 )
     cmove ;

```
#endif
_pkttoscr
#include "enter.i65"
    .word dup
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pkttoscr01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word threeplus
#include "page.i65"
pkttoscr01
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SCR!)
stack=( scr blkbuf vmbuf packet blkbuf newsize -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
tags=editor,nosymbol

 Uses Sweet16 to take a lot of the ridiculousness out of the
 pointer math involved in juggling packets in the buffer.
 This sets up for two MOVE operations.  The first move opens
 a hole correctly sized for the replacement packet.  The new
 packet is then moved into the hole.

#endif
pscrstore
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull                   ; blkbuf
    .byt add | R10              ; newpacket
    .byt st | TOS               ; end of new packet
    .byt ldd | TOS              ; new packetheader
    .byt ext
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
    .byt ld | R11
    .byt st | R9                ; newsize
    .byt pull
    .byt st | N0                ; packet
    .byt ldd | TOS              ; old packetheader
    .byt ext
    .word pktheader16
    .byt pull                   ; vmbuf
    .byt st | N3
    .byt ld | N0
    .byt sub | R9
    .byt st | TOS               ; packet-newsize+2
    .byt ld | R9
    .byt inr | ACC
    .byt inr | ACC
    .byt push                   ; newlength
    .byt ld | N3
    .byt push                   ; vmbuf
    .byt add | R11
    .byt sub | R9
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | R11
    .byt sub | N3
    .byt push                   ; packet-oldsize-vmbuf
    .byt nxt

;--------------------------------------------------------------
#if 0
name=MKPKT
stack=( blkbuf -- size )
tags=editor,nosymbol

 Builds an editable packet at `BLKBUF` from the current screen.
 The first three bytes of the packet are the linewrap bits for
 lines 1..24.  This is followed by 1000 screen code bytes,
 RLE-encoded unless storing them occupies less room.  The last
 two bytes of the packet are the packet header, containing the
 11-bit total packet length, in the range 5..1026, and the
 packet flags

 * $8000 = editable?  //true for editor screens, false for data blocks//

 * $4000 = uncompressed?

!!! pronounced: "make-packet"

```
: mkpkt   ( blkbuf -- size )
    >r 25 wrap^ r@ 3c!        \ retrieve linewrap from screen
( ) ( R; blkbuf )
    vidram b/scr -trailing    \ squeeze trailing spaces from screen
( vidram vidsize ) ( R; blkbuf )
    r@ 3+ swap rlencode       \ rlencode it
( targend uncompressed? ) ( R; blkbuf )
    $4000 and vidram or       \ editable, uncompressed flags
( targend pktflags ) ( R; blkbuf )
    over r> - 2+ dup>r
( targend pktflags size ) ( R; size )
    or swap !
( ) ( R; size )
    r> ;
( size )

```
#endif
_mkpkt
#include "enter.i65"
    .word tor
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word wrapabove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word plit
    .word $4000
#include "pad.i65"
    .word andx
#include "page.i65"
    .word vidram
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word orx
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCR>PKT
stack=( scr -- )
tags=editor,nosymbol
Stores the current screen into the packet buffer as screen `scr`.
If screen `scr` is read-only, nothing is written to the buffer

pronounced: "s-c-r-to-packet"

```
: scr>pkt   ( scr -- )
     writable? @
 ( scr flag )
    if
 ( scr )
        >r blkbuf dup mkpkt
 ( blkbuf newsize ) ( R; scr )
        r@ >pkt dup @ $7ff and
 ( blkbuf newsize packet oldsize )
        vmbuf @
 ( blkbuf newsize packet oldsize vmbuf )
        true
 ( blkbuf newsize packet oldsize vmbuf true )
        >6502
  ldy #5
  jsr locals
    ...   \ TOS=-1; N0=blkbuf; N1=newsize; N2=oldsize; N3=vmbuf R9=packet
    jsr toforth
 ( scr blkbuf newtail newsize vmbuf oldtail delta newvmbuf ) ( R; scr )
        vmbuf !
 ( scr blkbuf newtail newsize vmbuf oldtail delta ) ( R; scr )
        +move
 ( scr blkbuf newtail newsize ) ( R; scr )
        cmove r>
    then
 ( scr )
    drop ;

```
#endif
_scrtopkt
#include "enter.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(scrtopkt01-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word true          ; TOS=junk, Sweet-16 restacks the stack
#include "page.i65"
;  ( blkbuf newsize packet oldsize vmbuf true )
    .word to6502
    ldy #5
    jsr locals
;     ...   \ TOS=true; N0=blkbuf; N1=newsize; N2=packet; N3=oldsize R9=vmbuf
    brk
    .byt ld | N0
    .byt st | TOS               ; blkbuf
    .byt ld | N2
    .byt sub | N1
    .byt push                   ; newtail
    .byt ldd | TOS              ; 2+
    .byt ld | N1
    .byt push                   ; newsize
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt ld | N2
    .byt sub | N3
    .byt push                   ; oldtail
    .byt ldi | TOS              ; 1+
    .byt ld | N3
    .byt sub | N1
    .byt push                   ; delta
    .byt add | R9
    .byt push                   ; newvmbuf
    .byt rtn
#include "toforth.i65"
;  ( blkbuf newtail newsize vmbuf oldtail delta newvmbuf ) ( R; scr )
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
scrtopkt01                      ; THEN
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCRDEL
stack=( scr -- packet )
tags=editor,nosymbol
~STOP-DEL Delete Screen

Deletes the current screen from the packet buffer.  The edit
screen is replaced by the first available of:

* The next screen in the packet buffer, if it already exists

* The previous screen in the packet buffer

* Screen 0 is blanked and written to the packet buffer

```
: scrdel   ( scr -- packet )
    >pkt
    dup @
    vmbuf @ 2dup +
    dup
    vmbuf ! rot
    cmove
    #vmpkt 1-! ;

```
#endif
_scrdel
#include "enter.i65"
    .word _topkt
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneminusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITCOPY
stack=( -- )
tags=editor,nosymbol
~STOP-C Copy Line

Appends a copy of the current logical screen line to the paste buffer

```
: editcopy
   paste logline lineinfo
   (>paste) cmove 2drop ;

```
#endif
_editcopy
#include "enter.i65"
    .word _paste
#include "page.i65"
    .word logline           ; ( paste line )
#include "page.i65"
    .word lineinfo          ; ( paste screen 40|80 )
#include "page.i65"
    .word ptopaste          ; ( paste+ screen+ screen paste+1 len )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word twodrop          ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITDEL
stack=( -- )
tags=editor,nosymbol
~STOP-D Delete Line

Append the current logical screen line and delete it from the
screen

```
: editdel
   \ append the current line to the paste buffer
   editcopy
   \ mark the tail of the paste buffer and start a new buffer here
   paste dup >r               ( tpaste ) ( R; tpaste )
   \ append all lines from the next one to the bottom of screen to paste
   logline logline+ eos>paste ( ) ( R; tpaste )
   \ put everything back, with linewrap
   r@ logline lineinfo drop   ( tpaste screen ) ( R; tpaste )
   paste>                     ( d tpaste+ screen+ )
   VIDRAM+1000 over - blank   ( d tpaste+ ) ( R; tpaste )
   drop r> off                ( d )
   begin
       40 wrapfill            ( d flag )
   until
   wrap! ;

```
#endif
_editdel
#include "enter.i65"
    .word _editcopy             ; ( )
#include "page.i65"
    .word _paste                ; ( pastebuf2 )
#include "page.i65"
    .word dup                   ; ( pastebuf2 pastebuf2 )
#include "page.i65"
    .word tor                   ; ( pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word logline               ; ( pastebuf2 logline ) ( R; pastebuf2 )
#include "page.i65"
    .word loglineplus           ; ( pastebuf2 logline+ ) ( R; pastebuf2 )
#include "page.i65"
    .word _eostopaste           ; ( ) ( R; pastebuf2 ) send nextline...EOS to pastebuf2
#include "page.i65"
    .word rfetch                ; ( pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word logline               ; ( pastebuf2 logline ) ( R; pastebuf2 )
#include "page.i65"
    .word lineinfo              ; ( pastebuf2 screen 40|80 ) ( R; pastebuf2 )
#include "page.i65"
    .word drop                  ; ( pastebuf2 screen ) ( R; pastebuf2 )
#include "page.i65"
    .word _pastefrom            ; ( pastebuf2 screen ) ( R; pastebuf2 ) should exhaust the pastebuffer
#include "page.i65"
    .word plit                  ; ( d pastebuf2 screen 33768 ) ( R; pastebuf2 )
    .word VIDRAM+1000
#include "pad.i65"
    .word over                  ; ( d pastebuf2 screen 33768 screen ) ( R; pastebuf2 )
#include "page.i65"
    .word minus                 ; should always get 40 or 80
#include "page.i65"
    .word _blank                ; ( d pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word off
#include "page.i65"
editdel01                       ; BEGIN
    .word clit
    .byt 40
#include "pad.i65"
    .word wrapplus
#include "page.i65"
    .word qbranch
    .byt <(editdel01-*+1)       ; UNTIL
#include "pad.i65"
    .word wrapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITPASTE
stack=( -- )
tags=editor,nosymbol

~STOP-P

Insert the paste buffer above the current logical line

```
: editpaste   ( -- )
    \ mark the current tail of the paste buffer
    paste dup >r                      ( tpaste ) ( R; tpaste )
    \ append everything to end of screen to secondary paste buffer
    logline eos>paste                 ( ) ( R; tpaste )
    \
    pad logline lineinfo drop         ( paste screen ) ( R; tpaste )
    \ put everything back
    paste>                            ( d paste+ screen+ ) ( R; tpaste )
    2drop  r> off  wrap! ;

```
#endif
_editpaste
#include "enter.i65"
    .word _paste                        ; ( tpaste )
#include "page.i65"
    .word dup                           ; ( tpaste tpaste )
#include "page.i65"
    .word tor                           ; ( tpaste ) ( R; tpaste )
#include "page.i65"
    .word logline                       ; ( tpaste logline ) ( R; tpaste )
#include "page.i65"
    .word _eostopaste                   ; ( ) ( R; tpaste )
#include "page.i65"
    .word _pad                          ; ( paste )
#include "page.i65"
    .word logline                       ; ( paste logline ) ( R; tpaste )
#include "page.i65"
    .word lineinfo                      ; ( paste screen 40|80 ) ( R; tpaste )
#include "page.i65"
    .word drop                          ; ( paste screen ) ( R; tpaste )
#include "page.i65"
    .word _pastefrom                    ; ( d paste+ screen+ ) ( R; tpaste )
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word off
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITZILCH
stack=( -- )
tags=editor,nosymbol

 STOP-Z   Zilch the paste buffer

```
: editzilch   ( -- )
     pad off ;

```
#endif
_editzilch
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITNOWRAP
stack=( -- )
tags=editor,nosymbol

 reset the linewrap table and make this screen writeable

#endif
_editnowrap
#include "enter.i65"
    .word writableq
#include "page.i65"
    .word on
#include "page.i65"
    .word to6502
    stx storex
    ldx #24
editnowrap01
    asl $e0,x
    sec
    ror $e0,x
    dex
    bpl editnowrap01
    ldx storex
    jmp exit

;--------------------------------------------------------------
#if 0
name=>EDIT
stack=( toscr -- )
tags=editor,nosymbol

 Save current editor screen in packet buffer
 Set "toscr" as the current SCR and edit it

```
: >edit
     scr @ scr!
     0 max scr@ ;

```
#endif
_toedit
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _scrtopkt
#include "page.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITTOPSCR
stack=( -- )
tags=editor,nosymbol

 from the top (first) screen

#endif
_edittopscr
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITNEXTSCR
stack=( -- )
tags=editor,nosymbol

 restore from the next screen or append a blank one

```
: editnextscr   ( -- )
   scr @ 1+ editto ;

```
#endif
_editnextscr
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITPREVSCR
stack=( -- )
tags=editor,nosymbol

 restore from the previous screen or insert a blank one

```
: editprevscr   ( -- )
   scr @ 1- editto ;

```
#endif
_editprevscr
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word _toedit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITQUIT
stack=( -- )
tags=editor,nosymbol

 STOP-Q   Quit the editor

~wut? use left-arrow to return to the editor on the current
screen, and screen on here (=-1) so left-arrow becomes "edit
the current display as a screen" Leave SCR alone on the info
page and use left-arrow to return to edit mode on that screen

#endif
_editquit
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _scrtopkt
#include "page.i65"
    .word editingq
#include "page.i65"
    .word off
#include "page.i65"
    .word rfrom         ; discard returns
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word drop          ; we won't be needing these
#include "page.i65"
    .word exit          ; exiting from EDIT

;--------------------------------------------------------------
#if 0
name=EDITINDEX
stack=( -- )
tags=editor,nosymbol

 STOP-I   Present an index screen and let the user select one to edit

#endif
editindex
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITSAVE
stack=( -- )
tags=editor,nosymbol

 STOP-S   Save all buffers to a PRG file

#endif
editsave
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITLOAD
stack=( -- )
tags=editor,nosymbol

 STOP-L   Load a group of buffers from a PRG file

#endif
_editload
#include "enter.i65"
    .word _pdq
    .byt editload02-*-1
    .asc    CLR,"LOADING"
editload02
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITVERIFY
stack=( -- )
tags=editor,nosymbol

 STOP-V   Verify a buffer file vs. memory

#endif
editverify
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITRESTORE
stack=( -- )
tags=editor,nosymbol

 STOP-R   Restore the current screen from the buffer

#endif
editrestore
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITDELSCR
stack=( -- )
tags=editor,nosymbol

 delete the current screen.  restore from next, then prev, then blank

#endif
editdelscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITINSSCR
stack=( -- )
tags=editor,nosymbol

 insert a new, blank screen

#endif
editinsscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITINIT
stack=( scr -- )
tags=editor,nosymbol

 prepare before we drop into the editor infinite loop

```
: editinit   ( scr -- )
     scr@ editzilch ;

```
#endif
_editinit
#include "enter.i65"
    .word editingq
#include "page.i65"
    .word on
#include "page.i65"
    .word _pkttoscr
#include "page.i65"
    .word _editzilch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITMENU
stack=( -- addr )
tags=editor,nosymbol

 returns the address of a counted string of menu commands

#endif
editmenu
     jsr docreate
     .byt editmenu01-*-1        ; number of menu items = 16
     .asc "QISLVZRDCP"          ; command keys
     .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenu01
     .word _editquit             ; CFA of corresponding Forth word
     .word editindex
     .word editsave
     .word _editload
     .word editverify
     .word _editzilch
     .word editrestore
     .word _editdel
     .word _editcopy
     .word _editpaste
     .word editdelscr
     .word editinsscr
     .word _edittopscr
     .word _editnowrap
     .word _editnextscr
     .word _editprevscr

;--------------------------------------------------------------
#if 0
name=EDITCMD
stack=( -- )
tags=editor,nosymbol

 get a key and perform that command

#endif
_editcmd
#include "enter.i65"
    .word editmenu              ; ( editmenu )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex              ; ( index|0 )
#include "page.i65"
    .word qdup                  ; ( index index | 0 )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editcmd01-*+1)
#include "pad.i65"
    .word twostar               ; ( 2*index )
#include "page.i65"
    .word editmenu              ; ( 2*index editmenu )
#include "page.i65"
    .word dup                   ; ( 2*index editmenu editmenu )
#include "page.i65"
    .word cfetch                ; ( 2*index editmenu #items )
#include "page.i65"
    .word plus                  ; ( 2*index editmenu+#items )
#include "page.i65"
    .word plus                  ; ( 2*index+editmenu+#items )
#include "page.i65"
    .word oneminus              ; ( 2*index+editmenu+#items-1 )
#include "page.i65"
    .word fetch                 ; ( editcmdcfa )
#include "page.i65"
    .word execute               ; ( )
#include "page.i65"
editcmd01                       ; THEN
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITIRQTOGGLE
stack=( -- )
tags=editor,nosymbol

 Enable or disable the IRQ handler within EDIT that checks for
 the STOP key in the screen editor.

```
: editirqtoggle   ( -- )
     MAINIRQ^edit02  irq^ ;

```
#endif
_editirqtoggle
#include "enter.i65"
    .word plit
    .word (MAINIRQ^edit02)
#include "pad.i65"
    .word irqcaret
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDIT
stack=( scr -- )
tags=editor
#endif
_edit
#include "enter.i65"
    .word _editinit
#include "page.i65"
edit00              ; reentry to editor here
    .word _editirqtoggle   ; enable STOP key trap
#include "page.i65"
    .word to6502
    stx storex      ; preserve Forth data stack pointer
    tsx
    stx n           ; preserve machine stack frame pointer

edit01              ; PET screen editor forever loop
    jsr CHRIN       ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #$0d        ; don't just leave the cursor two characters past end of line
    jsr CHROUT      ; Kernel - so echo the carriage return
    jmp edit01      ; ... do this forever

edit02              ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda $9b         ; copy of contents of PIA1 Port B for testing STOP key, etc...
    cmp #$ef        ; test STOP key
    bne edit03
                    ; looks like someone pressed STOP. Exit the editor
                    ; but not so fast!  Are we in quotes or inserts?
    lda $cd         ; nonzero is quotes mode
    ora $dc         ; number of inserts pending
    beq edit04
edit03
    jmp MAINIRQ     ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
edit04
    jsr UDTIM       ; keep the clock running even if someone leans on STOP
    ;sec            ; because f7a1 debounce loop always sets carry
    inc $a7         ; turn off cursor
    lda $a9         ; true character at cursor position
    jsr FIX_CHR     ; ROM $E606 on 40-column BASIC4 PET
    ;jsr UNFLIP_CRSR ; ~wut? probably need to flip off the cursor
    ldx n
    txs             ; reset stack frame
    ldx storex      ; restore Forth stack pointer
#include "toforth.i65"
    .word _editirqtoggle        ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd  ; get and perform editor command
#include "page.i65"
    .word branch
    .byt <(edit00-*+1)
#include "pad.i65" ; this never executes. editquit breaks out by dropping returns
    .word exit

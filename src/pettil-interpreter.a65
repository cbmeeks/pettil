; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=Error messages
tags=general,nosymbol
PETTIL system messages, output by [[FAIL]]
#endif
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08,msg09

msg01
    .byt msg02-*-1
    .asc "STACK UNDERFLOW"
msg02
    .byt msg03-*-1
    .asc "STACK OVERFLOW"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc " MISSING"
msg10
;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value
#endif
_petscii
#include "enter.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  Core (0) is the last
vocabulary searched.  Invoking a vocabulary pushes it to the head
of the stack.
#endif
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Set the core vocabulary as context
#endif
_forth
#include "enter.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
New definitions will be created in the top vocabulary in vstack
#endif
_definitions
#include "enter.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word currvoc
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen16a
    jmp put

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.


```
symbol table entry
+---------------+
|    CFA[low]   |  +0      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  +2      Length field
[I]             |          Immediate bit
| [V]           |          Vocabulary bit
|   [S]         |          Smudge bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +3      Name field
|           ... |
|   name[len]   |
+~~~~~~~~~~~~~~~+
?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
+~~~~~~~~~~~~~~~+
```
#endif
pearsonhash
    stx storex
    jsr pearsonhash01
    ldx storex
    jmp put

pearsonhash01
    jsr nfalen16a           ; A=length; Y=0
    sta r0                  ; seed hash1 with length
    tay                     ; count backwards
pearsonhash02
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda r0                          ;[3]
    eor pearson,x                   ;[4]
    sta r0                          ;[3]
    dey
    bne pearsonhash02
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor r0                  ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    rts

;--------------------------------------------------------------
#if 0
name=pearsonhash16
tags=interpreter,nosymbol
Sweet16 wrapper around Pearson hash function

* inputs
** ACC (R0) length
** TOS (R1) NFA
* returns
** ACC (R0) Pearson hash hexdigit
#endif
pearsonhash16
    ldy r0
    jsr pearsonhash02
    sty r0+1
    sta r0
    rts
    
;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=nosymbol,concepts
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash
    jsr nfalen16a               ; A=length; Y=0
    tay
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

bloomhash01
    lda #0
    sta r0
    sta r0+1
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc r0                      ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta r0                      ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda r0
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next
nfaplus01                       ; should *never* return Z=true
    jsr nfalen16a
    clc
    bvc nfaplus02
    sec
nfaplus02
    adc #3                      ; +cfa +length/flags +vocid
    adc tos
    sta tos
    bcc nfaplus03
    inc tos+1
nfaplus03
    rts

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive

!!!mode flag

* TRUE -- list is unsorted (SYMNEW)
* FALSE -- list is sorted (SYMTAB)
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname; N1 = vocid; N2 = modeflag
    ;ldy #0
    sty n+8                     ; N4 = result flag
    sty n+9
    lda (n),y
    and #$1f
    sta n+6                     ; N3 = length we seek
pseek01
    jsr nfalen16a
    ;ldy #0
    beq pseek07                 ; end of list? exit with NFA FALSE
    bcs pseek03                 ; smudged? not findable. next!
    lda n+2
    beq pseek02                 ; searching root?
    bvc pseek03                 ; is this word within a vocabulary?
    ldy r11
    iny
    eor (tos),y                 ; get vocabulary byte
    bne pseek03                 ; not the right vocabulary? next!
pseek02
    lda r11
    cmp n+6                     ; compare lengths
    bne pseek04                 ; same length, compare strings too
    jsr strcomp16a
    ;ldy #0                     ; thank you, strcomp
    bcc pseek03
    ; winner!
    inc n+8                     ; assume immediate, set N4 = +1
    lda (tos),y                 ; length and flags
    bmi pseek06                 ; immediate?
    dey
    sty n+8
    sty n+9                     ; normal, set N4 = -1
pseek06
    brk
    .byt ld | TOS
    .byt push                   ; push the NFA
    .byt popd | TOS             ; get the CFA
    .byt br , <(pseek08-*-2)

pseek04
    bcc pseek03                 ; shorter length? next!
    lda n+4                     ; check modeflag
    beq pseek07                 ; core mode, and we've gone past it
pseek03
    jsr nfaplus01
    bne pseek01                 ; bra

pseek07
    ; loser...
    brk
    .byt ld | N0                ; get the original name
    .byt st | TOS
    .byt push                   ; push the name address twice
pseek08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | N4                ; status flag
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

```
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
_pvfind
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FIND
stack=( addr1 -- addr2 flag )
tags=interpreter,forth-83,nosymbol
addr1 is the address of a counted string, which is the word to look
up in the dictionary.

if not found, addr2 is the original addr1, and flag = 0
if found, addr2 is the code field address of the word,
and flag = -1 for normal words, +1 for immediate words

! outer interpreter

name is the address of a counted string we are searching for.
fflag is the find mode.  False means NFAs are sorted, True means check them all
nfa is the first nfa in the hash list

vocid identifies which vocabulary to search.  Vocabularies may be
nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
NFAs (with the vocid appended to the name before hashing) on the stack.
The final vocabulary searched will be core, and (FIND) will exit afterward.

  0 = corelist

  1 = assembler

  2+ = vocabularies added by the user

(FIND) first searches all unsorted names beginning at SYMTAIL, without regard 
to name length.  If it fails to find the word there,
it tries the hash list, which is sorted in ascending size
order.  Vocabularies are searched first, beginning with CONTEXT and chaining
up until core (0) is reached.  The vocid is appended to the word when
searching that vocabulary.  Only one symbol within a vocabulary may be
active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
may be active within more than one vocabulary.

 returns
       ( cfa -1 ) found normal word
       ( cfa 1 ) found immediate word
       ( name 0 ) not in dictionary

```
: find ( name -- xfa flag )
    dup bloom# >bit bloom + cbit@
    if
        >r  vstack
 ( vstack ) ( R; name )
        begin
            c@+ r@ over 
 ( vptr vocid name vocid ) ( R; name )
            (vfind)
 ( vptr vocid nfa xfa found? ) ( R; name )
            ?dup
            if
                rdrop 2>r 3drop 2r> exit
            then
            2drop 0=
        until
        drop r>
    then 
    false ;
```
#endif
_find
#include "enter.i65"
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(find04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word vstack
#include "page.i65"
find01
    .word cfetchplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
    .word twotor
#include "page.i65"
    .word threedrop
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word exit
#include "page.i65"
find03
    .word twodrop
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
find04
    .word false
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word dup c@ ?: find 0 ;
```
#endif
_existsq
#include "enter.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word pquerycolon
    .word _find
    .word zero
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? 0=  3 ?error ;
```
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word three
#include "page.i65"
    .word _qerror
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.TIB
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address

```
: source.tib   ( -- addr size )
    tib #tib @ ;
```
#endif
_sourcetib
#include "enter.i65"
    .word tib
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.BLK
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address and size

```
: source.blk   ( -- addr size )
    block b/buf ;
```
#endif
_sourceblk
#include "enter.i65"
    .word _block
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Loads the next logical line from the virtual screen buffer into another
80-character buffer, returning a flag indicating if there was a next line

```
: refill.scr   ( -- )
    #lin off
    >in off
    lin dup 1+! @
    25 <
    if
        lin @                   ( lin )
        dup >bit blkbuf + cbit@ ( lin flag )
        swap 24 = or            ( flag )
        if
            forty
        else
            lin 1+! eighty
        then                    ( 40|80 )
        dup    LNMX c!
        3      DFLTN c!
        @lin @ PNT dup dup>r 3c@ >r >r !
        0      PNTR c!          ( 40|80 )
        cas2buf over 2dup expect -trailing
        r> r> r> 3c!            ( restore screen cursor )
        @lin +!
        span @  #lin !
    then ;
```
#endif
_refillscr
#include "enter.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word lin
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(refillscr03-*+1)
#include "pad.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word tobit
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt 24
#include "pad.i65"
    .word eq
#include "page.i65"
    .word orx
#include "page.i65"
    .word qbranch
    .byt <(refillscr01-*+1)
#include "pad.i65"
    .word forty
#include "page.i65"
    .word branch
    .byt <(refillscr02-*+1)
#include "pad.i65"
refillscr01
    .word lin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word eighty
#include "page.i65"
refillscr02
    .word dup
#include "page.i65"
    .word clit
    .byt LNMX
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word three
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word atlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt PNT
#include "pad.i65"
    .word dup
#include "page.i65"
    .word duptor
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
    .word store
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt PNTR
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word dup
#include "page.i65"
    .word atlin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word swap
#include "page.i65"
    .word twodup
#include "page.i65"
    .word expect
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word dup
#include "page.i65"
    .word span
#include "page.i65"
    .word store
#include "page.i65"
    .word numlin
#include "page.i65"
    .word store
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threecstore
#include "page.i65"
refillscr03
    .word exit

;--------------------------------------------------------------
#if 0
name=EOL?.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Leaves true when, while parsing a screen, the cursor is at the end of
a line.  This test triggers a refill event.

```
: eol?.scr   ( -- flag )
    #lin @  >in @  over min  =
    lin @ 25 < and ;
```
#endif
_eolqscr
#include "enter.i65"
    .word numlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _min
#include "page.i65"
    .word eq
#include "page.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.SCR
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from a screen.  Leaves
an address pointing to the beginning of a line and line size 40|80

```
: source.scr   ( -- addr size )
    begin
        eol?.scr
    while
        refill.scr
    repeat
    cas2buf  #lin @ ;
```
#endif
_sourcescr
#include "enter.i65"
sourcescr01
    .word _eolqscr
#include "page.i65"
    .word qbranch
    .byt <(sourcescr02-*+1)
#include "pad.i65"
    .word _refillscr
#include "page.i65"
    .word branch
    .byt <(sourcescr01-*+1)
#include "pad.i65"
sourcescr02
    .word cas2buf
#include "page.i65"
    .word numlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE
stack=( -- addr size )
tags=interpret,nosymbol
Returns the base address of the buffer that [[INTERPRET]] is
reading from, and the buffer size.
#endif
source
    jmp (uarea+uservsource-userarea)

;--------------------------------------------------------------
#if 0
name=SOURCE!
stack=( -- )
tags=vm,interpreter,~wut?,nosymbol
Sets the input source to TIB, BLK, or SCR

```
: source!   ( -- )
    blk @  ?dup
    if
        block  writable? @
        if
            3+ @lin !  lin on  #lin off  ['] source.scr
        else
            drop  ['] source.blk
        then
    else
        ['] source.tib
    then
    (source) ! ;
```
todo: something here so that LOAD can restore position on a screen #41
#endif
_sourcestore
#include "enter.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(sourcestore02-*+1)
#include "pad.i65"
    .word _block
#include "page.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(sourcestore01-*+1)
#include "pad.i65"
    .word threeplus
#include "page.i65"
    .word atlin
#include "page.i65"
    .word store
#include "page.i65"
    .word lin
#include "page.i65"
    .word on
#include "page.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word plit
    .word _sourcescr
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore01
    .word drop
#include "page.i65"
    .word plit
    .word _sourceblk
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore02
    .word zero
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word plit
    .word _sourcetib
#include "pad.i65"
sourcestore03
    .word psource
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( addr1 size1 char -- addr2 count2 )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to size1 bytes are skipped *WHILE* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.
#endif
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( addr count char -- addr count )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to count1 bytes are skipped *UNTIL* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.

#endif
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt ld | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name='STREAM
stack=( -- addr size )
tags=numword,~wut?,nosymbol
Calculates SOURCE offset by >IN with respect to buffer size.

```
 : 'stream   ( -- addr size )
       source   ( baseaddr size )
       dup >in @ min /string ;
```
#endif
_tickstream
#include "enter.i65"
    .word source
#include "page.i65"
    .word dup
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _min
#include "page.i65"
    .word _slashstring
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORD
stack=( char -- addr )
tags=interpreter
 Generates a counted string by non-destructively accepting
 characters from the input stream until the delimiting
 character char is encountered or the input stream is
 exhausted.  Leading delimiters are ignored.  The entire
 character string is stored in memory beginning at addr as a
 sequence of bytes.  The string is followed by a blank which
 is not included in the count.  The first byte of the string
 is the number of characters {0..255}.  If the string is
 longer than 255 characters, the count is unspecified.  If
 the input stream is already exhausted as WORD is called,
 then a zero length character string will result.

 If the delimiter is not found the value of >IN is the size
 of the input stream.  If the delimiter is found >IN is
 adjusted to indicate the offset to the character following
 the delimiter.  #TIB is unmodified.

 The counted string returned by WORD may reside in the "free"
 dictionary area at HERE or above.  Note that the text
 interpreter may also use this area.
See: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream

```
 fig high level
 : word   ( c -- addr )
       blk @  if  blk @ block  else  tib @  then
       >in @ + swap enclose here 34 blank >in +!
       over - >r r@ here c! + here 1+ r> cmove ;

 : word   ( c -- nfa )
      >r                              ; ( -- ) ( R; c )
  ( ) ( R; c )
      'stream
  ( addr size ) ( R; c )
      under
  ( addr addr size ) ( R; c )
      r@ skip
  ( addr addr2 count2 ) ( R; c )
      under
  ( addr addr2 addr2 count2 ) ( R; c )
      r> scan
  ( addr addr2 addr3 count )
      drop 2dup swap -
  ( addr addr2 addr3 size )
      >r
  ( addr addr2 addr3 ) ( R; size )
      rot - 1+
  ( addr2 addr3 size2 ) ( R; size )
      >in +!
  ( addr2 addr3 ) ( R; size )
      r> here
  ( addr2 addr3 size here )
      2dup c!
  ( addr2 addr3 size here )
      1+ swap cmove
  ( addr2 )
      here bl over
  ( addr2 here bl here )
      count + c! ;
  ( addr2 here )

: word   ( char -- addr )
    >r 'stream
    under  r@ skip
    under  r> scan
    drop
    2dup swap -  >r
    rot - 1+ >in +!
    r> here dup bl blank
    2dup c!  1+ swap cmove
    here ;

: word   ( char -- addr )
    >r 'stream
    under r@ skip  under r> scan  drop
    2dup swap -  >r
    rot - 1+ >in +!
    r> here dup bl blank
    2dup c!  1+ swap cmove
    here ;
```
#endif
_word
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word under
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word here
#include "page.i65"
    .word dup
#include "page.i65"
    .word bl
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _dolstore
#include "page.i65"
    .word here
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?CHAR
stack=( char -- addr )
tags=compiler,nosymbol
Scans ahead in the input stream until `char` is found.  Moves >IN beyond
that character.
#endif
_qchar
#include "enter.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=fig,forth-83,interpreter
The Forth interpreter loop

consistent eager-loaded approach
TIB source comes already loaded from QUIT
BLK source comes already loaded from BLOCK
SCR source will eager-load each line from the block buffer, already loaded by BLOCK

```
create jumptable  next ,   dlit ,  drop ,  droplit ,
                \ double  double,  single    single,
: interpret   ( -- )
    begin
        ?stack                  \ make sure things are okay
        bl word   ( addr )      \ eager-load for screens is done by SOURCE
        dup c@    ( addr len )  \ WORD returns zero-length when SOURCE is exhausted
    while
        find ?dup
        if        ( cfa findflag )
            \               find -1    find +1
            \             ____________________
            \ state -1   | compile     execute
            \ state 0    | execute     execute
            state @ <>  ?: execute ,xt
        else      ( here )
            number
            jumptable  dpl @ 0< 2*  state @ + 2* -
            @ execute
        then
    repeat
    drop ;
```
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(interpret04-*+1)
#include "pad.i65"
    .word _find
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "pad.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word plit
    .word interpret06           ; case table
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word twostar
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
interpret03
    .word branch
    .byt <(interpret01-*+1)
#include "pad.i65"
interpret04
    .word drop
#include "page.i65"
    .word exit

interpret06
    .word next
    .word _dlit
    .word drop
    .word _droplit

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=forth-83,fig
Accept a line of input from the user

```
: query   ( -- )
    tib 80 expect
    span @ #tib !
    >in off ;
```
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=forth-83,interpreter
This is the infinite outer interpreter loop:
      - resets the return stack (RP!)
      - outputs a carriage return (CR)
      - waits for a line of input (QUERY)
      - interprets that line

```
: quit
    [ rp!
    blk off  source!
    begin
        cr
        query interpret
        state @ 0=
        if
            ." OK"
        then
    again ;
```
#endif
_quit
#include "enter.i65"
    .word _lbracket             ; STATE OFF
#include "page.i65"
    .word rpstore
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore          ; set input source
#include "page.i65"
quit01                          ; BEGIN
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=fig,forth-79,forth-83,interpreter
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word _forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
_tosyms
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=nosymbol,ext,interpreter
32-bit wide Bloom filter for skipping REHASH passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=nosymbol,ext
Automatically move symbol table and vmbuf to someplace that leaves
~512 bytes for symbol table growth

The "lastpad" address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
_automem
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSFILTER
stack=( symbols -- )
tags=nosymbol
During the first half of rehash, it is unnecessary to make a
pass through the entire symbol table searching for words of a
given length, if none of that length exist.  This is a
bloom filter to eliminate those symbol table passes.

```
: passfilter   ( symbols -- )
    passbits 4 erase
    ( nfa )
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat drop ;

```
#endif
_passfilter
#include "enter.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
passfilter01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(passfilter02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(passfilter01-*+1)
#include "page.i65"
passfilter02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=forgotten16
tags=nosymbol

* inputs
** TOS (R1) NFA
* returns
** R11 CFA
** C true if in either dictionary
#endif
forgotten16
    jsr forgotten16a
    rol R14H
    rts

forgotten16a
    jsr tos2minus
    ldy #0
    lda (tos),y
    sta r11
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sta r11+1
    sbc uarea+usertdict-userarea+1
    bcs forgotten16c            ; word is in TDICT
    dey
forgotten16b
    lda uarea+usernewdp-userarea
    cmp (tos),y
    iny
    lda uarea+usernewdp-userarea+1
    sbc (tos),y
forgotten16c
    rts

;--------------------------------------------------------------
#if 0
name=intdictq16
tags=nosymbol
Checks if the current CFA is in the transient dictionary.  Sets N5
to the NFA

#endif
intdictq16
    jsr tos2minus
    ldy #0
    lda (tos),y
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sbc uarea+usertdict-userarea+1
    jsr tos2plus
    bcc intdictq16b
    lda tos
    sta n+10
    lda tos+1
    sta n+11                    ; N5
intdictq16b
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=wakeup16
tags=nosymbol
Wakes up an ancestor when a descendant is forgotten

* inputs
** ACC (R0) NFA of ancestor

* returns

#endif
wakeup16
    ldy #0
    lda (r0),y
    eor #bit5
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=descendant16
tags=nosymbol

* inputs
** TOS (R1) pointer to NFA
* returns
** N2 (R4) adds NFA to descendant list if it's active
#endif
descendant16
    ldy #2
    lda (tos),y
    and #bit5                   ; check smudge bit
    bne descendant16b
    dey
    sec
    lda n+4
    sbc #2
    sta n+4
    bcs descendant16a
    dec n+5
descendant16a
    lda tos,y
    sta (n+4),y
    dey
    bpl descendant16a
descendant16b
    rts

;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol
Copies a string from (n) to (tos) via the Y register.  Copies the 0th byte,
and moves N0 beyond the copied string

* inputs
** TOS (R1) source base address
** N0 (R2) target base address
** N1 (R3) string length
* returns
** Y = FF
#endif
symcopy16
    ldy n+2                     ; string length
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+2
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=?MIGRATE1
stack=( src targ vmbuf i -- targ+ )
tags=interpreter,nosymbol
#endif
qmigrate1
    brk
    .byt ld | TOS
    .byt st | N1                ; I
    .byt pull
    .byt st | N2                ; descendants
    .byt st | N8                ; vmbuf
    .byt pull
    .byt st | N7                ; targ0
    .byt st | N0                ; targ
    .byt pull
qmigrate1a
    .byt ext
    .word nfalen16
    .byt bz , <(qmigrate1d-*-2) ; are we done?
    .byt cpr | N1
    .byt bnz , <(qmigrate1c-*-2)    ; not what we are looking for?
; we have one of the right length
; is it in bounds?
    .byt ext
    .word forgotten16
    .byt bc , <(qmigrate1b-*-2)     ; not forgotten, migrate it
    .byt ext
    .word descendant16
    .byt br , <(qmigrate1c-*-2)     ; next

qmigrate1b
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+

qmigrate1c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1a-*-2)

qmigrate1d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate1e
    .byt ld | N2
    .byt cpr | N8                   ; any descendants?
    .byt bz , <(qmigrate1i-*-2)     ; nope
    .byt ld | N1
    .byt st | N3
    .byt sub | ACC
    .byt st | N1                    ; no ancestor
    .byt st | N4                    ; zero highest-so-far
    .byt st | N5                    ; zero tdict-maybe

    .byt ldd | N2                   ; get the address of the CFA, which is pretty worthless.
    .byt st | N0
    .byt inr | N0
    .byt inr | N0                   ; this is the descendant NFA
    .byt ld | N7                    ; rewind the list for this size
    .byt push
    .byt ldd | TOS                  ; get the CFA
    .byt st | N6
qmigrate1h
    .byt ext
    .word nfalen16
    .byt cpr | N3
    .byt bnz , <(qmigrate1g-*-2)    ; done with this size list, check out
    .byt ext
    .word strcomp16
    .byt bnc , <(qmigrate1f-*-2)    ; that's not it
    .byt ext
    .word intdictq16
    .byt bc , <(qmigrate1f-*-2)
    .byt ld | N6
    .byt cpr | N4
    .byt bnc , <(qmigrate1f-*-2)
    .byt st | N4                    ; highest-so-far
    .byt ld | TOS
    .byt st | N1                    ; keep a copy of NFA to go with the highest-so-far
qmigrate1f
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1h-*-2)

qmigrate1g
    .byt pull
    .byt ld | N1
    .byt bnz , <(qmigrate1j-*-2)
    .byt ld | N5
    .byt bz , <(qmigrate1e-*-2)
qmigrate1j
    .byt ext                        ; activate the highest-so-far or maybe-tdict word
    .word wakeup16
    .byt br , <(qmigrate1e-*-2)

qmigrate1i
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH1)
stack=( -- lastsym )
tags=interpreter,nosymbol
Phase 1 of REHASH

* Make a pass through SYMTAB + SYMNEW, create Bloom filter of sizes
* For each size 1..31
* - If it has members, merge SYMTAB + SYMNEW to PAD, ordered by length
* - tack on three zeroes at the end
* - Make a pass through PAD at that size
* - - If active and between CFA..HERE
* - - - Make a pass through PAD at current size
* - - - Reawaken youngest ancestor less than CFA (or in TDICT)
* set DP = cfa
* Return the last symbol at PAD for automatic memory allocation

```
: (rehash1)   ( -- )
    >syms 2+ pad   over passfilter
    32 1 do
        i >bit  passbits + cbit@
        if
            under  vmbuf @  i
 ( src src targ vmbuf i )
            ?migrate1
            dup 3 erase
 ( src targ+ )
        then
    loop nip ;                  \ automem wants the next address at PAD, targ+
```
#endif
_prehash1
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word _passfilter
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
prehash101
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(prehash102-*+1)
#include "pad.i65"
    .word under
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate1
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
prehash102
    .word ploop
    .byt <(prehash101-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=bloomhash16
tags=nosymbol
Sweet16 wrapper for Bloom hash

sets bloom filter bit

* inputs
** TOS (R1) NFA
** N1 (R3) length
* returns
** ACC (R0) address
#endif
bloomhash16
    ldy n+2                     ; NFA size in N1
    jsr bloomhash01
    pha
    lsr
    lsr
    lsr
    clc
    adc #<(bloom+3)
    sta r0
    tya
    adc #>(bloom+3)
    sta r0+1
    pla
    tay
    lda power2,y
    ldy #0
    ora (r0),y
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=?MIGRATE2
stack=( src targ -- targ+ )
tags=nosymbol,interpreter
#endif
qmigrate2
    brk
    .byt ld | TOS
    .byt st | N3                ; I
    .byt pull
    .byt st | N0                ; targ
    .byt pull                   ; src
    .byt ext
    .word tos2plus
qmigrate2a
    .byt ext
    .word nfalen16
    .byt st | N1
    .byt bz , <(qmigrate2d-*-2) ; are we done?

    .byt ext
    .word pearsonhash16
    .byt cpr | N3
    .byt bnz , <(qmigrate2c-*-2)    ; not what we are looking for?
; we have one of the right hashcode
    .byt ext
    .word tos2minus
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+
    .byt ext
    .word bloomhash16               ; set the bloom filter bit

qmigrate2c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate2a-*-2)

qmigrate2d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate2e
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH2)
stack=( -- )
tags=nosymbol,interpreter
Phase 2 of REHASH

* symtab 32 erase
* bloom 8 erase
* target = symtab+32
* For each hashcode 0..15
* - set symtab+i*2 = target
* - run all the symbols
* - - if hashcode matches, and it's alive, append it to target
* set symnew = symtail = target
* symnew 3 erase

```
: (rehash2)   ( -- )
    symtab @ 32 erase
    bloom 8 erase
    pad >syms
    16 0 do
        dup i 2* symtab @ + !
        under i  migrate2
    loop
( target )
    dup symnew ! dup symtail !
    3 erase ;
```
#endif
_prehash2
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word _erase
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
prehash201
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word under
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate2
#include "page.i65"
    .word ploop
    .byt <(prehash201-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
rebuild the symbol table at SYMTAB, moving VMBUF and SYMTAB
at halftime, if necessary.  The CFA is used in phase 1 to
rewaken sleeping ancestors.  Passing HERE will not wake up
anything.

```
: (rehash)   ( cfa -- )
    1- newdp !
    (rehash1)
    automem
    (rehash2)
    newdp @ 1+ dp ! ;
```
#endif
_prehash
#include "enter.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word _prehash1
#include "page.i65"
    .word _automem
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word 1024*3
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _prehash2
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word _info
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (rehash) ;   \ effectively a FORGET nil

```
#endif
_rehash
#include "enter.i65"
    .word here
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;
```
#endif
_forget
#include "enter.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Dump the entire vocabulary list.  This should eventually be
refined to display the words in the context vocabulary, the
parent of that, etc... up to the core vocabulary, and then
sorted by descending CFA.

```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
_words
#include "enter.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
_dots
#include "enter.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    1+
    ?do
        #out @  dup 0=
        if
            over  5 .r
        then
        30 >
        if
            cr
        then
```
#endif
_dump
#include "enter.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(dump04-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word cr
dump02
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump03-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
dump03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word pleave
    .byt <(dump04-*+1)
#include "pad.i65"
dump05
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump04
    .word drop
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit
    
;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
_nextblock
#include "enter.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit


; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter
#if 0
name=Error messages
tags=general,nosymbol
PETTIL system messages, output by [[FAIL]]
#endif
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08,msg09

msg01
    .byt msg02-*-1
    .asc "STACK UNDERFLOW"
msg02
    .byt msg03-*-1
    .asc "STACK OVERFLOW"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc " MISSING"
msg10
;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 8-byte Bloom filter used by the core dictionary.  The hash
is designed to tend to filter out tokens containing numbers
#endif
bloom
    jsr docreate
    .dsb 8,0      ; 64 bits, used by hash2 (bloom filter)
pearson             ; the bytes between pearson..forth
    .byt 243, 178, 217, 2, 54, 84, 189, 60 ; 310 words

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Set the core vocabulary as context
#endif
forth
    jsr dovocab
    .word 0                 ; no parent
    .byt 0                  ; root vocabulary

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Makes the context vocabulary current
#endif
_definitions
#include "enter.i65"
    .word context
#include "page.i65"
    .word fetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

symbol table

+---------------+
|    CFA[low]   |  +0      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  +2      Length field
[I]             |          Immediate bit
| [V]           |          Vocabulary bit
|   [S]         |          Smudge bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +3      Name field
|           ... |
|   name[len]   |
+~~~~~~~~~~~~~~~+
?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
+~~~~~~~~~~~~~~~+
#endif
pearsonhash
    stx storex
    jsr nfalen01            ; A=length; Y=0
    sta n                   ; seed hash1 with length
    tay                     ; count backwards
pearsonhash01
    lda (tos),y                     ;[5]
    and #(forth-pearson-1)          ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    dey
    bne pearsonhash01
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    ldx storex
    jmp put

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- mask addr )
tags=nosymbol
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Returns
a mask and address (starting at bloom) suitable for CBIT!
or CBIT@.
#endif
bloomhash
    stx storex
    jsr nfalen01                ; A=length; Y=0
    sty n
    tay
bloomhash01
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash02             ;[3] carry is set only for digits
    adc n                       ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta n                       ;[3]
    bne bloomhash02             ; never return 0 if any digits present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash02
    dey
    bne bloomhash01
    lda n
    sty tos+1
    pha
    and #7
    tax
    lda power2,x
    sta tos                     ; mask
    pla
    lsr
    lsr
    lsr
    clc
    adc #<bloom+3
    ldy #>bloom+3
    bcc bloomhash03
    iny
bloomhash03
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01
    jmp put

;--------------------------------------------------------------
#if 0
name=VOCABS$
stack=( -- addr )
tags=vocabulary,interpreter,nosymbol
String variable holds up to 9 vocabularies to search, not
including core.
#endif
vocabsd
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=VOCABS>
stack=( -- vocabid )
tags=nosymbol,interpreter,vocabulary,ext
Presents the next one-byte vocabulary id from VOCABS$, slides
the rest of the vocab string buffer to the left by one
#endif
vocabsfrom
    lda vocabsd+3
    pha
    ldy #(256-9)                ; an INY loop was tighter.  I checked the pointers
vocabsfrom01
    lda vocabsd-(256-13),y      ; slide everything down one.  +3 for jsr docreate
    sta vocabsd-(256-12),y
    iny
    bne vocabsfrom01
    pla
    jmp pushya

;--------------------------------------------------------------
#if 0
name=VOCID
stack=( vocabulary -- vocabid )
tags=nosymbol
Retrieves the vocabulary identifier from the given vocabulary
#endif
_vocid
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(VOCABLIST)
stack=( -- )
tags=nosymbol
Sets the VOCABS$ string to the chain of vocabularies between
context and core

```
: (vocablist)
    vocabs$ context
    begin
        dup @ -rot
        vocid tuck c!+ -rot
        0=
    until 2drop ;
```
#endif
_pvocablist
#include "enter.i65"
    .word vocabsd
#include "page.i65"
    .word context
#include "page.i65"
pvocablist01
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word _vocid
#include "page.i65"
    .word tuck
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvocablist01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VOC+
stack=( vocabid nfa -- )
tags=nosymbol
Append the vocabulary id to the string at NFA, and set the
vocabulary member bit on the name field
#endif
vocplus
    jsr nfalen01
    tay
    iny
    lda stackl,x
    inx                         ; poor man's pop -- voc+ discards two arguments
    sta (tos),y                 ; concatenate vocab ident
    tya
    ora #$40                    ; turn on vocab bit
    ldy #0
    beq vocminus01              ; bra

;--------------------------------------------------------------
#if 0
name=VOC-
stack=( nfa -- )
tags=nosymbol
Strip the vocabulary byte from the string and clear the vocabulary
member bit
#endif
vocminus
    jsr nfalen01
    sec
    sbc #1
vocminus01
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
#if 0
name=((FIND))
stack=( name fflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive
#endif
ppfind
    ldy #2
    jsr locals                  ; TOS = nfa; N0 = name; N1 = find flag (0=core; true=new)
    sty n+8                     ; N4 = result flag
    sty n+9
    lda (n),y
    and #$1f
    ;sty n+7
    sta n+6                     ; N3 = length we seek
ppfind02
    jsr nfalen01
    beq ppfind07                ; end of list? return ( NAME 0 )
    bcs ppfind03                ; smudged? not findable. next!
    cmp n+6                     ; compare lengths
    beq ppfind04                ; same length, compare strings too
    bcc ppfind03                ; shorter length?  next!
    bit n+2                     ; check unsorted mode (N) vs. core mode (P)
    bmi ppfind03                ; look at all names on this list
    bpl ppfind07                ; core mode, and we've gone past it
ppfind03
    jsr nfaplus01
    bne ppfind02                ; bra
ppfind04
    jsr strcomp
    bcc ppfind03                ; non-match? next!

    ; winner!
    inc r9                      ; assume immediate (returns +1)
    ;ldy #0                     ; thank you, strcomp
    lda (tos),y                 ; length and flags
    bmi ppfind06                ; immediate?
    dey
    sty r9
    sty r9+1                    ; set R9 = -1
ppfind06
    brk
    .byt ld | TOS
    .byt push                   ; push the NFA
    .byt popd | TOS             ; get the CFA
    .byt br , <(ppfind08-*-2)
ppfind07
    ; loser...
    brk
    .byt ld | N0                ; get the original name
    .byt st | TOS
    .byt push                   ; push the name address twice
ppfind08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | R9                ; status flag
    .byt push
    .byt nxt
#endif

;--------------------------------------------------------------
#if 0
name=(FIND)
stack=( name -- nfa xfa flag )
tags=nosymbol

```
: (find)   ( name -- nfa cfa flag | name name 0 )
    true symnew @ 2+ ((find))
    ?dup 0=
    if
 ( name name )
        drop false over pearsonhash 2* symtab @ + @ 2+ ((find))
    then ;
 ( nfa xfa flag | name name 0 )
```
#endif
_pfind
#include "enter.i65"
    .word true                  ; search unsorted list
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word ppfind
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pfind01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word false                 ; lists are sorted by size
#include "page.i65"
    .word over
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word ppfind
#include "page.i65"
pfind01
    .word exit

;--------------------------------------------------------------
#if 0
name=(VOCFIND)
stack=( vocid name -- nfa xfa flag )
tags=nosymbol
Trial search within a vocabulary, used by FIND

```
: (vocfind   ( vocid name -- )
    dup>r voc+ r@ (find) r> voc- ;

```
#endif
_pvocfind
#include "enter.i65"
    .word duptor
#include "page.i65"
    .word vocplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _pfind
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word vocminus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FIND
stack=( addr1 -- addr2 flag )
tags=interpreter,forth-83
addr1 is the address of a counted string, which is the word to look
up in the dictionary.

if not found, addr2 is the original addr1, and flag = 0
if found, addr2 is the code field address of the word,
and flag = -1 for normal words, +1 for immediate words

! outer interpreter

name is the address of a counted string we are searching for.
fflag is the find mode.  False means NFAs are sorted, True means check them all
nfa is the first nfa in the hash list

vocid identifies which vocabulary to search.  Vocabularies may be
nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
NFAs (with the vocid appended to the name before hashing) on the stack.
The final vocabulary searched will be core, and (FIND) will exit afterward.

  0 = corelist

  1 = assembler

  2+ = vocabularies added by the user

(FIND) first searches the unsorted names beginning at SYMTAIL, and keeps
going without regard to name length.  If it fails to find the word there,
it tries the hash list, which is expected to be sorted in ascending size
order.  Vocabularies are searched first, beginning with CONTEXT and chaining
up until core (0) is reached.  The vocid is appended to the word when
searching that vocabulary.  Only one symbol within a vocabulary may be
active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
may exist within more than one vocabulary.

For example, at cold start the user types in,

```
VOCABULARY LATIN          \ creates a new user vocabulary with vocid = 3
LATIN DEFINITIONS         \ sets CURRENT to LATIN, definitions added there
: EPLURIBUSUNUM ;         \ adds a new word to the LATIN vocabulary
VOCABULARY PIGLATIN       \ creates a new user vocabulary with vocid = 4
                          \ PIGLATIN is a member of the LATIN vocabulary
PIGLATIN DEFINITIONS      \ sets CURRENT to PIGLATIN, new definitions there
: IXNAY ;                 \ adds a new word to the PIGLATIN vocabulary
FORTH                     \ set CONTEXT to core
IXNAY  not found          \ IXNAY is a member of PIGLATIN, out of context
PIGLATIN  not found       \ PIGLATIN is a member of LATIN vocabulary
LATIN PIGLATIN            \ set context to LATIN; set context to PIGLATIN
IXNAY  ok                 \ search for "IXNAY" + $04, found in PIGLATIN(4)
EPLURIBUSUNUM  ok         \ search for "EPLURIBUSUNUM" + $04, not found.
                          \ search for "EPLURIBUSUNUM" + $03, in LATIN(3)
DEPTH .  0 ok             \ search for "DEPTH" + $04, not found in PIGLATIN(4)
                          \ search for "DEPTH" + $03, not found in LATIN(3)
                          \ search for "DEPTH", found in core(0)

 returns
       ( cfa -1 ) if found normal word
       ( cfa 1 ) if found immediate word
       ( name 0 ) if not in dictionary

: find   ( addr1 -- addr2 flag )
    0 over bloomhash cbit@
 ( addr1 0 bloomflag )
    if
 ( addr1 )
        0 rot >r  (vocablist)
 ( 0 0 ) ( R; name )
        begin
            2drop vocabs> r@ over
 ( vocid name vocid ) ( R; name )
            if
 ( vocid name ) ( R; name )
                under (vocfind)
 ( vocid ( nfa cfa flag | name name 0 ) ) ( R; name )
            else
 ( 0 name ) ( R; name )
                (find)
 ( 0 ( nfa cfa flag | name name 0 ) ) ( R; name )
            then
 ( vocid nfa xfa flag ) ( R; name )
            rot drop
 ( vocid xfa flag ) ( R; name )
            rot 0= over or
        until
        r> drop
 ( xfa flag ) ( R; name )
    else
        false
    then
  ( xfa flag ) ( R; name )
      ;

```
#endif
_find
#include "enter.i65"
    .word zero
#include "page.i65"
    .word over
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(find04-*+1)
#include "page.i65"
    .word zero
#include "page.i65"
    .word rot
#include "page.i65"
    .word tor
#include "page.i65"
    .word _pvocablist
#include "page.i65"
find01
    .word twodrop
#include "page.i65"
    .word vocabsfrom
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word under
#include "page.i65"
    .word _pvocfind
#include "page.i65"
    .word branch
    .byt <(find03-*+1)
#include "pad.i65"
find02
    .word _pfind
#include "page.i65"
find03
    .word rot
#include "page.i65"
    .word drop
#include "page.i65"
    .word rot
#include "page.i65"
    .word zeq
#include "page.i65"
    .word over
#include "page.i65"
    .word orx
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
find04
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words
and returns either

```
: exists?
   bl word dup c@ if find else 0 then ;
```
#endif
_existsq
#include "enter.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(existsq01-*+1)
#include "pad.i65"
    .word _find
#include "page.i65"
    .word branch
    .byt <(existsq02-*+1)
#include "pad.i65"
existsq01
    .word zero
#include "page.i65"
existsq02
    .word exit

;--------------------------------------------------------------
#if 0
name=?FAIL
stack=( flag err# -- )
tags=nosymbol
Aborts with the error message if flag is true

```
: ?fail   ( flag err# -- )
    swap if fail else drop then ;
```
#endif
_qfail
#include "enter.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(qfail01-*+1)
#include "pad.i65"
    .word fail
#include "page.i65"
    .word branch
    .byt <(qfind02-*+1)
#include "pad.i65"
qfail01
    .word drop
#include "page.i65"
qfind02
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word three
#include "page.i65"
    .word _qfail
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=forth-83,fig
Accept a line of input from the user

```
: query   ( -- )
    tib 80 expect
    span @ #tib !
    blk off
    >in off ;
```
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT?
stack=( -- flag )
tags=interpreter,~wut?
Leaves a flag indicating if the input buffer is exhausted

```
: quit?   ( -- flag )
    blk @ writable? @ and
    if
        true when screen line > 24
    else
        >in @ #tib @ >
    then ;
```
#endif
_quitq
#include "enter.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=fig,forth-83,interpreter
The Forth interpreter loop

```
: interpret
    begin
        ?stack exists? ?dup
        if
 ( cfa findflag )
            state @ <>
            ( state -1 or 0; find -1 or +1 )
            ( only compile if state -1 and find -1, otherwise execute )
            ?: execute ,xt
        else
 ( here )
            number
            [ jumptable ] literal
            dpl @ 0< 2*  state @ + 2* - 
            @ execute
        then
        quit?                   ( end of input stream? )
    until ;

    create jumptable next , dlit , drop , droplit ,

```
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack            ; ( )
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(interpret03-*+1)
#include "pad.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _commaxt
#include "pad.i65"
    .word branch
    .byt <(interpret05-*+1)
#include "pad.i65"
interpret03
    .word _number
#include "page.i65"
    .word plit
    .word interpret06           ; case table
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word twostar
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
interpret05
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word exit
interpret06
    .word next
    .word _dlit
    .word drop
    .word _droplit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=forth-83,interpreter
This is the infinite outer interpreter loop:
      - resets the return stack (RP!)
      - outputs a carriage return (CR)
      - waits for a line of input (QUERY)
      - interprets that line
#endif
_quit
#include "enter.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _lbracket         ; STATE OFF
#include "page.i65"
    .word rpstore
#include "page.i65"
quit01                                  ; BEGIN
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=fig,forth-79,forth-83,interpreter
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
_tosyms
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SYM+
stack=( nfa target -- target+ )
tags=interpreter,ext
add a symbol to the symbol table, and turn on its bloomfilter bit
leave the address following the symbol on the stack

```
: sym+
    ( nfa target )
    over bloomhash cbit!
    ( nfa target )
    over nfalen 1+
    ( nfa target len+1 )
    2dup + >r
    ( nfa target len+1 ) ( R; target+ )
    cmove r> ;
    ( target+ )

```
#endif
_symplus
#include "enter.i65"
    .word over
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next
nfaplus01               ; this should *never* return Z=true
    jsr nfalen01
    clc
    adc #3
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=SYMBYSIZE
stack=( searchlen nfa -- flag )
tags=interpreter,ext,nosymbol
returns true iff

searchleng matches the current length? (I)

and (CFA < DP or CFA > TDICT?)

```
: symbysize   ( searchlen nfa -- flag )
    nfalen = ;

```
#endif
_symbysize
#include "enter.i65"
    .word nfalen
#include "page.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SYMBYHASH
stack=( hash nfa -- flag )
tags=interpreter,ext,nosymbol
returns true iff

calculate its pearson hash

and that matches the current hash?

```
: symbyhash   ( hash nfa -- flag )
    dup pearsonhash rot = dup
    if
        swap name>
        dup b/buf newdp @ between?
        swap tdict @ memsiz @ between?  or
    then nip ;

```
#endif
_symbyhash
#include "enter.i65"
    .word dup
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word rot
#include "page.i65"
    .word eq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(symbyhash01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf       ; 1024 = $0400 start of BASIC
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word swap
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word memsiz
#include "page.i65"
    .word fetch
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word orx
#include "page.i65"
symbyhash01
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SYMSORT
stack=( 'compare searchfor src target -- target+ )
tags=interpreter,ext,nosymbol
Make a pass through the symbol table at PAD, copying eligible
symbols to target

```
: symsort   ( 'compare searchfor src target )
    >r 2+
    ( 'compare searchfor nfa ) ( R; target )
    begin
        \ not done yet?
        dup nfalen
        ( 'compare searchfor nfa currlen ) ( R; target )
    while
        ( 'compare searchfor nfa ) ( R; target )
        3dup rot execute
        ( 'compare searchfor nfa flag ) ( R; target )
        if
            \ copy the CFA
            ( 'compare searchfor nfa ) ( R; target )
            r> over name> !+
            \ copy the symbol
            ( 'compare searchfor nfa target+2 )
            under sym+ >r
            ( 'compare searchfor nfa ) ( R; target+ )
        then
        \ advance source pointer
        nfa+
        ( 'compare searchfor nfa+ ) ( R; target+ )
    repeat
    ( 'compare searchfor nfa+ ) ( R; target+ )
    3drop r> ;   ( target+ )

```
#endif
_symsort
#include "enter.i65"
    .word tor
#include "page.i65"
    .word twoplus
#include "page.i65"
symsort01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qbranch
    .byt <(symsort03-*+1)
#include "pad.i65"
    .word threedup
#include "page.i65"
    .word rot
#include "page.i65"
    .word execute
#include "page.i65"
    .word qbranch
    .byt <(symsort02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word under
#include "page.i65"
    .word _symplus
#include "page.i65"
    .word tor
#include "page.i65"
symsort02
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(symsort01-*+1)
#include "pad.i65"
symsort03
    .word threedrop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=nosymbol,ext,interpreter
32-bit wide Bloom filter for skipping REHASH passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=>BLOOM
stack=( n -- mask offset )
tags=interpreter,ext
transform an integer into a bitmask and offset, suitable for
addressing a bloom filter

mask = 2^(n%8)

offset = n/8

```
: >bloom   ( n -- mask offset )
        dup 7 and power2 + c@
        swap 2/ 2/ 2/ ;
```
#endif
tobloom
    dex
    lda tos
    and #7
    tay
    lda power2,y
    sta stackl,x
    lda #0
    sta stackh,x
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos             ; /8
    lda tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=nosymbol,ext
Automatically move symbol table and vmbuf to someplace that leaves
~512 bytes for symbol table growth

The "lastpad" address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
_automem
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=ANCESTOR
stack=( -- addr )
tags=nosymbol,interpreter,ext
variable that holds the youngest ancestor for REHASH
#endif
ancestor
    jsr docreate
    .word 0

;--------------------------------------------------------------
#if 0
name=SAMEASME?
stack=( descendant candidate -- flag )
tags=nosymbol,interpreter,ext
#endif
sameasmeq
    ldy #1
    jsr locals          ; N0 = descendant; TOS = candidate
    jsr nfalen01
    sta n+6
    jsr strcomp
    ldy #0
    bcc sameasmeq01
    dey
sameasmeq01
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=?CANDIDATE
stack=( descendant candidate -- )
tags=nosymbol,interpreter,ext

```
: ?candidate   ( descendant candidate -- )
  ( descendant candidate )
    \ candidate is inactive?
    dup c@ $20 and
  ( descendant candidate flag )
    if
  ( descendant candidate )
      \ candidate remains in dictionary?
      \ and is more recent than prior candidates?
        dup name>  ancestor @  dup
        if
            nip name>
        then
        newdp @  between?
  ( descendant candidate flag )
        if
  ( descendant candidate )
            2dup sameasme?
  ( descendant candidate flag )
            if
                dup ancestor !
                32 third cbit!
            then
        then
    then
    2drop ;
```
#endif
_qcandidate
#include "enter.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(qcandidate01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word ancestor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(qcandidate02-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word namefrom
#include "page.i65"
qcandidate02
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word qbranch
    .byt <(qcandidate01-*+1)
#include "pad.i65"
    .word twodup
#include "page.i65"
    .word sameasmeq
#include "page.i65"
    .word qbranch
    .byt <(qcandidate01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word ancestor
#include "page.i65"
    .word store
#include "page.i65"
    .word bl
#include "page.i65"
    .word third
#include "page.i65"
    .word cbitstore
#include "page.i65"
qcandidate01
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?ANCESTOR
stack=( descendant nfa -- )
tags=interpreter,nosymbol
Searches for a qualifying ancestor and exchanges the smudge bit

```
: ?ancestor   ( descendant startnfa -- )
  ( descendant startnfa )
    ancestor off
  ( descendant startnfa )
    begin
  ( descendant nfa )
        dup nfalen
  ( descendant nfa length )
    while
  ( descendant nfa )
        2dup ?candidate
        nfa+
    repeat
    ancestor @ ?dup
    if
        smudge
    then
    2drop ;

```
#endif
_qancestor
#include "enter.i65"
    .word ancestor
#include "page.i65"
    .word off
#include "page.i65"
qancestor01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qbranch
    .byt <(qancestor02-*+1)
#include "pad.i65"
    .word twodup
#include "page.i65"
    .word _qcandidate
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(qancestor01-*+1)
#include "pad.i65"
qancestor02
    .word ancestor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qancestor03-*+1)
#include "pad.i65"
    .word smudge
#include "page.i65"
qancestor03
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REAWAKEN
stack=( nfa -- )
tags=nosymbol
Scans the symbol table for ancestors of forgotten descendants to reactivate
```
 ( start )
 2+ dup>r
 ( startnfa ) ( R; startnfa )
 begin
     dup
     nfalen
 while
 ( nfa )
     dup c@ $20 and 0=
     over name>  newdp @ dp @ between? and
     if
         dup r@ ?ancestor
     then
     nfa+
    repeat
    r> 2drop ;

```
#endif
_reawaken
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word duptor
#include "page.i65"
reawaken01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qbranch
    .byt <(reawaken02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word andx
#include "page.i65"
    .word zeq
#include "page.i65"
    .word over
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(reawaken03-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _qancestor
#include "page.i65"
reawaken03
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(reawaken01-*+1)
#include "pad.i65"
reawaken02
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSFILTER
stack=( symbols -- )
tags=nosymbol
During the first half of rehash, it is unnecessary to make a
pass through the entire symbol table searching for words of a
given length, if none of that length exist.  This is a
bloom filter to eliminate those symbol table passes.

```
: passfilter   ( symbols -- )
    passbits 4 erase
    2+
    ( nfa )
    begin
        dup nfalen ?dup
    while
        >bloom passbits + cbit!
        nfa+
    repeat drop ;

```
#endif
_passfilter
#include "enter.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word twoplus
#include "page.i65"
passfilter01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(passfilter02-*+1)
#include "pad.i65"
    .word tobloom
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(passfilter01-*+1)
#include "page.i65"
passfilter02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH1)
stack=( -- lastsym )
tags=interpreter,nosymbol,ext
Phase 1 of REHASH

* Make a pass through SYMTAB + SYMNEW, create Bloom filter of sizes
* For each size 1..31
* - If it has members, merge SYMTAB + SYMNEW to PAD, ordered by length
* - tack on three zeroes at the end
* - Make a pass through PAD at that size
* - - If active and between CFA..HERE
* - - - Make a pass through PAD at current size
* - - - Reawaken youngest ancestor less than CFA (or in TDICT)
* set DP = cfa
* Return the last symbol at PAD for automatic memory allocation

```
: (rehash1)   ( -- )
( )
    >syms pad   over passfilter
( symbols pad )
    32 1 do
( src targ )
        i >bloom
( src targ mask offset )
        passbits + cbit@
( src targ flag )
        if
            dup >r
( src targ ) ( R; src )
            [ 'symbysize ] literal i
( src targ 'compare i ) ( R; src )
            2over symsort nip
( src targ+ ) ( R; src )
            over 3 erase r> reawaken
        then
( src targ+ )
    loop  nip ;

```
#endif
_prehash1
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word _passfilter
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
prehash101
    .word i
#include "page.i65"
    .word tobloom
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(prehash102-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word plit
    .word _symbysize
#include "pad.i65"
    .word i
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _symsort
#include "page.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _reawaken
#include "page.i65"
prehash102
    .word ploop
    .byt <(prehash101-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH2)
stack=( -- )
tags=nosymbol,interpreter,ext
Phase 2 of REHASH

* symtab 32 erase
* bloom 8 erase
* target = symtab+32
* For each hashcode 0..15
* - set symtab+i*2 = target
* - run all the symbols
* - - if hashcode matches, and it's alive, append it to target
* set symnew = symtail = target
* symnew 3 erase

```
: (rehash2)   ( -- )
    symtab @ 32 erase
    bloom 8 erase
    pad >syms
    16 0 do
        dup i 2* symtab @ + !
        [ 'symbyhash ] literal i
        2over symsort nip
    loop
( target )
    dup symnew ! dup symtail !
    3 erase ;

```
#endif
_prehash2
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word _erase
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
prehash201
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word plit
    .word _symbyhash
#include "pad.i65"
    .word i
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _symsort
#include "page.i65"
    .word nip
#include "page.i65"
    .word ploop
    .byt <(prehash201-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
rebuild the symbol table at SYMTAB, moving VMBUF and SYMTAB
at halftime, if necessary.  The CFA is used in phase 1 to
rewaken sleeping ancestors.  Passing HERE will not wake up
anything.

```
: (rehash)   ( cfa -- )
    newdp !
    (rehash1)
    automem
    (rehash2)
    newdp @ dp ! ;

```
#endif
_prehash
#include "enter.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word _prehash1
#include "page.i65"
    .word _automem
#include "page.i65"
    .word _prehash2
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (rehash) ;   \ effectively a FORGET nil

```
#endif
_rehash
#include "enter.i65"
    .word here
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( -- )
    '
 ( cfa )
    dup fence @ u<
 ( cfa flag )
    if
        7 fail
    then
 ( cfa )
    (rehash) ;

```
#endif
_forget
#include "enter.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(forget03-*+1)
#include "pad.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word fail                  ; CAN'T FORGET BELOW FENCE
#include "page.i65"
forget03
    .word _prehash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Dump the entire vocabulary list.  This should eventually be
refined to display the words in the context vocabulary, the
parent of that, etc... up to the core vocabulary, and then
sorted by descending CFA.

```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

```
#endif
_words
#include "enter.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word bl
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word minus
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------

; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=~ Error messages
tags=general,nosymbol
PETTIL system messages, output by [[FAIL]]
#endif
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08
    .word msg09,msg10,msg11

msg01
    .byt msg02-*-1
    .asc "STACK UNDERFLOW"
msg02
    .byt msg03-*-1
    .asc "STACK OVERFLOW"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc " MISSING"
msg10
    .byt msg11-*-1
    .byt "CORRUPT VIRTUAL MEMORY"
msg11
    .byt msg12-*-1
    .byt "BAD ADDRESSING MODE"
msg12

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word dup c@ ?: find 0 ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word pquerycolon
    .word _find
    .word zero
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word zeq
    .word qerror
    .byt 3                      ; NOT FOUND
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.TIB
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address

```
: source.tib   ( -- addr size )
    tib #tib @ ;
```
#endif
#include "align.i65"
_sourcetib
    jsr enter
#include "page.i65"
    .word tib
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.BLK
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address and size

```
: source.blk   ( -- addr size )
    block b/buf ;
```
#endif
#include "align.i65"
_sourceblk
    jsr enter
#include "page.i65"
    .word _block
#include "page.i65"
    .word bperbuf
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Loads the next logical line from the virtual screen buffer into another
80-character buffer, returning a flag indicating if there was a next line

```
: refill.scr   ( -- )
    #lin off
    >in off
    lin dup 1+! @
    25 <
    if
        lin @                   ( lin )
        dup >bit blkbuf + cbit@ ( lin flag )
        swap 24 = or            ( flag )
        if
            forty
        else
            lin 1+! eighty
        then                    ( 40|80 )
        dup    LNMX c!
        3      DFLTN c!
        @lin @ PNT dup dup>r 3c@ >r >r !
        0      PNTR c!          ( 40|80 )
        cas2buf over 2dup expect -trailing
        r> r> r> 3c!            ( restore screen cursor )
        @lin +!
        span @  #lin !
    then ;
```
#endif
#include "align.i65"
_refillscr
    jsr enter
#include "page.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word lin
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(refillscr03-*+1)
#include "pad.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word tobit
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt 24
#include "pad.i65"
    .word eq
#include "page.i65"
    .word orx
#include "page.i65"
    .word qbranch
    .byt <(refillscr01-*+1)
#include "pad.i65"
    .word forty
#include "page.i65"
    .word branch
    .byt <(refillscr02-*+1)
#include "pad.i65"
refillscr01
    .word lin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word eighty
#include "page.i65"
refillscr02
    .word dup
#include "page.i65"
    .word clit
    .byt LNMX
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word three
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word atlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt PNT
#include "pad.i65"
    .word dup
#include "page.i65"
    .word duptor
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
    .word store
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt PNTR
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word dup
#include "page.i65"
    .word atlin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word swap
#include "page.i65"
    .word twodup
#include "page.i65"
    .word expect
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word dup
#include "page.i65"
    .word span
#include "page.i65"
    .word store
#include "page.i65"
    .word numlin
#include "page.i65"
    .word store
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threecstore
refillscr03
    .word exit

;--------------------------------------------------------------
#if 0
name=EOL?.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Leaves true when, while parsing a screen, the cursor is at the end of
a line.  This test triggers a refill event.

```
: eol?.scr   ( -- flag )
    #lin @  >in @  over min  =
    lin @ 25 < and ;
```
#endif
#include "align.i65"
_eolqscr
    jsr enter
#include "page.i65"
    .word numlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _min
#include "page.i65"
    .word eq
#include "page.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word andx
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.SCR
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from a screen.  Leaves
an address pointing to the beginning of a line and line size 40|80

```
: source.scr   ( -- addr size )
    begin
        eol?.scr
    while
        refill.scr
    repeat
    cas2buf  #lin @ ;
```
#endif
#include "align.i65"
_sourcescr
    jsr enter
#include "page.i65"
sourcescr01
    .word _eolqscr
#include "page.i65"
    .word qbranch
    .byt <(sourcescr02-*+1)
#include "pad.i65"
    .word _refillscr
#include "page.i65"
    .word branch
    .byt <(sourcescr01-*+1)
#include "pad.i65"
sourcescr02
    .word cas2buf
#include "page.i65"
    .word numlin
#include "page.i65"
    .word fetch
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE
stack=( -- addr size )
tags=interpret,nosymbol
Returns the base address of the buffer that [[INTERPRET]] is
reading from, and the buffer size.
#endif
source
    jmp (uarea+uservsource-userarea)

;--------------------------------------------------------------
#if 0
name=SOURCE!
stack=( -- )
tags=vm,interpreter,nosymbol
Sets the input source to TIB, BLK, or SCR

```
: source!   ( -- )
    blk @  ?dup
    if
        block  isscr?
        if
            3+ @lin !  lin on  #lin off  ['] source.scr
        else
            drop  ['] source.blk
        then
    else
        ['] source.tib
    then
    (source) ! ;
```
~ something here so that LOAD can restore position on a screen #41
#endif
#include "align.i65"
_sourcestore
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(sourcestore02-*+1)
#include "pad.i65"
    .word _block
#include "page.i65"
    .word isscrq
#include "page.i65"
    .word qbranch
    .byt <(sourcestore01-*+1)
#include "pad.i65"
    .word threeplus
#include "page.i65"
    .word atlin
#include "page.i65"
    .word store
#include "page.i65"
    .word lin
#include "page.i65"
    .word on
#include "page.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word plit
    .word _sourcescr
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore01
    .word drop
#include "page.i65"
    .word plit
    .word _sourceblk
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore02
    .word zero
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word plit
    .word _sourcetib
#include "pad.i65"
sourcestore03
    .word psource
#include "page.i65"
    .word store
    .word exit

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( addr1 size1 char -- addr2 count2 )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to size1 bytes are skipped *WHILE* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.
#endif
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( addr count char -- addr count )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to count1 bytes are skipped *UNTIL* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.

#endif
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt ld | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name='STREAM
stack=( -- addr size )
tags=numword,nosymbol
Calculates SOURCE offset by >IN with respect to buffer size.

```
 : 'stream   ( -- addr size )
       source   ( baseaddr size )
       dup >in @ min /string ;
```
#endif
#include "align.i65"
_tickstream
    jsr enter
#include "page.i65"
    .word source
#include "page.i65"
    .word dup
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _min
#include "page.i65"
    .word _slashstring
    .word exit

;--------------------------------------------------------------
#if 0
name=WORD
stack=( char -- addr )
tags=interpreter
 Generates a counted string by non-destructively accepting
 characters from the input stream until the delimiting
 character char is encountered or the input stream is
 exhausted.  Leading delimiters are ignored.  The entire
 character string is stored in memory beginning at addr as a
 sequence of bytes.  The string is followed by a blank which
 is not included in the count.  The first byte of the string
 is the number of characters {0..255}.  If the string is
 longer than 255 characters, the count is unspecified.  If
 the input stream is already exhausted as WORD is called,
 then a zero length character string will result.

 If the delimiter is not found the value of >IN is the size
 of the input stream.  If the delimiter is found >IN is
 adjusted to indicate the offset to the character following
 the delimiter.  #TIB is unmodified.

 The counted string returned by WORD may reside in the "free"
 dictionary area at HERE or above.  Note that the text
 interpreter may also use this area.
See: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream

```
: word   ( char -- addr )
    >r 'stream
    under r@ skip  under r> scan  drop
    2dup swap -  >r
    rot - 1+ >in +!
    r> here dup bl blank $!
    here ;
```
#endif
#include "align.i65"
_word
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word under
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word here
#include "page.i65"
    .word dup
#include "page.i65"
    .word bl
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _dolstore
#include "page.i65"
    .word here
    .word exit

;--------------------------------------------------------------
#if 0
name=?CHAR
stack=( char -- addr )
tags=compiler,nosymbol
Scans ahead in the input stream until `char` is found.  Moves >IN beyond
that character.
#endif
#include "align.i65"
_qchar
    jsr enter
#include "page.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
    .word exit

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=fig,forth-83,interpreter
The Forth interpreter loop

consistent eager-loaded approach
TIB source comes already loaded from QUIT
BLK source comes already loaded from BLOCK
SCR source will eager-load each line from the block buffer, already loaded by BLOCK

```
create jumptable  next ,   dlit ,  drop ,  droplit ,
                \ double  double,  single    single,
: interpret   ( -- )
    begin
        ?stack                  \ make sure things are okay
        bl word   ( addr )      \ eager-load for screens is done by SOURCE
        dup c@    ( addr len )  \ WORD returns zero-length when SOURCE is exhausted
    while
        find ?dup
        if        ( cfa findflag )
            \               find -1    find +1
            \             ____________________
            \ state -1   | compile     execute
            \ state 0    | execute     execute
            state @ <>  ?: execute ,xt
        else      ( here )
            number
            jumptable  dpl @ 0< 2*  state @ + 2* -
            @ execute
        then
    repeat
    drop ;
```
#endif
#include "align.i65"
_interpret
    jsr enter
#include "page.i65"
interpret01
    .word qstack
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(interpret04-*+1)
#include "pad.i65"
    .word _find
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "pad.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word plit
    .word interpret06           ; case table
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word twostar
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
interpret03
    .word branch
    .byt <(interpret01-*+1)
#include "pad.i65"
interpret04
    .word drop
    .word exit

interpret06
    .word next
    .word _dlit
    .word drop
    .word _droplit

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=forth-83,fig
Accept a line of input from the user

```
: query   ( -- )
    tib 80 expect
    span @ #tib !
    >in off ;
```
#endif
#include "align.i65"
_query
    jsr enter
#include "page.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=forth-83,interpreter
This is the infinite outer interpreter loop:
      - resets the return stack (RP!)
      - outputs a carriage return (CR)
      - waits for a line of input (QUERY)
      - interprets that line

```
: quit
    [ rp!
    blk off  source!
    begin
        cr
        query interpret
        state @ 0=
        if
            ." OK"
        then
    again ;
```
#endif
#include "align.i65"
_quit
    jsr enter
#include "page.i65"
    .word _lbracket             ; STATE OFF
#include "page.i65"
    .word rpstore
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore          ; set input source
#include "page.i65"
quit01                          ; BEGIN
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
;#include "pad.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=fig,forth-79,forth-83,interpreter
#endif
#include "align.i65"
_abort
    jsr enter
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _quit


; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=Error messages
tags=general,nosymbol
PETTIL system messages, output by [[FAIL]]
#endif
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08,msg09,msg10

msg01
    .byt msg02-*-1
    .asc "STACK UNDERFLOW"
msg02
    .byt msg03-*-1
    .asc "STACK OVERFLOW"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc " MISSING"
msg10
    ; next message. pad here for testing page-alignment
    .byt "CORRUPT VIRTUAL MEMORY"
msg11

;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    ; these numbers were generated by the pearson.rb Ruby script which
    ; generates random hashes and selects the set that best balances
    ; a list of Forth words
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value

usage: `PETSCII "X" .` responds `88  OK`

~ doesn't work for quote character ($22)
~ uses `WORD` so parsing rules are lax.
word following close-quote is parsed, e.g.
`PETSCII "X"." FOO" .` result is `FOO88  OK`
`PETSCII """""""" .
#endif
#include "align.i65"
_petscii
    jsr enter
#include "page.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  [[FORTH]] (vocid = 0) is
the last vocabulary searched, and is always present.  Executing a
vocabulary pushes it to the head of this stack.
#endif
#include "align.i65"
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary order.  Equivalent to `ONLY FORTH` in ANS Forth
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VSTACK]] search order to [[CURRENT]].
#endif
#include "align.i65"
_definitions
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit


nfalen16a                       ; used by several Forth primitives
    ldy #0
    lda (tos),y
nfalen16b
    sta r11
    asl
    asl
    asl                         ; set carry flag if smudge bit
    lda r11
    and #$1f                    ; return length in A
    bit r11                   ; set V flag = Vocabulary bit
    sta r11
    rts

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the Pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.


```
symbol table entry
+---------------+
|    CFA[low]   |  +0      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  +2      Length field
[I]             |          Immediate bit
| [V]           |          Vocabulary bit
|   [S]         |          Smudge bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +3      Name field
|           ... |
|   name[len]   |
+---------------+
?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
+---------------+
```
#endif
pearsonhash
    stx xsave
    jsr pearsonhash01
    ldx xsave
    jmp put

pearsonhash01
    jsr nfalen01            ; A=length
    sta r0                  ; seed hash1 with length
    tay                     ; count backwards
pearsonhash02
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda r0                          ;[3]
    eor pearson,x                   ;[4]
    sta r0                          ;[3]
    dey
    bne pearsonhash02
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor r0                  ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=nosymbol,concepts
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash
    jsr nfalen16a               ; A=length; Y=0
    tay
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

bloomhash01
    lda #0
    sta r0
    sta r0+1
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc r0                      ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta r0                      ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda r0
    rts

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FIND
stack=( addr1 -- addr2 flag )
tags=interpreter,forth-83,nosymbol
addr1 is the address of a counted string, which is the word to look
up in the dictionary.

if not found, addr2 is the original addr1, and flag = 0
if found, addr2 is the code field address of the word,
and flag = -1 for normal words, +1 for immediate words

! outer interpreter

name is the address of a counted string we are searching for.
fflag is the find mode.  False means NFAs are sorted, True means check them all
nfa is the first nfa in the hash list

vocid identifies which vocabulary to search.  Vocabularies may be
nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
NFAs (with the vocid appended to the name before hashing) on the stack.
The final vocabulary searched will be core, and (FIND) will exit afterward.

  0 = corelist

  1 = assembler

  2+ = vocabularies added by the user

(FIND) first searches all unsorted names beginning at SYMTAIL, without regard
to name length.  If it fails to find the word there,
it tries the hash list, which is sorted in ascending size
order.  Vocabularies are searched first, beginning with CONTEXT and chaining
up until core (0) is reached.  The vocid is appended to the word when
searching that vocabulary.  Only one symbol within a vocabulary may be
active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
may be active within more than one vocabulary.

 returns
       ( cfa -1 ) found normal word
       ( cfa 1 ) found immediate word
       ( name 0 ) not in dictionary

```
: find ( name -- xfa flag )
    dup bloom# >bit bloom + cbit@
    if
        >r  vstack
 ( vstack ; name )
        begin
            c@+ r@ over
 ( vptr vocid name vocid ; name )
            (vfind)
 ( vptr vocid nfa xfa found? ; name )
            ?dup
            if
                rdrop 2>r 3drop 2r> exit
            then
            2drop 0=
        until
        drop r>
    then
    false ;
```
#endif
#include "align.i65"
_find
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(find04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word vstack
#include "page.i65"
find01
    .word cfetchplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
    .word twotor
#include "page.i65"
    .word threedrop
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word exit
#include "page.i65"
find03
    .word twodrop
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
find04
    .word false
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word dup c@ ?: find 0 ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word pquerycolon
    .word _find
    .word zero
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word three
#include "page.i65"
    .word _qerror
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.TIB
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address

```
: source.tib   ( -- addr size )
    tib #tib @ ;
```
#endif
#include "align.i65"
_sourcetib
    jsr enter
#include "page.i65"
    .word tib
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.BLK
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from the console.  Leaves
an address and size

```
: source.blk   ( -- addr size )
    block b/buf ;
```
#endif
#include "align.i65"
_sourceblk
    jsr enter
#include "page.i65"
    .word _block
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Loads the next logical line from the virtual screen buffer into another
80-character buffer, returning a flag indicating if there was a next line

```
: refill.scr   ( -- )
    #lin off
    >in off
    lin dup 1+! @
    25 <
    if
        lin @                   ( lin )
        dup >bit blkbuf + cbit@ ( lin flag )
        swap 24 = or            ( flag )
        if
            forty
        else
            lin 1+! eighty
        then                    ( 40|80 )
        dup    LNMX c!
        3      DFLTN c!
        @lin @ PNT dup dup>r 3c@ >r >r !
        0      PNTR c!          ( 40|80 )
        cas2buf over 2dup expect -trailing
        r> r> r> 3c!            ( restore screen cursor )
        @lin +!
        span @  #lin !
    then ;
```
#endif
#include "align.i65"
_refillscr
    jsr enter
#include "page.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word lin
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(refillscr03-*+1)
#include "pad.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word tobit
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt 24
#include "pad.i65"
    .word eq
#include "page.i65"
    .word orx
#include "page.i65"
    .word qbranch
    .byt <(refillscr01-*+1)
#include "pad.i65"
    .word forty
#include "page.i65"
    .word branch
    .byt <(refillscr02-*+1)
#include "pad.i65"
refillscr01
    .word lin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word eighty
#include "page.i65"
refillscr02
    .word dup
#include "page.i65"
    .word clit
    .byt LNMX
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word three
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word atlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt PNT
#include "pad.i65"
    .word dup
#include "page.i65"
    .word duptor
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
    .word store
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt PNTR
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word dup
#include "page.i65"
    .word atlin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word swap
#include "page.i65"
    .word twodup
#include "page.i65"
    .word expect
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word dup
#include "page.i65"
    .word span
#include "page.i65"
    .word store
#include "page.i65"
    .word numlin
#include "page.i65"
    .word store
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threecstore
#include "page.i65"
refillscr03
    .word exit

;--------------------------------------------------------------
#if 0
name=EOL?.SCR
stack=( -- flag )
tags=interpreter,nosymbol
Leaves true when, while parsing a screen, the cursor is at the end of
a line.  This test triggers a refill event.

```
: eol?.scr   ( -- flag )
    #lin @  >in @  over min  =
    lin @ 25 < and ;
```
#endif
#include "align.i65"
_eolqscr
    jsr enter
#include "page.i65"
    .word numlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _min
#include "page.i65"
    .word eq
#include "page.i65"
    .word lin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word lt
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE.SCR
stack=( -- addr size )
tags=interpreter,nosymbol
Target of SOURCE vector when input is from a screen.  Leaves
an address pointing to the beginning of a line and line size 40|80

```
: source.scr   ( -- addr size )
    begin
        eol?.scr
    while
        refill.scr
    repeat
    cas2buf  #lin @ ;
```
#endif
#include "align.i65"
_sourcescr
    jsr enter
#include "page.i65"
sourcescr01
    .word _eolqscr
#include "page.i65"
    .word qbranch
    .byt <(sourcescr02-*+1)
#include "pad.i65"
    .word _refillscr
#include "page.i65"
    .word branch
    .byt <(sourcescr01-*+1)
#include "pad.i65"
sourcescr02
    .word cas2buf
#include "page.i65"
    .word numlin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOURCE
stack=( -- addr size )
tags=interpret,nosymbol
Returns the base address of the buffer that [[INTERPRET]] is
reading from, and the buffer size.
#endif
source
    jmp (uarea+uservsource-userarea)

;--------------------------------------------------------------
#if 0
name=SOURCE!
stack=( -- )
tags=vm,interpreter,nosymbol
Sets the input source to TIB, BLK, or SCR

```
: source!   ( -- )
    blk @  ?dup
    if
        block  screen? @
        if
            3+ @lin !  lin on  #lin off  ['] source.scr
        else
            drop  ['] source.blk
        then
    else
        ['] source.tib
    then
    (source) ! ;
```
~ something here so that LOAD can restore position on a screen #41
#endif
#include "align.i65"
_sourcestore
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(sourcestore02-*+1)
#include "pad.i65"
    .word _block
#include "page.i65"
    .word _scrpktq
#include "page.i65"
    .word qbranch
    .byt <(sourcestore01-*+1)
#include "pad.i65"
    .word threeplus
#include "page.i65"
    .word atlin
#include "page.i65"
    .word store
#include "page.i65"
    .word lin
#include "page.i65"
    .word on
#include "page.i65"
    .word numlin
#include "page.i65"
    .word off
#include "page.i65"
    .word plit
    .word _sourcescr
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore01
    .word drop
#include "page.i65"
    .word plit
    .word _sourceblk
#include "pad.i65"
    .word branch
    .byt <(sourcestore03-*+1)
#include "pad.i65"
sourcestore02
    .word zero
#include "page.i65"
    .word clit
    .byt DFLTN
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word plit
    .word _sourcetib
#include "pad.i65"
sourcestore03
    .word psource
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( addr1 size1 char -- addr2 count2 )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to size1 bytes are skipped *WHILE* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.
#endif
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( addr count char -- addr count )
tags=numword,nosymbol

 addr1 is the starting address in the input stream where up
 to count1 bytes are skipped *UNTIL* they match char.  Returns
 addr2 as the address of the first non-matching character and
 count2 as the remaining number of bytes in the buffer.

#endif
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt ld | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name='STREAM
stack=( -- addr size )
tags=numword,nosymbol
Calculates SOURCE offset by >IN with respect to buffer size.

```
 : 'stream   ( -- addr size )
       source   ( baseaddr size )
       dup >in @ min /string ;
```
#endif
#include "align.i65"
_tickstream
    jsr enter
#include "page.i65"
    .word source
#include "page.i65"
    .word dup
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _min
#include "page.i65"
    .word _slashstring
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORD
stack=( char -- addr )
tags=interpreter
 Generates a counted string by non-destructively accepting
 characters from the input stream until the delimiting
 character char is encountered or the input stream is
 exhausted.  Leading delimiters are ignored.  The entire
 character string is stored in memory beginning at addr as a
 sequence of bytes.  The string is followed by a blank which
 is not included in the count.  The first byte of the string
 is the number of characters {0..255}.  If the string is
 longer than 255 characters, the count is unspecified.  If
 the input stream is already exhausted as WORD is called,
 then a zero length character string will result.

 If the delimiter is not found the value of >IN is the size
 of the input stream.  If the delimiter is found >IN is
 adjusted to indicate the offset to the character following
 the delimiter.  #TIB is unmodified.

 The counted string returned by WORD may reside in the "free"
 dictionary area at HERE or above.  Note that the text
 interpreter may also use this area.
See: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream

```
: word   ( char -- addr )
    >r 'stream
    under r@ skip  under r> scan  drop
    2dup swap -  >r
    rot - 1+ >in +!
    r> here dup bl blank $!
    here ;
```
#endif
#include "align.i65"
_word
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word under
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word here
#include "page.i65"
    .word dup
#include "page.i65"
    .word bl
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _dolstore
#include "page.i65"
    .word here
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?CHAR
stack=( char -- addr )
tags=compiler,nosymbol
Scans ahead in the input stream until `char` is found.  Moves >IN beyond
that character.
#endif
#include "align.i65"
_qchar
    jsr enter
#include "page.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=fig,forth-83,interpreter
The Forth interpreter loop

consistent eager-loaded approach
TIB source comes already loaded from QUIT
BLK source comes already loaded from BLOCK
SCR source will eager-load each line from the block buffer, already loaded by BLOCK

```
create jumptable  next ,   dlit ,  drop ,  droplit ,
                \ double  double,  single    single,
: interpret   ( -- )
    begin
        ?stack                  \ make sure things are okay
        bl word   ( addr )      \ eager-load for screens is done by SOURCE
        dup c@    ( addr len )  \ WORD returns zero-length when SOURCE is exhausted
    while
        find ?dup
        if        ( cfa findflag )
            \               find -1    find +1
            \             ____________________
            \ state -1   | compile     execute
            \ state 0    | execute     execute
            state @ <>  ?: execute ,xt
        else      ( here )
            number
            jumptable  dpl @ 0< 2*  state @ + 2* -
            @ execute
        then
    repeat
    drop ;
```
#endif
#include "align.i65"
_interpret
    jsr enter
#include "page.i65"
interpret01
    .word qstack
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(interpret04-*+1)
#include "pad.i65"
    .word _find
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "pad.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word plit
    .word interpret06           ; case table
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word twostar
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
interpret03
    .word branch
    .byt <(interpret01-*+1)
#include "pad.i65"
interpret04
    .word drop
#include "page.i65"
    .word exit

interpret06
    .word next
    .word _dlit
    .word drop
    .word _droplit

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=forth-83,fig
Accept a line of input from the user

```
: query   ( -- )
    tib 80 expect
    span @ #tib !
    >in off ;
```
#endif
#include "align.i65"
_query
    jsr enter
#include "page.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=forth-83,interpreter
This is the infinite outer interpreter loop:
      - resets the return stack (RP!)
      - outputs a carriage return (CR)
      - waits for a line of input (QUERY)
      - interprets that line

```
: quit
    [ rp!
    blk off  source!
    begin
        cr
        query interpret
        state @ 0=
        if
            ." OK"
        then
    again ;
```
#endif
#include "align.i65"
_quit
    jsr enter
#include "page.i65"
    .word _lbracket             ; STATE OFF
#include "page.i65"
    .word rpstore
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore          ; set input source
#include "page.i65"
quit01                          ; BEGIN
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=fig,forth-79,forth-83,interpreter
#endif
#include "align.i65"
_abort
    jsr enter
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
#include "align.i65"
_tosyms
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=bloomhash16
tags=nosymbol
Sweet16 wrapper for Bloom hash

sets bloom filter bit

* inputs
** TOS (R1) NFA
** N1 (R3) length
* returns
** ACC (R0) address
#endif
bloomhash16
    ldy n+2                     ; NFA size in N1
    jsr bloomhash01
    pha
    lsr
    lsr
    lsr
    clc
    adc #<(bloom+3)
    sta r0
    tya
    adc #>(bloom+3)
    sta r0+1
    pla
    tay
    lda power2,y
    ldy #0
    ora (r0),y
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Dump the entire vocabulary list.  This should eventually be
refined to display the words in the context vocabulary, the
parent of that, etc... up to the core vocabulary, and then
sorted by descending CFA.

```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
#include "align.i65"
_dots
    jsr enter
#include "page.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    1+
    ?do
        #out @  dup 0=
        if
            over  5 .r
        then
        30 >
        if
            cr
        then
```
#endif
#include "align.i65"
_dump
    jsr enter
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(dump04-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word cr
dump02
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump03-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
dump03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word pleave
    .byt <(dump04-*+1)
#include "pad.i65"
dump05
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump04
    .word drop
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit


; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=XYZZY
stack=( -- )
tags=extra
Forth breakpoint, used for debugging in VICE

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=C@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchange the bytes at `addr1` and `addr2`

#endif
cfetchswapstore
    ldy #2
    jsr locals
    lda (n),y
    pha
    lda (tos),y
    sta (n),y
    pla
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
    2dup c@swap!
    1+ 1 +under c@swap! ;
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word exit

;#include "page.i65"
;    .word twodup
;#include "page.i65"
;    .word twotor
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- ) 
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=MAINIRQ
stack=( -- )
tags=events
#endif
cmainirq
    jsr doconst
    .word MAINIRQ

;--------------------------------------------------------------
#if 0
name=DORINGBUFFER
stack=( -- addr )
tags=compiler,nosymbol

#endif
doringbuffer
    jsr dodoes
#include "page.i65"
    .word four
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EVENTS
stack=( -- )
tags=events
This is a [[RINGBUFFER]] of five 3-byte elements, used by the 
event IRQ routine.  New events are added like this:

* erase the next 3 bytes in the buffer
* increment the tail by +3
* [[C!]] the timeout byte
* [[!]] the CFA word

The [[!]] operation writes the most significant (high) byte
last, and no code field exists on the zero page.  When both the
timeout byte and the MSB of the CFA are non-zero, an event is
said to be latched, and the IRQ will add it to the [[EVENTS]] list
(and remove it from [[NEW-EVENTS]])

#endif
events
    jsr doringbuffer
    .byt 15                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
future
    .dsb 15,0

;--------------------------------------------------------------
#if 0
name=PRESENT
stack=( -- )
tags=events
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
presentcfa
    jsr docreate
present
    .byt 0                  ; size
    .dsb 10,0
presentcfalo = *-1
    .dsb 10,0
presentcfahi = *-1
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=TASKS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 2-byte elements, used by the 
event IRQ routine.  It will contain a list of CFAs to be executed
in order by the mainline code.  Mainline code should not add
elements to this queue, but can remove them by first zeroing 
the CFA then adding +2 to the head pointer

#endif
tasks
    jsr doringbuffer
    .byt 20                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
past
    .dsb 20,0

;--------------------------------------------------------------
#if 0
name=EVENTSADDR
stack=( -- addr )
tags=subroutine,nosymbol
return
TOS = address of the EVENT ring
#endif
eventsaddr
    lda #<future
    ldy #>future
    bne settos              ; bra
;--------------------------------------------------------------
#if 0
name=TASKSADDR
stack=( -- addr )
tags=subroutine,nosymbol
return
TOS = address of the TASK ring
#endif
tasksaddr
    lda #<past              ; this event has expired
    ldy #>past
    ;
settos
    sta tos
    sty tos+1
    rts

;--------------------------------------------------------------
#if 0
name=EVENTRING
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
input
A
N = 0 for head, 1 for tail
V = 0 for past/TASKS, 1 for future/EVENTS
bits 0..5 = offset to add

return
TOS = address
A = always nonzero because A = P register
#endif
ringo
    pha
    asl                     ; copy N flag to C flag
    bpl ringo01
    jsr eventsaddr
    bne ringo02             ; bra
ringo01
    jsr tasksaddr
ringo02
    pla
    and #$3f
    ; fall through
;--------------------------------------------------------------
#if 0
name=(RINGBUF+)
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
This subroutine is reentrant.  It is called by the interrupt
service routine and the mainline routine, so it can't use any
memory as it might interrupt itself.  The IRQ service routine
will push its own ringbuffers on the stack

|register|input|output|
|^''A''|^Offset to add to head or tail||
|^''X''|unused|unused|
|^''Y''||~|
|^''C''|''0''<br/>''1''|move the head (read)<br/>move the tail (write)|
|^''Z''|''true'' always true||

Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
pringbufplus
    php                     ; keep a copy of carry flag 0=head 1=tail
    dec tos+1               ; back up to prev page
    ldy #$fe                ; head
    bcc pringbufplus01
    iny                     ; no tail
    clc
pringbufplus01
    ;clc
    adc (tos),y             ; [head|tail] += offset
    sta (tos),y
    ldy #$fc
    cmp (tos),y             ; compare to size
    bcc pringbufplus03      ; inside the lines?
    iny                     ; $fd wrap counter
    lda (tos),y
    adc #0
    sta (tos),y             ; increment wrap counter
    iny                     ; head
    plp                     ; check copy of C flag
    bcc pringbufplus02
    iny
pringbufplus02
    lda #0
    sta (tos),y             ; zero head|tail pointer
    inc tos+1               ; move back to current page
    rts                     ; Z = 0
pringbufplus03
    ;clc                    ; TOS += new position
    adc tos
    sta tos
    lda tos+1
    adc #1
    sta tos+1
    pla                     ; discard carry flag
    rts                     ; Z = 0

;--------------------------------------------------------------
#if 0
name=RINGBUF+
stack=( offset -1|-2 ringbuf -- addr )
tags=compiler
Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
ringbufplus
    lsr stackl,x            ; Carry bit is true for -1, false for -2
    lda stackl+1,x          ; offset, 0 for read
    jsr pringbufplus
    inx
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=RBUFFULL
stack=( addr -- flag )
tags=events,nosymbol,subroutine
|^''A''|''00''<br/>head = tail|
|~|''!00''<br/>data in buffer|
|^''Y''|''00''<br/>head = tail|
|~|''ff''<br/>buffer contains data|
|^''C''|''true''<br/>buffer is full iff head=tail|
|~|''false''<br/>buffer is empty iff head=tail|
|^''Z''|''true''<br/>head = tail|
|~|''false''<br/>head != tail|
|''TOS''|unchanged|
#endif
rbuffull
    dec tos+1
    ldy #$fd            ; wrap counter
    lda (tos),y
    lsr                 ; parity bit to C flag
    iny                 ; head $fe
    lda (tos),y
    iny                 ; tail $ff
    eor (tos),y
    php
    bne rbuffull02
rbuffull01
    iny
rbuffull02
    inc tos+1
    plp
    rts
;--------------------------------------------------------------
#if 0
name=RBUFDATA?
stack=( addr -- flag )
tags=events
Returns [[TRUE]] if the ring buffer has data, [[FALSE]] if empty
#endif
rbufdataq
    jsr rbuffull
    tya
    bne rbufdataq01
    adc #0              ; full(1) or empty(0) depends on C flag
rbufdataq01
    jmp put

;--------------------------------------------------------------
#if 0
name=EVENTIRQ
stack=( -- )
tags=events,nosymbol
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
eventirq
    lda tos+1
    pha
    lda tos
    pha

    ldx present
    beq nextcube
doboil
    dec present,x
    bne nextboil
    jsr tasksaddr
    lda #0                  ; read|head|tasks
    jsr ringo               ; tos points to the next task
    ldy #0
    lda presentcfalo,x
    sta (tos),y
    iny
    lda presentcfahi,x
    sta (tos),y
    lda #2                  ; move|head|tasks
    jsr ringo
    ldy present
    dec present
    lda present,y
    sta present,x
    lda presentcfalo,y
    sta presentcfalo,x
    lda presentcfahi,y
    sta presentcfahi,x      ; remove expired event
nextboil
    dex
    bne doboil
nextcube
    jsr eventsaddr
    jsr rbuffull
    bcs testcube
    beq nomoreice
testcube
    lda #0|bit7|bit6        ; read | tail | events
    jsr ringo               ; tos points to the new event
    ldy #2
    lda (tos),y
    beq nomoreice           ; cfahi=0?  this event is incomplete. we're done
    pha
    dey
    lda (tos),y             ; cfalo
    pha
    dey
    lda (tos),y             ; delay
    bne water
    ;lda #0                 ; read|head|tasks
    jsr ringo               ; tos points to the next task
    ldy #0
    pla
    sta (tos),y
    iny
    pla
    sta (tos),y
    lda #2                  ; move|head|tasks
    jsr ringo               ; move the tail to consume event
    bne water01             ; bra
water
    inc present             ; add a new event
    ldx present
    sta present,x
    pla
    sta presentcfalo,x
    pla
    sta presentcfahi,x
water01
    jsr eventsaddr
    lda #3|bit7|bit6        ; move | tail | events
    jsr ringo               ; move the tail to consume event
    jmp nextcube
nomoreice
    pla
    sta tos
    pla
    sta tos+1
    jmp MAINIRQ

;--------------------------------------------------------------
#if 0
name=GO
stack=( -- )
tags=events
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
go
    lda #<(MAINIRQ^eventirq)
    ldy #>(MAINIRQ^eventirq)
    jsr push6502
    jmp irqcaret

;--------------------------------------------------------------
#if 0
name=ADD-EVENT
stack=( cfa delay -- )
tags=events
```
: add-event   ( cfa duration -- )
    events rbufdata? 1-
    if
        0 -2 events ringbuf+
        swap c!+ !
        3 -2 events ringbuf+ drop
    then ;
```
#endif
#include "align.i65"
_addevent
    jsr enter
#include "page.i65"
    .word events
#include "page.i65"
    .word rbufdataq
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word qbranch
    .byt <(addevent01-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word minustwo
#include "page.i65"
    .word events
#include "page.i65"
    .word ringbufplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word minustwo
#include "page.i65"
    .word events
#include "page.i65"
    .word ringbufplus
#include "page.i65"
    .word drop
#include "page.i65"
addevent01
    .word exit

;--------------------------------------------------------------
#if 0
name=BLVI
stack=( anchor offset -- )
tags=events
Blank a 6-character column on the screen

e.g. `VIDRAM 600 + 0 BLVI` erases the left column while 
`VIDRAM 600 + 39 BLVI` erases the rightmost column
#endif
blvi
    ldy #2
    jsr locals
    clc
    lda tos
    adc #200
    tay
    lda #6
    sta n+2
blvi01
    lda #' '
    sta (n),y
    tya
    sec
    sbc #40
    tay
    dec n+2
    bne blvi01
    jmp drop

;--------------------------------------------------------------
#if 0
name=DRAWVI
stack=( from to columns -- )
tags=events
#endif
drawvi
    ldy #4
    jsr locals
    lda tos
    asl
    ;clc
    adc tos
    asl
    adc #5
    sta n+4             ; column offset = bottom character
    inc tos
drawvi01
    dec tos
    bmi done
    clc
    lda tos
    adc #200
    sta n+5             ; screen offset = bottom right corner
    lda #7
    sta n+6             ; column countdown
drawvi02                ; for each column
    dec n+6
    beq drawvi01
    ldy n+4
    lda (n),y
    dey
    sty n+4             ; back up one character
    ldy n+5
    sta (n+2),y         ; draw character
    sec
    tya
    sbc #40
    sta n+5             ; go up one line on screen
    jmp drawvi02        ; bra
done
    jmp drop

;--------------------------------------------------------------
#if 0
name=FACE
stack=( -- addr )
tags=events
#endif
face
    jsr docreate
;    .byt 1,2,3,4,5,6
;    .byt 7,8,9,10,11,12
;    .byt 13,14,15,16,17,18
;    .byt 19,20,21,22,23,24
;    .byt 49,50,51,52,53,54

;    .byt $55,$5d,$5d,$5d,$4a,$20
;    .byt $40,$20,$20,$20,$40,$20
;    .byt $40,$20,$20,$4a,$72,$a0
;    .byt $40,$57,$20,$40,$40,$4b
;    .byt $49,$20,$4b,$6e,$4b,$20

    .byt $55,$5d,$5d,$5d,$4a,$20
    .byt $40,$57,$20,$4a,$40,$4a
    .byt $40,$20,$4b,$40,$72,$a0
    .byt $40,$57,$20,$4b,$40,$4b
    .byt $49,$5d,$5d,$5d,$4b,$20

;--------------------------------------------------------------
#if 0
name=JIFFIES
stack=( u -- )
tags=events
#endif
#include "align.i65"
_jiffies
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _jiffyfetch
#include "page.i65"
    .word dplus
#include "page.i65"
jiffies01
    .word _jiffyfetch
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(jiffies01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BUBBLEZONE
stack=( n -- )
tags=events

!!Constant
Bubble zone

```
vidram 360 + constant bubblezone
```
#endif
bubblezone
    jsr doconst
    .word VIDRAM+360

;--------------------------------------------------------------
#if 0
name=HEADZONE
stack=( n -- )
tags=events

!!Constant
Head zone

```
vidram 600 + constant headzone
```
#endif
headzone
    jsr doconst
    .word VIDRAM+600

;--------------------------------------------------------------
#if 0
name=BARZONE
stack=( n -- )
tags=events

!!Constant
Bar zone

```
vidram 840 + constant barzone
```
#endif
barzone
    jsr doconst
    .word VIDRAM+840

;--------------------------------------------------------------
#if 0
name=STROLL
stack=( n -- )
tags=events

```
: stroll   ( n -- )
    36 0 do
        face  i 4 <
        if
            4 i - 6 * +
        then
        vidram  i 4 >
        if
            dup i 5 - blvi
            i +
        then
        i 4 min  drawvi
        dup jiffies
    loop  drop ;

```
#endif
#include "align.i65"
_stroll
    jsr enter
#include "page.i65"
    .word clit
    .byt 33
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
stroll01
    .word face
#include "page.i65"
    .word i
#include "page.i65"
    .word four
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(stroll02-*+1)
#include "pad.i65"
    .word four
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word star
#include "page.i65"
    .word plus
#include "page.i65"
stroll02
    .word headzone
#include "page.i65"
    .word i
#include "page.i65"
    .word four
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(stroll03-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word clit
    .byt 5
#include "pad.i65"
    .word minus
#include "page.i65"
    .word blvi
#include "page.i65"
    .word i
#include "page.i65"
    .word four
#include "page.i65"
    .word minus
#include "page.i65"
    .word plus
#include "page.i65"
stroll03
    .word i
#include "page.i65"
    .word four
#include "page.i65"
    .word _min
#include "page.i65"
    .word drawvi
#include "page.i65"
    .word dup
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word ploop
    .byt <(stroll01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FLIPROW
stack=( addr -- )
tags=events

Flip a row of five characters
```
: fliprow   ( addr -- addr )
    face swap 4 drawvi ;
```
#endif
fliprow
    ldy #4
fliprow01
    lda (tos),y
    pha
    dey
    bpl fliprow01
    ldy #4
fliprow02
    pla
    sty n
    ldy #(cornerflip-corners-1)
fliprow03
    cmp corners,y
    bne fliprow04
    pha
    tya
    lsr
    tay
    pla
    eor cornerflip,y
    ldy #0
fliprow04
    dey
    bpl fliprow03
    ldy n
    sta (tos),y
    dey
    bpl fliprow02
    jmp next
corners
    .byt $55,$49,$4a,$4b,$70,$6e,$6d,$7d
    .byt $6b,$73,$69,$5f,$df,$e9,$e5,$e7
cornerflip
    .byt $55^$49,$4a^$4b,$70^$6e,$6d^$7d
    .byt $6b^$73,$69^$5f,$df^$e9,$e5^$e7

;--------------------------------------------------------------
#if 0
name=MIRROR
stack=( addr -- )
tags=events

```
: mirror   ( addr -- )
    6 0 do
        fliprow forty +
    loop  drop ;
```
#endif
#include "align.i65"
_mirror
    jsr enter
#include "page.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
mirror01
    .word fliprow
#include "page.i65"
    .word forty
#include "page.i65"
    .word plus
#include "page.i65"
    .word ploop
    .byt <(mirror01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FRONT
stack=( addr -- )
tags=events

```
: front   ( addr -- )
    face swap 4 drawvi ;
```
#endif
#include "align.i65"
_front
    jsr enter
#include "page.i65"
    .word plit  
    .word frontface
#include "page.i65"
    .word swap
#include "page.i65"
    .word four
#include "page.i65"
    .word drawvi
#include "page.i65"
    .word exit
frontface
    .byt $55,$5d,$5d,$5d,$4a,$20
    .byt $40,$57,$20,$4a,$40,$4a
    .byt $40,$20,$4b,$40,$72,$a0
    .byt $40,$57,$20,$4b,$40,$4b
    .byt $49,$5d,$5d,$5d,$4b,$20

;--------------------------------------------------------------
#if 0
name=SAVE-FACE
stack=( addr -- )
tags=events
Saves a 30-byte image to the FACE area

```
: save-face   ( addr -- )
    5 0 do
        6 0 do
            dup i forty * j +  + c@
            face j 6 * i + c!
        loop
    loop drop ;
```
#endif
#include "align.i65"
_saveface
    jsr enter
#include "page.i65"
    .word clit
    .byt 5
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
saveface01
    .word clit
    .byt 6
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
saveface02
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word forty
#include "page.i65"
    .word star
#include "page.i65"
    .word j
#include "page.i65"
    .word plus
#include "page.i65"
    .word plus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word face
#include "page.i65"
    .word j
#include "page.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word star
#include "page.i65"
    .word i
#include "page.i65"
    .word plus
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word ploop
    .byt <(saveface02-*+1)
#include "pad.i65"
    .word ploop
    .byt <(saveface01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RIGHT-FACE
stack=( n -- )
tags=events

```
: right-face   ( addr -- )
    1+
    3 0 do
        forty + dup>r
        @ r@ 2+ ! r@ 2 blank r>
    loop
    3+ 110 swap c! ;

```
#endif
#include "align.i65"
_rightface
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word three
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
rightface01
    .word forty
#include "page.i65"
    .word plus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word store
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word two
#include "page.i65"
    .word _blank
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word ploop
    .byt <(rightface01-*+1)
#include "pad.i65"
    .word threeplus
#include "page.i65"
    .word clit
    .byt 110
#include "pad.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BOARD
stack=( -- )
tags=events
Paint the game background

```
: board   ( -- )
    editing dup on 3 block off ;
```
#endif
#include "align.i65"
_board
    jsr enter
#include "page.i65"
    .word editing
#include "page.i65"
    .word dup
#include "page.i65"
    .word on
#include "page.i65"
    .word three
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SPEED
stack=( -- )
tags=events
!!Variable

Speed of player walking
#endif
#include "align.i65"
speed
    jsr docreate
    .word 12

;--------------------------------------------------------------
#if 0
name=REDO
stack=( -- )
tags=events
!!Variable

CFA of event to redo
#endif
redo
    jsr docreate
    .word _scroll

;--------------------------------------------------------------
#if 0
name=RESCHEDULE
stack=( -- )
tags=events
scroll the bar to the left

```
: reschedule   ( -- )
    redo @ speed @ add-event ;
```
#endif
#include "align.i65"
_reschedule
    jsr enter
#include "page.i65"
    .word redo
#include "page.i65"
    .word fetch
#include "page.i65"
    .word speed
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _addevent
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCROLL
stack=( -- )
tags=events
scroll the bar to the left

```
: scroll   ( -- )
    reschedule
    [ vidram 24 40 * + 1+ ] literal
    [ vidram 999 + ] literal  -1 +move
    [ vidram 983 + ] c@
    [ vidram 999 + ] c! ;
```
#endif
#include "align.i65"
_scroll
    jsr enter
#include "page.i65"
    .word _reschedule
#include "page.i65"
    .word plit
    .word VIDRAM+961
#include "pad.i65"
    .word plit
    .word VIDRAM+999
#include "pad.i65"
    .word minusone
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word plit
    .word VIDRAM+983
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word plit
    .word VIDRAM+999
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECK
stack=( -- addr )
tags=events
deck of Chit Chat cards

#endif
deck
    jsr docreate
    .dsb 36

;--------------------------------------------------------------
#if 0
name=NEWDECK
stack=( -- )
tags=events

```
: newdeck   ( -- )
    deck
    3 0 do
        6 0 do
            j 2* 2* 2* i +
            dup>r c!+  r> c!+
        loop
    loop  drop ;
```
#endif
#include "align.i65"
_newdeck
    jsr enter
#include "page.i65"
    .word deck
#include "page.i65"
    .word three
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
newdeck01
    .word clit
    .byt 6
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
newdeck02
    .word j
#include "page.i65"
    .word twostar
#include "page.i65"
    .word twostar
#include "page.i65"
    .word twostar
#include "page.i65"
    .word i
#include "page.i65"
    .word plus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word ploop
    .byt <(newdeck02-*+1)
#include "pad.i65"
    .word ploop
    .byt <(newdeck01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RANDMASK
stack=( n -- mask )
tags=events
returns the next power of 2 mask >= n

```
: randmask   ( n -- mask )
    1
    begin
        2* 2dup u<
    until nip ;
```
#endif
#include "align.i65"
_randmask
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
randmask01
    .word twostar
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(randmask01-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RNDMAX
stack=( max -- rnd )
tags=events
generate a random unsigned byte less than `max`

```
: rndmax   ( addr size -- )
    1- dup randmask
    begin
        randu
        3dup and >
    while
        drop
    repeat
    and nip ;
```
#endif
#include "align.i65"
_rndmax
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _randmask
#include "page.i65"
rndmax01
    .word randuc
#include "page.i65"
    .word threedup
#include "page.i65"
    .word andx
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(rndmax02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(rndmax01-*+1)
#include "pad.i65"
rndmax02
    .word andx
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MOD36
stack=( offset -- offset )
tags=events
returns `offset` - 36 if `offset` > 35

This is a severely limited mod36, it only handles arguments
between 0..71
#endif
mod36
    lda tos
    cmp #36
    bcc mod36a
    sbc #36
    sta tos
mod36a
    jmp next

;--------------------------------------------------------------
#if 0
name=SHUFFLE
stack=( index size -- )
tags=events
shuffle `size` bytes starting at the `index` element

```
: shuffle   ( base size -- )
    dup 0 do
        2dup  rndmax + mod36  deck +
        third i +  mod36  deck +
        c@swap!
    loop 2drop ;
```
#endif
#include "align.i65"
_shuffle
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
shuffle01
    .word twodup
#include "page.i65"
    .word _rndmax
#include "page.i65"
    .word plus
#include "page.i65"
    .word mod36
#include "page.i65"
    .word deck
#include "page.i65"
    .word plus
#include "page.i65"
    .word third
#include "page.i65"
    .word i
#include "page.i65"
    .word plus
#include "page.i65"
    .word mod36
#include "page.i65"
    .word deck
#include "page.i65"
    .word plus
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word ploop
    .byt <(shuffle01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=XYZZY
stack=( -- )
tags=extra
Forth breakpoint, used for debugging in VICE when `break .xyzzy`
is enabled, as it is in the `pettil.dbg` configuration file

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=C@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchange the bytes at `addr1` and `addr2`

#endif
cfetchswapstore
    ldy #2
    jsr locals
    lda (n),y
    pha
    lda (tos),y
    sta (n),y
    pla
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
    2dup c@swap!
    1+ 1 +under c@swap! ;
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word exit

;#include "page.i65"
;    .word twodup
;#include "page.i65"
;    .word twotor
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- )
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAUSE
stack=( -- )
tags=nucleus,ext
Scans keyboard and if 'space' was pressed, pauses until any key
is pressed.

```
: ?pause   ( -- )
    ?key bl =
    if false pause then ;
```
#endif
#include "align.i65"
_qpause
    jsr enter
#include "page.i65"
    .word qkey
#include "page.i65"
    .word bl
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(qpause01-*+1)
#include "pad.i65"
    .word false
#include "page.i65"
    .word _pause
#include "page.i65"
qpause01
    .word exit

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=JIFFIES
stack=( u -- )
tags=events
#endif
#include "align.i65"
_jiffies
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _jiffyfetch
#include "page.i65"
    .word dplus
#include "page.i65"
jiffies01
    .word _jiffyfetch
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(jiffies01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RANDMASK
stack=( n -- mask )
tags=events
returns the next power of 2 mask >= n

```
: randmask   ( n -- mask )
    1
    begin
        2* 2dup u<
    until nip ;
```
#endif
#include "align.i65"
_randmask
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
randmask01
    .word twostar
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(randmask01-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RNDMAX
stack=( max -- rnd )
tags=events
generate a random unsigned byte less than `max`

```
: rndmax   ( max -- )
    dup 0= ?exit
    1- dup randmask
    begin
        randu
        3dup and >
    while
        drop
    repeat
    and nip ;
```
#endif
#include "align.i65"
_rndmax
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _randmask
#include "page.i65"
rndmax01
    .word randuc
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word andx
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(rndmax02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(rndmax01-*+1)
#include "pad.i65"
rndmax02
    .word andx
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
    jsr slmod40
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODS
stack=( u -- u%40 u/40 )
tags=math,nosymbol
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
slmod40
    jsr slip
    lda #0
    ldy #16
slmod40b
    cmp #20
    bcc slmod40c
    sbc #20
slmod40c
    rol tos
    rol tos+1
    rol
    dey
    bne slmod40b
    sta stackl,x
    sty stackh,x
    rts

;--------------------------------------------------------------
#if 0
name=40*
stack=( u -- u*40 )
tags=math
Fast integer unsigned TOS multiply by 40, no overflow checking
#endif
fortytimes
    lda tos+1
    pha
    lda tos
    asl
    rol tos+1
    asl
    rol tos+1
    adc tos
    sta tos
    pla
    adc tos+1
    asl tos
    rol
    asl tos
    rol
    asl tos
    rol
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=ARGS
stack=( ? n -- n )
tags=math
Peels n arguments off the stack and stores them in the `N` area
#endif
args
    lda tos
    asl
    tay
    jsr locals
    jmp drop

;--------------------------------------------------------------
#if 0
name=SCROLLUP
stack=( lines -- addr )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

```
: scrollup   ( lines -- addr )
    2+ 40*  560
    vidram 2dup >r >r
    dup>r
    vidram + dup vidram
    560 r@ - cmove r> - ;



    2+ 40* vidram over + vidram 560
    2dup + >r 3 roll - >r cmove 2r> - ;


: scrollup   ( lines -- )
    dup>r
    vidram + vidram [ 40 15 * ] literal r@ -
    2dup + >r cmove
    r> r> 40 + blank ;

vidram+560-160
vidram+160
vidram
560-160

: scrollup   ( lines -- addr )
    2+ 40*
                        160
    560 over -
                        160 400
    vidram tuck 2dup 2>r
                        160 vidram 400 vidram ; vidram 400
    + -rot +
                        400+vidram vidram+160  ; vidram 400
    r> r> cmove ;
```
#endif
#include "align.i65"
_scrollup
    jsr enter
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plit
    .word 560
#include "pad.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word tuck
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word plus
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=HORIZBUBBLE
stack=( width speaker -- )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

: lines   ( lines -- )
    40* dup>r
    vidram + vidram [ 40 15 * ] literal r@ -
    2dup + >r cmove
    r> r> 40 + blank ;

#endif
#include "align.i65"
_horizbubble
    jsr enter
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word duptor
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plit
    .word 40*15
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word forty
#include "page.i65"
    .word plus
#include "page.i65"
    .word _blank
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MSG
stack=( u -- u%40 u/40 )
tags=math

|>|msg|jsr docreate|storage area|
|^2|^msgtarg|^to|^unpack target usually CAS2BUF|
|^2|^msgsrc|^from|^unpack from usually BLKBUF|
|^1|^msgtargptr|^target pointer|^offset into output buffer|
|^1|^msgsrcptr|^source pointer|^offset into source buffer|
|^4|^msgchars|^chars|^counter and three characters|
|^1|^msgspeaker|^speaker|^0 = bar<br/>7 = player<br/>15 = chick<br/>23 = interloper|
|^1|^msgmaxwidth|^maximum width|^longest line in this bubble|
|^1|^msgwidth|^width|^width of current line|
|^1|^msgcharcount|^char count|^countdown of chars remaining to output in this line|
|^1|^msgheight|height|^number of lines in this bubble<br/>0 for bar|
|^1|^msglinecount|^line count|^lines remaining to process in this bubble<br/>FF for bar|
|^0|^msgend|^end|^end of message structure|

#endif
msg
    jsr docreate
msgsrc
    .word 0                 ; from
msgsrcptr
    .byt 0
msgtargptr
    .byt 0
msgspeaker
    .byt 0                  ; whom is speaking? (0=player)
msgwidth
    .byt 0                  ; this line 1..38
msgmaxwidth
    .byt 0                  ; longest line 1..38
msgcharcount
    .byt 0                  ; output chars remaining this line
msgheight
    .byt 0                  ; number of lines 1..3
msglinecount
    .byt 0                  ; lines remaining to process
msgchars
    .byt 0,$aa,$bb,$cc      ; chars
msgend

;--------------------------------------------------------------
#if 0
name=(MSG.BUBBLE)
stack=( -- speaker maxwidth lines )
tags=mmm
#endif
pmsgbubble
    brk
    .byt set | N3
    .word msgspeaker
    .byt ldi | N3           ; speaker
    .byt st | TOS
    .byt inr | N3           ; skip msgwidth
    .byt ldd | N3           ; msgmaxwidth (msgcharcount==0)
    .byt push
    .byt ldi | N3           ; msgheight
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=MSG.BUBBLE
stack=( )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

: msg.bubble   ( )
    (msg.bubble)
;

#endif
#include "align.i65"
_msgbubble
    jsr enter
#include "page.i65"
    .word pmsgbubble
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _scrollup
#include "page.i65"
    .word pmsgbubble
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MSG.BAR
stack=( )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

: msg.bar   ( )
;

#endif
#include "align.i65"
_msgbar
    jsr enter
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RAD50CHAR
stack=( )
tags=math,nosymbol

returns:
    A = current rad50 char
    Y = count
    N = clear

|0|EOM|
|1-26|a-z|
|27|' '|
|28-37|0-9|
|38|'.'|
|39|alt|
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
rad50char
    ldy msgchars            ; count remaining in this triplet
    bne rad50char03
    ldy msgsrcptr           ; triplet is empty, get next word
    lda (n+2),y
    sta tos
    iny
    lda (n+2),y
    sta tos+1
    iny
    sty msgsrcptr
    jsr slmod40             ; chop
    sta msgchars+1
    jsr slmod40             ; chop ha-daa!
    sta msgchars+2
    lda tos
    sta msgchars+3          ; put three remainders in msg[10..12]
    inx
    inx
    ldy #3
    sty msgchars            ; reset triplet counter to 3
rad50char03
    dec msgchars
    lda msgchars,y
    rts

;--------------------------------------------------------------
#if 0
name=R50PROC
stack=( msg -- flag )
tags=math

* `from` is the start of a RAD50-encoded `script`
* `to` is the target address to where the `script` is unpacked in `segments`, which are delimited by `actions` ending in the `endscene` action
* `msg` is a pointer to a RAD50-encoded message

This word is executed iterative by [[R50SCRIPT]] until it
returns a true flag once the script is complete

|binary|means|value|h
|000000|endscript||
|000001|idea|1|
|000010|bartender|2|
|000011|||
|000100|||
|000101|Player|1|
|000110|Player|2|
|000111|Player|3|
|001000|||
|001001|Chick|1|
|001010|Chick|2|
|001011|Chick|3|
|001100|||
|001101|Interloper|1|
|001110|Interloper|2|
|001111|Interloper|3|



d;m 0;ii 33a 3ff;ii 8000 83e7;m 1ad0 1aef;n



```
    jsr rad50char           ; actor & lines
    beq r50proc09           ; done?
    tay
    and #$fc                ; isolate speaker bits.  0 = bar
    asl
    ;clc
    sbc #0                  ; 7 = player; 15 = chick; 23 = interloper
    sta msgspeaker          ; speaker offset (above right eye)
    tya
    and #$03                ; isolate height bits
    sta msgheight           ; for the bar, 1=thought, 2=bartender
    sta msglinecount
```
#endif
r50proc
    jsr rad50char           ; actor & lines
    beq r50proc09           ; done?
    and #%00000011          ; isolate count bits
    sta msgheight
    sta msglinecount
    eor msgchars,y          ; isolate speaker bits.  0 = bar
    asl
    ;clc
    sbc #0                  ; 7 = player; 15 = chick; 23 = interloper
    sta msgspeaker          ; speaker offset (above right eye)
r50proc01
    jsr rad50char           ; length
    sta msgwidth            ; of this line
    sta msgcharcount        ; countdown
    cmp msgmaxwidth         ; of longest line
    bcc r50proc02
    sta msgmaxwidth
r50proc02
    jsr rad50char           ; top of character loop
    beq r50altchar          ; space = 0
    cmp #27                 ; alpha?
    beq r50altpunct         ; comma = 27
    bcc r50alphanum       ; a-z = 1..26
    ;sec
    adc #19                 ; 0-9 = 28..37, +20 --> 48..57
    cmp #58                 ; numeric?
    bcc r50alphanum         ; number
    lsr
    bcc r50altpunct         ; period = 29
    jsr rad50char           ; from second alphabet, or action
    .byt $2c                ; BIT abs, skip next instruction
r50altpunct
    ;sec
    sbc #26
r50altchar
    tay
    lda r50table,y        ; alt character set
r50alphanum
    ldy msgtargptr
    inc msgtargptr
    sta (n),y               ; ship it
    dec msgcharcount
    bne r50proc02
    dec msglinecount
    bmi r50proc04           ; this is for the bar
    php
    clc
    lda #40
    sbc msgwidth            ; 40 is always > msgwidth
    adc msgtargptr          ; which always sets carry here
    sta msgtargptr
    plp
    bne r50proc01           ; loop back for more lines?
    ldy #2                  ; add current src offset to src
    lda (n+4),y             ; and zero src offset in MSG structure
    pha
    lda #0
    sta (n+4),y
    tay
    pla
    clc
    adc (n+4),y
    pha
    tya
    iny
    adc (n+4),y
    sta (n+4),y
    dey
    pla
    sta (n+4),y
r50proc04
    lda #$ff
r50proc09
    tay
    jmp put

r50table
    .byt $20,$2c,$2e,$21, $22,$23,$24,$25       ;" ,.!"#$%
    .byt $26,$27,$28,$29, $2a,$2b,$2d,$2f       ;"&'()*+-/
    .byt $3a,$3b,$3c,$3d, $3e,$3f,$40,$1b       ;":;<=>?@[
    .byt $1c,$1d,$1e,$1f, $60,$5e               ;"\]^_|~

r50actions
    .word r50actions-1                       ;30
    .word r50actions-1                        ;31
    .word r50actions-1                     ;32
    .word r50actions-1                  ;33
    .word r50actions-1                     ;34

;--------------------------------------------------------------
#if 0
name=?BUTTON
stack=( -- keyval|false )
tags=mmm
Detects a leading edge transition of either spacebar or return
key and leaves either key value on the stack, otherwise [[FALSE]]

LSTX contains the ASCII value of the current keypress
or 255 if no key is pressed.
#endif
qbutton
    lda LSTX   ;get current button value, 255=none
    cmp qbutton03   ;changed?
    beq qbutton01
    sta qbutton03   ;remember new state
    cmp #13   ;acceptable value?
    beq qbutton02
    cmp #32
    beq qbutton02
qbutton01
    lda #0   ;return false
qbutton02
    jmp push0a

qbutton03
    .byt 0

;--------------------------------------------------------------
#if 0
name=R50SEGMENT
stack=( linecount\speaker -- )
tags=mmm

Perform one of the following:

* output a speech bubble
** speaker is 7, 15, or 23
* have an idea
** speaker is 0
** height is 1
* bartender talks
** speaker is 0
** height is 2


#endif
#include "align.i65"
r50segment
    ldy msgspeaker
    beq r50segment01
    ldy #2
r50segment01
;    lda r50segtable+1,y
    pha
;    lda r50segtable,y
    pha
    rts
r50segtable
    nop

;--------------------------------------------------------------
#if 0
name=R50SCRIPT
stack=( from to -- )
tags=mmm
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]

```
: script   ( n -- )
    2* 0 block tuck dup @ + + @ +
    cas2buf r50script ;

\ address of message #n
: >msg   ( n -- addr )
    2* 0 block tuck dup @ + + @ + ;

: msg.init   ( src targ -- msg )
    msg dup (msgend-msgtarg) erase
    3dup 2!  3 args ;

: script   ( n -- )
    >msg msg.init

msg dup (msgend-msgtarg) erase

: r50script   ( n -- )
    >script cas2buf msg.init
    msg dup (msgend-msgtarg) erase
    3dup 2!  3 args
    begin
        msg.targ 192 blank
        r50proc
    while

    msg dup 14 erase  3dup 2!  3 args
    begin
        r50proc
        ?dup ?: msg.bubble msg.bar
    until ;
```


d;m 0;ii 33a;m 1a65 1a74;z


#endif
#include "align.i65"
_r50script
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 192
#include "pad.i65"
    .word _blank
#include "page.i65"
    .word msg
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt (msgend-msgsrc)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word twostore
#include "page.i65"
    .word three
#include "page.i65"
    .word args
#include "page.i65"
r50script01
    .word r50proc
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(r50script02-*+1)
#include "pad.i65"
    .word r50segment
#include "page.i65"
    .word branch
    .byt <(r50script01-*+1)
#include "pad.i65"
r50script02
    .word exit

;--------------------------------------------------------------
#if 0
name=>MSG
stack=( n -- addr )
tags=mmm
Return the start address of script #`n`.  Script numbers begin
at 1.

```
\ address of message #n
: >msg   ( n -- addr )
    1- 2* 0 block tuck dup @ + + @ + ;
;```
#endif
#include "align.i65"
_tomsg
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zero
#include "page.i65"
    .word _block
#include "page.i65"
    .word tuck
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=GAME
stack=( -- )
tags=mmm
bubble position
the lesser of 38-w, x-1
the larger of 0, x-w



#endif
#include "align.i65"
_game
    jsr enter
#include "page.i65"
    .word _rndmax
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INHALE
stack=( -- 'msg cas2buf msg x )
tags=mmm
Set up a few variables used by [[UTTER]] and its friends.
Used prior to the `3 ARGS` when some intervening word has
altered the `N` area needed by [[R50DECODE]]

```
: inhale   ( -- 'msg cas2buf msg x )
    msg cas2buf over @ dup ;
```
#endif
#include "align.i65"
_inhale
    jsr enter
#include "page.i65"
    .word msg
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word over
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UTTER
stack=( -- flag )
tags=mmm
Put text on the screen and return [[TRUE]] at end of script

* next speech bubble in a script
* bartender
* thought
Uses the Lazy loading pattern.  Kick things off by storing
the script number at [[MSG]]. On first invocation, `UTTER`
will look up the address of the first message in that
script, blank the [[CAS2BUF]] area, and zero other internal
[[MSG]] variables.

Annoyingly, the operating system uses part of the 2nd tape
buffer for its own purposes, so we don't get the whole 192
bytes.  164 is enough since we never exceed three lines in
a text bubble and all output to the bar is one line

```
: utter   ( -- flag )
    msg @ 0= ?dup ?exit         \ done?
    inhale  msb 0=
    if
        >msg -rot
        (192-28) blank  dup (msgend-msgsrc) erase  !
        inhale drop
    then
    third  3 args
    r50proc  ?dup ?: msg.bubble msg.bar ;
```



d;m 0;ii 33a 3ff;m 1ad0 1aef;z



#endif
#include "align.i65"
_utter
    jsr enter
#include "page.i65"
    .word msg
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _inhale
#include "page.i65"
    .word msb
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(utter01-*+1)
#include "pad.i65"
    .word _tomsg
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word clit
    .byt 192-28             ; key repeat, 6/5 clock adjust above here
#include "pad.i65"
    .word _blank
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt (msgend-msgsrc)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word store
#include "page.i65"
    .word _inhale
#include "page.i65"
    .word drop
#include "page.i65"
utter01
    .word third
#include "page.i65"
    .word three
#include "page.i65"
    .word args
#include "page.i65"
    .word r50proc
#include "page.i65"
    .word qdup
#include "page.i65"
    .word pquerycolon
    .word _msgbubble
    .word _msgbar
#include "pad.i65"
    .word exit

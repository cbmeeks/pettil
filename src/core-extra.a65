; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=xyzzy
stack=( -- )
tags=nosymbol
Forth breakpoint, used for debugging in VICE

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( var1 var2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- ) 
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=DORINGBUFFER
stack=( -- addr )
tags=compiler,nosymbol

#endif
doringbuffer
    jsr dodoes
#include "page.i65"
    .word four
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EVENTS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 3-byte elements, used by the 
event IRQ routine.  It should not be read or written directly
by mainline code.

#endif
events
    jsr doringbuffer
    .byt 30                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
    .dsb 30,0

;--------------------------------------------------------------
#if 0
name=NEW-EVENTS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of five 3-byte elements, used by the 
event IRQ routine.  New events are added like this:

* erase the next 3 bytes in the buffer
* increment the tail by +3
* [[C!]] the timeout byte
* [[!]] the CFA word

The [[!]] operation writes the most significant (high) byte
last, and no code field exists on the zero page.  When both the
timeout byte and the MSB of the CFA are non-zero, an event is
said to be latched, and the IRQ will add it to the [[EVENTS]] list
(and remove it from [[NEW-EVENTS]])

#endif
newevents
    jsr doringbuffer
    .byt 15                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
    .dsb 15,0

;--------------------------------------------------------------
#if 0
name=TASKS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 2-byte elements, used by the 
event IRQ routine.  It will contain a list of CFAs to be executed
in order by the mainline code.  Mainline code should not add
elements to this queue, but can remove them by first zeroing 
the CFA then adding +2 to the head pointer

#endif
tasks
    jsr doringbuffer
    .byt 20                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
    .dsb 20,0

;--------------------------------------------------------------
#if 0
name=RINGBUF+
stack=( offset -1|-2 ringbuf -- addr )
tags=compiler
Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
ringbufplus
    lsr stackl,x            ; Carry bit is true for -1, false for -2
    lda stackl+1,x          ; offset, 0 for read
    jsr pringbufplus
    inx
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=(RINGBUF+)
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
This subroutine is reentrant.  It is called by the interrupt
service routine and the mainline routine, so it can't use any
memory as it might interrupt itself.  The IRQ service routine
will push its own ringbuffers on the stack
|register|input|output|
|^''A''|^Offset to add to head or tail|
|^''X''|~|
|^''Y''|~|
|^''C''|''0'' increment the head (read)<br/>''1'' increment the tail|
Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
pringbufplus
    pha                     ; keep a copy of offset
    php                     ; keep a copy of carry flag 0=head 1=tail
    dec tos+1               ; back up to prev page
    ldy #$fe                ; head
    bcc pringbufplus01
    iny                     ; no tail
    clc
pringbufplus01
    ;clc
    adc (tos),y             ; [head|tail] += offset
    sta (tos),y
    ldy #$fc
    cmp (tos),y             ; compare to size
    bcc pringbufplus03      ; inside the lines?
    iny                     ; $fd wrap counter
    lda (tos),y
    adc #0
    sta (tos),y             ; increment wrap counter
    iny                     ; head
    plp                     ; check copy of C flag
    bcc pringbufplus02
    iny
pringbufplus02
    lda #0
    sta (tos),y             ; zero head|tail pointer
    pla                     ; discard copy of offset
    inc tos+1               ; move back to current page
    rts
pringbufplus03
    ;clc                    ; TOS += offset
    adc tos
    sta tos
    lda tos+1
    adc #1
    sta tos+1
    pla                     ; discard carry flag
    pla                     ; restore offset
    rts

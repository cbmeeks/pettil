; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=XYZZY
stack=( -- )
tags=extra
Forth breakpoint, used for debugging in VICE when `break .xyzzy`
is enabled, as it is in the `pettil.dbg` configuration file

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=C@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchange the bytes at `addr1` and `addr2`

#endif
cfetchswapstore
    ldy #2
    jsr locals
    lda (n),y
    pha
    lda (tos),y
    sta (n),y
    pla
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
    2dup c@swap!
    1+ 1 +under c@swap! ;
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word exit

;#include "page.i65"
;    .word twodup
;#include "page.i65"
;    .word twotor
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- )
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAUSE
stack=( -- )
tags=nucleus,ext
Scans keyboard and if 'space' was pressed, pauses until any key
is pressed.

```
: ?pause   ( -- )
    ?key bl =
    if false pause then ;
```
#endif
#include "align.i65"
_qpause
    jsr enter
#include "page.i65"
    .word qkey
#include "page.i65"
    .word bl
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(qpause01-*+1)
#include "pad.i65"
    .word false
#include "page.i65"
    .word _pause
#include "page.i65"
qpause01
    .word exit

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=JIFFIES
stack=( u -- )
tags=events
#endif
#include "align.i65"
_jiffies
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _jiffyfetch
#include "page.i65"
    .word dplus
#include "page.i65"
jiffies01
    .word _jiffyfetch
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(jiffies01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RANDMASK
stack=( n -- mask )
tags=events
returns the next power of 2 mask >= n

```
: randmask   ( n -- mask )
    1
    begin
        2* 2dup u<
    until nip ;
```
#endif
#include "align.i65"
_randmask
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
randmask01
    .word twostar
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(randmask01-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RNDMAX
stack=( max -- rnd )
tags=events
generate a random unsigned byte less than `max`

```
: rndmax   ( addr size -- )
    1- dup randmask
    begin
        randu
        3dup and >
    while
        drop
    repeat
    and nip ;
```
#endif
#include "align.i65"
_rndmax
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _randmask
#include "page.i65"
rndmax01
    .word randuc
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word andx
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(rndmax02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(rndmax01-*+1)
#include "pad.i65"
rndmax02
    .word andx
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
    jsr slmod40
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODS
stack=( u -- u%40 u/40 )
tags=math,nosymbol
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
slmod40
    jsr slip
    lda #0
    ldy #16
slmod40b
    cmp #20
    bcc slmod40c
    sbc #20
slmod40c
    rol tos
    rol tos+1
    rol
    dey
    bne slmod40b
    sta stackl,x
    sty stackh,x
    rts

;--------------------------------------------------------------
#if 0
name=40*
stack=( u -- u*40 )
tags=math
Fast integer unsigned TOS multiply by 40, no overflow checking
#endif
fortytimes
    lda tos+1
    pha
    lda tos
    asl
    rol tos+1
    asl
    rol tos+1
    adc tos
    sta tos
    pla
    adc tos+1
    asl tos
    rol
    asl tos
    rol
    asl tos
    rol
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=MSG
stack=( u -- u%40 u/40 )
tags=math
|0|EOM|
|1-26|a-z|
|27|' '|
|28-37|0-9|
|38|'.'|
|39|alt|
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
msg
    jsr docreate
    .word 0                 ; to
    .word 0                 ; from
    .word 0                 ; counters
    .byt 0,$aa,$bb,$cc      ; chars

;--------------------------------------------------------------
#if 0
name=RAD50FILL
stack=( )
tags=math

returns: Y=count
#endif
rad50char
    ldy msg+9               ; count remaining in this triplet
    bne rad50fill03
    ldy msg+7               ; triplet is empty, get next word
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    iny
    sty msg+7
    jsr slmod40             ; chop
    sta msg+10
    jsr slmod40             ; chop ha-daa!
    sta msg+11
    lda tos
    sta msg+12              ; put three remainders in msg[10..12]
    inx
    inx
    ldy #3
    sty msg+9               ; reset triplet counter to 3
rad50fill03
    dec msg+9
    lda msg+9,y
    rts

;--------------------------------------------------------------
#if 0
name=RAD50PROCESS
stack=( from to -- len )
tags=math
#endif
rad50process
    ldy #4
    jsr locals
rad50process01
    jsr rad50char
    beq rad50altchar        ; space
    cmp #27                 ; alpha?
    beq rad50altchar        ; comma
    bcc rad50alphanum       ; 1..26
    ;sec
    adc #19                 ; sets 0-9 range 28..37 --> 48..57
    cmp #57                 ; numeric?
    bcc rad50alphanum       ; number
    lsr                     ; is it 38 or 39 then?
    bcc rad50altchar        ; period = 29

    jsr rad50char           ; 0..31 are characters
    cmp #(rad50actions-rad50table)
    bcc rad50altchar
    asl
    tay
    lda rad50actions-63,y
    pha
    lda rad50actions-64,y
    pha
    rts                     ; jump to command

rad50altchar
    tay
    lda rad50table,y        ; alt character set
    .byt $2c                ; BIT abs instruction
rad50period
    lda #$2e                ; '.'
rad50alphanum
    ldy msg+8
    inc msg+8
    sta (n+2),y             ; ship it
    bpl rad50process01
rad50eom
    tay
    lda msg+8               ; return length
    jmp put
rad50table
    .byt $20,$00, $1b,$1c,$1d,$1e,$1f, $21      ;" @[\]^_!
    .byt $22,$23,$24,$25,$26,$27,$28,$29        ;""#$%&'()
    .byt $2a,$2b, $2d, $2f, $3a,$3b,$3c,$3d     ;"*+-/:;<=
    .byt $3e,$3f ,$51,$2c,$57,$2e,$41,$53       ;">?Q,W.AS
    .byt $5a,$58                                ;"ZX
rad50actions
    .word rad50endline
    .word rad50togglespeaker
    .word rad50endbubble
    .word rad50endscene

rad50endbubble
    lda #25
rad50togglespeaker
    lda #26
rad50endthought
    lda #27
rad50endline
    lda #28
rad50endscene
    lda #29

;--------------------------------------------------------------
#if 0
name=RAD50DECODE
stack=( from to -- size )
tags=math
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]

hello, world!
32d4 4d7f 6e8f 609c 1f1e 0000

#endif
#include "align.i65"
_rad50decode
        jsr enter
#include "page.i65"
        .word msg
#include "page.i65"
        .word _threedup
#include "page.i65"
        .word twostore
#include "page.i65"
        .word dup
#include "page.i65"
        .word four
#include "page.i65"
        .word plus
#include "page.i65"
        .word three
#include "page.i65"
        .word _erase
#include "page.i65"
        .word xyzzy
#include "page.i65"
        .word rad50process
#include "page.i65"
        .word exit

; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=XYZZY
stack=( -- )
tags=extra
Forth breakpoint, used for debugging in VICE when `break .xyzzy`
is enabled, as it is in the `pettil.dbg` configuration file

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=C@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchange the bytes at `addr1` and `addr2`

#endif
cfetchswapstore
    ldy #2
    jsr locals
    lda (n),y
    pha
    lda (tos),y
    sta (n),y
    pla
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
    2dup c@swap!
    1+ 1 +under c@swap! ;
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word exit

;#include "page.i65"
;    .word twodup
;#include "page.i65"
;    .word twotor
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- )
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAUSE
stack=( -- )
tags=nucleus,ext
Scans keyboard and if 'space' was pressed, pauses until any key
is pressed.

```
: ?pause   ( -- )
    ?key bl =
    if false pause then ;
```
#endif
#include "align.i65"
_qpause
    jsr enter
#include "page.i65"
    .word qkey
#include "page.i65"
    .word bl
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(qpause01-*+1)
#include "pad.i65"
    .word false
#include "page.i65"
    .word _pause
#include "page.i65"
qpause01
    .word exit

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=JIFFIES
stack=( u -- )
tags=events
#endif
#include "align.i65"
_jiffies
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _jiffyfetch
#include "page.i65"
    .word dplus
#include "page.i65"
jiffies01
    .word _jiffyfetch
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(jiffies01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RANDMASK
stack=( n -- mask )
tags=events
returns the next power of 2 mask >= n

```
: randmask   ( n -- mask )
    1
    begin
        2* 2dup u<
    until nip ;
```
#endif
#include "align.i65"
_randmask
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
randmask01
    .word twostar
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(randmask01-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RNDMAX
stack=( max -- rnd )
tags=events
generate a random unsigned byte less than `max`

```
: rndmax   ( max -- )
    dup 0= ?exit
    1- dup randmask
    begin
        randu
        3dup and >
    while
        drop
    repeat
    and nip ;
```
#endif
#include "align.i65"
_rndmax
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _randmask
#include "page.i65"
rndmax01
    .word randuc
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word andx
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(rndmax02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(rndmax01-*+1)
#include "pad.i65"
rndmax02
    .word andx
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
    jsr slmod40
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODS
stack=( u -- u%40 u/40 )
tags=math,nosymbol
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
slmod40
    jsr slip
    lda #0
    ldy #16
slmod40b
    cmp #20
    bcc slmod40c
    sbc #20
slmod40c
    rol tos
    rol tos+1
    rol
    dey
    bne slmod40b
    sta stackl,x
    sty stackh,x
    rts

;--------------------------------------------------------------
#if 0
name=40*
stack=( u -- u*40 )
tags=math
Fast integer unsigned TOS multiply by 40, no overflow checking
#endif
fortytimes
    lda tos+1
    pha
    lda tos
    asl
    rol tos+1
    asl
    rol tos+1
    adc tos
    sta tos
    pla
    adc tos+1
    asl tos
    rol
    asl tos
    rol
    asl tos
    rol
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=MSG
stack=( u -- u%40 u/40 )
tags=math
|0|EOM|
|1-26|a-z|
|27|' '|
|28-37|0-9|
|38|'.'|
|39|alt|
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
msg
    jsr docreate
msgtarg
    .word 0                 ; to
msgsrc
    .word 0                 ; from
msgtargptr
    .byt 0
msgsrcptr
    .byt 0
msgchars
    .byt 0,$aa,$bb,$cc      ; chars
msgspeaker
    .byt 0                  ; whom is speaking? (0=player)
msgmaxwidth
    .byt 0
msgheight
    .byt 0

;--------------------------------------------------------------
#if 0
name=RAD50FILL
stack=( )
tags=math

returns: Y=count
#endif
rad50char
    ldy msgchars            ; count remaining in this triplet
    bne rad50fill03
    ldy msgsrcptr           ; triplet is empty, get next word
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    iny
    sty msgsrcptr
    jsr slmod40             ; chop
    sta msgchars+1
    jsr slmod40             ; chop ha-daa!
    sta msgchars+2
    lda tos
    sta msgchars+3          ; put three remainders in msg[10..12]
    inx
    inx
    ldy #3
    sty msgchars            ; reset triplet counter to 3
rad50fill03
    dec msgchars
    lda msgchars,y
    rts

;--------------------------------------------------------------
#if 0
name=RAD50PROCESS
stack=( from to -- len )
tags=math
#endif
rad50process
    ldy #6
    jsr locals
rad50process01
    jsr rad50char
    beq rad50altchar        ; space = 0
    cmp #27                 ; alpha?
    beq rad50altpunct       ; comma = 27
    bcc rad50alphanum       ; a-z = 1..26
    ;sec
    adc #19                 ; 0-9 = 28..37 --> 48..57
    cmp #58                 ; numeric?
    bcc rad50alphanum       ; number
    lsr
    bcc rad50altpunct       ; period = 29

    jsr rad50char           ; from second alphabet, or action
    cmp #(rad50actions-rad50table)
    bcc rad50altchar
    asl
    ;clc
    tay
    lda rad50actions-59,y
    pha
    lda rad50actions-60,y
    pha
    rts                     ; jump to command

rad50altpunct
    sbc #26
rad50altchar
    tay
    lda rad50table,y        ; alt character set
rad50alphanum
    ldy msgtargptr
    inc msgtargptr
    sta (n+2),y             ; ship it
    bpl rad50process01      ; bra
rad50exit
    ldy #0
    lda msgtargptr          ; return length
    jmp put
rad50table
    .byt $20,$2c,$2e,$21, $22,$23,$24,$25       ;" ,.!"#$%
    .byt $26,$27,$28,$29, $2a,$2b,$2d,$2f       ;"&'()*+-/
    .byt $3a,$3b,$3c,$3d, $3e,$3f,$40,$1b       ;":;<=>?@[
    .byt $1c,$1d,$1e,$1f, $60,$5e               ;"\]^_|~

rad50actions
    .word rad50endline-1                        ;30
    .word rad50togglespeaker-1                  ;31
    .word rad50endbubble-1                      ;32
    .word rad50endscene-1                       ;33

rad50endbubble
    jmp rad50endbubble
rad50togglespeaker
    lda #$12
    lsr msgspeaker
    bcs rad50togglespeaker01
    lda #$92
    inc msgspeaker
rad50togglespeaker01
    jsr $ffd2
    jmp rad50process01

rad50endthought
    jmp rad50endthought

rad50endline
    lda msgheight
    beq rad50endline01
    lda #0
    sta msgtargptr
    lda n+2
    adc #40
    sta n+2
    bcc rad50endline01
    inc n+3
rad50endline01
    inc msgheight
    jmp rad50process01

rad50endscene
    jmp rad50exit

;--------------------------------------------------------------
#if 0
name=RAD50DECODE
stack=( from to -- size )
tags=math
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]

hello, world!
32d4 4d7f 6e8f 609c 1f1e 0000

#endif
#include "align.i65"
_rad50decode
        jsr enter
#include "page.i65"
        .word msg
#include "page.i65"
        .word _threedup
#include "page.i65"
        .word twostore
#include "page.i65"
        .word dup
#include "page.i65"
        .word four
#include "page.i65"
        .word plus
#include "page.i65"
        .word three
#include "page.i65"
        .word _erase
#include "page.i65"
        .word msg
#include "page.i65"
        .word xyzzy
#include "page.i65"
        .word rad50process
#include "page.i65"
        .word exit

;--------------------------------------------------------------
#if 0
name=GAME
stack=( -- )
tags=mmm
bubble position
the lesser of 38-w, x-1
the larger of 0, x-w



#endif
#include "align.i65"
_game
        jsr enter
#include "page.i65"
game01
        .word _pause
#include "page.i65"
        .word _pause
#include "page.i65"
        .word zero
#include "page.i65"
        .word _block
#include "page.i65"
        .word cas2buf
#include "page.i65"
        .word duptor
#include "page.i65"
        .word _rad50decode
#include "page.i65"
game02
        .word msg
#include "page.i65"
        .word nine
#include "page.i65"
        .word plus
#include "page.i65"
        .word cfetch
        .word plus
#include "page.i65"
        .word forty
#include "page.i65"
        .word over
#include "page.i65"
        .word minus
#include "page.i65"
        .word twominus
#include "page.i65"
        .word qdup
#include "page.i65"
        .word qbranch
        .byt <(game02-*+1)
#include "page.i65"
        .word _rndmax
#include "page.i65"
game03
        .word rfrom
#include "page.i65"
        .word plus
#include "page.i65"
        .word vidram
#include "page.i65"
        .word exit


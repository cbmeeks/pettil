; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=xyzzy
stack=( -- )
tags=nosymbol
Forth breakpoint, used for debugging in VICE

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( var1 var2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- ) 
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=DORINGBUFFER
stack=( -- addr )
tags=compiler,nosymbol

#endif
doringbuffer
    jsr dodoes
#include "page.i65"
    .word four
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EVENTS
stack=( -- )
tags=events
This is a [[RINGBUFFER]] of five 3-byte elements, used by the 
event IRQ routine.  New events are added like this:

* erase the next 3 bytes in the buffer
* increment the tail by +3
* [[C!]] the timeout byte
* [[!]] the CFA word

The [[!]] operation writes the most significant (high) byte
last, and no code field exists on the zero page.  When both the
timeout byte and the MSB of the CFA are non-zero, an event is
said to be latched, and the IRQ will add it to the [[EVENTS]] list
(and remove it from [[NEW-EVENTS]])

#endif
events
    jsr doringbuffer
    .byt 15                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
future
    .dsb 15,0

;--------------------------------------------------------------
#if 0
name=PRESENT
stack=( -- )
tags=events
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
presentcfa
    jsr docreate
present
    .byt 0                  ; size
    .dsb 10,0
presentcfalo = *-1
    .dsb 10,0
presentcfahi = *-1
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=TASKS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 2-byte elements, used by the 
event IRQ routine.  It will contain a list of CFAs to be executed
in order by the mainline code.  Mainline code should not add
elements to this queue, but can remove them by first zeroing 
the CFA then adding +2 to the head pointer

#endif
tasks
    jsr doringbuffer
    .byt 20                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
past
    .dsb 20,0

;--------------------------------------------------------------
#if 0
name=EVENTSADDR
stack=( -- addr )
tags=subroutine,nosymbol
return
TOS = address of the EVENT ring
#endif
eventsaddr
    lda #<future
    ldy #>future
    bne settos              ; bra
;--------------------------------------------------------------
#if 0
name=TASKSADDR
stack=( -- addr )
tags=subroutine,nosymbol
return
TOS = address of the TASK ring
#endif
tasksaddr
    lda #<past              ; this event has expired
    ldy #>past
    ;
settos
    sta tos
    sty tos+1
    rts

;--------------------------------------------------------------
#if 0
name=EVENTRING
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
input
A
N = 0 for head, 1 for tail
V = 0 for past/TASKS, 1 for future/EVENTS
bits 0..5 = offset to add

return
TOS = address

#endif
ringo
    pha
    asl                     ; copy N flag to C flag
    bpl ringo01
    jsr eventsaddr
    bne ringo02             ; bra
ringo01
    jsr tasksaddr
ringo02
    pla
    and #$3f
    ; fall through
;--------------------------------------------------------------
#if 0
name=(RINGBUF+)
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
This subroutine is reentrant.  It is called by the interrupt
service routine and the mainline routine, so it can't use any
memory as it might interrupt itself.  The IRQ service routine
will push its own ringbuffers on the stack

|register|input|output|
|^''A''|^Offset to add to head or tail||
|^''X''|unused|unused|
|^''Y''||~|
|^''C''|''0''<br/>''1''|move the head (read)<br/>move the tail (write)|

Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
pringbufplus
    php                     ; keep a copy of carry flag 0=head 1=tail
    dec tos+1               ; back up to prev page
    ldy #$fe                ; head
    bcc pringbufplus01
    iny                     ; no tail
    clc
pringbufplus01
    ;clc
    adc (tos),y             ; [head|tail] += offset
    sta (tos),y
    ldy #$fc
    cmp (tos),y             ; compare to size
    bcc pringbufplus03      ; inside the lines?
    iny                     ; $fd wrap counter
    lda (tos),y
    adc #0
    sta (tos),y             ; increment wrap counter
    iny                     ; head
    plp                     ; check copy of C flag
    bcc pringbufplus02
    iny
pringbufplus02
    lda #0
    sta (tos),y             ; zero head|tail pointer
    inc tos+1               ; move back to current page
    rts
pringbufplus03
    ;clc                    ; TOS += new position
    adc tos
    sta tos
    lda tos+1
    adc #1
    sta tos+1
    pla                     ; discard carry flag
    rts

;--------------------------------------------------------------
#if 0
name=RINGBUF+
stack=( offset -1|-2 ringbuf -- addr )
tags=compiler
Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
ringbufplus
    lsr stackl,x            ; Carry bit is true for -1, false for -2
    lda stackl+1,x          ; offset, 0 for read
    jsr pringbufplus
    inx
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=MAINIRQ
stack=( -- )
tags=events
#endif
cmainirq
    jsr doconst
    .word MAINIRQ

;--------------------------------------------------------------
#if 0
name=RBUFFULL
stack=( addr -- flag )
tags=events,nosymbol,subroutine
|^''A''|''00''<br/>head = tail|
|~|''!00''<br/>data in buffer|
|^''Y''|''00''<br/>head = tail|
|~|''ff''<br/>buffer contains data|
|^''C''|''true''<br/>buffer is full iff head=tail|
|~|''false''<br/>buffer is empty iff head=tail|
|''TOS''|unchanged|
#endif
rbuffull
    dec tos+1
    ldy #$fd            ; wrap counter
    lda (tos),y
    lsr
    iny                 ; head
    lda (tos),y
    iny                 ; tail
    eor (tos),y
    bne rbuffull02
rbuffull01
    iny
rbuffull02
    inc tos+1
    rts

;--------------------------------------------------------------
#if 0
name=RBUFDATA?
stack=( addr -- flag )
tags=events
Returns [[TRUE]] if the ring buffer has data, [[FALSE]] if empty
#endif
rbufdataq
    jsr rbuffull
    tya
    bne rbufdataq01
    adc #0              ; full(1) or empty(0) depends on C flag
rbufdataq01
    jmp put

;--------------------------------------------------------------
#if 0
name=EVENTIRQ
stack=( -- )
tags=events,nosymbol
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
eventirq
    lda tos+1
    pha
    lda tos
    pha

    ldx present
    beq nextcube
doboil
    dec present,x
    bne nextboil
yeahhere
    jsr tasksaddr
    lda #0                  ; read|head|tasks
    jsr ringo               ; tos points to the next task
    ldy #0
    lda presentcfalo,x
    sta (tos),y
    iny
    lda presentcfahi,x
    sta (tos),y
    lda #2                  ; move|head|tasks
    jsr ringo
    ldy present
    dec present
    lda present,y
    sta present,x
    lda presentcfalo,y
    sta presentcfalo,x
    lda presentcfahi,y
    sta presentcfahi,x      ; remove expired event
nextboil
    dex
    bne doboil
nextcube
    jsr eventsaddr
    jsr rbuffull
    beq nomoreice
testcube
    lda #0|bit7|bit6        ; read | tail | events
    jsr ringo               ; tos points to the new event
    ldy #0                  ; ~ do most calls to pringbufplus need Y=0 after?
    lda (tos),y
    beq nomoreice           ; timer=0? this event is incomplete. we're done
    ldy #2
    lda (tos),y
    beq nomoreice           ; cfahi=0?  this event is incomplete. we're done
meltcube
    inc present             ; add a new event
    ldx present
    lda (tos),y
    sta presentcfahi,x
    dey
    lda (tos),y
    sta presentcfalo,x
    dey
    lda (tos),y
    sta present,x
    jsr eventsaddr
    lda #3|bit7|bit6        ; move | tail | events
    jsr ringo               ; move the tail to consume event
    jmp nextcube
nomoreice
    pla
    sta tos
    pla
    sta tos+1
    jmp MAINIRQ

;--------------------------------------------------------------
#if 0
name=GO
stack=( -- )
tags=events
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* for each present event
* * decrement present event countdown timer
* * when timer reaches zero
* * * add expired event CFAs to the [[TASKS]] queue
* * * remove expired event
* until future queue is empty 
* or this future event is incomplete
* * add this future event to the present events queue
* * advance the tail of the future events queue
* chain the ROM IRQ service routine
#endif
go
    lda #<(MAINIRQ^eventirq)
    ldy #>(MAINIRQ^eventirq)
    jsr push6502
    jmp irqcaret


; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=xyzzy
stack=( -- )
tags=nosymbol
Forth breakpoint, used for debugging in VICE

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( var1 var2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- ) 
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=DORINGBUFFER
stack=( -- addr )
tags=compiler,nosymbol

#endif
doringbuffer
    jsr dodoes
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EVENTS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 3-byte elements, used by the 
event IRQ routine.  It should not be read or written directly
by mainline code.

#endif
events
    jsr doringbuffer
    .byt 0                  ; head
    .byt 0                  ; tail
    .byt 30                 ; size
    .dsb 30,0

;--------------------------------------------------------------
#if 0
name=NEW-EVENTS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of five 3-byte elements, used by the 
event IRQ routine.  New events are added like this:

* erase the next 3 bytes in the buffer
* increment the tail by +3
* [[C!]] the timeout byte
* [[!]] the CFA word

The [[!]] operation writes the most significant (high) byte
last, and no code field exists on the zero page.  When both the
timeout byte and the MSB of the CFA are non-zero, an event is
said to be latched, and the IRQ will add it to the [[EVENTS]] list
(and remove it from [[NEW-EVENTS]])

#endif
newevents
    jsr doringbuffer
    .byt 0                  ; head
    .byt 0                  ; tail
    .byt 15                 ; size
    .dsb 15,0

;--------------------------------------------------------------
#if 0
name=TASKS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 2-byte elements, used by the 
event IRQ routine.  It will contain a list of CFAs to be executed
in order by the mainline code.  Mainline code should not add
elements to this queue, but can remove them by first zeroing 
the CFA then adding +2 to the head pointer

#endif
tasks
    jsr doringbuffer
    .byt 0                  ; head
    .byt 0                  ; tail
    .byt 20                 ; size
    .dsb 20,0

;--------------------------------------------------------------
#if 0
name=HEAD/TAIL+
stack=( addr offset -2|-3 -- addr )
Increments (and possibly wraps) the head or tail of a [[RINGBUFFER]].
Returns the memory address pointed to by the adjusted pointer.

Use -2 for the tail, -3 for the head
Use an offset of 0 to read the pointer location.
#endif
headtailplus
    ldy #4
    jsr locals              ; N0 = offset; N1 = addr
    dec n+3                 ; back up one page
    ldy tos                 ; use $fd, $fe, $ff offsets for head, tail, limit
    lda n                   ; the offset.  One byte will suffice
    clc
    adc (n+2),y             ; offset+[head|tail]
    ldy #$ff
    eor (n+2),y
    beq headtailplus01      ; did we hit limit?  use A=0 to wrap
    eor (n+2),y             ; no, change A back to the sum
headtailplus01
    ldy tos                 ; offset to head or tail
    sta (n+2),y
    ;clc                    ; ringbuffer limited to one page
    adc n+2
    sta tos
    lda n+3
    adc #1                  ; put back the earlier page decrement
    sta tos+1
    jmp next

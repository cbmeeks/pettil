; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=XYZZY
stack=( -- )
tags=extra
Forth breakpoint, used for debugging in VICE when `break .xyzzy`
is enabled, as it is in the `pettil.dbg` configuration file

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=C@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchange the bytes at `addr1` and `addr2`

#endif
cfetchswapstore
    ldy #2
    jsr locals
    lda (n),y
    pha
    lda (tos),y
    sta (n),y
    pla
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( addr1 addr2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
    2dup c@swap!
    1+ 1 +under c@swap! ;
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word cfetchswapstore
#include "page.i65"
    .word exit

;#include "page.i65"
;    .word twodup
;#include "page.i65"
;    .word twotor
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- )
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAUSE
stack=( -- )
tags=nucleus,ext
Scans keyboard and if 'space' was pressed, pauses until any key
is pressed.

```
: ?pause   ( -- )
    ?key bl =
    if false pause then ;
```
#endif
#include "align.i65"
_qpause
    jsr enter
#include "page.i65"
    .word qkey
#include "page.i65"
    .word bl
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(qpause01-*+1)
#include "pad.i65"
    .word false
#include "page.i65"
    .word _pause
#include "page.i65"
qpause01
    .word exit

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=JIFFIES
stack=( u -- )
tags=events
#endif
#include "align.i65"
_jiffies
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _jiffyfetch
#include "page.i65"
    .word dplus
#include "page.i65"
jiffies01
    .word _jiffyfetch
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(jiffies01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RANDMASK
stack=( n -- mask )
tags=events
returns the next power of 2 mask >= n

```
: randmask   ( n -- mask )
    1
    begin
        2* 2dup u<
    until nip ;
```
#endif
#include "align.i65"
_randmask
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
randmask01
    .word twostar
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(randmask01-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RNDMAX
stack=( max -- rnd )
tags=events
generate a random unsigned byte less than `max`

```
: rndmax   ( max -- )
    dup 0= ?exit
    1- dup randmask
    begin
        randu
        3dup and >
    while
        drop
    repeat
    and nip ;
```
#endif
#include "align.i65"
_rndmax
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _randmask
#include "page.i65"
rndmax01
    .word randuc
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word andx
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(rndmax02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(rndmax01-*+1)
#include "pad.i65"
rndmax02
    .word andx
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
    jsr slmod40
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODS
stack=( u -- u%40 u/40 )
tags=math,nosymbol
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
slmod40
    jsr slip
    lda #0
    ldy #16
slmod40b
    cmp #20
    bcc slmod40c
    sbc #20
slmod40c
    rol tos
    rol tos+1
    rol
    dey
    bne slmod40b
    sta stackl,x
    sty stackh,x
    rts

;--------------------------------------------------------------
#if 0
name=40*
stack=( u -- u*40 )
tags=math
Fast integer unsigned TOS multiply by 40, no overflow checking
#endif
fortytimes
    lda tos+1
    pha
    lda tos
    asl
    rol tos+1
    asl
    rol tos+1
    adc tos
    sta tos
    pla
    adc tos+1
    asl tos
    rol
    asl tos
    rol
    asl tos
    rol
    sta tos+1
fortytimes01
    jmp next

;--------------------------------------------------------------
#if 0
name=ARGS
stack=( ? n -- n )
tags=math
Peels n arguments off the stack and stores them in the `N` area
#endif
args
    lda tos
    asl
    tay
    jsr locals
    beq fortytimes01                ; next

;--------------------------------------------------------------
#if 0
name=SCROLLUP
stack=( lines -- )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

: lines   ( lines -- )
    40* dup>r
    vidram + vidram [ 40 15 * ] literal r@ -
    2dup + >r cmove
    r> r> 40 + blank ;

#endif
#include "align.i65"
_scrollup
    jsr enter
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word duptor
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plit
    .word 40*15
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word forty
#include "page.i65"
    .word plus
#include "page.i65"
    .word _blank
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=HORIZBUBBLE
stack=( width speaker -- )
tags=mmm
Scroll the speech bubble area up some number of `lines`

vidram+lines*40 vidram (15-lines)*40 cmove
vidram+(15-lines)*40 (lines+1)*40 blank

: lines   ( lines -- )
    40* dup>r
    vidram + vidram [ 40 15 * ] literal r@ -
    2dup + >r cmove
    r> r> 40 + blank ;

#endif
#include "align.i65"
_horizbubble
    jsr enter
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word duptor
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word plit
    .word 40*15
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word forty
#include "page.i65"
    .word plus
#include "page.i65"
    .word _blank
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MSG
stack=( u -- u%40 u/40 )
tags=math

|>|msg|jsr docreate|storage area|
|^2|^msgtarg|^to|^unpack target usually CAS2BUF|
|^2|^msgsrc|^from|^unpack from usually BLKBUF|
|^1|^msgtargptr|^target pointer|^offset into output buffer|
|^1|^msgsrcptr|^source pointer|^offset into source buffer|
|^4|^msgchars|^chars|^counter and three characters|
|^1|^msgspeaker|^speaker|^0 = bar<br/>7 = player<br/>15 = chick<br/>23 = interloper|
|^1|^msgmaxwidth|^maximum width|^longest line in this bubble|
|^1|^msgwidth|^width|^width of current line|
|^1|^msgcharcount|^char count|^countdown of chars remaining to output in this line|
|^1|^msgheight|height|^number of lines in this bubble<br/>0 for bar|
|^1|^msglinecount|^line count|^lines remaining to process in this bubble<br/>FF for bar|
|^0|^msgend|^end|^end of message structure|

#endif
msg
    jsr docreate
msgtarg
    .word 0                 ; to
msgsrc
    .word 0                 ; from
msgtargptr
    .byt 0
msgsrcptr
    .byt 0
msgchars
    .byt 0,$aa,$bb,$cc      ; chars
msgspeaker
    .byt 0                  ; whom is speaking? (0=player)
msgmaxwidth
    .byt 0                  ; longest line 1..38
msgwidth
    .byt 0                  ; this line 1..38
msgcharcount
    .byt 0                  ; output chars remaining this line
msgheight
    .byt 0                  ; number of lines 1..3
msglinecount
    .byt 0                  ; lines remaining to process
msgend

;--------------------------------------------------------------
#if 0
name=RAD50CHAR
stack=( )
tags=math,nosymbol

returns:
    A = current rad50 char
    Y = count
    N = clear

|0|EOM|
|1-26|a-z|
|27|' '|
|28-37|0-9|
|38|'.'|
|39|alt|
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
rad50char
    ldy msgchars            ; count remaining in this triplet
    bne rad50char03
    ldy msgsrcptr           ; triplet is empty, get next word
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    iny
    sty msgsrcptr
    jsr slmod40             ; chop
    sta msgchars+1
    jsr slmod40             ; chop ha-daa!
    sta msgchars+2
    lda tos
    sta msgchars+3          ; put three remainders in msg[10..12]
    inx
    inx
    ldy #3
    sty msgchars            ; reset triplet counter to 3
rad50char03
    dec msgchars
    lda msgchars,y
    rts

;--------------------------------------------------------------
#if 0
name=RAD50ENDLINE
stack=( -- )
tags=math

#endif
rad50endline
    lda msgtargptr
    sec
rad50process01
    sbc #40
    bcs rad50process01
    adc #40                 ; width % 40
    cmp msgmaxwidth
    bcc rad50process02
    sta msgmaxwidth
    clc
rad50process02
    lda msgheight
    beq rad50endline01
    lda msgtargptr
    adc #40
    sta msgtargptr
rad50endline01
    inc msgheight
    jmp next

;--------------------------------------------------------------
#if 0
name=RAD50TOGGLESPEAKER
stack=( from to -- size )
tags=math

#endif
rad50togglespeaker
    lda #$12
    lsr msgspeaker
    bcs rad50togglespeaker01
    lda #$92
    inc msgspeaker
rad50togglespeaker01
    jsr $ffd2
    jmp next

;--------------------------------------------------------------
#if 0
name=(RAD50ENDBUBBLE)
stack=( -- height width speaker )
tags=math

#endif
prad50endbubble
    brk
    .byt set | ACC
    .word (msgend-msgtarg)
    .byt add | N2
    .byt st | N3
    .byt pop | N3               ; msg.height
    .byt st | TOS
    .byt pop | N3               ; msg.width
    .byt push
    .byt pop | N3               ; msg.speaker
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=RAD50ENDBUBBLE
stack=( )
tags=math

* scroll the screen up
* horizontally locate the bubble
* copy the text from the buffer to video
* draw the bubble
* connect the speaker

```
: rad50endbubble ( x -- 0 )
    rad50endline  (rad50endbubble)
    ( speaker width height )
    dup 2+ scrollup
    cas2buf
```
#endif
#include "align.i65"
_rad50endbubble
    jsr enter
#include "page.i65"
    .word rad50endline
#include "page.i65"
    .word prad50endbubble       ; ( height width speaker )
#include "page.i65"
    .word dup
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word tor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _scrollup
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word plit
    .word VIDRAM+14*40
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus           ; horizontally locate here
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word false
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RAD50ENDSCENE
stack=( )
tags=math

#endif
rad50endscene
    jmp rad50exit

;--------------------------------------------------------------
#if 0
name=RAD50ENDTHOUGHT
stack=( )
tags=math

#endif
rad50endthought
    jmp rad50endthought

;--------------------------------------------------------------
#if 0
name=R50PROC
stack=( from to msg -- flag )
tags=math

* `from` is the start of a RAD50-encoded `script`
* `to` is the target address to where the `script` is unpacked in `segments`, which are delimited by `actions` ending in the `endscene` action
* `msg` is a pointer to a RAD50-encoded message

This word is executed iterative by [[R50SCRIPT]] until it
returns a true flag once the script is complete

|binary|means|value|h
|000000|endscript||
|000001|idea|1|
|000010|bartender|2|
|000011|||
|000100|||
|000101|Player|1|
|000110|Player|2|
|000111|Player|3|
|001000|||
|001001|Chick|1|
|001010|Chick|2|
|001011|Chick|3|
|001100|||
|001101|Interloper|1|
|001110|Interloper|2|
|001111|Interloper|3|



d;m 0;ii 33a;m 1ab0 1acf;n

```
    jsr rad50char           ; actor & lines
    beq r50proc09           ; done?
    tay
    and #$fc                ; isolate speaker bits.  0 = bar
    asl
    ;clc
    sbc #0                  ; 7 = player; 15 = chick; 23 = interloper
    sta msgspeaker          ; speaker offset (above right eye)
    tya
    and #$03                ; isolate height bits
    sta msgheight           ; for the bar, 1=thought, 2=bartender
    sta msglinecount
```



#endif
r50proc
    jsr rad50char           ; actor & lines
    beq r50proc09           ; done?
    and #%00000011          ; isolate count bits
    sta msgheight
    sta msglinecount
    eor msgchars,y          ; isolate speaker bits.  0 = bar
    asl
    ;clc
    sbc #0                  ; 7 = player; 15 = chick; 23 = interloper
    sta msgspeaker          ; speaker offset (above right eye)
r50proc01
    jsr rad50char           ; length
    sta msgwidth            ; of this line
    sta msgcharcount        ; countdown
    cmp msgmaxwidth         ; of longest line
    bcc r50proc02
    sta msgmaxwidth
r50proc02
    jsr rad50char           ; top of character loop
    beq r50altchar          ; space = 0
    cmp #27                 ; alpha?
    beq r50altpunct         ; comma = 27
    bcc r50alphanum       ; a-z = 1..26
    ;sec
    adc #19                 ; 0-9 = 28..37, +20 --> 48..57
    cmp #58                 ; numeric?
    bcc r50alphanum         ; number
    lsr
    bcc r50altpunct         ; period = 29
    jsr rad50char           ; from second alphabet, or action
    .byt $2c                ; BIT abs, skip next instruction
r50altpunct
    ;sec
    sbc #26
r50altchar
    tay
    lda r50table,y        ; alt character set
r50alphanum
    ldy msgtargptr
    inc msgtargptr
    sta (n+2),y             ; ship it
    dec msgcharcount
    bne r50proc02
    dec msglinecount
    bmi r50proc04           ; this is for the bar
    php
    clc
    lda #40
    sbc msgwidth            ; 40 is always > msgwidth
    adc msgtargptr          ; which always sets carry here
    sta msgtargptr
    plp
    bne r50proc01           ; loop back for more lines?
r50proc04
    lda #$ff
r50proc09
    tay
    jmp put

r50table
    .byt $20,$2c,$2e,$21, $22,$23,$24,$25       ;" ,.!"#$%
    .byt $26,$27,$28,$29, $2a,$2b,$2d,$2f       ;"&'()*+-/
    .byt $3a,$3b,$3c,$3d, $3e,$3f,$40,$1b       ;":;<=>?@[
    .byt $1c,$1d,$1e,$1f, $60,$5e               ;"\]^_|~

r50actions
    .word rad50endscene-1                       ;30
    .word rad50endline-1                        ;31
    .word _rad50endbubble-1                     ;32
    .word rad50togglespeaker-1                  ;33
    .word rad50endthought-1                     ;34

;--------------------------------------------------------------
#if 0
name=RAD50PROCESS
stack=( from to msg -- flag )
tags=math

* `from` is the start of a RAD50-encoded `script`
* `to` is the target address to where the `script` is unpacked in `segments`, which are delimited by `actions` ending in the `endscene` action
* `msg` is a pointer to a RAD50-encoded message

This word is executed iterative by [[RAD50DECODE]] until it
returns a true flag once the script is complete

|Action|Value|Description|h
|^endbubble|^33|^scroll the screen up `height`+2 lines<br/>copy text from buffer to screen<br/>wrap the text with a bubble<br/>wait for user to press spacebar|
|^endthought|^32|^turn on `RVS` bit<br/>erase thought area<br/>copy text to thought area|
|^endscene|^31|^same as endbubble,<br/>but displays next thought<br/>instead of waiting for spacebar press|
|^togglespeaker|^30|^|
|^append|^29|^|
#endif
rad50process
    jsr rad50char
    beq rad50altchar        ; space = 0
    cmp #27                 ; alpha?
    beq rad50altpunct       ; comma = 27
    bcc rad50alphanum       ; a-z = 1..26
    ;sec
    adc #19                 ; 0-9 = 28..37 --> 48..57
    cmp #58                 ; numeric?
    bcc rad50alphanum       ; number
    lsr
    bcc rad50altpunct       ; period = 29

    jsr rad50char           ; from second alphabet, or action
    cmp #(rad50actions-rad50table)
    bcc rad50altchar
    asl
    tay
    lda rad50actions-59,y
    pha
    lda rad50actions-60,y
    pha
    rts                     ; EXECUTE

rad50altpunct
    sbc #26
rad50altchar
    tay
    lda rad50table,y        ; alt character set
rad50alphanum
    ldy msgtargptr
    inc msgtargptr
    sta (n+2),y             ; ship it
    bpl rad50process        ; bra
rad50exit
    ldy #0
    lda msgtargptr          ; return length
    jmp put
rad50table
    .byt $20,$2c,$2e,$21, $22,$23,$24,$25       ;" ,.!"#$%
    .byt $26,$27,$28,$29, $2a,$2b,$2d,$2f       ;"&'()*+-/
    .byt $3a,$3b,$3c,$3d, $3e,$3f,$40,$1b       ;":;<=>?@[
    .byt $1c,$1d,$1e,$1f, $60,$5e               ;"\]^_|~

rad50actions
    .word rad50endscene-1                       ;30
    .word rad50endline-1                        ;31
    .word _rad50endbubble-1                     ;32
    .word rad50togglespeaker-1                  ;33
    .word rad50endthought-1                     ;34

;--------------------------------------------------------------
#if 0
name=R50SEGMENT
stack=( linecount\speaker -- )
tags=mmm

Perform one of the following:

* output a speech bubble
** speaker is 7, 15, or 23
* have an idea
** speaker is 0
** height is 1
* bartender talks
** speaker is 0
** height is 2


#endif
#include "align.i65"
r50segment
    ldy msgspeaker
    beq r50segment01
    ldy #2
r50segment01
    lda r50segtable+1,y
    pha
    lda r50segtable,y
    pha
    rts
r50segtable
    nop

;--------------------------------------------------------------
#if 0
name=R50SCRIPT
stack=( from to -- )
tags=mmm
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]

```
: r50script   ( from to -- width height 0 )
    dup 192 blank
    msg dup (msgend-msgtarg) erase
    3dup 2!  3 args
    begin
        r50proc
    while

    msg dup 14 erase  3dup 2!  3 args
    begin
        r50proc  ?dup
    while
        execute
    repeat ;
```


d;m 0;ii 33a;m 1a65 1a74;z


#endif
#include "align.i65"
_r50script
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 192
#include "pad.i65"
    .word _blank
#include "page.i65"
    .word msg
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt (msgend-msgtarg)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word twostore
#include "page.i65"
    .word three
#include "page.i65"
    .word args
#include "page.i65"
r50script01
    .word r50proc
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(r50script02-*+1)
#include "pad.i65"
    .word r50segment
#include "page.i65"
    .word branch
    .byt <(r50script01-*+1)
#include "pad.i65"
r50script02
    .word exit

;--------------------------------------------------------------
#if 0
name=RAD50DECODE
stack=( from to -- from to howmany )
tags=mmm
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]

```
: rad50decode   ( from to -- width height 0 )
    msg dup 14 erase  3dup 2!  3 args
    begin
        rad50process
        ?dup
    while
        execute
    repeat ;
```


d;m 0;ii 33a;m 1a65 1a74;z


#endif
#include "align.i65"
_rad50decode
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 192
#include "pad.i65"
    .word _blank
#include "page.i65"
    .word msg
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt (msgend-msgtarg)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _threedup
#include "page.i65"
    .word twostore
#include "page.i65"
    .word three
#include "page.i65"
    .word args
#include "page.i65"
rad50decode01
    .word rad50process
#include "page.i65"
    .word qbranch
    .byt <(rad50decode01-*+1)
#include "pad.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCRIPT
stack=( n -- )
tags=mmm
rad50decode and play back script #`n`

```
: script   ( n -- )
    2* 0 block tuck dup @ + + @ +
    cas2buf r50script ;
```
#endif
#include "align.i65"
_script
    jsr enter
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zero
#include "page.i65"
    .word _block
#include "page.i65"
    .word tuck
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word _r50script
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCRIPT2
stack=( n -- )
tags=mmm
rad50decode and play back script #`n`

```
: script2   ( n -- )
    2* 0 block tuck dup @ + + @ +
    cas2buf rad50decode cmove ;
```
#endif
#include "align.i65"
_script2
    jsr enter
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zero
#include "page.i65"
    .word _block
#include "page.i65"
    .word tuck
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word _rad50decode
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=GAME
stack=( -- )
tags=mmm
bubble position
the lesser of 38-w, x-1
the larger of 0, x-w



#endif
#include "align.i65"
_game
    jsr enter
#include "page.i65"
game01
    .word _pause
#include "page.i65"
    .word _pause
#include "page.i65"
    .word zero
#include "page.i65"
    .word _block
#include "page.i65"
    .word cas2buf
#include "page.i65"
    .word duptor
#include "page.i65"
    .word _rad50decode
#include "page.i65"
game02
    .word msg
#include "page.i65"
    .word nine
#include "page.i65"
    .word plus
#include "page.i65"
    .word cfetch
    .word plus
#include "page.i65"
    .word forty
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(game02-*+1)
#include "pad.i65"
    .word _rndmax
#include "page.i65"
game03
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word vidram
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?BUTTON
stack=( -- keyval|false )
tags=mmm
Detects a leading edge transition of either spacebar or return
key and leaves either key value on the stack, otherwise [[FALSE]]

LSTX contains the ASCII value of the current keypress
or 255 if no key is pressed

#endif
qbutton
    lda LSTX        ; $97 -- Current Key Pressed 255 = No Key
    ldy latch
    beq testkeys
    ldy #0
testthis
    cmp latch
    bne unlatch
testkeys
    cmp #13
    beq latchit
    cmp #32
    bne unlatch
latchit
    eor latch
    beq fail
    .byt $24        ; BIT zp
unlatch
    tya
    sta latch
    .byt $24        ; BIT zp
fail
    tya
    jmp pushya
latch
    .byt $0

; pettil-clean.a65
#echo .       pettil-clean.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
#echo .       remix - just the core, no Sweet16
; wrapper to build PETTIL core dictionary

; include debugging logic
#define DEBUG

; target machine
#define PET_ROM4

#include "../inc/cbm.def"
#include "../inc/pettil.def"

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================

#define basic $0401
*=basic-2
;--------------------------------------------------------------
#if 0
name=BASIC bootstrap
tags=system,nosymbol
PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to kick off the cold start routine
#endif
petbasic
    .word basic                 ; this will be the load address
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold
;--------------------------------------------------------------
#if 0
name=Zero page buffer and NEXT routine
tags=system,nosymbol
This buffer holds an image at load time of zero page between
$00..$8D. PETTIL cold start calls the `zpswap` routine to
exchange it with the BASIC zero page on entry or exit.

At $86 is PETTIL's 15-clock inner interpreter consisting of
just three instructions.  Whoa.  It's fast.
#endif
zpbuf
;==============================================================
;==== zero page buffer and user area                       ====
;==============================================================
;
;
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,uarea,$3003   ; overlapping
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ;
    nop                     ; see "RANDU" for how it works
    nop                     ;
;
;       NEXT
;               +IP
;               [IP] -> PC
;
; minimalist NEXT
;$86
zpnext
    inc ip                  ; [5]
    inc ip                  ; [5]
;ip = *+1
    jmp ($cafe)             ; [5]

                            ;[15] cycles total
;$8D TIME                   ; end of zero page buffer, Jiffy clock is here

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;--------------------------------------------------------------
#if 0
name=User Area
stack=( -- )
tags=system,uservar,nosymbol
Storage for user variables and initialization data for some of them
#endif
userarea
; uarea initialization data
; WARM
userup          .word uarea     ;
usersp0         .word bos+1     ;
userrp0         .word $01fe     ;
userwarm

; COLD
userfence       .word cold      ;
userdp          .word cold      ;
userstartup     .word hot       ; bootstrap COLD->HOT->LAUNCH
usermemsiz      .word 0
userdrvnum      .word 1         ; cassette #1 is default device
userfilename    .word 0         ; counted string, default filename
usercold

; SOFT
; everything below initializes to 0 at COLD and is untouched by WARM
;
; memory pointers, in descending order
usercontext     = usercold+0
usercurrent     = usercold+2
usertdict       = usercold+6
usersymtail     = usercold+8
usersymnew      = usercold+10
usersymtab      = usercold+12
uservmbuf       = usercold+14
usernumvmpkt    = usercold+16
userblk         = usercold+18
userscr         = usercold+20
usereditingq    = usercold+22
userwritableq   = usercold+24
usernumvoc      = usercold+26
usernewest      = usercold+28
usernewdp       = usercold+30
userwarning     = usercold+32
userbase        = usercold+34
userdpl         = usercold+36
userhld         = usercold+38
usertoin        = usercold+40
userspan        = usercold+42
usernumtib      = usercold+44
usernumout      = usercold+46
usernumline     = usercold+48
userstate       = usercold+50
usercsp         = usercold+52

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+64,0

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;--------------------------------------------------------------
#if 0
name=Core includes
tags=nosymbol
These are the source files included in [[PETTIL-CORE]]
#endif
corebase
#include "core-subroutines.a65"
#include "../core-user.a65"
#include "../core-inner.a65"
#include "../core-nucleus.a65"
#include "../core-device.a65"
#include "../core-pet.a65"
#include "core-numword.a65"
#include "../core-double.a65"
#include "../core-string.a65"
;#include "../core-vm.a65"

;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=system,nosymbol
Dropping out to BASIC can be accomplished on purpose with MON
(to get to TIM), then .X to get to BASIC.  It also will happen
by mistake if cassette i/o is interrupted by the STOP key or
any tape error.  There may be other ways.  WARM should be able
to bring the system back to a usable state.

!!Tasks

* aloha
* - swap zero page with zpbuf
* - switch Sweet16<-->TIM BRK vector
* - switch PETTIL<-->BASIC IRQ vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* print start message CR,"WELCOME TO PETTIL!",CR
* STARTUP @ EXECUTE
#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
#include "toforth.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable

;--------------------------------------------------------------
#if 0
name=COLD
stack=( -- )
tags=system,nosymbol
A sample application
#endif
cold
    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1

    jmp cold2warm               ; start Forth, run HOT next

;--------------------------------------------------------------
#if 0
name=HOT
stack=( -- )
tags=system,nosymbol
A sample application
#endif
hot
#include "enter.i65"
hot01
	.word cr
#include "page.i65"
	.word clit
	.byt 39
#include "pad.i65"
	.word zero
#include "page.i65"
	.word pdo
#include "page.i65"
hot02
	.word randu
#include "page.i65"
	.word one
#include "page.i65"
	.word andx
#include "page.i65"
	.word clit
	.byt 205
#include "pad.i65"
	.word plus
#include "page.i65"
	.word emit
#include "page.i65"
	.word ploop
	.byt <(hot02-*+1)
#include "pad.i65"
	.word branch
	.byt <(hot01-*+1)

; core-numword.a65
#echo .       core-numword.a65          NUMBER and WORD

;--------------------------------------------------------------
#if 0
name=DIGIT
stack=( char base -- digit true | false )
tags=numword

 Converts a single character to a digit using the current number
 base.  A flag on TOS indicates whether the conversion succeeded.
~wut? possible to code golf this down with BCD tricks?
"http://www.6502.org/tutorials/decimal_mode.html
#endif
digit
    ldy #$ff        ; assume success
    lda stackl,x    ; get the character
    sec
    sbc #'0'
    bcc digit02     ; char was < '0'? not a digit, fail
    cmp #10
    bcc digit01     ; digit is in the range 00-09
    sbc #7          ; no? alphabet adjust 'A' --> $0a
digit01
    cmp tos         ; compare to current number base
    bcs digit02     ; not in current number base? fail
    sta stackl,x    ; digit in the current number base
    .byt $2c        ; BIT xxyy, skip the next two bytes
digit02
    iny             ; fail, set flag to 0
    inx             ; drop the stack

    tya             ; ya = flag word $0000 or $ffff
    jmp put         ; next!

;--------------------------------------------------------------
#if 0
name=HOLD
stack=( char -- )
tags=numword


 Inserts  character into a pictured numeric out-
 put string.
 char is inserted into a pictured numeric output
 string.  Typically used between  <#  and  #> .
#endif
_hold
#include "enter.i65"
    .word minusone
#include "page.i65"
    .word hld
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=<#
stack=( -- )
tags=numword


#endif
_ltsharp
#include "enter.i65"
    .word _pad              ; ( pad )
#include "page.i65"
    .word hld               ; ( pad hld )
#include "page.i65"
    .word store             ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#>
stack=
tags=numword

#endif
_sharpgt
#include "enter.i65"
    .word twodrop
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
    .word exit

;--------------------------------------------------------------
#if 0
name=SIGN
stack=( n -- )
tags=numword

 If n is negative, an ASCII "-" (minus sign) is appended to the
 pictured numeric output string.  Typically used between <# and #> .

#endif
_sign
#include "enter.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(sign01-*+1)
#include "pad.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word _hold
#include "page.i65"
sign01
    .word exit

;--------------------------------------------------------------
#if 0
name=#
stack=( +d1 -- +d2 )
tags=numword

 +d1 is divided by BASE and the quotient is
 placed onto the stack.  The remainder is con-
 verted to an ASCII character and appended to
 the output string toward lower memory ad-
 dresses.
 The remainder of +d1 divided by the value of
 BASE is converted to an ASCII character and ap-
 pended to the output string toward lower memory
 addresses.  +d2 is the quotient and is main-
 tained for further processing.  Typically used
 between <# and #> .
#endif
_sharp
#include "enter.i65"
    .word base              ; ( d base )
#include "page.i65"
    .word fetch             ; ( d @base )
#include "page.i65"
    .word udslashmod        ; ( rem d )
#include "page.i65"
    .word rot               ; ( d rem )
#include "page.i65"
    .word to6502
    lda tos
    sed
    cmp #10
    adc #'0'
    cld
    sta tos                 ; ( d char )
#include "toforth.i65"
    .word _hold             ; ( d )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#S
stack=( d -- )
tags=numword

#endif
_sharps
#include "enter.i65"
sharps01        .word _sharp            ; ( d )
#include "page.i65"
    .word twodup           ; ( d d )
#include "page.i65"
    .word dzeq              ; ( d flag )
#include "page.i65"
    .word qbranch
    .byt <(sharps01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(U.)
stack=
tags=numword,nosymbol

#endif
_pudot
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=U.
stack=( n -- )
tags=numword

#endif
_udot
#include "enter.i65"
    .word _pudot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=U.R
stack=( u n -- )
tags=numword

 u is converted using the value of BASE and then
 displayed as an unsigned number right-aligned
 in a field +n characters wide.  If the number
 of characters required to display u is greater
 than +n, an error condition exists.

#endif
_udotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pudot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(.)
stack=( n -- )
tags=nosymbol,i/o,inner
#endif
_pdot
#include "enter.i65"
    .word dup               ; ( n n )
#include "page.i65"
    .word abs               ; ( n +n )
#include "page.i65"
    .word zero              ; ( n +d )
#include "page.i65"
    .word _ltsharp          ; ( n +d )
#include "page.i65"
    .word _sharps           ; (
#include "page.i65"
    .word rot
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.
stack=( n -- )
tags=numword


 The value of n is displayed in a free field for-
 mat with a leading minus sign if n is negative.
#endif
_dot
#include "enter.i65"
    .word _pdot             ; ( addr count )
#include "page.i65"
    .word type              ; ( )
#include "page.i65"
    .word _space            ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.R
stack=( n1 w -- )
tags=numword

#endif
_dotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pdot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UD.)
stack=( d -- )
tags=numword,nosymbol

#endif
_puddot
#include "enter.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
    .word exit

;--------------------------------------------------------------
#if 0
name=UD.
stack=( d -- )
tags=numword

#endif
_uddot
#include "enter.i65"
    .word _puddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UD.R
stack=( d n -- )
tags=numword

#endif
_uddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _puddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(D.)
stack=( d -- )
tags=numword,nosymbol

#endif
_pddot
#include "enter.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word dabs
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=D.
stack=( d -- )
tags=numword

#endif
_ddot
#include "enter.i65"
    .word _pddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
    .word exit

;--------------------------------------------------------------
#if 0
name=D.R
stack=( d n -- )
tags=numword

#endif
_ddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
    .word exit

;--------------------------------------------------------------
#if 0
name=?
stack=( addr -- )
tags=i/o,memory
Fetches the value at `addr` and outputs it via [[.]]

#endif
_question
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word _dot
#include "page.i65"
    .word exit


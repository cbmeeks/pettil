; pettil-compiler.a65
#echo .       pettil-compiler.a65       Compiler

;--------------------------------------------------------------
#if 0
name=HERELSB
stack=( -- c )
tags=compiler
 Returns the least significant byte of DP
#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ALLOT
stack=( n -- )
tags=compiler

#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,
stack=( w -- )
tags=compiler

#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C,
stack=( b -- )
tags=compiler

#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,$
stack=( ?? -- ?? )
tags=compiler

#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,CFA
stack=( addr -- )
tags=compiler

 Set the code field of a new definition, taking page alignment
 into account.  The address is the creator word's CFA, e.g. : or
 VARIABLE

```
: ,cfa   ( xt -- )
    herelsb $fc =
    if
        $ea c,
    then
    $20 c,
    , ;

```
#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,XT
stack=( xt -- )
tags=compiler

 Encloses the execution token into the dictionary, paying heed
 to page alignment and inserting the 'page' token into the
 dictionary stream at page boundaries


```
: ,xt   ( xt -- )
     herelsb $fc >
     if
         ['] page ,
         herelsb
         if
             dp 1+!
         then
     then
     , ;

```
#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILING?
stack=( -- f )
tags=compiler,nosymbol
True if STATE is on

```
: compiling?   ( -- flag )
   state @ ;
```
#endif
_compilingq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?COMP
stack=( -- )
tags=compiler,nosymbol

 Check the STATE variable to see if we are compiling, issue an
 error if STATE is off (INTERPRET mode)

```
: ?comp   ( -- )
    5  compiling?  ?: drop fail ;
```
#endif
_qcomp
#include "enter.i65"
    .word clit
    .byt 5                      ; "COMPILATION ONLY"
#include "pad.i65"
    .word _compilingq
#include "page.i65"
    .word pquerycolon
    .word drop
    .word fail
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?:
stack=( "name1" "name2" -- )
tags=control,compiler
flags=immediate
Immediate word that compiles its own runtime word (?:) and two branches. The first branch is the true
branch, and the second is the false branch.  One of those is executed by (?:) at runtime.

Used in the form

```
( flag ) :? this that

is equivalent to

if this else that then

: ?:   ( "name1" "name2" -- )
    ?comp compile (?:) ' , ' , ; immediate
```
#endif
_querycolon
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _compile
    .word pquerycolon
#include "pad.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler

 Toggle the smudge bit so it won't be found by FIND.  In PETTIL,
 the smudge bit does double duty, also marking as inactive any
 words that have been redefined.

#endif
smudge
    ldy #0
    lda (tos),y
    eor #$20
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
     dup nfalen  over c@
  ( nfa len len|flags )
     $40 and 0<> +             \ vocab bit? drop final char
     1 +under type ;

```
#endif
_iddot
#include "enter.i65"
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word andx
#include "page.i65"
    .word zne
#include "page.i65"
    .word plus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?VOCAB
stack=( name -- name )
tags=compiler,nosymbol

```
\ if current vocabulary isn't root, append the vocid to name and set V bit
: ?vocab   ( name -- name )
    current vocid ?dup
    if
        over voc+
    then ;

```
#endif
_qvocab
#include "enter.i65"
    .word current
#include "page.i65"
    .word _vocid
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qvocab01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word vocplus
#include "page.i65"
qvocab01
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( addr -- )
tags=compiler,nosymbol

 Creates a new symbol table entry with a CFA linking back to HERE,
 where (CREATE) will compile "jsr addr", with consideration for page
 alignment


```
: (create)   ( addr -- )
\ parse input stream to here, and search context and its parents for name
     exists? nip
  ( addr flag )
     here ?vocab swap          \ append vocabid if current != core
  ( addr here flag )
     if
  ( addr here )
\ is potential duplicate word in the current (not a parent) vocabulary?
\ otherwise it's not a redefinition, treat it as a new word
         (find) nip
  ( addr nfa flag )
         if
  ( addr nfa )
             [ RVSON ] cliteral emit
             dup id. smudge    \ smudge the previously existing word
             [ RVSOFF ] cliteral emit
             ."  EXISTS"
             here              \ leave the address of the name
        then
  ( addr here )
    then
   ( addr here )
     symtail @                 \ add the symbol to the symbol table
   ( addr here symtail )
     2dup !                    \ new CFA
   ( addr here symtail )
     2+ dup newest !           \ set NEWEST
   ( addr here symtail+2 )
     over nfalen 1+ 2dup +     \
   ( addr here symtail+2 len+1 symtail+len+3 )
     dup symtail ! 3 erase     \ mark new symtail
   ( addr here symtail+2 len+1 )
     third bloomhash cbit!     \ add symbol to the bloom filter
   ( addr here symtail+2 len+1 )
     cmove
   ( addr )
     ,cfa ; \ enclose "JSR DOCREATE" in the dictionary

```
#endif
_pcreate
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word nip
#include "page.i65"
    .word here
#include "page.i65"
    .word _qvocab
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(create02-*+1)
#include "pad.i65"
    .word _pfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(create02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word smudge
#include "page.i65"
    .word clit
    .byt RVSOFF
#include "pad.i65"
    .word emit
#include "page.i65"
    .word pdq
    .byt (pcreate01-*-1)
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
create02
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twodup
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
   .word newest
#include "page.i65"
   .word store
#include "page.i65"
   .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word third
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _commacfa
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CREATE
stack=( -- ; parses the next token in the input stream )
tags=compiler,defining
 A defining word executed in the form

     `CREATE <name>`

     Creates a dictionary entry for <name>.  After <name> is
     created, the next available dictionary location is the first
     byte of <name>'s parameter field.  When <name> is
     subsequently executed, the address of the first byte of
     <name>'s parameter field is left on the stack.  CREATE does
     not allocate space in <name>'s parameter field.

#endif
_create
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:
stack=( -- )
tags=compiler,defining,fig
 A defining word executed in the form:

 `: <name> ... ;`

 Creates a word definition for `<name>` in the compilation
 vocabulary and sets compilation state true. Text from the
 input stream is subsequently compiled.  `<name>` is called
 a "colon definition".  The newly created word definition
 for <name> cannot be found in the dictionary until the
 corresponding `;` or `;CODE` is successfully processed.

 An error condition exists if a word is not found and cannot
 be converted to a number or if, during compilation from mass
 storage, the input stream is exhausted before encountering `;`
 or `;CODE`.  The stack is checked for balance when a `;`
 terminates the definition.

!!! pronounced: "colon"

```
: :   ( -- )
      current @ context !
      [ 'enter ]  (create)
      !csp   latest smudge  ] ;

```
#endif
_colon
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word plit
    .word enter
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _storecsp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;
stack=( -- )
tags=compiler,fig
flags=immediate
 An immediate word which terminates a colon-definition and
 stops further compilation. Compiles the run-time `exit`

!!! pronounced: "semi"

```
: ;   ( -- )
     ?csp
     ['] exit compile   latest smudge [ ; immediate

```
#endif
_semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CONSTANT
stack=( n -- )
tags=compiler

: constant   ( n -- )

#endif
_constant
#include "enter.i65"
    .word plit
    .word doconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CCONSTANT
stack=( n -- )
tags=compiler

 create an 8-bit constant

#endif
_cconstant
#include "enter.i65"
    .word plit
    .word docconst
#include "pad.i65"
    .word _pcreate
#include "enter.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VARIABLE
stack=( -- )
tags=compiler,forth-79
               A defining word executed in the form:
                       `VARIABLE <name>`
               A dictionary entry for <name> is created and two bytes are
               ALLOTted in its parameter field.  This parameter field is to
               be used for contents of the variable.  The application is
               responsible for initializing the contents of the variable
               which it creates.  When <name> is later executed, the
               address of its parameter field is placed on the stack.
#endif
_variable
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LATEST
stack=( -- nfa )
tags=compiler

 Leaves the name field address of the top-most word in the
 symbol table.

#endif
_latest
#include "enter.i65"
    .word newest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler

 returns the NFA of a given word, or 0 if this CFA isn't found
 in the symbol table.

```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ) ( R; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ) ( R; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;

```
#endif
_toname
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler

#endif
namefrom
    sec
    lda tos
    sbc #2
    sta tos
    bcs namefrom01
    dec tos+1
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=!CSP
tags=nosymbol,compiler
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$,
stack=( addr -- )
tags=string
Enclose a quoted string in the dictionary
#endif
_stringcomma
#include "enter.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$>PAD
stack=( addr -- )
tags=string
Move a string at `addr` to the [[PAD]]
#endif
_stringtopad
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word duptor
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _move
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(
stack=( text) -- )
tags=forth-83
flags=immediate
Begins a Forth comment, terminated by the next ')' character in
the input stream
#endif
_lparen
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name="
stack=( text" == ) ( -- addr )
tags=string
flags=immediate
State-smart string literal.  In compile mode, encloses a string
in the dictionary.  In interpret mode, returns the address of a
string ([[PAD]])

```
: "   ( text" == ) ( -- addr )
    state @
    dup if compile (") then
    [ ascii " ] literal  word >in 1+!
    ( state here )
    swap ?: $, $>pad ;

```
!!!pronounced: "quote"
#endif
_quote
#include "enter.i65"
    .word _compilingq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(quote01-*+1)
#include "pad.i65"
    .word _compile
    .word pquote
#include "pad.i65"
quote01
    .word clit
    .byt '"'
#include "pad.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word pquerycolon
    .word _stringcomma
    .word _stringtopad
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=."
stack=( text" -- )
tags=compiler,i/o
flags=immediate
Output a string

Scans ahead in the input stream for a close " character and
encloses the string in the dictionary.

#endif
_dotq
#include "enter.i65"
    .word _compilingq
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(dotq01-*+1)
#include "pad.i65"
    .word _compile
    .word pdq
#include "pad.i65"
dotq01
    .word clit
    .byt '"'
#include "pad.i65"
	.word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word pquerycolon
    .word _stringcomma
    .word _stringdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT"
stack=( flag -- ) ( -- ; compiling )
tags=compiler,~wut?
flags=immediate

todo: handle page boundary crossings after error text
#endif
_abortq
#include "enter.i65"
    .word _dotq
#include "page.i65"
    .word _compile
    .word _abort
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAIRS
stack=( a b -- )
tags=compiler,nosymbol,control
Aborts compilation if `a`<>`b`

!!! pronounced: "query-pairs"
#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
#if 0
name=?CSP
stack=
tags=compiler,nosymbol

#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILE
stack=( -- )
tags=compiler,~wut?

todo: xxff buggish?
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup           ; check for xxFF here, on this copy?
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[
stack=( -- )
tags=compiler
flags=immediate

#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=]
wikiname=}
stack=( -- )
tags=compiler

#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
    .word qstack
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(;CODE)
stack=( -- )
tags=compiler

#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOES>
stack=( -- )
tags=compiler
flags=immediate

#endif
_does
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.(
stack=( -- )
tags=compiler
flags=immediate

#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _word
#include "page.i65"
    .word toin
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(PUNCT?)
stack=
tags=compiler

#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PUNCT?
stack=
tags=compiler

#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>MARK
stack=
tags=compiler

#endif
_qtomark
#include "enter.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?<MARK
stack=
tags=compiler,control,nosymbol

#endif
_qfrommark
#include "enter.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>RESOLVE
stack=
tags=compiler,control,nosymbol

#endif
_qtoresolve
#include "enter.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word here
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cstore
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
#if 0
name=?<RESOLVE
stack=
tags=compiler,control,nosymbol
flags=immediate


#endif
_qltresolve
#include "enter.i65"
    .word swap
#include "page.i65"
    .word here
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
#if 0
name=ADD>MARK
stack=
tags=compiler,nosymbol,control

#endif
_addtomark
#include "enter.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01
    .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[']
wikiname={'}
stack=( == ) ( -- n )
tags=compiler
flags=immediate
Enclose the code field address of the next word in the input stream
into the dictionary as a [[literal|LITERAL]]
#endif
_brtick
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IMMEDIATE
stack=
tags=compiler

#endif
_immediate
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $80
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VOCABULARY
stack=
tags=compiler,defining

 see FD-V05N3 p. 5
#endif
_vocabulary
    .word plit
    .word dovocab
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(VOCAB)
stack=( -- )
tags=compiler,primitive
The business end of a word defined by VOCABULARY.  Gets the PFA
of the vocabulary and stores it in CONTEXT
#endif
dovocab
    pla
    clc
    adc #1
    sta n
    pla
    bcc dovocab01
    tay
    iny
    tya
dovocab01
    ldy #usercontext-userarea+1
    sta (up),y
    lda n
    dey
    sta (up),y
    jmp next

;--------------------------------------------------------------
#if 0
name=BEGIN
stack=
tags=compiler,control
flags=immediate

#endif
_begin
#include "enter.i65"
    .word _qfrommark
#include "page.i65"
    .word one
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=THEN
stack=
tags=compiler,control
flags=immediate

#endif
_then
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DO
stack=
tags=compiler
flags=immediate

#endif
_do
#include "enter.i65"
    .word _compile
    .word pdo
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?DO
stack=
tags=compiler,control
flags=immediate

#endif
_qdo
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOOP
stack=
tags=compiler
flags=immediate

#endif
_loop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "page.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=+LOOP
stack=
tags=compiler,control
flags=immediate

#endif
_plusloop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "page.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LEAVE
stack=
tags=compiler
flags=immediate

#endif
_leave
#include "enter.i65"
    .word _compile
    .word pleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=?LEAVE
stack=
tags=compiler,control
flags=immediate

#endif
_qleave
#include "enter.i65"
    .word _compile
    .word pqleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=UNTIL
stack=
tags=compiler
flags=immediate

#endif
_until
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AGAIN
stack=
tags=compiler,control
flags=immediate

#endif
_again
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REPEAT
stack=
tags=compiler,control
flags=immediate

#endif
_repeat
#include "enter.i65"
    .word _again
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IF
stack=
tags=compiler,control
flags=immediate

#endif
_if
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ELSE
stack=
tags=compiler,control
flags=immediate

#endif
_else
#include "enter.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WHILE
stack=
tags=compiler
flags=immediate

#endif
_while
#include "enter.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2CONSTANT
stack=
tags=compiler

#endif
_twoconst
#include "enter.i65"
    .word plit
    .word do2const
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2VARIABLE
stack=
tags=compiler

#endif
_twovariable
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[COMPILE]
wikiname={COMPILE}
stack=( -- )
tags=compiler,forth-79,forth-83
flags=immediate
Used in the form:

   `[COMPILE] <name>`

Forces compilation of the following word <name>.  This
allows compilation of an immediate word when it would
otherwise have been executed.


!!!pronounced: "bracket-compile"

#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

#if 0
name=DROPLIT
stack=( d == ) ( -- n )
tags=compiler
Compiles the least significant 16 bits of a double into the dictionary as
a numeric literal

!!!pronounced: drop-lit
#endif
_droplit
#include "enter.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(literal00-*+1)

;--------------------------------------------------------------
#if 0
name=LITERAL
stack=( n == ) ( -- n )
tags=compiler
Enclose `n` into the dictionary.  At runtime, leaves `n` on the
stack.
#endif
_literal
#include "enter.i65"
literal00
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01
    .word _compile
    .word plit
#include "pad.i65"
    .word _comma
#include "page.i65"
literal02
    .word exit

;--------------------------------------------------------------
#if 0
name=DLIT
stack=( d == ) ( -- d )
tags=compiler
Compiles a double into the dictionary as a numeric literal
!!!pronounced: d-lit
#endif
_dlit
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOAD1)
stack=( lineaddr 39|79 -- )
tags=vm,~wut?
Beginnings of LOAD
#endif
pload1
    lda #3
    sta DFLTN                   ; Screen = device 3
    lda stackl,x
    sta PNT                     ; PNT pointer - current scren line address
    lda stackh,x
    sta PNT+1
    lda #0
    sta PNTR                    ; PNTR cursor column on current line
    lda tos
    sta LNMX                    ; LNMX physical screen line length
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( scr -- )
tags=compiler

 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  >IN  BLK  BLOCK

#endif
_load
#include "enter.i65"
    .word _block
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word clit
    .byt 39
#include "pad.i65"
    .word pload1
#include "page.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word _clrscr
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-FORTH
stack=( -- )
tags=compiler,unimplemented

 Writes a binary file of the core dictionary to mass storage
 ($0401 to HERE)

#endif
_saveforth
#include "enter.i65"
    .word exit

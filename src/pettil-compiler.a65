; pettil-compiler.a65
#echo .       pettil-compiler.a65       Compiler

;--------------------------------------------------------------
#if 0
name=HERELSB
stack=( -- c )
tags=compiler,nosymbol
 Returns the least significant byte of DP
#endif
#include "align.i65"
_herelsb
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ALLOT
stack=( n -- )
tags=compiler

#endif
#include "align.i65"
_allot
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,
stack=( w -- )
tags=compiler

#endif
#include "align.i65"
_comma
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C,
stack=( b -- )
tags=compiler

#endif
#include "align.i65"
_ccomma
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CFA,
stack=( addr -- )
tags=compiler,nosymbol

 Set the code field of a new definition, taking page alignment
 into account.  The address is the creator word's CFA, e.g. : or
 VARIABLE

```
: cfa,   ( xt -- )
    \ test for $xxFC or $xxFD, insert NOP
    begin
        herelsb $fe and $fc =
    while
        $ea c,
    repeat
    $20 c,
    , ;

```
#endif
#include "align.i65"
_cfacomma
    jsr enter
#include "page.i65"
cfacomma01
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fe
#include "pad.i65"
    .word andx
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(cfacomma02-*+1)
#include "pad.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(cfacomma01-*+1)
#include "pad.i65"
cfacomma02
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=XT,
stack=( xt -- )
tags=compiler,nosymbol

 Encloses the execution token into the dictionary, paying heed
 to page alignment and inserting the 'page' token into the
 dictionary stream at page boundaries


```
: xt,   ( xt -- )
     herelsb $fc >
     if
         ['] page ,
         herelsb
         if
             dp 1+!
         then
     then
     , ;

```
#endif
#include "align.i65"
_xtcomma
    jsr enter
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(xtcomma01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(xtcomma01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
xtcomma01
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILING?
stack=( -- f )
tags=compiler,nosymbol
True if STATE is on

```
: compiling?   ( -- flag )
   state @ ;
```
#endif
#include "align.i65"
_compilingq
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?ERROR
stack=( flag errcode -- )
tags=ext,compiler,nosymbol
Aborts with a numbered error if the flag is true

```
: ?error   ( flag errcode -- )
    swap  ?: fail drop ;
```
#endif
#include "align.i65"
_qerror
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word pquerycolon
    .word fail
    .word drop
#include "pad.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=?COMP
stack=( -- )
tags=compiler,nosymbol

 Check the STATE variable to see if we are compiling, issue an
 error if STATE is off (INTERPRET mode)

```
: ?comp   ( -- )
    compiling? 5 ?error ;
```
#endif
#include "align.i65"
_qcomp
    jsr enter
#include "page.i65"
    .word _compilingq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word clit
    .byt 5                      ; "COMPILATION ONLY"
#include "pad.i65"
    .word _qerror
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILE
stack=( -- )
tags=compiler,nosymbol

~ xxff buggish?
#endif
#include "align.i65"
_compile
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup           ; ~ check for xxFF here, on this copy?
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _xtcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler,nosymbol

 Toggle the smudge bit so it won't be found by FIND.  In PETTIL,
 the smudge bit does double duty, also marking as inactive any
 words that have been [[REDEFINED]].

#endif
smudge
    ldy #0
    lda (tos),y
    eor #bit5
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
     dup nfalen  over c@
  ( nfa len len|flags )
     $40 and 0<> +             \ vocab bit? drop final char
     1 +under type ;

```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word andx
#include "page.i65"
    .word zne
#include "page.i65"
    .word plus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol

* for duplicate names
** issues "EXISTS" warning message
** sets REDEFINED user variable
* new symbol table entry
** symbol cfa links back to HERE
** compiles page-aligned `JSR cfa` at HERE
```
: (create)   ( cfa -- )
    bl word dup c@ 0=
    if 2drop exit then
    current c@ (vfind) nip
    if
        [ RVSON ] cliteral emit
        dup id.
        redefined !
        ." [RVSOFF] EXISTS"
        here
    then
    ( cfa here )
    dup bloom# >bit bloom + cbit!       \ add to bloom filter
    ( cfa here )
    symtail @  dup>r  2+ dup newest !   \ set NEWEST
    ( cfa here symtail+2 ; symtail )
    over nfalen 1+ 
    ( cfa here symtail+2 nfalen+1 ; symtail )

    current @ ?dup 
    if
    ( cfa here symtail+2 nfalen+1 current ; symtail )
        >r  here c@ $40 or here c!
    ( cfa here symtail+2 nfalen+1+1 ; current symtail )
        r> over here + c!  1+
    ( cfa here symtail+2 nfalen+1+1 ; symtail )
    then
    ( cfa here symtail+2 nfalen+1+voc ; symtail )
    
    2dup +
    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )
    dup symtail ! 3 erase              \ mark new symtail
    ( cfa here symtail+2 len+1 ; symtail )
    cmove cfa,
    ( cfa ; symtail )
    here 3- r> ! ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pcreate03-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit
#include "page.i65"
pcreate03
    .word current
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word redefined
#include "page.i65"
    .word store
#include "page.i65"
    .word pdq
    .byt pcreate01-*-1
    .byt RVSOFF
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
pcreate02
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word newest
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pcreate04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word here
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word orx
#include "page.i65"
    .word here
#include "page.i65"
    .word cstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
pcreate04
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CREATE
stack=( -- ; parses the next token in the input stream )
tags=compiler,defining
 A defining word executed in the form

     `CREATE <name>`

     Creates a dictionary entry for <name>.  After <name> is
     created, the next available dictionary location is the first
     byte of <name>'s parameter field.  When <name> is
     subsequently executed, the address of the first byte of
     <name>'s parameter field is left on the stack.  CREATE does
     not allocate space in <name>'s parameter field.

#endif
#include "align.i65"
_create
    jsr enter
#include "page.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:
stack=( -- )
tags=compiler,defining,fig
 A defining word executed in the form:

 `: <name> ... ;`

 Creates a word definition for `<name>` in the compilation
 vocabulary and sets compilation state true. Text from the
 input stream is subsequently compiled.  `<name>` is called
 a "colon definition".  The newly created word definition
 for <name> cannot be found in the dictionary until the
 corresponding `;` or `;CODE` is successfully processed.

 An error condition exists if a word is not found and cannot
 be converted to a number or if, during compilation from mass
 storage, the input stream is exhausted before encountering `;`
 or `;CODE`.  The stack is checked for balance when a `;`
 terminates the definition.

!!! pronounced: "colon"

```
: :   ( -- )
      [ 'enter ]  (create)
      !csp   latest smudge  redefined off  ] ;
```
#endif
#include "align.i65"
_colon
    jsr enter
#include "page.i65"
    .word redefined
#include "page.i65"
    .word off                   ; turn REDEFINED off before (CREATE)
#include "page.i65"
    .word plit
    .word enter
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _storecsp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge                ; smudge the newly minted symbol
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;
stack=( -- )
tags=compiler,fig
flags=immediate
 An immediate word which terminates a colon-definition and
 stops further compilation. Compiles the run-time `exit`

!!! pronounced: "semi"

```
: ;   ( -- )
    ?csp
    ['] exit compile   
    latest smudge       \ unsmudge the new colon definition
    redefined dup @ dup  :? smudge drop  off
    [ ; immediate
```
#endif
#include "align.i65"
_semi
    jsr enter
#include "page.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "pad.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word redefined
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word pquerycolon
    .word smudge
    .word drop
#include "pad.i65"
    .word off
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?:
stack=( "name1" "name2" -- )
tags=control,compiler
flags=immediate
Immediate word that compiles its own runtime word (?:) and two branches. The first branch is the true
branch, and the second is the false branch.  One of those is executed by (?:) at runtime.

Used in the form

```
( flag ) :? this that

is equivalent to

if this else that then

: ?:   ( "name1" "name2" -- )
    ?comp 
    herelsb $f8 > 
    if
        ['] page ,
        here herelsb xor $100 + dp !
    then
    compile (:?) ' , ' , ; immediate
```
~ this is some ugly page management.  consider using a call to NEXT1
followed by NOP instruction to word-align, if it's odd and near the 
top of the page.  Also an inline call to `padjust` 
#endif
#include "align.i65"
_querycolon
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $f8
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(querycolon01-*+1)
#include "pad.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word here
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word xor
#include "page.i65"
    .word plit
    .word $100
#include "pad.i65"
    .word plus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
querycolon01
    .word _compile
    .word pquerycolon
#include "pad.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=<BUILDS
stack=( -- ; parses the next token in the input stream )
tags=compiler,defining
 A defining word executed in the form

     `<BUILDS <name> ... DOES> ... ;`

     Creates a dictionary entry for <name>.  After <name> is
     created, the next available dictionary location is the first
     byte of <name>'s parameter field.  When <name> is
     subsequently executed, the address of the first byte of
     <name>'s parameter field is left on the stack.  CREATE does
     not allocate space in <name>'s parameter field.

#endif
#include "align.i65"
_builds
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word tdp
#include "page.i65"
    .word _fetchswapstore
#include "page.i65"
    .word plit
    .word dodoes
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOES>
stack=( -- )
tags=compiler
#endif
#include "align.i65"
_does
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word tdp
#include "page.i65"
    .word _fetchswapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CONSTANT
stack=( n -- )
tags=compiler

: constant   ( n -- )

#endif
#include "align.i65"
_constant
    jsr enter
#include "page.i65"
    .word plit
    .word doconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CCONSTANT
stack=( n -- )
tags=compiler

 create an 8-bit constant

#endif
#include "align.i65"
_cconstant
    jsr enter
#include "page.i65"
    .word plit
    .word docconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VARIABLE
stack=( -- )
tags=compiler,forth-79
               A defining word executed in the form:
                       `VARIABLE <name>`
               A dictionary entry for <name> is created and two bytes are
               ALLOTted in its parameter field.  This parameter field is to
               be used for contents of the variable.  The application is
               responsible for initializing the contents of the variable
               which it creates.  When <name> is later executed, the
               address of its parameter field is placed on the stack.
#endif
#include "align.i65"
_variable
    jsr enter
#include "page.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LATEST
stack=( -- nfa )
tags=compiler

 Leaves the name field address of the top-most word in the
 symbol table.

#endif
#include "align.i65"
_latest
    jsr enter
#include "page.i65"
    .word newest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler

 returns the NFA of a given word, or 0 if this CFA isn't found
 in the symbol table.

```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ) ( R; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ) ( R; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;

```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler

todo: could probably be squeezed as 2- @
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=!CSP
tags=compiler,nosymbol
#endif
#include "align.i65"
_storecsp
    jsr enter
#include "page.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$,
stack=( addr -- )
tags=string
Enclose a quoted string in the dictionary
#endif
#include "align.i65"
_stringcomma
    jsr enter
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$>PAD
wikiname=$.>PAD
stack=( addr -- )
tags=string
Move a string at `addr` to the [[PAD]]
#endif
#include "align.i65"
_stringtopad
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word duptor
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _move
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(
stack=( text) -- )
tags=forth-83
flags=immediate
Begins a Forth comment, terminated by the next ')' character in
the input stream
#endif
#include "align.i65"
_lparen
    jsr enter
#include "page.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(."")
stack=( cfa text" -- )
tags=compiler,i/o,nosymbol
common code for ." and "

```
: (."")  ( cfa -- )
    compiling?  dup>r  ?: xt, drop
    [char] " ?char swap  r>
    if
        $, rdrop
    then
    drop ;
```
#endif
#include "align.i65"
_pdqq
    jsr enter
#include "page.i65"
    .word _compilingq
#include "page.i65"
    .word duptor
#include "page.i65"
    .word pquerycolon
    .word _xtcomma
    .word drop
#include "pad.i65"
    .word clit
    .byt '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(pdqq01-*+1)
#include "pad.i65"
    .word _stringcomma
#include "page.i65"
    .word rdrop
#include "page.i65"
pdqq01
    .word exit

;--------------------------------------------------------------
#if 0
name="
stack=( text" == ) ( -- addr )
tags=string
flags=immediate
State-smart string literal.  In compile mode, encloses a string
in the dictionary.  In interpret mode, returns the address of a
string ([[PAD]])

```
: "   ( text" == ) ( -- addr )
    [ ' (") ] literal   (."")  $>pad ;
```
!!!pronounced: "quote"
#endif
#include "align.i65"
_quote
    jsr enter
#include "page.i65"
    .word plit
    .word pquote
#include "pad.i65"
    .word _pdqq
#include "page.i65"
    .word _stringtopad
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=."
wikiname=.''
stack=( text" -- )
tags=compiler,i/o
flags=immediate
Output a string

Scans ahead in the input stream for a close " character and
encloses the string in the dictionary.

```
: ."   ( text" == ) ( -- addr )
    [ ' (.") ] literal   (."")  $. ;
```
!!!pronounced: "dot-quote"
#endif
#include "align.i65"
_dotq
    jsr enter
#include "page.i65"
    .word plit
    .word pdq
#include "pad.i65"
    .word _pdqq
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT"
stack=( flag -- ) ( -- ; compiling )
tags=compiler
flags=immediate
#endif
#include "align.i65"
_abortq
    jsr enter
#include "page.i65"
    .word _dotq
#include "page.i65"
    .word _compile
    .word _abort
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAIRS
stack=( a b -- )
tags=compiler,nosymbol,control
Aborts compilation if `a`<>`b`

```
: ?pairs
    <> 6 ?error ;
```
!!! pronounced: "query-pairs"
#endif
#include "align.i65"
_qpairs
    jsr enter
#include "page.i65"
    .word ne
#include "page.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word _qerror
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
#if 0
name=?CSP
stack=
tags=compiler,nosymbol

#endif
#include "align.i65"
_qcsp
    jsr enter
#include "page.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _qerror
#include "page.i65"
qcsp01
    .word exit

;--------------------------------------------------------------
#if 0
name=[
stack=( -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_lbracket
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=]
wikiname=}
stack=( -- )
tags=compiler

#endif
#include "align.i65"
_rbracket
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
    .word qstack
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(;CODE)
stack=( -- )
tags=compiler,nosymbol

#endif
#include "align.i65"
_psemi
    jsr enter
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;CODE
stack=( -- )
tags=compiler,unimplemented
flags=immediate

#endif
#include "align.i65"
_scode
    jsr enter
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.(
stack=( -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_dotp
    jsr enter
#include "page.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>MARK
stack=
tags=compiler,nosymbol

#endif
#include "align.i65"
_qtomark
    jsr enter
#include "page.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?<MARK
stack=
tags=compiler,control,nosymbol

#endif
#include "align.i65"
_qfrommark
    jsr enter
#include "page.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>RESOLVE
stack=
tags=compiler,control,nosymbol

#endif
#include "align.i65"
_qtoresolve
    jsr enter
#include "page.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word here
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cstore
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
#if 0
name=?<RESOLVE
stack=
tags=compiler,control,nosymbol
flags=immediate


#endif
#include "align.i65"
_qltresolve
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word here
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
#if 0
name=ADD>MARK
stack=
tags=compiler,nosymbol,control

#endif
#include "align.i65"
_addtomark
    jsr enter
#include "page.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01
    .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[']
wikiname={'}
stack=( == ) ( -- n )
tags=compiler
flags=immediate
Enclose the code field address of the next word in the input stream
into the dictionary as a [[literal|LITERAL]].  Forces compilation of
immediate words
#endif
#include "align.i65"
_brtick
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _xtcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IMMEDIATE
stack=
tags=compiler

#endif
#include "align.i65"
_immediate
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $80
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VOCABULARY
stack=( -- )
tags=compiler,defining

 see FD-V05N3 p. 5
#endif
#include "align.i65"
_vocabulary
    jsr enter
#include "page.i65"
    .word plit
    .word dovocab
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word numvoc
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _latest
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "pad.i65"
    .word andx
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(VOCAB)
stack=( -- )
tags=compiler,primitive,unimplemented,nosymbol
The business end of a word defined by VOCABULARY.  Gets the PFA
of the vocabulary and stores it in CONTEXT

```
: (vocab)   ( -- )
    vstack dup 1+ 8  cmove>
    r@ 1+ c@ vstack c! >6502
    ; code to de-dup vstack
```
#endif
dovocab
    pla
    sta n
    pla
    tay
    lda n
    jsr push6502
    lda ip+1
    pha
    lda ip
    pha
#include "toforth.i65"
    .word vstack
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word cmovegt
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cstore
#include "page.i65"
    .word to6502
dovocab01
    ldy #4              ; start after JSR DOVOCAB and new vocid
dovocab02
    lda vstack,y
    beq dovocab04       ; all done when we hit FORTH vocab
    eor vstack+3        ; compare to new vocid
    beq dovocab03       ; this vocabulary is a duplicate?
    iny
    bne dovocab02       ; bra
dovocab03
    iny
    lda vstack,y
    sta vstack-1,y
    bne dovocab03
dovocab04
    jmp exit

;--------------------------------------------------------------
#if 0
name=BEGIN
stack=
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_begin
    jsr enter
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word one
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=THEN
stack=
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_then
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DO
stack=( ulim llim -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_do
    jsr enter
#include "page.i65"
    .word _compile
    .word pdo
#include "pad.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?DO
stack=( ulim llim -- )
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_qdo
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOOP
stack=( -- )
tags=compiler
flags=immediate

Immediate word, compiles runtime code to terminate a loop that
counts up by 1.  The loop index and limit are treated as unsigned, e.g. `0 0 DO LOOP` will iterate 65536 times.  This is distinct from [[+LOOP]] which treats the loop index/limit both as signed integers. 
#endif
#include "align.i65"
_loop
    jsr enter
#include "page.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=+LOOP
stack=( n -- )
tags=compiler,control
flags=immediate

Immediate word, compiles runtime code to terminate a loop that
steps by an arbitrary value on the stack, terminating when the loop index goes past the limit.  

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]

~ pass pploop or ploop as an argument, combine these
#endif
#include "align.i65"
_plusloop
    jsr enter
#include "page.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LEAVE
stack=( -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_leave
    jsr enter
#include "page.i65"
    .word _compile
    .word pleave
#include "pad.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=?LEAVE
stack=( n -- ) 
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_qleave
    jsr enter
#include "page.i65"
    .word _compile
    .word pqleave
#include "pad.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=UNTIL
stack=( f -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_until
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AGAIN
stack=( -- )
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_again
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REPEAT
stack=
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_repeat
    jsr enter
#include "page.i65"
    .word _again
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IF
stack=( f -- )
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_if
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ELSE
stack=( -- )
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_else
    jsr enter
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WHILE
stack=( f -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_while
    jsr enter
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2CONSTANT
stack=( d == ) ( -- d )
tags=compiler

#endif
#include "align.i65"
_twoconst
    jsr enter
#include "page.i65"
    .word _constant
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2VARIABLE
stack=( == ) ( -- )
tags=compiler
Create storage for a new double
#endif
#include "align.i65"
_twovariable
    jsr enter
#include "page.i65"
    .word _variable
#include "page.i65"
    .word two
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DROPLIT
stack=( d == ) ( -- n )
tags=compiler,nosymbol
Compiles the least significant 16 bits of a double into the dictionary as
a numeric literal

!!!pronounced: drop-lit
#endif
#include "align.i65"
_droplit
    jsr enter
#include "page.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(literal00-*+1)

;--------------------------------------------------------------
#if 0
name=LITERAL
stack=( n == ) ( -- n )
tags=compiler
flags=immediate
Enclose `n` into the dictionary.  At runtime, leaves `n` on the
stack.
#endif
#include "align.i65"
_literal
    jsr enter
#include "page.i65"
literal00
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01
    .word _compile
    .word plit
#include "pad.i65"
    .word _comma
#include "page.i65"
literal02
    .word exit

;--------------------------------------------------------------
#if 0
name=DLIT
stack=( d == ) ( -- d )
tags=compiler
Compiles a double into the dictionary as a numeric literal
!!!pronounced: d-lit
#endif
#include "align.i65"
_dlit
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( scr -- )
tags=compiler

 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  >IN  BLK  BLOCK

```
: load   ( scr -- )
    ?dup
    if
        blk @ >r  >in @ >r
        blk !  source! interpret
        r> >in !  r> blk !  source!
    then ;
```
#endif
#include "align.i65"
_load
    jsr enter
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(load01-*+1)
#include "pad.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word toin
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _sourcestore
#include "page.i65"
load01
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-FORTH
stack=( -- )
tags=compiler,unimplemented

 Writes a binary file of the core dictionary to mass storage
 ($0401 to HERE)

#endif
#include "align.i65"
_saveforth
    jsr enter
#include "page.i65"
    .word exit

; core-double.a65
#echo .       core-double.a65           32-bit numbers

;--------------------------------------------------------------
#if 0
name=D+
stack=( d1 d2 -- d1+d2 )
tags=forth-83,double
Add two double precision numbers
#endif
dplus
    clc
    lda stackl,x
    adc stackl+2,x
    sta stackl+2,x
    lda stackh,x
    adc stackh+2,x
    sta stackh+2,x
    lda tos
    adc stackl+1,x
    pha
    lda tos+1
    adc stackh+1,x
    tay
    pla
    inx
    inx
    jmp put            ; [29]

;--------------------------------------------------------------
#if 0
name=D<
stack=( d1 d2 -- flag )
tags=forth-83,double,primitive
Compare two doubles.  True if d1 < d2
#endif
dlt
    ldy #0          ; false
    jsr dcmp
    bvc dlt01
    eor #$80
dlt01
    bpl dlt02
    dey             ; true
dlt02
    sty tos
    sty tos+1
    jmp threedrop
dcmp
    sec
    lda stackl+2,x
    sbc stackl,x
    lda stackh+2,x
    sbc stackh,x
    lda stackl+1,x
    sbc tos
    lda stackh+1,x
    sbc tos+1
    rts

;--------------------------------------------------------------
#if 0
name=DNEGATE
stack=( d -- -d )
tags=forth-83,double,primitive
Negate the double on the stack
#endif
dnegate
    jsr dodnegate
    jmp next
dodnegate
    sec
    lda #0
    sbc stackl,x
    sta stackl,x
    lda #0
    sbc stackh,x
    sta stackh,x
    jmp neg2

;--------------------------------------------------------------
#if 0
name=DABS
stack=( d -- +d )
tags=forth-83,double,primitive
Returns the absolute value of double "d"
#endif
dabs
    lda tos+1
    bpl dabs01
    jmp dnegate
dabs01
    jmp next

;--------------------------------------------------------------
#if 0
name=2DUP
stack=( n1 n2 -- n1 n2 n1 n2 )
tags=double,stack,forth-83,primitive
Make a copy of the double on top of stack
#endif
twodup
    sec
    .byt $24                    ; BIT z.p. instruction, fall through
;--------------------------------------------------------------
#if 0
name=2OVER
stack=( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
tags=primitive,double,stack,forth-83
Copy the double underneath the double on top of stack to become the new top of stack
#endif
twoover
    clc
    dex
    dex
    lda tos+1
    sta stackh+1,x
    lda tos
    sta stackl+1,x
    bcc twoover01
twodup01
    lda stackh+2,x
    sta stackh,x
    lda stackl+2,x
    sta stackl,x
    jmp next
twoover01
    lda stackh+4,x
    sta stackh,x
    lda stackl+4,x
    sta stackl,x
    lda stackh+3,x
    sta tos+1
    lda stackl+3,x
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=2ROT
stack=( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )
tags=double,primitive,ext
Rotate the three doubles on the stack
#endif
tworot
    ldy stackh+4,x
    lda stackh+2,x
    sta stackh+4,x
    lda stackh,x
    sta stackh+2,x
    sty stackh,x
    ldy stackl+4,x
    lda stackl+2,x
    sta stackl+4,x
    lda stackl,x
    sta stackl+2,x
    sty stackl,x            ; done moving lo words
    ldy stackh+3,x
    lda stackh+1,x
    sta stackh+3,x
    lda tos+1
    sta stackh+1,x
    sty tos+1
    ldy stackl+3,x
    lda stackl+1,x
    sta stackl+3,x
    lda tos
    sta stackl+1,x
    sty tos                 ; done moving hi words
    jmp next

;--------------------------------------------------------------
#if 0
name=2SWAP
stack=( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )
tags=double,primitive,ext
Swap the two doubles on the stack
#endif
twoswap
    ldy tos+1
    lda stackh+1,x
    sta tos+1
    sty stackh+1,x
    ldy tos
    lda stackl+1,x
    sta tos
    sty stackl+1,x
    ldy stackh,x
    lda stackh+2,x
    sta stackh,x
    sty stackh+2,x
    ldy stackl,x
    lda stackl+2,x
    sta stackl,x
    sty stackl+2,x
    jmp next

;--------------------------------------------------------------
#if 0
name=2!
stack=( hi lo addr -- )
tags=double,primitive,ext,memory
Store the double "hi" "lo" to "addr"
tags=forth-83,memory,double
#endif
twostore
    ldy #0
twostore01
    lda stackh,x
    sta (tos),y
    iny
    lda stackl,x
    sta (tos),y
    iny
    inx
    cpy #4
    bne twostore01
    jmp pops

;--------------------------------------------------------------
#if 0
name=2@
stack=( addr -- hi lo )
tags=double,primitive,ext,memory
tags=forth-83,memory,double
Retrieve the double stored at "addr" to the stack
#endif
twofetch
    ldy #3
    dex
    lda (tos),y
    sta stackh,x
    dey
    lda (tos),y
    sta stackl,x
    dey
    lda (tos),y
    sta n
    dey
    lda (tos),y
    ldy n
    jmp put

;--------------------------------------------------------------
#if 0
name=D-
stack=( d1 d2 -- d1-d2 )
tags=double,math,forth-83
Subtract "d2" from "d1" leaving the result on the stack
#endif
dminus
    jsr dodnegate
    jmp dplus

;--------------------------------------------------------------
#if 0
name=D0=
stack=( d -- flag )
tags=double,primitive,logical
Leave true if the double "d" is zero
#endif
dzeq
    ldy #0
    lda tos
    ora tos+1
    ora stackl,x
    ora stackh,x
    bne dzeq01
    dey
    bmi dzeq01

;--------------------------------------------------------------
#if 0
name=D=
tags=double,primitive,logical
stack=( hi2 lo2 hi1 lo1 -- flag )
Leaves true if the two doubles are equal
#endif
deq
    ldy #0
    lda tos
    eor stackl+1,x
    bne deq01
    lda tos+1
    eor stackh+1,x
    bne deq01
    lda stackl,x
    eor stackl+2,x
    bne deq01
    lda stackh,x
    eor stackh+2,x
    bne deq01
    dey
deq01
    inx
    inx
dzeq01
    inx
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=DU<
stack=( d1 d2 -- flag )
tags=double,primitive,logical,forth-83
Performs an unsigned compare of two doubles and leaves true if "d1" < "d2"
#endif
dult
    jsr dcmp
    bcs deq01
    dey
dult01
    bcc deq01

;--------------------------------------------------------------
#if 0
name=D2/
stack=( d -- d/2 )
tags=double,primitive,math
Divides double "d" by 2, unsigned
#endif
dtwoslash
    lsr stackh,x
    ror stackl,x
    ror tos+1
    ror tos
    jmp next

;--------------------------------------------------------------
#if 0
name=D2*
stack=( d -- d*2 )
tags=double,primitive,math
Multiply the double "d" by 2
#endif
dtwostar
    asl stackl,x
    rol stackh,x
    rol tos
    rol tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=D>
stack=( d1 d2 -- flag )
tags=double
#endif
_dgt
#include "enter.i65"
    .word twoswap
#include "page.i65"
    .word dlt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DMIN
stack=( d1 d2 -- d3 )
tags=double,forth-83
Returns d1 or d2, whichever is smaller (signed)
#endif
_dmin
#include "enter.i65"
    .word twoover
#include "page.i65"
    .word twoover
#include "page.i65"
    .word _dgt
#include "page.i65"
    .word qbranch
    .byt <(dmin01-*+1)
#include "pad.i65"
    .word twoswap
#include "page.i65"
dmin01
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DMAX
stack=( d1 d2 -- d3 )
tags=double,ext
Returns the larger of two doubles, signed
#endif
_dmax
#include "enter.i65"
    .word twoover
#include "page.i65"
    .word twoover
#include "page.i65"
    .word dlt
#include "page.i65"
    .word qbranch
    .byt <(dmax01-*+1)
#include "pad.i65"
    .word twoswap
#include "page.i65"
dmax01
    .word twodrop
#include "page.i65"
    .word exit


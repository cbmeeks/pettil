; core-user.a65
#echo .       core-user.a65             Core User Variables

; user variables required for pettil-core

;--------------------------------------------------------------
#if 0
name=USERVAR
stack=( -- addr )
tags=uservar,nosymbol
Runtime action of all user variables.  Returns the address of
the user variable.

~ could be improved by guaranteeing no page-boundary crossing
in user variable space
#endif
uservar
    pla
    sta n
    pla
    sta n+1
    ldy #1
    clc
    lda (n),y
    adc up
    ldy up+1
    bcc uservar01       ; ~ if user variables are limited to one page,
    iny                 ; ~ this is unnecessary
uservar01
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SP0
stack=( -- addr )
tags=uservar,fig
User variable
The data stack initialization value ($30)
#endif
sp0
    jsr uservar
    .byt usersp0-userarea

;--------------------------------------------------------------
#if 0
name=RP0
stack=( -- addr )
tags=uservar,fig
[heading]User variable[/heading]
The return stack initialization value ($01FE)
#endif
rp0
    jsr uservar
    .byt userrp0-userarea

;--------------------------------------------------------------
#if 0
name=DP
stack=( -- addr )
tags=uservar,fig
Dictionary pointer
#endif
dp
    jsr uservar
    .byt userdp-userarea

;--------------------------------------------------------------
#if 0
name=MEMSIZ
stack=( -- addr )
tags=uservar,kernel
!!!User variable
Top of RAM, initialized at COLD from BASIC zero page variable at $34
This variable may be adjusted, e.g. to allocate a contiguous block of
memory at the top of RAM
#endif
memsiz
    jsr uservar
    .byt usermemsiz-userarea

;--------------------------------------------------------------
#if 0
name=SYMTAB
stack=( -- addr)
tags=uservar,interpreter,compiler
!!!User variable
The symbol table design is one of the most un-Forthy things about PETTIL, or
maybe it's one of the most-Forthy things.  Depends on your perspective.  It's
very nonstandard, I'll grant you that.  But it accomplishes much with a small
code footprint.  Some people would say that Forth is whatever can run a standard
Forth program.  I would say the definition of Forth is closer to "whatever
Chuck Moore wants it to do."  Or in this case what I want it to do.

* Very fast [[FIND]] (and compile) times
* Searches (on average) only 1/16th of the dictionary
* Uses a Bloom filter to weed out numbers
* Disappears completely once the application is built

Symbol table start address, points to a structure in memory
consisting of

|!Field|!Size|!Description|
|Thread addresses|32 bytes|16 pointers to the start of each symbol thread,<br>balanced by a Pearson hash|
|^Thread<br>(repeats 16x)|^2 bytes<br>1 byte<br>1..31&nbsp;bytes<br>(repeats for each<br>symbol in the<br>thread)|^Code field address<br>Length and flags, sorted by ascending length<br>Symbol text|
|>|>|New symbols are appended, unsorted, after the 16th thread<br>See [[SYMNEW]] and [[SYMTAIL]] |
|^Symbols|^2 bytes<br>1 byte<br>1..31 bytes|Code field address<br>Length and flags<br>Symbol text|

The symbol table will vary in size, and as words are added to [[SYMNEW]],
searches will slow down. The word [[REHASH]] rebuilds the symbol table and
empties out [[SYMNEW]].  The symbol table is easily moved as there are no
link fields in PETTIL.`SYMTAB` may be repositioned during [[REHASH]] by
[[AUTOMEM]], which starts it at a page boundary a minimum of two pages
lower than [[BLKBUF]]

* whenever [[FORGET]] is invoked
* whenever the user types [[REHASH]]

!!!pronounced: "sim-tab"
#endif
symtab
    jsr uservar
    .byt usersymtab-userarea

;--------------------------------------------------------------
#if 0
name=SYMTAIL
stack=( -- addr )
tags=uservar
[heading]User variable[/heading]
Symbol table end address

Where new symbols are appended
#endif
symtail
    jsr uservar
    .byt usersymtail-userarea

;--------------------------------------------------------------
#if 0
name=STARTUP
stack=( -- addr )
tags=uservar
!!!User variable
Code field address of the word that executes on startup.  In
the development environment, this is set to [[ABORT]]
#endif
startup
    jsr uservar
    .byt userstartup-userarea

;--------------------------------------------------------------
#if 0
name=SA#
stack=( -- addr )
tags=uservar,vm,i/o
!!!User variable
User variable that holds the secondary address for [[FILE]]

!!!pronounced: "S-A-num"
#endif
sanum
    jsr uservar
    .byt usersanum-userarea

;--------------------------------------------------------------
#if 0
name=DRV#
stack=( -- addr )
tags=uservar,vm,i/o
!!!User variable
User variable that holds the device # used by [[SAVE-BUFFERS]]
[[LOAD-BUFFERS]] STOP-S STOP-V and STOP-L in the editor

!!!pronounced: "drive-num"
#endif
drvnum
    jsr uservar
    .byt userdrvnum-userarea

;--------------------------------------------------------------
#if 0
name=FILENAME
stack=( -- addr )
tags=uservar,vm,i/o
!!!User variable
User variable that holds the address of a counted string which is
the filename that will be used on the next [[SAVE-BUFFERS]]
[[LOAD-BUFFERS]] or STOP-S STOP-V STOP-L in the editor
#endif
filename
    jsr uservar
    .byt userfilename-userarea

;--------------------------------------------------------------
#if 0
name=VMBUF
stack=( -- addr )
tags=uservar,vm
!!!User variable
User variable that points to the bottom of the virtual memory
packet buffer.  Save and Verify operations use this as their
base address.  Load operations will load from magnetic media
to [[PAD]], then [[move|MOVE]] that data up so it ends just below
[[BLKBUF]] before setting `VMBUF`.  Creating and destroying
packets changes the value of `VMBUF`

!!!pronounced: "v-m-buff"
#endif
vmbuf
    jsr uservar
    .byt uservmbuf-userarea

;--------------------------------------------------------------
#if 0
name=#VMPKT
tags=uservar,vm
stack=( -- addr )
!!!User variable
Number of virtual memory packets
#endif
numvmpkt
    jsr uservar
    .byt usernumvmpkt-userarea

;--------------------------------------------------------------
#if 0
name=SCRPKT
tags=uservar,vm,editor
stack=( -- addr )
!!!User variable
PETTIL's editor distinguishes between "data" and "screen" blocks
using a bitflag (metadata) in the packet header.

Data blocks are 1024 bytes and can't be completely displayed on
the PET's 40x25 hardware.  The editor will show the first 1000 bytes
and otherwise treats such blocks as read-only.

Screens (typically source code) are read-write and the editor
will update the virtual memory packet buffer when leaving the screen,
e.g. via the STOP-Q editor command.  Screens also contain 24 bits
of linewrap information (the first three bytes of the block buffer),
and are treated as a collection of 40-character or 80-character
lines by the compiler.  In other words, line terminations are
considered to be whitespace when loading screens, and source lines
can extend all the way to the left and right edges.

The STOP-CLR editor command converts a data block into a screen,
discarding the last (unseen) 24 bytes and initializing the linewrap
to all 40-character lines, or it will reset the linewrap on existing
screens.  Changes aren't saved to the packet buffer until the screen
is exited.
#endif
scrpkt
    jsr uservar
    .byt userscrpkt-userarea

;--------------------------------------------------------------
#if 0
name=EDITING
tags=uservar,vm,editor
stack=( -- addr )
!!!User variable
If `EDITING`

* [[BLOCK]] will generate new [[screen packets|PETTIL packet map]]
* [[VIDRAM]] buffer is used by [[BLOCK]] and [[UPDATE]]
* screen packets are displayed and updated
* data packets are displayed but not updated

If not `EDITING`

* [[BLOCK]] will generate new [[data packets|PETTIL packet map]]
* [[BLKBUF]] buffer is used by [[BLOCK]] and [[UPDATE]]
* [[screen and data packets|PETTIL packet map]] are updated
#endif
editing
    jsr uservar
    .byt userediting-userarea

;--------------------------------------------------------------
#if 0
name=TDICT
tags=uservar
stack=( -- addr )
!!!User variable
base address of transient dictionary
#endif
tdict
    jsr uservar
    .byt usertdict-userarea

;--------------------------------------------------------------
#if 0
name=BASE
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
!!!User variable
current system number base.  Resets to decimal (base 10) on ABORT
#endif
base
    jsr uservar
    .byt userbase-userarea

;--------------------------------------------------------------
#if 0
name=DPL
tags=uservar
stack=( -- addr )
!!!User variable
User variable containing the number of digits following the
decimal in numeric input conversion
#endif
dpl
    jsr uservar
    .byt userdpl-userarea

;--------------------------------------------------------------
#if 0
name=HLD
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
!!!User variable
#endif
hld
    jsr uservar
    .byt userhld-userarea

;--------------------------------------------------------------
#if 0
name=BLK
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
!!!User variable
The address of a variable containing the number of the mass
storage block being interpreted as the input stream.  If the
value of BLK is zero the input stream is taken from the text
input buffer.  {{0..the number of blocks available -1}}
#endif
blk
    jsr uservar
    .byt userblk-userarea

;--------------------------------------------------------------
#if 0
name=SCR
stack=( -- addr )
tags=uservar,forth-83
The address of a user variable containing the
number of the screen most recently LISTed or EDITed
#endif
scr
    jsr uservar
    .byt userscr-userarea

;--------------------------------------------------------------
#if 0
name=LIN
stack=( -- addr )
tags=uservar
!!!User variable
Used by INTERPRET to keep track of the current line of the
current BLK being interpreted.  LIN starts at 0 and increments
by 1 or 2 according to the linewrap bits, until it exceeds 24.
At that point (going off the bottom of the screen), LIN is set
to -1
#endif
lin
    jsr uservar
    .byt userlin-userarea

;--------------------------------------------------------------
#if 0
name=@LIN
stack=( -- )
tags=uservar
!!!User variable
Used by [[INTERPRET]] to hold the address within the block buffer of the
current line.  It begins at [[BLKBUF]]+3 and goes up in increments of 40 or
80 until LIN reaches 25
#endif
atlin
    jsr uservar
    .byt useratlin-userarea

;--------------------------------------------------------------
#if 0
name=#LIN
stack=( -- addr )
tags=uservar,interpret
!!!User variable
Size of the current line indicated by [[LIN]], either 40 or 80.
Used by [[WORD]] when loading screens
#endif
numlin
    jsr uservar
    .byt usernumlin-userarea

;--------------------------------------------------------------
#if 0
name=>IN
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
The address of a user variable which contains the present
character offset within the input stream.
#endif
toin
    jsr uservar
    .byt usertoin-userarea

;--------------------------------------------------------------
#if 0
name=SPAN
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
The address of a variable containing the count of characters
actually received and stored by the last execution of EXPECT
#endif
span
    jsr uservar
    .byt userspan-userarea

;--------------------------------------------------------------
#if 0
name=#TIB
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
The address of a variable containing the number of bytes in
the text input buffer.  #TIB is accessed by WORD when BLK is
zero.  {{0..capacity of TIB}}
#endif
numtib
    jsr uservar
    .byt usernumtib-userarea

;--------------------------------------------------------------
#if 0
name=#OUT
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
User variable
Counts number of characters that have been emitted
#endif
numout
    jsr uservar
    .byt usernumout-userarea

;--------------------------------------------------------------
#if 0
name=#LINE
tags=uservar,fig,forth-79,forth-83
stack=( -- addr )
User variable
Counts the number of lines output
#endif
numline
    jsr uservar
    .byt usernumline-userarea

;--------------------------------------------------------------
#if 0
name=WARNING
tags=uservar,fig,forth-79
stack=( -- addr )
User variable
A user variable containing a value controlling messages.

* 0 = messages will be presented by number
* addr = address of the error messages table
#endif
warning
    jsr uservar
    .byt userwarning-userarea

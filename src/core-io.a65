; core-device.a65
#echo .       core-device.a65           I/O

;--------------------------------------------------------------
#if 0
name=EMIT
stack=( c -- )
tags=forth-83,i/o
#endif
emit
    jmp emitvector
emitvector
    inc uarea+usernumout-userarea
    bne emit01
    inc uarea+usernumout-userarea+1
emit01
    lda tos
    jsr CHROUT
    jmp drop

;--------------------------------------------------------------
#if 0
name=KEY
stack=( -- c )
tags=forth-83,i/o
Wait for a keypress by the user
#endif
key
    stx storex
key01
    jsr GETIN
    beq key01
key02
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=?KEY
stack=( -- c )
tags=i/o
Get a character from the keyboard, or 0 if no key pressed
#endif
qkey
    stx storex
    jsr GETIN
    bcs key02

;--------------------------------------------------------------
#if 0
name=?TERMINAL
stack=( -- flag )
tags=forth-83,i/o
Returns true if the stop key was pressed
#endif
qterminal
    ldy #0
    lda $9b
    cmp #$ef            ; check STOP key
    bne qterminal01
    dey
qterminal01
    tya
    jmp pushya

;--------------------------------------------------------------
#if 0
name=CR
stack=( -- )
tags=forth-83,i/o
Output a carriage return
#endif
cr
    jmp crvector
crvector
    lda #$0d
    jsr CHROUT
    lda #0
    sta uarea+usernumout-userarea
    sta uarea+usernumout-userarea+1
    inc uarea+usernumline-userarea
    bne cr01
    inc uarea+usernumline-userarea+1
cr01
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=xyzzy
stack=( -- )
tags=nosymbol
Forth breakpoint, used for debugging in VICE

```
: foo
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint
    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a breakpoint in secondaries

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
_jiffyfetch
#include "enter.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx storex
    jsr CLRCHN
    ldx storex
    jmp next

;--------------------------------------------------------------
#if 0
name=EXPECT
stack=( addr +n -- )
tags=forth-83,i/o
Stores up to +n characters into memory beginning at addr.
Receive characters and store each into memory.
The transfer begins at addr proceeding towards
higher addresses one byte per character until
either "return" is received or until +n characters have been transfered.  No more than +n
characters will be stored.  The "return" is not
stored into memory.  No characters are received
or transfered if +n is zero.  All characters
actually received and stored into memory will
be displayed, with the "return" displaying as a
space.
#endif
expect
    jmp expectvector
expectvector
    ldy #1
    jsr locals
    stx storex
    dey
    ;ldy #$ff
expect01
    iny
    cpy tos
    bcs expect02
    jsr CHRIN
    cmp #$0d
    beq expect02
    sta (n),y
    bne expect01
expect02
    lda #0
    sty uarea+userspan-userarea
    sta uarea+userspan-userarea+1
    ldx storex
    jmp drop

;--------------------------------------------------------------
#if 0
name=OPEN
stack=( n1 n2 n3 -- f )
tags=i/o,kernel
Open the logical file number n1 on device n2 with secondary
address n3.  Filename must have been set with NAME.  Returns
an error flag f (0=none, 24=error).
ftp://www.zimmers.net/pub/cbm/vic20/programming/VIC-Forth/Manual.txt
#endif
_open

;--------------------------------------------------------------
#if 0
name=HPIN
stack=( n -- f )
tags=i/o,kernel
Send the current input stream to logical file number n.
Returns and error flag f (0=none, 24=error).  See OPEN.

!!!pronounced: "h-p-in".
#endif
_hpin

;--------------------------------------------------------------
#if 0
name=HPOFF
stack=( -- )
tags=i/o,kernel
Restore the current input and output stream to the
keyboard and screen respectively.  Pronounced "h-p-off".
#endif
_hpoff

;--------------------------------------------------------------
#if 0
name=HPOUT
stack=( n -- f )
tags=i/o,kernel
 consider CMDIN CMDOUT CMDOFF
 Send the current output stream to logical file number n.
 Returns an error flag f (0=none, 24=error).  See OPEN.
 Pronounced "h-p-out".
#endif
_hpout

;--------------------------------------------------------------
#if 0
name=CSAVE
stack=( -- f )
tags=i/o,kernel
 Save the wordlist and USER-variables to cassette.  The
 wordlist may be given a name (see NAME).  Returns an error
 flag (0=none, 24=error).  See CLOAD.
#endif
_csave

;--------------------------------------------------------------
#if 0
name=CLOAD
stack=( -- f )
tags=i/o,kernel
 Load the saved wordlist from cassette.  Returns an error
 flag f (0=none, 24=error).  See CSAVE.
#endif
_cload

;--------------------------------------------------------------
#if 0
name=?DISC
stack=( -- )
tags=i/o,kernel
          Read the disk error channel storing the message at address
          $8C0 (C64-FORTH) or $1295 (VIC-FORTH) and the length byte
          at $8BF (C64-FORTH) or $1294 (VIC-FORTH).  See COUNT and
          TYPE.  Pronounced "question-disc".
#endif
_qdisc

;--------------------------------------------------------------
#if 0
name=IRQ^
stack=( eormask -- )
tags=device
Called by the editor (and anything else) to flip the IRQ vector
on and off between two different values
#endif
irqcaret
    jsr toggleirq
    jmp drop

;--------------------------------------------------------------
#if 0
name=SPACE
stack=( -- )
tags=forth-83,i/o
Emits a space character
#endif
_space
#include "enter.i65"
    .word bl
#include "page.i65"
    .word emit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SPACES
stack=( n -- )
tags=forth-83,i/o
Emits "n" spaces
#endif
_spaces
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(spaces02-*+1)
#include "pad.i65"
spaces01
    .word _space
#include "page.i65"
    .word ploop
    .byt <(spaces01-*+1)
#include "pad.i65"
spaces02
    .word exit

;--------------------------------------------------------------
#if 0
name=COUNT
stack=( addr1 -- addr2 n1 )
tags=forth-83
Leaves the address, addr2 and the character count +n of text
beginning at addr1.  addr2 is addr1+1 and n1 is the length of
the counted string at addr1.  The byte at addr1 contains the
byte count +n.  Range of +n is {0...255}.
#endif
count
    ldy #0
    lda (tos),y
    inc tos
    bne count01
    inc tos+1
count01
    jmp pushya

;--------------------------------------------------------------
#if 0
name=TYPE
stack=( addr count -- )
tags=forth-83,i/o
#endif
type
    ldy #1
    jsr locals
    clc
    lda tos
    adc uarea+usernumout-userarea
    sta uarea+usernumout-userarea
    lda tos+1
    adc uarea+usernumout-userarea+1
    sta uarea+usernumout-userarea+1
    ;ldy #0
type01
    cpy tos
    bne type02
    dec tos+1
    bpl type02
    jmp drop
type02
    lda (n),y
    jsr CHROUT
    iny
    bne type01
    inc n+1
    bne type01

;--------------------------------------------------------------
#if 0
name=/STRING
stack=( addr1 u1 n -- addr2 u2 )
tags=string
Adjust the character string at c-addr1 by n characters. The resulting
character string, specified by c-addr2 u2, begins at c-addr1 plus n
characters and is u1 minus n characters long.

!!!pronounced: "slash-string"
#endif
_slashstring
#include "enter.i65"
    .word duptor
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$.
stack=( addr -- )
tags=string
Outputs a string

#endif
_stringdot
#include "enter.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(")
stack=( -- )
tags=nosymbol,inner,i/o
Types the inline counted string from the dictionary and moves IP
to just after the string, paging if necessary
#endif
_pq
#include "enter.i65"
    .word rfrom             ; ( cstring-2 )
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word plus
#include "page.i65"
    .word to6502
skipinline
    lda tos+1
    sta ip+1
    lda tos
    sta ip
    jsr slide
    lda #0
    jmp pad

;--------------------------------------------------------------
#if 0
name=DIGIT
stack=( char base -- digit true | false )
tags=numword,~wut?

 Converts a single character to a digit using the current number
 base.  A flag on TOS indicates whether the conversion succeeded.
todo: possible to code golf this down with BCD tricks?
"http://www.6502.org/tutorials/decimal_mode.html
#endif
digit
    ldy #$ff        ; assume success
    lda stackl,x    ; get the character
    sec
    sbc #'0'
    bcc digit02     ; char was < '0'? not a digit, fail
    cmp #10
    bcc digit01     ; digit is in the range 00-09
    sbc #7          ; no? alphabet adjust 'A' --> $0a
digit01
    cmp tos         ; compare to current number base
    bcs digit02     ; not in current number base? fail
    sta stackl,x    ; digit in the current number base
    .byt $2c        ; BIT xxyy, skip the next two bytes
digit02
    iny             ; fail, set flag to 0
    inx             ; drop the stack

    tya             ; ya = flag word $0000 or $ffff
    jmp put         ; next!

;--------------------------------------------------------------
#if 0
name=HOLD
stack=( char -- )
tags=numword


 Inserts  character into a pictured numeric out-
 put string.
 char is inserted into a pictured numeric output
 string.  Typically used between  <#  and  #> .
#endif
_hold
#include "enter.i65"
    .word minusone
#include "page.i65"
    .word hld
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NUMBER
stack=( addr -- d )
tags=numword

 Convert the counted string at addr, to a signed
 32-bit integer, using the value of BASE .  If numeric
 conversion is not possible, an error condition exists.  The
 string may contain a preceding minus sign.

```
 \ There is a string that is probably a number stored from addrlow..addrhigh
 \ convert a counted string to a signed double, keeping track of the decimal
: number  ( addr -- d )
  ( addr )
     0 0 rot count
  ( 0 0 addr+1 len )
     over c@ [ ascii - ] literal  =
  ( 0 0 addr+1 len negative? )
     dup>r
  ( 0 0 addr+1 len negative? ) ( R; -- negative? )
     +
  ( 0 0 addr+1 lenadj ; adjust length for sign char )
     over + r@ -
  ( 0 0 addr+1 addrhigh+1 )
     swap  r@ -
  ( 0 0 addrhigh+1 addrlow )
     dpl on
     ?do
  ( d )
         base @ >r
  ( d ) ( R; base negative? )
         i c@  r@  digit
  ( -- d currdigit~?~ flag )
         if
             swap r@ um*
             drop rot
             r@ um* d+
             dpl @ 1+  0= negate dpl +!
         else
             i c@ [ ascii . ] literal  =
             dpl @ 0<  and
             if
                 dpl off
             else
                 3 fail ( abort" not found" )
             then
         then
         r> drop
  ( R; negative? ; discard base )
     loop
     r>  if  dnegate  then ;

```
#endif
_number
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word rot
#include "page.i65"
    .word count
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word duptor
#include "page.i65"
    .word plus
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word on
#include "page.i65"
    .word pqdo
    .byt <(number05-*+1)
#include "pad.i65"
number01
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word digit
#include "page.i65"
    .word qbranch
    .byt <(number02-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word umstar
#include "page.i65"
    .word drop
#include "page.i65"
    .word rot
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word umstar
#include "page.i65"
    .word dplus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(number04-*+1)
#include "pad.i65"
number02
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(number03-*+1)
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word off
#include "page.i65"
    .word branch
    .byt <(number04-*+1)
#include "pad.i65"
number03
    .word three
#include "page.i65"
    .word fail
#include "page.i65"
number04            ; then then
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word ploop
    .byt <(number01-*+1)
#include "pad.i65"
number05
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(number07-*+1)
#include "pad.i65"
    .word dnegate
#include "page.i65"
number07
    .word exit

;--------------------------------------------------------------
#if 0
name=<#
stack=( -- )
tags=numword


#endif
_ltsharp
#include "enter.i65"
    .word _pad              ; ( pad )
#include "page.i65"
    .word hld               ; ( pad hld )
#include "page.i65"
    .word store             ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#>
stack=
tags=numword

#endif
_sharpgt
#include "enter.i65"
    .word twodrop
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
    .word exit

;--------------------------------------------------------------
#if 0
name=SIGN
stack=( n -- )
tags=numword

 If n is negative, an ASCII "-" (minus sign) is appended to the
 pictured numeric output string.  Typically used between <# and #> .

#endif
_sign
#include "enter.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(sign01-*+1)
#include "pad.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word _hold
#include "page.i65"
sign01
    .word exit

;--------------------------------------------------------------
#if 0
name=(#)
stack=( +d1 -- +d2 )
tags=numword,nosymbol
base is the current system number base, which must be between 2 and 36.
This helper primitive divides d1 by BASE, returning the quotient d2 
and the remainder (as an ascii digit).  Called by '#'
#endif
sharp
        lda  #0         ;partial remainder
        ldy  #32        ;loop counter
sharp2
        asl  stackl,x   ;Dividend
        rol  stackh,x   ;  is gradually replaced
        rol  tos        ;  with the quotient
        rol  tos+1      ;a is gradually replaced
        rol             ;  with the remainder
        cmp  uarea+userbase-userarea       ;partial remainder < BASE?
        bcc  sharp3     ;  no: update the partial
        sbc  uarea+userbase-userarea       ;    remainder and partial
        inc  stackl,x   ;    quotient
sharp3
        dey
        bne  sharp2     ;loop 32 times
        cmp  #10
        sed
        adc  #'0'       ;adjust remainder to ASCII
        cld
        jmp  pushya     ; actually need to do a HOLD

;--------------------------------------------------------------
#if 0
name=#
stack=( +d1 -- +d2 )
tags=numword

 +d1 is divided by BASE and the quotient is
 placed onto the stack.  The remainder is con-
 verted to an ASCII character and appended to
 the output string toward lower memory ad-
 dresses.
 The remainder of +d1 divided by the value of
 BASE is converted to an ASCII character and ap-
 pended to the output string toward lower memory
 addresses.  +d2 is the quotient and is main-
 tained for further processing.  Typically used
 between <# and #> .
#endif
_sharp
#include "enter.i65"
    .word base              ; ( d base )
#include "page.i65"
    .word fetch             ; ( d @base )
#include "page.i65"

; psharp will replace the following block of code
;    .word psharp

    .word udslashmod        ; ( rem d )
#include "page.i65"
    .word rot               ; ( d rem )
#include "page.i65"
    .word to6502
    lda tos
    sed
    cmp #10
    adc #'0'
    cld
    sta tos                 ; ( d char )
#include "toforth.i65"

    .word _hold             ; ( d )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#S
stack=( d -- )
tags=numword

#endif
_sharps
#include "enter.i65"
sharps01
    .word _sharp            ; ( d )
#include "page.i65"
    .word twodup           ; ( d d )
#include "page.i65"
    .word dzeq              ; ( d flag )
#include "page.i65"
    .word qbranch
    .byt <(sharps01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UD.)
stack=( d -- )
tags=numword,nosymbol
Print an unsigned double

```
: (ud.)
    <# #s #> ;
```
#endif
_puddot
#include "enter.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(D.)
stack=( d -- )
tags=numword,nosymbol
Print a signed double

```
: (d.)
    dup>r  dabs  <# #s r> sign #> ;
```
#endif
_pddot
#include "enter.i65"
    .word duptor
#include "page.i65"
    .word dabs
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(U.)
stack=( u -- )
tags=numword,nosymbol
Print an unsigned number

```
: (u.)
    0 (ud.) ;
```
#endif
_pudot
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _puddot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(.)
stack=( n -- )
tags=nosymbol,i/o,inner
Print a signed number

```
: (.)
    s->d (d.) ;
```
#endif
_pdot
#include "enter.i65"
    .word _stod
#include "page.i65"
    .word _pddot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UD.
stack=( ud -- )
tags=numword

#endif
_uddot
#include "enter.i65"
    .word _puddot
#include "page.i65"
    .word branch
    .byt <(tse-*+1)
;--------------------------------------------------------------
#if 0
name=D.
stack=( d -- )
tags=numword

#endif
_ddot
#include "enter.i65"
    .word _pddot
#include "page.i65"
    .word branch
    .byt <(tse-*+1)
;--------------------------------------------------------------
#if 0
name=U.
stack=( n -- )
tags=numword

#endif
_udot
#include "enter.i65"
    .word _pudot
#include "page.i65"
    .word branch
    .byt <(tse-*+1)
;--------------------------------------------------------------
#if 0
name=.
stack=( n -- )
tags=numword


 The value of n is displayed in a free field for-
 mat with a leading minus sign if n is negative.
#endif
_dot
#include "enter.i65"
    .word _pdot             ; ( addr count )
#include "page.i65"
tse
    .word type              ; ( )
#include "page.i65"
    .word _space            ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=U.R
stack=( u w -- )
tags=numword

 u is converted using the value of BASE and then
 displayed as an unsigned number right-aligned
 in a field +n characters wide.  If the number
 of characters required to display u is greater
 than +n, an error condition exists.

#endif
_udotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pudot
#include "page.i65"
    .word branch
    .byt <(rjustify-*+1)
;--------------------------------------------------------------
#if 0
name=.R
stack=( n1 w -- )
tags=numword

#endif
_dotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pdot
#include "page.i65"
    .word branch
    .byt <(rjustify-*+1)
;--------------------------------------------------------------
#if 0
name=UD.R
stack=( d w -- )
tags=numword

#endif
_uddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _puddot
#include "page.i65"
    .word branch
    .byt <(rjustify-*+1)
;--------------------------------------------------------------
#if 0
name=D.R
stack=( d n -- )
tags=numword

#endif
_ddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pddot
#include "page.i65"
rjustify
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?
stack=( addr -- )
tags=i/o,memory
Fetches the value at `addr` and outputs it via [[.]]

#endif
_question
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word _dot
#include "page.i65"
    .word exit


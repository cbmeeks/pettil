; pettil-utils.a65
#echo .       pettil-utils.a65          Utility words

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value

usage: `PETSCII "X" .` responds `88  OK`

`PETSCII` uses `WORD` so parsing rules are lax.
Here are some anomalies when parsing quotes

```
PETSCII """""""""" .  OK
DEPTH . . 1 32  OK
PETSCII "X"." FOO" . FOO88  OK
PETSCII """""C EMIT  OK
EMIT C OK
```
#endif
#include "align.i65"
_petscii
    jsr enter
#include "page.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack

```
: .s ( ?? -- ?? )
    depth ?dup
    if
        0 do
            depth i - 1- pick  7 u.r space
        loop
    else
        ." stack empty"
    then ;
```
#endif
#include "align.i65"
_dots
    jsr enter
#include "page.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
    .byt <(dots04-*+1)
#include "pad.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word seven
#include "page.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots03-*-1
    .asc "STACK EMPTY"
dots03
#include "pad.i65"
dots04
    .word exit

;--------------------------------------------------------------
#if 0
name=H.
stack=( c -- )
tags=i/o
Prints out a number as an unsigned hexadecimal byte
```
: h.   ( c -- )
    base @ hex swap
    0 <# # # #> type
    base ! ;
```
#endif
#include "align.i65"
_hdot
    jsr enter
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word swap
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=4H.
stack=( u -- )
tags=i/o
Prints out a number as an unsigned hexadecimal word
```
: 4h.   ( u -- )
    dup msb h.
    lsb h. ;
```
#endif
#include "align.i65"
_fourhdot
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word msb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word lsb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=XLATE
stack=( char -- printablechar )
tags=i/o,nosymbol

#endif
xlate
    lda tos
    and #$7f
    cmp #$20
    bcs xlate01
    lda #'.'
    sta tos
xlate01
    jmp next

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    0
    ?do
        #out @ 0=
        if
            dup msb h.
            dup lsb h.
        then
        c@+ space h.
        #out @ 25 >
        if
            space 18 emit
            dup 8 - under
            do i c@ xlate emit loop cr
        then
        ?terminal  if leave then
    loop
    drop ;
```
#endif
#include "align.i65"
_dump
    jsr enter
#include "page.i65"
    .word zero
#include "page3.i65"
    .word pqdo
    .byt <(dump06-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _fourhdot
#include "page.i65"
dump02
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word _space
#include "page.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word eight
#include "page.i65"
    .word minus
#include "page.i65"
    .word under
#include "page.i65"
    .word pdo
    .byt <(dump04-*+1)
#include "pad.i65"
dump03
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word xlate
#include "page.i65"
    .word emit
#include "page.i65"
    .word ploop
    .byt <(dump03-*+1)
#include "pad.i65"
dump04
    .word cr
#include "page.i65"
dump05
    .word qterminal
#include "page.i65"
    .word pqleave
#include "page.i65"
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump06
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ID.L
stack=( nfa w -- )
tags=ext,nosymbol
Right-justified output of a name field

#endif
#include "align.i65"
_iddotl
    jsr enter
#include "page.i65"
    .word tuck
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
iddotl01
    .word rfetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(iddotl01-*+1)
#include "pad.i65"
    .word _spaces
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME.L10
stack=( cfa -- )
tags=ext,nosymbol

#endif
#include "align.i65"
_tonamedotl10
    jsr enter
#include "page.i65"
    .word _toname
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _iddotl
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=6SPACES
stack=( -- )
tags=editor
output 6 spaces

```
: 6spaces   ( -- )
    6 spaces ;
```
#endif
#include "align.i65"
_sixspaces
    jsr enter
#include "page.i65"
    .word six
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary

```
: words
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup id.  bl ?pause
        8 #out @ 7 and - spaces
        nfa+
    until drop ;

: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word _qpause
#include "page.i65"
    .word eight
#include "page.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word seven
#include "page.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INFO
stack=( -- )
tags=editor
Displays info on various editor and memory system variables

```
: info   ( -- )
    info05 c@ 0
    do
        i ?: 6spaces next
        i 2* 1+ info05 + @ dup
        >name.l10 execute
        @ 4h.
    loop
    cr ['] vstack >name id. 3 spaces
    vstack 10 0
    do
        c@+ space h.
    loop
    drop cr 
    ['] filename >name.l10
    filename @ dup 4h. space dup c@ h.
    space $. cr 
    ['] startup >name.l10
    startup @ >name.l10 ;
```
#endif
#include "align.i65"
_info
    jsr enter
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
    .byt <(info02-*+1)
#include "pad.i65"
info01
    .word i
#include "page.i65"
    .word pquerycolon
    .word _sixspaces
    .word next
#include "pad.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word execute
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _fourhdot
#include "page.i65"
    .word ploop
    .byt <(info01-*+1)
#include "pad.i65"
info02
    .word cr
#include "page.i65"
    .word plit
    .word vstack
#include "pad.i65"
    .word _toname
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word three
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
    .byt <(info04-*+1)
#include "pad.i65"
info03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word ploop
    .byt <(info03-*+1)
#include "pad.i65"
info04
    .word drop
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word filename
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word _fourhdot
#include "page.i65"
    .word _space
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word _space
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word startup
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word exit

info05
    .byt (info06-info05-1)/2
    .word base
    .word numvmpkt
    .word scr
    .word blk
    .word editing
    .word scrpkt
    .word dp
    .word vmbuf
    .word symtab
    .word symnew
    .word symtail
    .word tdict
    .word tdp
    .word memsiz
    .word numvoc
    .word current
    .word drvnum
    .word sanum
info06

; pettil-utils.a65
#echo .       pettil-utils.a65          Utility words

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value

usage: `PETSCII "X" .` responds `88  OK`

~ doesn't work for quote character ($22)
~ uses `WORD` so parsing rules are lax.
word following close-quote is parsed, e.g.
`PETSCII "X"." FOO" .` result is `FOO88  OK`
`PETSCII """""""" .
#endif
#include "align.i65"
_petscii
    jsr enter
#include "page.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
#include "align.i65"
_dots
    jsr enter
#include "page.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
#if 0
name=H.
stack=( c -- )
tags=i/o
Prints out a number as an unsigned hexadecimal byte
```
: h.   ( c -- )
    base @ hex swap
    0 <# # # #> type
    base ! ;
```
#endif
#include "align.i65"
_hdot
    jsr enter
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word swap
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=4H.
stack=( u -- )
tags=i/o
Prints out a number as an unsigned hexadecimal word
```
: 4h.   ( u -- )
    dup msb h.
    lsb h. ;
```
#endif
#include "align.i65"
_fourhdot
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word msb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word lsb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=XLATE
stack=( addr size -- )
tags=i/o,nosymbol

#endif
xlate
    lda tos
    and #$7f
    cmp #$20
    bcs xlate01
    lda #'.'
    sta tos
xlate01
    jmp next

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    0
    ?do
        #out @ 0=
        if
            dup msb h.
            dup lsb h.
        then
        c@+ space h.
        #out @ 25 > 
        if
            space 18 emit 
            dup 8 - under 
            do i c@ xlate emit loop cr
        then
        ?terminal  if leave then
    loop
    drop ;
    
```
#endif
#include "align.i65"
_dump
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(dump06-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _fourhdot
#include "page.i65"
dump02
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump04-*+1)
#include "pad.i65"
    .word _space
#include "page.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word minus
#include "page.i65"
    .word under
#include "page.i65"
    .word pdo
#include "page.i65"
dump03
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word xlate
#include "page.i65"
    .word emit
#include "page.i65"
    .word ploop
    .byt <(dump03-*+1)
#include "pad.i65"
    .word cr
#include "page.i65"
dump04
    .word qterminal
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word pleave
    .byt <(dump06-*+1)
#include "pad.i65"
dump05
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump06
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INFO
stack=( -- )
tags=editor
Updates the buffer and displays an info page of various editor and
memory system parameters

```
: info   ( -- )
    base @ hex info05 c@ 0
    do
        i 2* 1+ info05 + @ dup >name.l10 execute
        @ 4h.  3 spaces
    loop
    ['] vstack 10 dump cr
    ['] filename >name.l10 filename @ $. cr
    ['] startup >name.l10 startup @ >name.l10 cr
    base ! ;
```
#endif
#include "align.i65"
_info
    jsr enter
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
info02
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word execute
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _fourhdot
#include "page.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word _spaces
#include "page.i65"
    .word ploop
    .byt <(info02-*+1)
#include "pad.i65"
    .word cr
#include "page.i65"
    .word plit
    .word vstack
#include "pad.i65"
    .word _toname
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word three
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
info03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word ploop
    .byt <(info03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word filename
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word startup
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word exit

info05
    .byt 17
    .word numvmpkt
    .word editing
    .word scrpkt
    .word scr
    .word blk
    .word prev
    .word memsiz
    .word tdp
    .word tdict
    .word symtail
    .word symnew
    .word symtab
    .word vmbuf
    .word dp
    .word numvoc
    .word current
    .word drvnum

;--------------------------------------------------------------
#if 0
name=RINGBUFFER
stack=( size == ; -- head )
tags=compiler
Creates a FIFO ring buffer of `size` bytes with three 8-bit
offsets at the beginning to keep track of the head, tail,
and upper limit of the buffer.

|''head''|<|<|The next item to remove from the list|
|''tail''|<|<|Where to insert the next item on the list|
|''limit''|<|<|Never written to, marks the size of the list|
|timeout|cfa lo|cfa hi|Each event is 3 bytes wide|

```
: ringbuffer   ( size == ; -- head )
    <builds  dup>r   0 , c,     ( head, tail, size )
        here r> dup allot erase does> 3+ ;
```
#endif
#include "align.i65"
_ringbuffer
    jsr enter
#include "page.i65"
    .word plit
    .word doringbuffer
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word duptor
#include "page.i65"
    .word zero
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word here
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word _allot
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit
            

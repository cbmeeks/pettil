; pettil-utils.a65
#echo .       pettil-utils.a65          Utility words

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value

usage: `PETSCII "X" .` responds `88  OK`

~ doesn't work for quote character ($22)
~ uses `WORD` so parsing rules are lax.
word following close-quote is parsed, e.g.
`PETSCII "X"." FOO" .` result is `FOO88  OK`
`PETSCII """""""" .
#endif
#include "align.i65"
_petscii
    jsr enter
#include "page.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
#include "align.i65"
_dots
    jsr enter
#include "page.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
#if 0
name=H.
stack=( c -- )
tags=i/o
Prints out a number as an unsigned hexadecimal byte
```
: h.   ( c -- )
    base @ hex swap
    0 <# # # #> type
    base ! ;
```
#endif
#include "align.i65"
_hdot
    jsr enter
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word swap
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=4H.
stack=( u -- )
tags=i/o
Prints out a number as an unsigned hexadecimal word
```
: 4h.   ( u -- )
    dup msb h.
    lsb h. ;
```
#endif
#include "align.i65"
_fourhdot
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word msb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word lsb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=XLATE
stack=( addr size -- )
tags=i/o,nosymbol

#endif
xlate
    lda tos
    and #$7f
    cmp #$20
    bcs xlate01
    lda #'.'
    sta tos
xlate01
    jmp next

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    0
    ?do
        #out @ 0=
        if
            dup msb h.
            dup lsb h.
        then
        c@+ space h.
        #out @ 25 >
        if
            space 18 emit
            dup 8 - under
            do i c@ xlate emit loop cr
        then
        ?terminal  if leave then
    loop
    drop ;
```
#endif
#include "align.i65"
_dump
    jsr enter
#include "page.i65"
    .word zero
#include "page3.i65"
    .word pqdo
    .byt <(dump06-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _fourhdot
#include "page.i65"
dump02
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump04-*+1)
#include "pad.i65"
    .word _space
#include "page.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word minus
#include "page.i65"
    .word under
#include "page.i65"
    .word pdo
#include "page.i65"
dump03
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word xlate
#include "page.i65"
    .word emit
#include "page.i65"
    .word ploop
    .byt <(dump03-*+1)
#include "pad.i65"
    .word cr
#include "page.i65"
dump04
    .word qterminal
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word pleave
    .byt <(dump06-*+1)
#include "pad.i65"
dump05
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump06
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ID.L
stack=( nfa w -- )
tags=ext,nosymbol
Right-justified output of a name field

#endif
#include "align.i65"
_iddotl
    jsr enter
#include "page.i65"
    .word tuck
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twostar
#include "page.i65"
    .word minus
#include "page.i65"
iddotl01
    .word rfetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(iddotl01-*+1)
#include "pad.i65"
    .word _spaces
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME.L10
stack=( cfa -- )
tags=ext,nosymbol

#endif
#include "align.i65"
_tonamedotl10
    jsr enter
#include "page.i65"
    .word _toname
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _iddotl
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=6SPACES
stack=( -- )
tags=editor
output 6 spaces

```
: 6spaces   ( -- )
    6 spaces ;
```
#endif
#include "align.i65"
_sixspaces
    jsr enter
.word clit
    .byt 6
#include "pad.i65"
    .word _spaces
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary

```
: words
    cr >syms 2+ 
    begin
        dup nfalen ?terminal 0= and
    while
        dup id. 
        8 #out @ 7 and - spaces
        nfa+ 
    until drop ;

: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INFO
stack=( -- )
tags=editor
Updates the buffer and displays an info page of various editor and
memory system parameters

```
: info   ( -- )
    base @ hex  info05 c@ 0
    do
        i ?: 6spaces next
        i 2* 1+ info05 + @ dup
        >name.l10 execute
        @ 4h.  3 spaces
    loop
    ['] vstack 10 dump cr
    ['] filename >name.l10 filename @ $. cr
    ['] startup >name.l10 startup @ >name.l10 cr
    base ! ;
```
#endif
#include "align.i65"
_info
    jsr enter
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
info02
    .word i
#include "page.i65"
    .word pquerycolon
    .word _sixspaces
    .word next
#include "pad.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plit
    .word info05
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word execute
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _fourhdot
#include "page.i65"
    .word ploop
    .byt <(info02-*+1)
#include "pad.i65"
    .word cr
#include "page.i65"
    .word plit
    .word vstack
#include "pad.i65"
    .word _toname
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word three
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
info03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word ploop
    .byt <(info03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word filename
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "page.i65"
    .word plit
    .word startup
#include "pad.i65"
    .word _tonamedotl10
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _tonamedotl10
#include "page.i65"
    .word exit

info05
    .byt (info06-info05-1)/2
    .word numvmpkt
    .word editing
    .word scrpkt
    .word scr
    .word blk
    .word prev
    .word memsiz
    .word tdp
    .word tdict
    .word symtail
    .word symnew
    .word symtab
    .word vmbuf
    .word dp
    .word numvoc
    .word current
    .word drvnum
    .word base
info06

;--------------------------------------------------------------
#if 0
name=RINGBUFFER
stack=( size == ; -- head )
tags=compiler
Creates a [[FIFO|https://en.wikipedia.org/wiki/FIFO_%28computing_and_electronics%29]]                        ring buffer of `size` bytes with three 8-bit
offsets at the beginning to keep track of the head, tail,
and upper limit of the buffer.

|''size''|<|<|Never written to, marks the size of the list|
|^''wrap''|<|<|Incremented when head or tail reaches limit<br/>When head==tail, the parity bit (bit 0) indicates<br/>[[whether the buffer is full or empty.|http://en.wikipedia.org/wiki/Circular_buffer#Mirroring]]|
|''head''|<|<|Items are added to the list here|
|''tail''|<|<|Items are removed from the list here|
|timeout|cfa lo|cfa hi|Each event is 3 bytes wide|

```
: ringbuffer   ( size == ; -- head )
    <builds  dup>r   c,   ( $fc = limit,
                            $fd = wrap,
                            $fe = head,
                            $ff = tail )
        here r> 3+ dup allot erase does> 4 + ;
```
#endif
#include "align.i65"
_ringbuffer
    jsr enter
#include "page.i65"
    .word plit
    .word doringbuffer
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word duptor
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word here
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word _allot
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

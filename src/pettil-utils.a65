; pettil-utils.a65
#echo .       pettil-utils.a65          Utility words

;--------------------------------------------------------------
#if 0
name=PETSCII
stack=( -- c )
tags=string,ext
Converts a quoted character to its numeric value

usage: `PETSCII "X" .` responds `88  OK`

~ doesn't work for quote character ($22)
~ uses `WORD` so parsing rules are lax.
word following close-quote is parsed, e.g.
`PETSCII "X"." FOO" .` result is `FOO88  OK`
`PETSCII """""""" .
#endif
#include "align.i65"
_petscii
    jsr enter
#include "page.i65"
    .word clit
    .byt 34
#include "pad.i65"
    .word _word
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
#include "align.i65"
_dots
    jsr enter
#include "page.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
#if 0
name=H.
stack=( c -- )
tags=i/o
Prints out a number as an unsigned hexadecimal byte
```
: h.   ( c -- )
    base @ hex swap
    0 <# # # #> type
    base ! ;
```
#endif
#include "align.i65"
_hdot
    jsr enter
#include "page.i65"
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _hex
#include "page.i65"
    .word swap
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharp
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word type
#include "page.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=4H.
stack=( u -- )
tags=i/o
Prints out a number as an unsigned hexadecimal word
```
: 4h.   ( u -- )
    dup msb h.
    lsb h. ;
```
#endif
#include "align.i65"
_fourhdot
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word msb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word lsb
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DUMP
stack=( addr size -- )
tags=i/o
Dumps a region of memory as lines of eight bytes each

```
: dump   ( addr size -- )
    base @ hex -rot 0
    ?do
        #out @ 25 > if cr then
        #out @ 0=
        if
            dup 0 <# # # # # #> type
        then
        c@+ space 0 <# # # #> type
        ?terminal  if leave then
    loop
    drop base ! ;

: dump   ( addr size -- )
    0
    ?do
        #out @ 25 > if cr then
        #out @ 0=
        if
            dup msb h.
            dup lsb h.
        then
        c@+ space h.
        ?terminal  if leave then
    loop
    drop base ! ;
```
#endif
#include "align.i65"
_dump
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(dump04-*+1)
#include "pad.i65"
dump01
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(dump02-*+1)
#include "pad.i65"
    .word cr
dump02
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(dump03-*+1)
#include "pad.i65"
    .word _fourhdot
#include "page.i65"
dump03
    .word cfetchplus
#include "page.i65"
    .word _space
#include "page.i65"
    .word _hdot
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word qbranch
    .byt <(dump05-*+1)
#include "pad.i65"
    .word pleave
    .byt <(dump04-*+1)
#include "pad.i65"
dump05
    .word ploop
    .byt <(dump01-*+1)
#include "pad.i65"
dump04
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word exit


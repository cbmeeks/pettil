; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
#include "align.i65"
_tosyms
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  [[FORTH]] (vocid = 0) is
the last vocabulary searched, and is always present.  Executing a
vocabulary pushes it to the head of this stack.
#endif
#include "align.i65"
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary order.  Equivalent to `ONLY FORTH` in ANS Forth
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VSTACK]] search order to [[CURRENT]].
#endif
#include "align.i65"
_definitions
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the Pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  +0      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  +2      Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +3      Name field
|           ... |
|   name[len]   |
+---------------+
?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
+---------------+
```
#endif
pearsonhash
    stx xsave
    jsr pearsonhash01
    ldx xsave
    jmp put

pearsonhash01
    jsr nfalen01            ; A=length
    sta 2*R11               ; seed hash1 with length
    tay                     ; count backwards
pearsonhash03
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda 2*R11                       ;[3]
    eor pearson,x                   ;[4]
    sta 2*R11                       ;[3]
    dey
    bne pearsonhash03
    sty 2*R11+1
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor 2*R11               ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    ; these numbers were generated by the pearson.rb Ruby script which
    ; generates random hashes and selects the set that best balances
    ; a list of Forth words
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=nosymbol,concepts
Forth wrapper around Bloom hash function
#endif
bloomhash
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

;--------------------------------------------------------------
#if 0
name=bloomhash01
stack=( nfa -- n )
tags=nosymbol,subroutine
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash01
    jsr nfalen01
    tay
    lda #0
    sta 2*R11
    sta 2*R11+1
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc 2*R11                   ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta 2*R11                   ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01           ; A=length; Y=0
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=nfalen01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|symbol flag/length byte|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> last|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0
    lda (tos),y
    tay
    asl
    asl                 ; C = Vocab bit
    tya
    and #$1f
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next

;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|next NFA|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +length/flags +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=strcomp
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<b>inputs</b>|<|
|<b>TOS</b>|NFA in chain|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br>0=success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=symcopy
tags=nosymbol,subroutine
Copies a symbol from (`TOS`) to (`N0`) 
Copies the 0th byte, and moves N0 beyond the copied string


#endif
symcopy
;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs
** TOS (R1) source base address
** N0 (R2) target base address
** N1 (R3) string length
* returns
** Y = FF
#endif
symcopy16
    ldy n+2
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+2
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=qsmudge
stack=( nfa -- )
tags=compiler,nosymbol
#endif
qsmudge
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    jsr qsmudge
    jmp drop

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.

~ This should honor the Smudge bit
```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary
```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive
Called by [[(VFIND)]] for each dictionary segment search, e.g.
after this session:

```
VOCABULARY LATIN  OK
VOCABULARY GERMAN  OK
VOCABULARY SPANISH  OK
VOCABULARY FRENCH  OK
VOCABULARY RUSSIAN  OK
FORTH ASSEMBLER FRENCH LATIN  OK
VSTACK 5 DUMP 664E 02 05 01 00 00 OK
```
For each dictionary lookup, `(SEEK)` would be called eight times 
in this sequence:

# //unsorted// [[SYMNEW]] of //02// `LATIN`
# //hashed// [[SYMTAB]] of //02// `LATIN`
# //unsorted// [[SYMNEW]] of //05// `FRENCH`
# //hashed// [[SYMTAB]] of //05// `FRENCH`
# //unsorted// [[SYMNEW]] of //01// `ASSEMBLER`
# //hashed// [[SYMTAB]] of //01// `ASSEMBLER`
# //unsorted// [[SYMNEW]] of //00// `FORTH`
# //hashed// [[SYMTAB]] of //00// `FORTH`

|Register|Parameter|Description|h
|^N0|^searchname|`nfa` we are trying to find|
|^N1|^vocid|search vocabulary|
|^|^modeflag|TRUE = unsorted [[SYMNEW]]<br/>FALSE = sorted [[SYMTAB]]|
|^|^startnfa||
|^|^nfa||
|^|^xfa||
|^|^flag||

```
test case
    : fred   ." yaba daba doo" ;  ok
    vocabulary french  ok
    french definitions  ok
    : fred   ." ooh la la" ;
    fred ooh la la ok
    vocabulary german  ok
    : wilma  ." oui oui" ;
    german definitions  ok
    : fred   ." ja ja yabadoo" ;
    fred ja ja yabadoo ok
    french fred ooh la la ok
    german fred ja ja yabadoo ok
```
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname 
                                ; N1 = vocid; N2 = modeflag
    brk
    .byt sub | ACC
    .byt st | N4                ; set result = FALSE
    .byt ldi | N0               ; R0 = length of searchname
    .byt dcr | N0               ; fix pointer to searchname
    .byt rtn
pseek01
    jsr nfalen01
    beq pseek07                 ; end of list? exit with searchname/false
    eor r0                      ; check lengths, preserving C flag
    beq pseek20                 ; same length? proceed
    bit n+4                     ; sorted or unsorted?
    bmi pseek04                 ; unsorted. next!
pseek03                         ; okay, it's sorted
    eor r0                      ; restore length
    cmp r0                      ; end of sorted list?
    bcs pseek07                 ; went past it? exit with searchname/false
pseek04
    jsr nfaplus01               ; next!
    bne pseek01                 ; bra

pseek20
    ;lda #0
    dey                         ; just to set N flag, checking Smudge
                                ; there are no 0-length words, so won't
                                ; affect flag bits
    bmi pseek04                 ; smudged? next!
    ldy r0
    lda n+2                     ; are we looking in the Forth vocabulary?
    beq pseek02                 ; leave the carry flag alone
    bcc pseek04                 ; this word doesn't belong to a vocabulary? next!
    iny
    eor (tos),y                 ; check the vocabid
    bne pseek04                 ; mismatch vocabid?  next!
    dey
    clc
pseek02
    bcs pseek04                 ; this word belongs to a vocabulary? next!
    jsr strcomp                 ; compare names
    bne pseek04                 ; lengths match, 
                                ; vocabid matches, 
                                ; but names don't? next!
    ; winner!
    ;ldy #0
    lda (tos),y
    and #bit5
    adc #$e0                    ; C=1 if Immediate
    rol R14H                    ; propagate to Sweet16
    brk
    .byt popd | TOS             ; get the CFA
    .byt ldd | TOS              ; reget the CFA and fix TOS
    .byt dcr | N4
    .byt bnc , <(pseek10-*-2)
    .byt inr | N4
    .byt inr | N4
pseek10
    .byt push
    .byt ld | N4                ; return status flag
    .byt push
    .byt nxt

pseek07
    ; loser...
    brk
    .byt ld | N0
    .byt st | TOS
    .byt br , <(pseek10-*-2)                                

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNDEFINE
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
Removes the most recently defined symbol in SYMNEW.  Used by
error recovery

```
: undefine   ( -- )
    latest 2-  dup symtail !  dup @ dp !  3 erase ;
```
#endif
#include "align.i65"
_undefine
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
* for duplicate names
** issues "EXISTS" warning message
** sets REDEFINED user variable
* new symbol table entry
** symbol cfa links back to HERE
** compiles page-aligned `JSR cfa` at HERE
```
: (create)   ( cfa -- )
    bl word dup c@ 0=
    if 2drop exit then
    current c@ (vfind) nip
    if
        [ RVSON ] cliteral emit
        dup id.
        redefined !
        ." [RVSOFF] EXISTS"
        here
    then
    ( cfa here )
    dup bloom# >bit bloom + cbit!       \ add to bloom filter
    ( cfa here )
    symtail @  dup>r  2+ dup newest !   \ set NEWEST
    ( cfa here symtail+2 ; symtail )
    over nfalen 1+
    ( cfa here symtail+2 nfalen+1 ; symtail )

    current @ ?dup
    if
    ( cfa here symtail+2 nfalen+1 current ; symtail )
        >r  here c@ $40 or here c!
    ( cfa here symtail+2 nfalen+1+1 ; current symtail )
        r> over here + c!  1+
    ( cfa here symtail+2 nfalen+1+1 ; symtail )
    then
    ( cfa here symtail+2 nfalen+1+voc ; symtail )

    2dup +
    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )
    dup symtail ! 3 erase              \ mark new symtail
    ( cfa here symtail+2 len+1 ; symtail )
    cmove cfa,
    ( cfa ; symtail )
    here 3- r> ! ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pcreate03-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit
#include "page.i65"
pcreate03
    .word current
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word redefined
#include "page.i65"
    .word store
#include "page.i65"
    .word pdq
    .byt pcreate01-*-1
    .byt RVSOFF
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
pcreate02
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word newest
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pcreate04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word here
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word orx
#include "page.i65"
    .word here
#include "page.i65"
    .word cstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
pcreate04
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=ext,interpreter,nosymbol
32-bit wide Bloom filter for skipping [[REHASH]] passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=nosymbol,ext
Automatically move symbol table and vmbuf to someplace that leaves
at least 512 bytes for symbol table growth

The `lastpad` address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=smudgeclones
stack=( nfa -- nfa )
tags=interpreter,ext
Scan forward from the current clone to the end of the chain, 
setting the smudge bit for all exact matches to this clone

* same length
* same vocab bit
* same vocabulary if vocab bit set
* same name
#endif
smudgeclones
    ldx #3
    lda tos,x
    pha
    dex
    bpl smudgeclones+2
    lda tos
    sta n
    lda tos+1
    sta n+1
smudgeclonesb
    jsr nfaplus01
    tya
    beq smudgeclonesz
    ldy #0
    eor (n),y
    and #$5f
    bne smudgeclonesb
    jsr nfalen01
    adc #0
    tay
    jsr strcomp
    bne smudgeclonesb
yep                             ; we have a clone
    sec
    jsr qsmudge
    bne smudgeclonesb           ; bra
    nop
    nop
smudgeclonesz
    ldx #0
    pla
    sta tos,x
    inx
    cpx #4
    bne smudgeclonesz+2
    rts

;--------------------------------------------------------------
#if 0
name=YIN16
stack=( nfa -- nfa )
tags=interpreter,ext
Copy the symbol at TOS and any of its clones to N0

|register|<|purpose|notes|h
|^R0|^ACC|^param|^CFA|
|~|~|^return|^0 done with source|
|^R1|^TOS|nfa+||
|^R2|^N0|^targ+|pile up output here|
|^R3|^N1|^nfa|^temp storage used<br>for twin search<br>symcomp16 compares TOS vs N1|
|^R4|^N2|name length|length of fraternal twins|
|^R5|^N3|^symbol length|^length of identical twins<br>name+vocid|
|^R6|^N4|||
|^R7|^N5|||
|^R8|^N6|cfa||
|^R9|^N7|newdp|^discard CFAs between<br>these addresses|
|^R10|^N8|tdict|~|
|^R11|^EXT|||
|^R12|^SP|||
|^R13|^CPR|||
|^R14|^ST|||
|^R15|^PC|||

Yin has just a few questions:
    Are you Smudged?  Then you must be the firstborn twin
        We'll copy you first
        How's your address?  Do you still live here?
        
#endif
yin16
    ldy #0
    sty R14L                ; prior result
    jsr nfalen01
    beq yin16f
    tax
    adc #0
    sta n+2                 ; length of name+vocab
    txa
    and #$1f
    eor zi
    clc
    bne yin16f
    sec
    dey
    bpl yin16f              ; we have a clone
yeah
    brk
    .byt ld | TOS           ; sweet16 troika doll
    .byt st | R11
    .byt ld | N0
    .byt push
    .byt ld | R11
    .byt push
    .byt st | N0
clone01
    .byt ext
    .word nfaplus01
    .byt bz , <(clone01-*-2)
    
    
    jsr smudgeclones
    jsr dectos
    sec
    jsr qsmudge
    jsr inctos
    sec
yin16f
    rol R14H
    rts
    

; TOS=nfa1, N0=nfa2 
; N1=nfa1[len+voc]/nfa1[orig] 
; N2=nfa2[len+voc]/nfa2[orig]
; A = nfa1[len+voc]
; Y = nfa1[orig]
; ACC = CFA
; C = 1 smudge bits don't match (they never should)
; Y = nfa1[orig] still


; find/copy all identical twins that are
; in range
; if a twin is active, mark it inactive
; then mark the top twin active
; (it might be the same twin)
; begin
;   compare TOS.name (newtwin) vs N1.name (candidate)
;   identical?
;   if !(newdp < newtwin.cfa < tdict)  (keep newtwin?)
;   N1 = targ+2 (replace candidate with newtwin)
;   append newtwin to targ
;   unsmudge newtwin in symtab so it won't trigger a search
;   was newtwin active before we just activated it?  (we are done)
; until
; N1.unsmudge (activate the candidate)

;--------------------------------------------------------------
#if 0
name=PASS1
stack=( from to -- )
tags=nosymbol,interpreter,ext
Copying from [[SYMTAB]] down to [[PAD]], this passes over every
available name length resulting in all names sorted by ascending
size at [[PAD]].

Filtering occurs on this pass for forgotten symbols that fall 
between [[NEWDP]] and [[TDICT]].
#endif
#include "align.i65"
pass1
    ldy #1
    jsr locals              ; targ to N0
    brk
    .byt set | N8
    .word uarea+usernewdp-userarea
    .byt ldd | N8
    .byt st | N7                ; NEWDP
    .byt ldd | N8
    .byt st | N8                ; TDICT
pass1a                          ; for each name in symtab...symtail
    .byt ldd | TOS              ; get cfa from source
    .byt bz , <(pass1d-*-2)     ; cfa = 0 means no more source
    .byt cpr | N8
    .byt bc , <(pass1c-*-2)     ; in TDICT? green light
    .byt cpr | N7
    .byt bnc , <(pass1c-*-2)    ; in CORE? green light
pass1b
    .byt ext
    .word nfaplus01
    .byt popd | TOS
    .byt br , <(pass1a-*-2)     ; next!
pass1c
    .byt ext
    .word yin16                 ; will it blend?
    .byt bz , <(pass1d-*-2)     ; no more source?
    .byt bnc , <(pass1b-*-2)    ; only copy the same length as 'i'
    .byt std | N0
    .byt ext
    .word pearsonhash01
    .byt ld | R11
    .byt sti | N0
    .byt ext
    .word symcopy16
    .byt br , <(pass1b-*-2)     ; next
pass1d
    .byt ld | N0
    .byt st | TOS
    .byt nxt

    ; we get here when we find a smudged symbol.
    ; This will always be the first-defined (original) twin

    ; twins for purposes of deduplication have the same name+vocid (identical)
    ; each original twin will be processed only once with its identical twins
    ; continue from here through the end of the symbol table
    ; twins for purposes of copying have the same name (fraternal)
    ; only one identical twin may be active
    ; multiple fraternal twins may be active
    ; always copy twin with CFA in TDICT
    ; copy all identical twins with CFA < NEWDP (smudged or active)
    ; - unsmudge all identical twins after copying so we won't return here later
    ; all twins will be in the same sorted thread in SYMTAB
    ; all unsorted twins will be ascending by order defined in SYMNEW
    ; the active twin will be the last one found
    ; the active twin trades places with the last smudged twin copied

;--------------------------------------------------------------
#if 0
name=YANG16
stack=( nfa -- nfa )
tags=interpreter,ext
Conditionally copy the symbol at TOS to N0        
#endif
yang16
    ldy #0
    lda (tos),y
    jsr inctos
    eor zi
    and #$f
    bne yang16f                 ; same pearson hash?
    jsr nfalen01
    adc #0
    sta n+2
    beq yang16f
    jsr bloomhash01
    tax
    and #7
    tay
    txa
    lsr
    lsr
    lsr
    tax
    lda power2,y
    ora bloom+3,x
    sta bloom+3,x
    sec
    .byt $29                ; AND #
yang16f
    clc                     ; we did not copy
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=PASS2
stack=( from to -- )
tags=nosymbol,interpreter,ext
Copying from [[PAD]] back to [[SYMTAB]], this passes over each
Pearson hash value.  Names will be ordered chronologically by 
size within each Pearson hashed list at [[SYMTAB]].
#endif
#include "align.i65"
pass2
    ldy #1
    jsr locals              ; targ to N0
    brk
pass2a                          ; for each name in symtab...symtail
    .byt ldd | TOS              ; get cfa from source
    .byt bz , <(pass2c-*-2)     ; done with this pass?
    .byt ext
    .word yang16                ; compare Pearson hash to 'i'
    .byt bnc , <(pass2b-*-2)    ; Pearson hash <> 'i'?
    .byt std | N0               ; write cfa to target
    .byt ext
    .word symcopy16
pass2b
    .byt ext
    .word nfaplus01
    .byt popd | TOS
    .byt br , <(pass2a-*-2)     ; next!
pass2c
    .byt ld | N0
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (forget)   ( cfa -- )
    1- newdp !
    passbits 4 erase
    >syms pad  over 2+
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat  drop

( nfa targ )
    32 1 do
        over
        i >bit passbits + cbit@
( nfa targ+ nfa+ flag )
        ?:  pass1 drop
( nfa targ+ )
    loop nip 3 erase
( )
    automem
( )
    symtab @
    pad 2+ >syms
( nfa targ )
    16 0 do
        2dup pass2 nip nip
    loop
    nip dup 3 erase dup symnew ! symtail !
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word twoplus
#include "page.i65"
pforget01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pforget02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(pforget01-*+1)
#include "pad.i65"
pforget02
    .word drop
#include "page.i65"
    .word bl
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
pforget03
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word pquerycolon
    .word pass1
    .word drop
#include "pad.i65"
    .word ploop
    .byt <(pforget03-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _automem
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
pforget04
    .word twodup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word pass2
#include "page.i65"
    .word ploop
    .byt <(pforget04-*+1)
#include "pad.i65"
;    .word xyzzy
;#include "page.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word _words
;#include "page.i65"
;    .word cr
;#include "page.i65"
;    .word _info
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
Rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (forget) ;   \ effectively a FORGET nil
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01           ; A=length; Y=0
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=nfalen01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|symbol flag/length byte|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> last|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0
    lda (tos),y
    tay
    asl
    asl                 ; C = Vocab bit
    tya
    and #$1f
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next
    
;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|next NFA|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +length/flags +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=strcomp
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<b>inputs</b>|<|
|<b>TOS</b>|NFA in chain|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br>0=success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=symcopy
tags=nosymbol,subroutine
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs

#endif
symcopy
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it won't be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler

 Turn on the smudge bit.  Smudged names won't be found by FIND.
 In PETTIL, the smudge bit does double duty, also marking as
 inactive any names that have been [[REDEFINED]].

#endif
smudge
    sec
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive
Called by [[(VFIND)]] for each dictionary segment search, e.g.
after this session:

```
VOCABULARY LATIN  OK
VOCABULARY GERMAN  OK
VOCABULARY SPANISH  OK
VOCABULARY FRENCH  OK
VOCABULARY RUSSIAN  OK
FORTH ASSEMBLER FRENCH LATIN  OK
VSTACK 5 DUMP 664E 02 05 01 00 00 OK
```
For each dictionary lookup, `(SEEK)` would be called eight times 
in this sequence:

# //unsorted// [[SYMNEW]] of //02// `LATIN`
# //hashed// [[SYMTAB]] of //02// `LATIN`
# //unsorted// [[SYMNEW]] of //05// `FRENCH`
# //hashed// [[SYMTAB]] of //05// `FRENCH`
# //unsorted// [[SYMNEW]] of //01// `ASSEMBLER`
# //hashed// [[SYMTAB]] of //01// `ASSEMBLER`
# //unsorted// [[SYMNEW]] of //00// `FORTH`
# //hashed// [[SYMTAB]] of //00// `FORTH`

|Register|Parameter|Description|h
|^N0|^searchname|`nfa` we are trying to find|
|^N1|^vocid|search vocabulary|
|^|^modeflag|TRUE = unsorted [[SYMNEW]]<br/>FALSE = sorted [[SYMTAB]]|
|^|^startnfa||
|^|^nfa||
|^|^xfa||
|^|^flag||

```
                             ; still broken
    
    : fred   ." yaba daba doo" ;  ok
    vocabulary french  ok
    french definitions  ok
    : fred   ." ooh la la" ;
    fred ooh la la ok
    forth  ok
    vocabulary german  ok
    german definitions  ok
    : fred   ." ja ja yabadoo" ;
    fred yaba daba doo ok            ~~~?
    french fred ooh la la ok
    german fred ooh la la ok         ~~~?
    hex symnew ? 61ad  ok
    
>C:6180  6e 25 4c 45  41 56 45 4d  13 06 43 4d  44 4f 46 46   n%LEAVEM..CMDOFF
>C:6190  9e 64 06 53  4d 55 44 47  45 13 07 07  45 44 49 54   .d.SMUDGE...EDIT
>C:61a0  49 4e 47 41  66 07 50 45  54 53 43 49  49 d0 1a 04   INGAf.PETSCII...
>C:61b0  46 52 45 44  e5 1a 06 46  52 45 4e 43  48 e9 1a 44   FRED...FRENCH..D
>C:61c0  46 52 45 44  02 fa 1a 06  47 45 52 4d  41 4e 02 fe   FRED....GERMAN..
>C:61d0  1a 44 46 52  45 44 03 00  00 00 00 00  00 00 00 00   .DFRED..........
```
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname 
                                ; N1 = vocid; N2 = modeflag
    brk
    .byt sub | ACC
    .byt st | N4                ; set result = FALSE
    .byt ldi | N0               ; R0 = length of searchname
    .byt dcr | N0               ; fix pointer to searchname
    .byt rtn
pseek01
    jsr nfalen01
    beq pseek07                 ; end of list? exit with searchname/false
    eor r0                      ; check lengths, preserving C flag
    beq pseek20                 ; same length? proceed
    bit n+4                     ; sorted or unsorted?
    bmi pseek04                 ; unsorted. next!
pseek03                         ; okay, it's sorted
    eor r0                      ; restore length
    cmp r0                      ; end of sorted list?
    bcs pseek07                 ; went past it? exit with searchname/false
pseek04
    jsr nfaplus01               ; next!
    bne pseek01                 ; bra

pseek20
    ;lda #0
    dey                         ; just to set N flag, checking Smudge
                                ; there are no 0-length words, so won't
                                ; affect flag bits
    bmi pseek04                 ; smudged? next!
    ldy r0
    lda n+2                     ; are we looking in the Forth vocabulary?
    beq pseek02                 ; leave the carry flag alone
    bcc pseek04                 ; this word doesn't belong to a vocabulary? next!
    iny
    eor (tos),y                 ; check the vocabid
    bne pseek04                 ; mismatch vocabid?  next!
    dey
    clc
pseek02
    bcs pseek04                 ; this word belongs to a vocabulary? next!
    jsr strcomp                 ; compare names
    bne pseek04                 ; lengths match, 
                                ; vocabid matches, 
                                ; but names don't? next!
    ; winner!
    ;ldy #0
    lda (tos),y
    and #bit5
    adc #$e0                    ; C=1 if Immediate
    rol R14H                    ; propagate to Sweet16
    brk
    .byt popd | TOS             ; get the CFA
    .byt ldd | TOS              ; reget the CFA and fix TOS
    .byt dcr | N4
    .byt bnc , <(pseek10-*-2)
    .byt inr | N4
    .byt inr | N4
pseek10
    .byt push
    .byt ld | N4                ; return status flag
    .byt push
    .byt nxt

pseek07
    ; loser...
    brk
    .byt ld | N0
    .byt st | TOS
    .byt br , <(pseek10-*-2)                                

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;                  --------------------------------------------
;                  --------------------------------------------
;obsolescent words --------------------------------------------
;                  --------------------------------------------
;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs
** TOS (R1) source base address
** N0 (R2) target base address
** N1 (R3) string length
* returns
** Y = FF

~ fix this to account for (V flag) inside a vocabulary
#endif
symcopy16
symcopy01
    jsr nfalen16a
    tay
    bvc symcopy16a
    iny                      ; string length
    sty n+2
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+2
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=pearsonhash16
tags=interpreter,nosymbol
Sweet16 wrapper around Pearson hash function

* inputs
** ACC (R0) length
** TOS (R1) NFA
* returns
** ACC (R0) Pearson hash hexdigit

#endif
pearsonhash16
    ldy r0
    jsr pearsonhash02
    sty r0+1
    sta r0
    rts

;--------------------------------------------------------------
#if 0
name=nfalen16
tags=nosymbol
!!!Subroutine
Sweet16 wrapper around nfalen16a subroutine
Get name field length, ignoring flag bits

sets C flag if smudged

* inputs
** TOS = NFA pointer
* returns
** ACC = length of NFA
** C = smudge bit
** V = vocabulary bit
** R11L = length (copy of A)
** Y = 0

#endif
nfalen16
    jsr nfalen16a
    rol R14H
    sty R0H
    sta R0L
    sty R14L                    ; should be able to test length=0 without touching ACC first
    rts

; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
#include "align.i65"
_tosyms
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  [[FORTH]] (vocid = 0) is
the last vocabulary searched, and is always present.  Executing a
vocabulary pushes it to the head of this stack.
#endif
#include "align.i65"
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary order.  Equivalent to `ONLY FORTH` in ANS Forth
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VSTACK]] search order to [[CURRENT]].
#endif
#include "align.i65"
_definitions
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=nfalen01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N6</b>|flags/length byte|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|always <b>0</b>|
|^<b>N</b>|<b>0</b> not smudged<br/><b>1</b> smudged|
|^<b>V</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> end of list|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0                      ;[2]
    lda (tos),y                 ;[5]
nfalen02
    sta n+12                    ;[3]
    bit n+12                    ;[3]
    and #$1f                    ;[2]
    sta n+13                    ;[3]
    clc                         ;[2]
    bvc nfalen03                ;[2/3]
    sec                         ;[2]
nfalen03
    rts                         ;[6]

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01
    jmp put

;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<br><i>returns</i>|<|
|<b>TOS</b>|next NFA|
|<b>N6</b>|flags/length byte|
|<b>Y</b>|always <b>0</b>|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +flags/length +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next

;--------------------------------------------------------------
#if 0
name=symcomp
tags=nosymbol
Compares two symbols at TOS and N0

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<b>N0</b>|NFA being sought|
|<br><i>returns</i>|<|
|^<b>Y</b>|index of mismatch<br/><b>0</b> if success<br/><b>FF</b> end of list|
|^<b>Z</b>|symbols match?|
#endif
symcomp
    ldy #0
    lda (tos),y
    bne symcomp01
    dey
    rts
symcomp01
    eor (n),y
    and #$df
    bne strcomp02           ; length, vocab bit or smudge?
    jsr nfalen01
    adc #0
    ;clc
    tay
    ; fall through
;--------------------------------------------------------------
#if 0
name=strcomp
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br><b>0</b> if success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=symcomp16
tags=nosymbol,subroutine
Compares two symbols, returns Sweet-16 Carry flag set if match
#endif
symcomp16
    jsr symcomp
    clc
    bne symcomp16b
    sec
symcomp16b
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol,subroutine
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

|<br><i>inputs</i>|<|
|<b>TOS</b>|Source base address|
|<b>N0</b>|Target base address|
|<b>Y</b>|Name length (<i>symcopy16a</i>)|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|<b>FF</b>|
|<b>Z</b>|<b>0</b>|
#endif
symcopy16
    ldy n+4
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+4
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the Pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  -2      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab ident  ?  +len+1  Vocabulary token (if V bit set)
+---------------+
```
#endif
pearsonhash
    stx xsave
    jsr pearsonhash01
    ldx xsave
    jmp put

pearsonhash01
    jsr nfalen01            ; A=length
    sta 2*R11               ; seed hash1 with length
    tay                     ; count backwards
pearsonhash03
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda 2*R11                       ;[3]
    eor pearson,x                   ;[4]
    sta 2*R11                       ;[3]
    dey
    bne pearsonhash03
    sty 2*R11+1
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor 2*R11               ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    ; these numbers were generated by the pearson.rb Ruby script which
    ; generates random hashes and selects the set that best balances
    ; a list of Forth words
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=nosymbol,concepts
Forth wrapper around Bloom hash function
#endif
bloomhash
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

;--------------------------------------------------------------
#if 0
name=bloomhash01
stack=( nfa -- n )
tags=nosymbol,subroutine
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash01
    jsr nfalen01
    sty 2*R11
    sty 2*R11+1
    tay
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc 2*R11                   ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta 2*R11                   ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=qsmudge
stack=( nfa -- nfa )
tags=compiler,nosymbol
Smudges or unsmudges the byte pointed to by `tos`

|<br><i>inputs</i>|<|
|<b>C</b>|<b>0</b> unsmudge<br/><b>1</b> smudge|
|<b>TOS</b>|NFA address|
|<br><i>returns</i>|<|
|^<b>A</b>|altered byte|
|^<b>Y</b>|<b>0</b>|
#endif
qsmudge
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    jsr qsmudge
    jmp drop

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.

~ This should honor the Smudge bit

```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary

```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive
Called by [[(VFIND)]] for each dictionary segment search, e.g.
after this session:

```
VOCABULARY LATIN  OK
VOCABULARY GERMAN  OK
VOCABULARY SPANISH  OK
VOCABULARY FRENCH  OK
VOCABULARY RUSSIAN  OK
FORTH ASSEMBLER FRENCH LATIN  OK
VSTACK 5 DUMP 664E 02 05 01 00 00 OK
```
For each dictionary lookup, `(SEEK)` would be called eight times
in this sequence:

# //unsorted// [[SYMNEW]] of //02// `LATIN`
# //hashed// [[SYMTAB]] of //02// `LATIN`
# //unsorted// [[SYMNEW]] of //05// `FRENCH`
# //hashed// [[SYMTAB]] of //05// `FRENCH`
# //unsorted// [[SYMNEW]] of //01// `ASSEMBLER`
# //hashed// [[SYMTAB]] of //01// `ASSEMBLER`
# //unsorted// [[SYMNEW]] of //00// `FORTH`
# //hashed// [[SYMTAB]] of //00// `FORTH`
```
test case
    : fred   ." yaba daba doo" ;  ok
    vocabulary french  ok
    french definitions  ok
    : fred   ." ooh la la" ;
    fred ooh la la ok
    vocabulary german  ok
    : wilma  ." oui oui" ;
    german definitions  ok
    : fred   ." ja ja yabadoo" ;
    fred ja ja yabadoo ok
    french fred ooh la la ok
    german fred ja ja yabadoo ok
```
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname
                                ; N1 = vocid; N2 = modeflag (unsorted?)
    sty n+8
    sty n+9                     ; set result = FALSE
    jsr nfalen01
    beq pseek06                 ; end of list?
    lda (n),y
    and #$1f
    ldy n+2
    beq pseek00
    ldy #0
    ora #bit6                   ; set vocab bit
pseek00
    sta (n),y
    and #$1f
    tay
    iny
    lda n+2
    sta (n),y
pseek01
    jsr symcomp
    beq pseek04                 ; vocab/length/name match?
    bmi pseek06                 ; reached end of list?
    lda n+4
    bne pseek02                 ; unsorted list? next!
    tay
    lda (n),y
    and #$1f
    cmp n+13
    bcc pseek06
pseek02
    jsr nfaplus01               ; next!
    bne pseek01                 ; bra
pseek04                         ; winner!
    lda n+12
    and #bit5                   ; immediate?
    beq pseek04b
    tya
    iny
    bne pseek04c
pseek04b
    dey
    tya
pseek04c
    sta n+8
    sty n+9
    brk
    .byt popd | TOS
    .byt ldd | TOS

;    lda (tos),y
;    asl
;    asl
;    asl
;    tya
;    rol
;    sec
;    rol                         ; wind up with 3 or 1
;    sta n+8
;    brk
;    .byt popd | TOS             ; get the CFA
;    .byt ldd | TOS              ; reget the CFA and fix TOS
;    .byt dcr | N4               ; return -1 (not immediate)
;    .byt dcr | N4               ; return -1 (not immediate)
pseek05
    .byt push
    .byt ld | N4                ; return status flag
    .byt push
    .byt nxt
pseek06                         ; loser...
    brk
    .byt ld | N0                ; return NFA FALSE
    .byt st | TOS
    .byt br , <(pseek05-*-2)

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FIND
stack=( addr1 -- addr2 flag )
tags=interpreter,forth-83,nosymbol
addr1 is the address of a counted string, which is the word to look
up in the dictionary.

if not found, addr2 is the original addr1, and flag = 0
if found, addr2 is the code field address of the word,
and flag = -1 for normal words, +1 for immediate words

! outer interpreter

name is the address of a counted string we are searching for.
fflag is the find mode.  False means NFAs are sorted, True means check them all
nfa is the first nfa in the hash list

vocid identifies which vocabulary to search.  Vocabularies may be
nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
NFAs (with the vocid appended to the name before hashing) on the stack.
The final vocabulary searched will be core, and (FIND) will exit afterward.

  0 = corelist

  1 = assembler

  2+ = vocabularies added by the user

(FIND) first searches all unsorted names beginning at SYMTAIL, without regard
to name length.  If it fails to find the word there,
it tries the hash list, which is sorted in ascending size
order.  Vocabularies are searched first, beginning with CONTEXT and chaining
up until core (0) is reached.  The vocid is appended to the word when
searching that vocabulary.  Only one symbol within a vocabulary may be
active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
may be active within more than one vocabulary.

 returns
       ( cfa -1 ) found normal word
       ( cfa 1 ) found immediate word
       ( name 0 ) not in dictionary

```
: find ( name -- xfa flag )
    dup bloom# >bit bloom + cbit@
    if
        >r  vstack
 ( vstack ; name )
        begin
            c@+ r@ over
 ( vptr vocid name vocid ; name )
            (vfind)
 ( vptr vocid nfa xfa found? ; name )
            ?dup
            if
                rdrop 2>r 3drop 2r> exit
            then
            2drop 0=
        until
        drop r>
    then
    false ;
```
#endif
#include "align.i65"
_find
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(find04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word vstack
#include "page.i65"
find01
    .word cfetchplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
    .word twotor
#include "page.i65"
    .word threedrop
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word exit
#include "page.i65"
find03
    .word twodrop
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
find04
    .word false
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNDEFINE
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
Removes the most recently defined symbol in SYMNEW.  Used by
error recovery

```
: undefine   ( -- )
    latest 2-  dup symtail !  dup @ dp !  3 erase ;
```
#endif
#include "align.i65"
_undefine
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
* for duplicate names (same name & vocabulary)
** issues "//name// EXISTS" warning message
** sets [[REDEFINED]] user variable
* new symbol table entry
** symbol CFA links back to [[HERE]]
** compiles page-aligned `JSR cfa` at [[HERE]]
```
: (create)   ( cfa -- )
    bl word dup c@ 0=
    if 2drop exit then
    current c@ (vfind) nip
    if
        [ RVSON ] cliteral emit
        dup id.
        redefined !
        ." [RVSOFF] EXISTS"
        here
    then
    ( cfa here )
    dup bloom# >bit bloom + cbit!       \ add to bloom filter
    ( cfa here )
    symtail @  dup>r  2+ dup newest !   \ set NEWEST
    ( cfa here symtail+2 ; symtail )
    over nfalen 1+
    ( cfa here symtail+2 nfalen+1 ; symtail )

    current @ ?dup
    if
    ( cfa here symtail+2 nfalen+1 current ; symtail )
        >r  here c@ $40 or here c!
    ( cfa here symtail+2 nfalen+1+1 ; current symtail )
        r> over here + c!  1+
    ( cfa here symtail+2 nfalen+1+1 ; symtail )
    then
    ( cfa here symtail+2 nfalen+1+voc ; symtail )

    2dup +
    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )
    dup symtail ! 3 erase              \ mark new symtail
    ( cfa here symtail+2 len+1 ; symtail )
    cmove cfa,
    ( cfa ; symtail )
    here 3- r> ! ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pcreate03-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit
#include "page.i65"
pcreate03
    .word current
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word redefined
#include "page.i65"
    .word store
#include "page.i65"
    .word pdq
    .byt pcreate01-*-1
    .byt RVSOFF
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
pcreate02
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word newest
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pcreate04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word here
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word orx
#include "page.i65"
    .word here
#include "page.i65"
    .word cstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
pcreate04
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=ext,interpreter,nosymbol
32-bit wide Bloom filter for skipping [[REHASH]] passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=nosymbol,ext
Automatically move symbol table and vmbuf to someplace that leaves
at least 512 bytes for symbol table growth

The `lastpad` address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=unsmudgeclone16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Unsmudge the last clone
#endif
unsmudgeclone16
    clc
    .byt $29
    jmp qsmudge

;--------------------------------------------------------------
#if 0
name=smudgeclone16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Unsmudge the last clone
#endif
smudgeclone16
    sec
    jmp qsmudge

;--------------------------------------------------------------
#if 0
name=YIN16
stack=( nfa -- nfa )
tags=interpreter,ext
Copy the symbol at TOS and any of its clones to N0. Modify
clones as tbey are copied so they won't be copied twice.

|register|<|purpose|notes|h
|^R0|^ACC|^param|^CFA|
|~|~|^return|^0 done with source|
|^R1|^TOS|nfa+||
|^R2|^N0|^targ+|pile up output here|
|^R3|^N1|^nfa|^temp storage used<br>for twin search<br>symcomp compares TOS vs N1|
|^R4|^N2|name length|length of fraternal twins|
|^R5|^N3|^symbol length|^length of identical twins<br>name+vocid|
|^R6|^N4|||
|^R7|^N5|||
|^R8|^N6|cfa||
|^R9|^N7|newdp|^discard CFAs between<br>these addresses|
|^R10|^N8|tdict|~|
|^R11|^EXT|||
|^R12|^SP|||
|^R13|^CPR|||
|^R14|^ST|||
|^R15|^PC|||

When yin encountrs a clone at 'yeah'
found clone?
push (mark our place)
begin
	copy CFA
	smudge original
	calculate pearson hash
	copy symbol
	original CFA = NEWDP
	(find next clone)
	begin
	    nfaplus01
	    symcomp01
	    (is symtail?)
	    beq done
	    (is clone?)
	    bcc begin
	    is CFA in bounds?
	until
	br begin
until
done
unsmudge last clone
pull (resume)
#endif
yin16
    jsr nfalen01
    sty R14L                ; R0 prior result for bz test
    beq yin16f              ; length = 0 means end of list
    tay
    bvc yin04
    iny
yin04
    sty n+4                 ; length of name+vocab
    eor zi
    clc
    bne yin16f
    sec
    ldy n+12
    bpl yin16f
yeah
; this is the first clone. Its CFA is qualified.
    brk                     ; sweet16 troika doll
    .byt ld | TOS           ; mark our place
    .byt push
yin01                       ; BEGIN
    .byt popd | TOS         ; copy CFA at TOS to N0
    .byt ldd | TOS          ; fix TOS
    .byt bz , <(yin02-*-2)  ; at SYMTAIL?
    .byt ext
    .word smudgeclone16     ; smudge all clones before copying
    .byt std | N0
    .byt ext
    .word pearsonhash01     ; also copy the pearson hash
    .byt ld | R11
    .byt sti | N0
    .byt ext
    .word symcopy16
    .byt popd | TOS         ; back up 2 spaces
    .byt ld | N7
    .byt std | TOS          ; set the CFA = N7 to prevent duplication
yin02
    .byt ext
    .word nfaplus01
    .byt popd | TOS         ; get the CFA
    .byt ldd | TOS
    .byt bz , <(yin03-*-2)
    .byt cpr | N8
    .byt bc , <(yin02-*-2)   ; out of bounds? ignore
    .byt cpr | N7
    .byt bnc , <(yin02-*-2)  ; out of bounds? ignore
    .byt ext                 ; is it a clone?
    .word symcomp16
    .byt bnc ,  <(yin02-*-2)
    .byt std | N0
    .byt popd | TOS
    .byt ld | N7            ; overwrite CFA to prevent recopy
    .byt std | TOS          ; also TOS+2
    .byt ext
    .word symcopy16         ; copy the flags/length, name, ?vocid
    .byt ext
    .word nfaplus01
    .byt bz , <(yin01-*-2)
yin03
    .byt ext
    .word unsmudgeclone16   ; unsmudge the last clone
    .byt pull
    .byt rtn
    clc
yin16f
    rol R14H
    rts

; TOS=nfa1, N0=nfa2
; N1=nfa1[len+voc]/nfa1[orig]
; N2=nfa2[len+voc]/nfa2[orig]
; A = nfa1[len+voc]
; Y = nfa1[orig]
; ACC = CFA
; C = 1 smudge bits don't match (they never should)
; Y = nfa1[orig] still


; find/copy all identical twins that are
; in range
; if a twin is active, mark it inactive
; then mark the top twin active
; (it might be the same twin)
; begin
;   compare TOS.name (newtwin) vs N1.name (candidate)
;   identical?
;   if !(newdp < newtwin.cfa < tdict)  (keep newtwin?)
;   N1 = targ+2 (replace candidate with newtwin)
;   append newtwin to targ
;   unsmudge newtwin in symtab so it won't trigger a search
;   was newtwin active before we just activated it?  (we are done)
; until
; N1.unsmudge (activate the candidate)

;--------------------------------------------------------------
#if 0
name=PASS1
stack=( from to -- )
tags=nosymbol,interpreter,ext
Copying from [[SYMTAB]] down to [[PAD]], this passes over every
available name length resulting in all names sorted by ascending
size at [[PAD]].

Filtering occurs on this pass for forgotten symbols that fall
between [[NEWDP]] and [[TDICT]].
#endif
#include "align.i65"
pass1
    ldy #1
    jsr locals              ; targ to N0
    brk
    .byt set | N8
    .word uarea+usernewdp-userarea
    .byt ldd | N8
    .byt st | N7                ; NEWDP
    .byt ldd | N8
    .byt st | N8                ; TDICT
pass1a                          ; for each name in symtab...symtail
    .byt ldd | TOS              ; get cfa from source
    .byt bz , <(pass1d-*-2)     ; cfa = 0 means no more source
    .byt cpr | N8
    .byt bc , <(pass1c-*-2)     ; in TDICT? green light
    .byt cpr | N7
    .byt bnc , <(pass1c-*-2)    ; in CORE? green light
pass1b
    .byt ext
    .word nfaplus01
    .byt popd | TOS
    .byt br , <(pass1a-*-2)     ; next!
pass1c
    .byt ext
    .word yin16                 ; will it blend?
    .byt bz , <(pass1d-*-2)     ; no more source?
    .byt bnc , <(pass1b-*-2)    ; only copy the same length as 'i'
    .byt std | N0
    .byt ext
    .word pearsonhash01
    .byt ld | R11
    .byt sti | N0
    .byt ext
    .word symcopy16
    .byt br , <(pass1b-*-2)     ; next
pass1d
    .byt ld | N0
    .byt st | TOS
    .byt nxt

    ; we get here when we find a smudged symbol.
    ; This will always be the first-defined (original) twin

    ; twins for purposes of deduplication have the same name+vocid (identical)
    ; each original twin will be processed only once with its identical twins
    ; continue from here through the end of the symbol table
    ; twins for purposes of copying have the same name (fraternal)
    ; only one identical twin may be active
    ; multiple fraternal twins may be active
    ; always copy twin with CFA in TDICT
    ; copy all identical twins with CFA < NEWDP (smudged or active)
    ; - unsmudge all identical twins after copying so we won't return here later
    ; all twins will be in the same sorted thread in SYMTAB
    ; all unsorted twins will be ascending by order defined in SYMNEW
    ; the active twin will be the last one found
    ; the active twin trades places with the last smudged twin copied

;--------------------------------------------------------------
#if 0
name=YANG16
stack=( nfa -- nfa )
tags=interpreter,ext
Conditionally copy the symbol at TOS to N0
#endif
yang16
    ldy #0
    lda (tos),y
    jsr inctos
    eor zi
    and #$f                     ; ~ unnecessary?
    bne yang16f                 ; same pearson hash?
    jsr nfalen01
    adc #0
    sta n+4
    beq yang16f
    jsr bloomhash01
    tax
    and #7
    tay
    txa
    lsr
    lsr
    lsr
    tax
    lda power2,y
    ora bloom+3,x
    sta bloom+3,x
    sec
    .byt $29                ; AND #
yang16f
    clc                     ; we did not copy
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=PASS2
stack=( from to -- )
tags=nosymbol,interpreter,ext
Copying from [[PAD]] back to [[SYMTAB]], this passes over each
Pearson hash value.  Names will be ordered chronologically by
size within each Pearson hashed list at [[SYMTAB]].
#endif
#include "align.i65"
pass2
    ldy #1
    jsr locals              ; targ to N0
    brk
pass2a                          ; for each name in symtab...symtail
    .byt ldd | TOS              ; get cfa from source
    .byt bz , <(pass2c-*-2)     ; done with this pass?
    .byt ext
    .word yang16                ; compare Pearson hash to 'i'
    .byt bnc , <(pass2b-*-2)    ; Pearson hash <> 'i'?
    .byt std | N0               ; write cfa to target
    .byt ext
    .word symcopy16
pass2b
    .byt ext
    .word nfaplus01
    .byt popd | TOS
    .byt br , <(pass2a-*-2)     ; next!
pass2c
    .byt ld | N0
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (forget)   ( cfa -- )
    1- newdp !
    passbits 4 erase
    >syms pad  over 2+
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat  drop

( nfa targ )
    32 1 do
        over
        i >bit passbits + cbit@
( nfa targ+ nfa+ flag )
        ?:  pass1 drop
( nfa targ+ )
    loop nip 3 erase
( )
    automem
( )
    symtab @
    pad 2+ >syms
( nfa targ )
    16 0 do
        2dup pass2 nip nip
    loop
    nip dup 3 erase dup symnew ! symtail !
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word twoplus
#include "page.i65"
pforget01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pforget02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(pforget01-*+1)
#include "pad.i65"
pforget02
    .word drop
#include "page.i65"
    .word bl
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
pforget03
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word pquerycolon
    .word pass1
    .word drop
#include "pad.i65"
    .word ploop
    .byt <(pforget03-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _automem
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
pforget04
    .word twodup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word pass2
#include "page.i65"
    .word ploop
    .byt <(pforget04-*+1)
#include "pad.i65"
;    .word xyzzy
;#include "page.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word _words
;#include "page.i65"
;    .word cr
;#include "page.i65"
;    .word _info
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
Rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (forget) ;   \ effectively a FORGET nil
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

1254
```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

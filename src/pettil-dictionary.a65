; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01           ; A=length; Y=0
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=nfalen01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|symbol flag/length byte|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> last|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0
    lda (tos),y
    tay
    asl
    asl                 ; C = Vocab bit
    tya
    and #$1f
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next
    
;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|next NFA|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +length/flags +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=strcomp
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<b>inputs</b>|<|
|<b>TOS</b>|NFA in chain|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br>0=success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=symcopy
tags=nosymbol,subroutine
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs

#endif
symcopy
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it won't be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler

 Turn on the smudge bit.  Smudged names won't be found by FIND.
 In PETTIL, the smudge bit does double duty, also marking as
 inactive any names that have been [[REDEFINED]].

#endif
smudge
    sec
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive

!!!mode flag

* TRUE -- list is unsorted (SYMNEW)
* FALSE -- list is sorted (SYMTAB)
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname; 
                                ; N1 = vocid; N2 = modeflag
    brk
    .byt ldi | N0               ; R0 = length of searchname
    .byt dcr | N0
    .byt rtn
pseek01
    jsr nfalen01
    beq pseek07                 ; end of list? exit with searchname/false
    eor r0                      ; check lengths, preserving C flag
    beq pseek20                 ; same length? proceed
    bit n+4                     ; sorted or unsorted?
    bmi pseek04                 ; unsorted. next!
    eor r0                      ; restore length
    cmp r0                      ; end of sorted list?
    bcc pseek07                 ; went past it? exit with searchname/false
pseek20
    tya                         ; check smudge bit
    bmi pseek04                 ; smudged? next!
    and #bit5                   ; mask off immediate bit
    sta n+3                     ; save it for later
    lda n+2                     ; check vocabulary
    beq pseek02                 ; are we looking in Forth?
                                ; we are seeking in this vocabulary
    bcc pseek04                 ; this word is in Forth? next!
    ldy r0
    iny
    eor (tos),y                 ; compare vocabid
    bne pseek04                 ; vocabid doesn't match?  next!
pseek02
    ldy r0
    jsr strcomp                 ; compare names
    bne pseek04                 ; names don't match? next!
    ; winner!
    ;ldy #0                     ; thanks, strcomp

;pseek02    
    dey
    tya                         ; YA = -1
    bit n+3
    beq out
    iny
    lda #1
out
    jsr put6502

    dey                         ; Y=-1
    and #bit5                   ; check immediate bit
    beq pseek06
    tay
    iny

pseek03
    eor n+6
    cmp n+6
    bcs pseek07
pseek04
    jsr nfaplus01               ; ~ check this
    bne pseek01                 ; bra
    
pseek06
    tya
    brk
    .byt ld | TOS
    .byt push                   ; push the NFA
    .byt popd | TOS             ; get the CFA
    .byt br , <(pseek08-*-2)

pseek07
    ; loser...
    brk
    .byt ld | N0                ; get the original name
    .byt st | TOS
    .byt push                   ; push the name address twice
pseek08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | N4                ; status flag
    .byt push
    .byt nxt







 
    lda n+2                     ; which vocabulary are we looking in?
    beq pseek02                 ; searching root?
    bvc pseek03                 ; is this word within a vocabulary?
    clv                         ; allow this word to be found
    ldy r11
    iny
    eor (tos),y                 ; get vocabulary byte
    bne pseek03                 ; not the right vocabulary? next!

;pseek02
    bvs pseek03                 ; root search may not find vocabulary member
    lda r11
    cmp n+6                     ; compare lengths
    bne pseek04                 ; same length, compare strings too
    jsr strcomp
    bne pseek03
    ;ldy #0                     ; thank you, strcomp

    ; winner!
    inc n+8                     ; assume immediate, set N4 = +1
    lda (tos),y                 ; length and flags
    bmi pseek06                 ; immediate?
    dey
    sty n+8
    sty n+9                     ; normal, set N4 = -1
pseek06b
    brk
    .byt ld | TOS
    .byt push                   ; push the NFA
    .byt popd | TOS             ; get the CFA
    .byt br , <(pseek08-*-2)

pseek04b
    bcc pseek03                 ; shorter length? next!
    lda n+4                     ; check modeflag
    beq pseek07                 ; core mode, and we've gone past it


;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;                  --------------------------------------------
;                  --------------------------------------------
;obsolescent words --------------------------------------------
;                  --------------------------------------------
;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs
** TOS (R1) source base address
** N0 (R2) target base address
** N1 (R3) string length
* returns
** Y = FF

~ fix this to account for (V flag) inside a vocabulary
#endif
symcopy16
symcopy01
    jsr nfalen16a
    tay
    bvc symcopy16a
    iny                      ; string length
    sty n+2
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+2
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=pearsonhash16
tags=interpreter,nosymbol
Sweet16 wrapper around Pearson hash function

* inputs
** ACC (R0) length
** TOS (R1) NFA
* returns
** ACC (R0) Pearson hash hexdigit

#endif
pearsonhash16
    ldy r0
    jsr pearsonhash02
    sty r0+1
    sta r0
    rts

;--------------------------------------------------------------
#if 0
name=nfalen16
tags=nosymbol
!!!Subroutine
Sweet16 wrapper around nfalen16a subroutine
Get name field length, ignoring flag bits

sets C flag if smudged

* inputs
** TOS = NFA pointer
* returns
** ACC = length of NFA
** C = smudge bit
** V = vocabulary bit
** R11L = length (copy of A)
** Y = 0

#endif
nfalen16
    jsr nfalen16a
    rol R14H
    sty R0H
    sta R0L
    sty R14L                    ; should be able to test length=0 without touching ACC first
    rts

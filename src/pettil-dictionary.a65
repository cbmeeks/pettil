; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
#include "align.i65"
_tosyms
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  [[FORTH]] (vocid = 0) is
the last vocabulary searched, and is always present.  Executing a
vocabulary pushes it to the head of this stack.
#endif
#include "align.i65"
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary order.  Equivalent to `ONLY FORTH` in ANS Forth
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VSTACK]] search order to [[CURRENT]].
#endif
#include "align.i65"
_definitions
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NFALEN01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N6</b>|flags/length byte|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|always <b>0</b>|
|^<b>N</b>|<b>0</b> not smudged<br/><b>1</b> smudged|
|^<b>V</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> end of list|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0                      ;[2]
    lda (tos),y                 ;[5]
nfalen02
    sta n+12                    ;[3]
    and #$1f                    ;[2]
    sta n+13                    ;[3]
    bit n+12                    ;[3]
    clc                         ;[2]
    bvc nfalen03                ;[2/3]
    sec                         ;[2]
nfalen03
    rts                         ;[6]

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01
    jmp put

;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<br><i>returns</i>|<|
|<b>TOS</b>|next NFA|
|<b>N6</b>|flags/length byte|
|<b>Y</b>|always <b>0</b>|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +flags/length +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next

;--------------------------------------------------------------
#if 0
name=symcomp
tags=nosymbol
Compares two symbols at TOS and N0

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<b>N0</b>|NFA being sought|
|<br><i>returns</i>|<|
|^<b>Y</b>|index of mismatch<br/><b>0</b> if success<br/><b>FF</b> end of list|
|^<b>Z</b>|symbols match?|
#endif
symcomp
    ldy #0
    lda (tos),y
    bne symcomp01
    dey
    rts
symcomp01
    eor (n),y
    and #$df
    bne strcomp02           ; length, vocab bit or smudge?
    jsr nfalen01
    adc #0
    ;clc
    tay
    ; fall through
;--------------------------------------------------------------
#if 0
name=STRCOMP
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<br><i>inputs</i>|<|
|<b>TOS</b>|NFA|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br><b>0</b> if success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=SYMCOMP16
tags=subroutine,nosymbol
Compares two symbols, returns Sweet-16 Carry flag set if match
#endif
symcomp16
    jsr symcomp
    clc
    bne symcomp16b
    sec
symcomp16b
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=SYMCOPY16
tags=subroutine,nosymbol
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

|<br><i>inputs</i>|<|
|<b>TOS</b>|Source base address|
|<b>N0</b>|Target base address|
|<b>Y</b>|Name length (<i>symcopy16a</i>)|
|<br><i>returns</i>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|<b>FF</b>|
|<b>Z</b>|<b>0</b>|
#endif
symcopy16
    ldy n+13
    bit n+12
    bvc symcopy16a
    iny
    sty n+13
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+13
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=ext,nosymbol
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the Pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  -2      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab ident  ?  +len+1  Vocabulary token (if V bit set)
+---------------+
```
#endif
pearsonhash
    stx xsave
    jsr pearsonhash01
    ldx xsave
    jmp put

pearsonhash01
    jsr nfalen01            ; A=length
    sta 2*R11               ; seed hash1 with length
    tay                     ; count backwards
pearsonhash03
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda 2*R11                       ;[3]
    eor pearson,x                   ;[4]
    sta 2*R11                       ;[3]
    dey
    bne pearsonhash03
    sty 2*R11+1
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor 2*R11               ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=ext,nosymbol
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    ; these numbers were generated by the pearson.rb Ruby script which
    ; generates random hashes and selects the set that best balances
    ; a list of Forth words
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=ext,nosymbol
Forth wrapper around Bloom hash function
#endif
bloomhash
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

;--------------------------------------------------------------
#if 0
name=BLOOMHASH01
stack=( nfa -- n )
tags=subroutine,nosymbol
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash01
    jsr nfalen01
    sty 2*R11
    sty 2*R11+1
    tay
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc 2*R11                   ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta 2*R11                   ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda 2*R11
    rts

;--------------------------------------------------------------
#if 0
name=QSMUDGE
stack=( nfa -- nfa )
tags=compiler,nosymbol
Smudges or unsmudges the byte pointed to by `tos`

|<br><i>inputs</i>|<|
|<b>C</b>|<b>0</b> unsmudge<br/><b>1</b> smudge|
|<b>TOS</b>|NFA address|
|<br><i>returns</i>|<|
|^<b>A</b>|altered byte|
|^<b>Y</b>|<b>0</b>|
#endif
qsmudge
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    jsr qsmudge
    jmp drop

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.

~ This should honor the Smudge bit

```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary

```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,primitive,nosymbol
Called by [[(VFIND)]] for each dictionary segment search, e.g.
after this session:

```
VOCABULARY LATIN  OK
VOCABULARY GERMAN  OK
VOCABULARY SPANISH  OK
VOCABULARY FRENCH  OK
VOCABULARY RUSSIAN  OK
FORTH ASSEMBLER FRENCH LATIN  OK
VSTACK 5 DUMP 664E 02 05 01 00 00 OK
```
For each dictionary lookup, `(SEEK)` would be called eight times
in this sequence:

# //unsorted// [[SYMNEW]] of //02// `LATIN`
# //hashed// [[SYMTAB]] of //02// `LATIN`
# //unsorted// [[SYMNEW]] of //05// `FRENCH`
# //hashed// [[SYMTAB]] of //05// `FRENCH`
# //unsorted// [[SYMNEW]] of //01// `ASSEMBLER`
# //hashed// [[SYMTAB]] of //01// `ASSEMBLER`
# //unsorted// [[SYMNEW]] of //00// `FORTH`
# //hashed// [[SYMTAB]] of //00// `FORTH`
```
test case
    : fred   ." yaba daba doo" ;  ok
    vocabulary french  ok
    french definitions  ok
    : fred   ." ooh la la" ;
    fred ooh la la ok
    vocabulary german  ok
    : wilma  ." oui oui" ;
    german definitions  ok
    : fred   ." ja ja yabadoo" ;
    fred ja ja yabadoo ok
    french fred ooh la la ok
    german fred ja ja yabadoo ok
```
#endif
pseek
    ldy #6
    jsr locals                  ; TOS = startnfa; N0 = searchname
                                ; N1 = vocid; N2 = modeflag (unsorted?)
    sty n+8
    sty n+9                     ; set result = FALSE
    jsr nfalen01
    beq pseek06                 ; end of list?
    lda (n),y
    and #$1f
    ldy n+2
    beq pseek00
    ldy #0
    ora #bit6                   ; set vocab bit
pseek00
    sta (n),y
    and #$1f
    tay
    iny
    lda n+2
    sta (n),y
pseek01
    jsr symcomp
    beq pseek04                 ; vocab/length/name match?
    iny
    beq pseek06                 ; reached end of list?
    lda n+4
    bne pseek02                 ; unsorted list? next!
    tay
    lda (n),y
    and #$1f
    cmp n+13
    bcc pseek06
pseek02
    jsr nfaplus01               ; next!
    bne pseek01                 ; bra
pseek04                         ; winner!
    lda n+12
    and #bit5                   ; immediate?
    beq pseek04b
    tya
    iny
    bne pseek04c
pseek04b
    dey
    tya
pseek04c
    sta n+8
    sty n+9
    brk
    .byt popd | TOS
    .byt ldd | TOS

;    lda (tos),y
;    asl
;    asl
;    asl
;    tya
;    rol
;    sec
;    rol                         ; wind up with 3 or 1
;    sta n+8
;    brk
;    .byt popd | TOS             ; get the CFA
;    .byt ldd | TOS              ; reget the CFA and fix TOS
;    .byt dcr | N4               ; return -1 (not immediate)
;    .byt dcr | N4               ; return -1 (not immediate)
pseek05
    .byt push
    .byt ld | N4                ; return status flag
    .byt push
    .byt nxt
pseek06                         ; loser...
    brk
    .byt ld | N0                ; return NFA FALSE
    .byt st | TOS
    .byt br , <(pseek05-*-2)

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=primitive,nosymbol
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FIND
stack=( addr1 -- addr2 flag )
tags=interpreter,forth-83,nosymbol
addr1 is the address of a counted string, which is the word to look
up in the dictionary.

if not found, addr2 is the original addr1, and flag = 0
if found, addr2 is the code field address of the word,
and flag = -1 for normal words, +1 for immediate words

! outer interpreter

name is the address of a counted string we are searching for.
fflag is the find mode.  False means NFAs are sorted, True means check them all
nfa is the first nfa in the hash list

vocid identifies which vocabulary to search.  Vocabularies may be
nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
NFAs (with the vocid appended to the name before hashing) on the stack.
The final vocabulary searched will be core, and (FIND) will exit afterward.

  0 = corelist

  1 = assembler

  2+ = vocabularies added by the user

(FIND) first searches all unsorted names beginning at SYMTAIL, without regard
to name length.  If it fails to find the word there,
it tries the hash list, which is sorted in ascending size
order.  Vocabularies are searched first, beginning with CONTEXT and chaining
up until core (0) is reached.  The vocid is appended to the word when
searching that vocabulary.  Only one symbol within a vocabulary may be
active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
may be active within more than one vocabulary.

 returns
       ( cfa -1 ) found normal word
       ( cfa 1 ) found immediate word
       ( name 0 ) not in dictionary

```
: find ( name -- xfa flag )
    dup bloom# >bit bloom + cbit@
    if
        >r  vstack
 ( vstack ; name )
        begin
            c@+ r@ over
 ( vptr vocid name vocid ; name )
            (vfind)
 ( vptr vocid nfa xfa found? ; name )
            ?dup
            if
                rdrop 2>r 3drop 2r> exit
            then
            2drop 0=
        until
        drop r>
    then
    false ;
```
#endif
#include "align.i65"
_find
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(find04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word vstack
#include "page.i65"
find01
    .word cfetchplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
    .word twotor
#include "page.i65"
    .word threedrop
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word exit
#include "page.i65"
find03
    .word twodrop
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
find04
    .word false
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
* for duplicate names (same name & vocabulary)
** issues "//name// EXISTS" warning message
** sets [[REDEFINED]] user variable
* new symbol table entry
** symbol CFA links back to [[HERE]]
** compiles page-aligned `JSR cfa` at [[HERE]]
```
: (create)   ( cfa -- )
    bl word dup c@ 0=
    if 2drop exit then
    current c@ (vfind) nip
    if
        [ RVSON ] cliteral emit
        dup id.
        redefined !
        ." [RVSOFF] EXISTS"
        here
    then
    ( cfa here )
    dup bloom# >bit bloom + cbit!       \ add to bloom filter
    ( cfa here )
    symtail @  dup>r  2+ dup newest !   \ set NEWEST
    ( cfa here symtail+2 ; symtail )
    over nfalen 1+
    ( cfa here symtail+2 nfalen+1 ; symtail )

    current @ ?dup
    if
    ( cfa here symtail+2 nfalen+1 current ; symtail )
        >r  here c@ $40 or here c!
    ( cfa here symtail+2 nfalen+1+1 ; current symtail )
        r> over here + c!  1+
    ( cfa here symtail+2 nfalen+1+1 ; symtail )
    then
    ( cfa here symtail+2 nfalen+1+voc ; symtail )

    2dup +
    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )
    dup symtail ! 3 erase              \ mark new symtail
    ( cfa here symtail+2 len+1 ; symtail )
    cmove cfa,
    ( cfa ; symtail )
    here 3- r> ! ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pcreate03-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit
#include "page.i65"
pcreate03
    .word current
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word redefined
#include "page.i65"
    .word store
#include "page.i65"
    .word pdq
    .byt pcreate01-*-1
    .byt RVSOFF
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
pcreate02
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word newest
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pcreate04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word here
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word orx
#include "page.i65"
    .word here
#include "page.i65"
    .word cstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
pcreate04
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=ext,interpreter,nosymbol
32-bit wide Bloom filter for skipping [[REHASH]] passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=ext,nosymbol
Automatically move symbol table and vmbuf to someplace that leaves
at least 512 bytes for symbol table growth

The `lastpad` address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=UNSMUDGECLONE16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Unsmudge the last clone
#endif
unsmudgeclone16
    clc
    .byt $29            ; AND #

;--------------------------------------------------------------
#if 0
name=SMUDGECLONE16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Unsmudge the last clone
#endif
smudgeclone16
    sec
    jmp qsmudge

;--------------------------------------------------------------
#if 0
name=YIN16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Return -1 at end of list, -2 for copy, or a positive value to
skip this symbol.  Sweet16 carry flag is set if this symbol is
a clone.

|register|<|purpose|pass1|clone|h
|^R0|^ACC||^CFA||
|~|~|^return|^0 done with source||
|^R1|^TOS|nfa+|||
|^R2|^N0||^target|^target<br/>original|
|^R3|^N1|||original|
|^R4|^N2||positive|negative|
|^R5|^N3||||
|^R6|^N4||||
|^R7|^N5||||
|^R8|^N6|^symbol length|^length<br/>flags/length||
|^R9|^N7|newdp|^discard CFAs between<br>these addresses||
|^R10|^N8|tdict|~||
|^R11|^EXT|^return value|^<b>-1</b> end of list<br/><b>0</b> copy this symbol<br/><b>!0</b> do not copy<br/>||
|^R12|^SP||||
|^R13|^CPR||||
|^R14|^ST||<b>set</b> clone<br/><b>clear</b> not a clone<br/>||
|^R15|^PC||||
#endif
yin16
    jsr nfalen01
    stx R14L
    beq yin16d                  ; A=0? end of list. return -1
    eor zi
    bne yin16c                  ; bad length, return positive non-match
    bit n+4
    bpl yin16b                  ; match in pass1 mode
    lda n+13
    adc #0
    tay
yin16a
    lda (tos),y
    eor (n+2),y
    bne yin16d
    dey
    bne yin16a
    clc                         ; clone mode always returns carry false
    ror n+12                    ; clear sweet16 carry
yin16b
    lda #$c0
yin16c
    tay
yin16d
    dey
    sty 2*R11
    sty 2*R11+1
    asl n+12                    ; clone? is carry flag
    rol R14H
    rts
    
;--------------------------------------------------------------
#if 0
name=PASS1
stack=( from to -- )
tags=interpreter,ext,nosymbol
Copying from [[SYMTAB]] down to [[PAD]], this passes over every
available name length resulting in all names sorted by ascending
size at [[PAD]].

Filtering occurs on this pass for forgotten symbols that fall
between [[NEWDP]] and [[TDICT]].
#endif
#include "align.i65"
pass1
    ldy #2
    jsr locals                  ; targ to N0
    brk
    .byt sub | ACC
    .byt st | N2                ; clear "clone" mode
    .byt set | N8
    .word uarea+usernewdp-userarea
    .byt ldd | N8
    .byt st | N7                ; NEWDP
    .byt ldd | N8
    .byt st | N8                ; TDICT
    .byt ldd | TOS              ; get the first CFA
    .byt br , <(pass1b-*-2)     ; let's go
pass1a
    .byt ext
    .word nfaplus01
pass1b                          ; for each name in symtab...symtail
    .byt ext
    .word yin16                 ; will it blend?
    .byt bp , <(pass1a-*-2)     ; mismatch length? next!
    .byt bm1 , <(pass1j-*-2)    ; end of list?
    .byt bnc , <(pass1d-*-2)    ; first clone?
    .byt ld | TOS               ; clone mode ON
    .byt st | N1                ; pointer to first clone
    .byt push                   ; mark our place
    .byt dcr | N2               ; turn on "clone" mode
    .byt br , <(pass1d-*-2)
pass1c
    .byt pull                   ; clone mode OFF
    .byt sub | ACC
    .byt st | N2
    .byt br , <(pass1a-*-2)
pass1d
    .byt popd | TOS
    .byt ldd | TOS              ; get the CFA
    .byt cpr | N8
    .byt bc , <(pass1e-*-2)     ; in TDICT? green light
    .byt cpr | N7
    .byt bc , <(pass1a-*-2)    ; in CORE? green light
pass1e
    .byt std | N0
    .byt ext
    .word pearsonhash01
    .byt ld | R11
    .byt sti | N0               ; output the CFA and pearson hash
    .byt ld | N2
    .byt bp , <(pass1f-*-2)
    .byt ld | N0
    .byt st | N3                ; copy this, it might be the last one
    .byt ext 
    .word smudgeclone16         ; smudge the original
    .byt ext
    .word symcopy16
    .byt ext 
    .word unsmudgeclone16       ; unsmudge the copy
    .byt popd | TOS             ; make this clone uncopyable
    .byt ld | N7
    .byt std | TOS
    .byt br , <(pass1a-*-2)
pass1f
    .byt ext
    .word symcopy16
    .byt br , <(pass1a-*-2)
pass1j
    .byt ld | N2                ; check N2
    .byt bp , <(pass1k-*-2)
    .byt inr | N2               ; turn off clone mode
    .byt ld | N3
    .byt st | TOS
    .byt ext
    .word unsmudgeclone16       ; unsmudge (activate) the last clone
    .byt pull
    .byt br , <(pass1a-*-2)     ; unnest
pass1k
    .byt ld | N0
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
#if 0
name=YANG16
stack=( nfa -- nfa )
tags=interpreter,ext,nosymbol
Conditionally copy the symbol at TOS to N0
#endif
yang16
    ldy #0
    lda (tos),y
    jsr inctos
    eor zi
    and #$f                     ; ~ unnecessary?
    bne yang16f                 ; same pearson hash?
    jsr nfalen01
    adc #0
    sta n+4
    beq yang16f
    jsr bloomhash01
    tax
    and #7
    tay
    txa
    lsr
    lsr
    lsr
    tax
    lda power2,y
    ora bloom+3,x
    sta bloom+3,x
    sec
    .byt $29                ; AND #
yang16f
    clc                     ; we did not copy
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=PASS2
stack=( from to -- )
tags=interpreter,ext,nosymbol
Copying from [[PAD]] back to [[SYMTAB]], this passes over each
Pearson hash value.  Names will be ordered chronologically by
size within each Pearson hashed list at [[SYMTAB]].
#endif
#include "align.i65"
pass2
    ldy #2
    jsr locals              ; targ to N0
    brk
pass2a                          ; for each name in symtab...symtail
    .byt ldd | TOS              ; get cfa from source
    .byt bz , <(pass2c-*-2)     ; done with this pass?
    .byt ext
    .word yang16                ; compare Pearson hash to 'i'
    .byt bnc , <(pass2b-*-2)    ; Pearson hash <> 'i'?
    .byt std | N0               ; write cfa to target
    .byt ext
    .word symcopy16
pass2b
    .byt ext
    .word nfaplus01
    .byt popd | TOS
    .byt br , <(pass2a-*-2)     ; next!
pass2c
    .byt ld | N0
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=interpreter,ext,nosymbol
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA` 0|
|name| length| +1|
|vocid| 1| +length+1|
A ''//clone//'' is a symbol which has the

* same length, 
* same name 
* no vocabulary ([[FORTH]]) or same vocabulary
as another symbol in the dictionary, but with each
`clone` having a different `cfa`.  When a word is redefined,
the more recent definition replaces the original, so [[FORGET]]
will reverse that process.  The `smudge` flag bit ($80) is 
the key.

Smudge is set between ''[[:]]'' and ''[[;]]'' during a word's 
creation. If there is an error during compilation, [[UNDEFINE]] 
cleans up the partial (smudged) definition in the symbol table 
and also moves [[DP]] back to where it started.  There should 
only ever be one symbol at a time that is smudged during word
creation. 

The other reason a word is smudged is when it is redefined.  
When ''[[;]]'' closes the definition, if there is a previous 
active definition ([[REDEFINED]] is non-zero) then it will be 
smudged, and the new definition becomes active.  There should 
only ever be one active `clone` (the most recent) at a time.

As [[FORGET]] sorts through the symbol table, when it finds a
smudged symbol, that is how it knows it found a `clone`.  Since
PASS1 processes Pearson-hashed symbols in [[SYMTAB]] first, 
then [[SYMNEW]] symbols, the first clone found will also be 
the original definition of the word.  This order corresponds
to the chronological order in which symbols are added.  At this
point, PASS1 collects all the other clones and smudges them.  
When no more clones can be found, the last `clone` is unsmudged, 
making it the active one.

```
: (forget)   ( cfa -- )
    1- newdp !
    passbits 4 erase
    >syms pad  over 2+
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat  drop

( nfa targ )
    32 1 do
        over
        i >bit passbits + cbit@
( nfa targ+ nfa+ flag )
        ?:  pass1 drop
( nfa targ+ )
    loop nip 3 erase
( )
    automem
( )
    symtab @
    pad 2+ >syms
( nfa targ )
    16 0 do
        2dup pass2 nip nip
    loop
    nip dup 3 erase dup symnew ! symtail !
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word twoplus
#include "page.i65"
pforget01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pforget02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(pforget01-*+1)
#include "pad.i65"
pforget02
    .word drop
#include "page.i65"
    .word bl
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
pforget03
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word pquerycolon
    .word pass1
    .word drop
#include "pad.i65"
    .word ploop
    .byt <(pforget03-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _automem
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
pforget04
    .word twodup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word pass2
#include "page.i65"
    .word ploop
    .byt <(pforget04-*+1)
#include "pad.i65"
;    .word xyzzy
;#include "page.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
Rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (forget) ;   \ effectively a FORGET nil
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

1254
```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

#print (*-_tosyms)

; pettil-dictionary.a65
#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- addr )
tags=interpreter,ext
returns the address of the symbol portion of the symbol table
#endif
#include "align.i65"
_tosyms
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VSTACK
stack=( -- addr )
tags=vocabulary,interpreter
Vocabulary stack establishes search order.  [[FORTH]] (vocid = 0) is
the last vocabulary searched, and is always present.  Executing a
vocabulary pushes it to the head of this stack.
#endif
#include "align.i65"
vstack
    jsr docreate
    .dsb 10,0

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary order.  Equivalent to `ONLY FORTH` in ANS Forth
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VSTACK]] search order to [[CURRENT]].
#endif
#include "align.i65"
_definitions
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash )
tags=nosymbol,ext
input is NFA or address of a counted string
pearsonhash is the thread index (0..f)

the Pearson hash should return an evenly distributed
value between $00-$0f based on the wordset in the
core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.


```
symbol table entry
+---------------+
|    CFA[low]   |  +0      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  +2      Length field
[I]             |          Immediate bit
| [V]           |          Vocabulary bit
|   [S]         |          Smudge bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +3      Name field
|           ... |
|   name[len]   |
+---------------+
?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
+---------------+
```
#endif
pearsonhash
    stx xsave
    jsr pearsonhash01
    ldx xsave
    jmp put

pearsonhash01
    jsr nfalen01            ; A=length
    sta r0                  ; seed hash1 with length
    tay                     ; count backwards
pearsonhash02
    lda (tos),y                     ;[5]
    and #$07                        ;[2] (size of pearson table - 1)
    tax                             ;[2]
    lda r0                          ;[3]
    eor pearson,x                   ;[4]
    sta r0                          ;[3]
    dey
    bne pearsonhash02
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor r0                  ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM
stack=( -- addr )
tags=nosymbol,ext
The 64-bit Bloom filter used by the core dictionary.  The hash
is designed to filter out most tokens containing digits
#endif
bloom
    jsr docreate
    .word 0,0,0,0               ; 64 bits, used by hash2 (bloom filter)
pearson                         ; pearson hash table
    ; these numbers were generated by the pearson.rb Ruby script which
    ; generates random hashes and selects the set that best balances
    ; a list of Forth words
    .byt 243, 178, 217, 2, 54, 84, 189, 60

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( nfa -- n )
tags=nosymbol,concepts
Forth wrapper around Bloom hash function
#endif
bloomhash
    jsr nfalen01
    tay
    jsr bloomhash01             ; A=bloom#; Y=0
    jmp put

;--------------------------------------------------------------
#if 0
name=bloomhash01
stack=( nfa -- n )
tags=nosymbol,subroutine
The dictionary Bloom filter tries to answer the question,
'is this word a number or does it contain numbers?'
returning zero (no digits present) or the sum (mod64)
of each digits in this word plus how many digits.  If
any digit is present, BLOOMHASH will not return zero.

This is expected to sparsely populate the 64-bit wide
bloom filter field, allowing FIND to bypass the symbol
table search if the bit is turned off.

Calculate the bloom filter hash between 0..63.  Use >BIT
and CBIT! or CBIT@ to do something useful with the result.
#endif
bloomhash01
    lda #0
    sta r0
    sta r0+1
bloomhash02
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash03             ;[3] carry is set only for digits
    adc r0                      ;[3] anything with digits is nonzero
    and #(8*(pearson-(bloom+3)))-1   ;[2] keep it within the filter bits
    sta r0                      ;[3]
    bne bloomhash03             ; never return 0 if digits are present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash03
    dey
    bne bloomhash02
    lda r0
    rts

;--------------------------------------------------------------
#if 0
name=bloomhash16
tags=nosymbol
Sweet16 wrapper for Bloom hash

sets bloom filter bit

* inputs
** TOS (R1) NFA
** N1 (R3) length
* returns
** ACC (R0) address
#endif
bloomhash16
    ldy n+2                     ; NFA size in N1
    jsr bloomhash01
    pha
    lsr
    lsr
    lsr
    clc
    adc #<(bloom+3)
    sta r0
    tya
    adc #>(bloom+3)
    sta r0+1
    pla
    tay
    lda power2,y
    ldy #0
    ora (r0),y
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=NFALEN
stack=( nfa -- length )
tags=nosymbol
Return the length of the name
#endif
nfalen
    jsr nfalen01           ; A=length; Y=0
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=nfalen01
stack=( nfa -- nfa )
tags=dictionary,nosymbol
!!! Subroutine
Get the length of the symbol at TOS

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>A</b>|name length (without vocabid)|
|<b>Y</b>|symbol flag/length byte|
|^<b>Z</b>|<b>0</b> not last<br/><b>1</b> last|
|^<b>C</b>|<b>0</b> Forth<br/><b>1</b> Vocabulary|
#endif
nfalen01
    ldy #0
    lda (tos),y
    tay
    asl
    asl                 ; C = Vocab bit
    tya
    and #$1f
    rts

;--------------------------------------------------------------
#if 0
name=NFA+
stack=( nfa -- nfa+ )
tags=interpreter,ext,primitive,nosymbol
Chain to the next NFA on the list
#endif
nfaplus
    jsr nfaplus01
    jmp next

;--------------------------------------------------------------
#if 0
name=nfaplus01
stack=( nfa -- nfa+ )
tags=dictionary,nosymbol
!!! Subroutine
Chain to the next NFA on the list

|<b>inputs</b>|<|
|<b>TOS</b>|NFA|
|<b>returns</b>|<|
|<b>TOS</b>|next NFA|
|<b>Z</b>|always <b>0</b>|
#endif
nfaplus01
    jsr nfalen01
    adc #3              ; +cfa +length/flags +vocid
    ;clc
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
#if 0
name=strcomp
tags=nosymbol
Compares two strings known to be the same length pointed to by
`TOS` and `N0`.

|<b>inputs</b>|<|
|<b>TOS</b>|NFA in chain|
|<b>N0</b>|NFA being sought|
|<b>Y</b>|length|
|<b>returns</b>|<|
|<b>TOS</b>|unchanged|
|<b>N0</b>|unchanged|
|^<b>Y</b>|index of mismatch<br>0=success|
|<b>Z</b>|strings match?|
|<b>C</b>|unchanged|
#endif
strcomp
    lda (tos),y
    eor (n),y
    bne strcomp02
    dey
    bne strcomp
strcomp02
    rts

;--------------------------------------------------------------
#if 0
name=symcopy
tags=nosymbol,subroutine
Copies a symbol from (`TOS`) to (`N0`) 
Copies the 0th byte, and moves N0 beyond the copied string


#endif
symcopy
    rts

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.

~ This should honor the Smudge bit
```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
Displays the name of a word

```
: id.   ( nfa -- )
    1+ dup 1- nfalen type ;
```
#endif
#include "align.i65"
_iddot
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WORDS
stack=( -- )
tags=interpreter,dictionary,forth-83
Display the entire dictionary.

~ display just the words in the current context
~ display words by vocabulary
```
: words   ( -- )
     >syms 2+
 ( nfa )
     begin
         dup nfalen
 ( nfa flag )
     while
         dup id.
         nfa+
     until
     drop ;

: words   ( -- )
    cr >syms 2+
    begin
        dup nfalen ?terminal 0= and
    while
        dup
        name> >name.l10
        nfa+
    repeat
    drop ;
```
#endif
#include "align.i65"
_words
    jsr enter
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
words01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qterminal
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(words02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word numout
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(words01-*+1)
#include "pad.i65"
words02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( searchname vocid modeflag startnfa -- nfa xfa flag )
tags=interpreter,nosymbol,primitive
Called by [[(VFIND)]] for each dictionary segment search, e.g.
after this session:

```
VOCABULARY LATIN  OK
VOCABULARY GERMAN  OK
VOCABULARY SPANISH  OK
VOCABULARY FRENCH  OK
VOCABULARY RUSSIAN  OK
FORTH ASSEMBLER FRENCH LATIN  OK
VSTACK 5 DUMP 664E 02 05 01 00 00 OK
```
For each dictionary lookup, `(SEEK)` would be called eight times 
in this sequence:

# //unsorted// [[SYMNEW]] of //02// `LATIN`
# //hashed// [[SYMTAB]] of //02// `LATIN`
# //unsorted// [[SYMNEW]] of //05// `FRENCH`
# //hashed// [[SYMTAB]] of //05// `FRENCH`
# //unsorted// [[SYMNEW]] of //01// `ASSEMBLER`
# //hashed// [[SYMTAB]] of //01// `ASSEMBLER`
# //unsorted// [[SYMNEW]] of //00// `FORTH`
# //hashed// [[SYMTAB]] of //00// `FORTH`

|Register|Parameter|Description|h
|^N0|^searchname|`nfa` we are trying to find|
|^N1|^vocid|search vocabulary|
|^|^modeflag|TRUE = unsorted [[SYMNEW]]<br/>FALSE = sorted [[SYMTAB]]|
|^|^startnfa||
|^|^nfa||
|^|^xfa||
|^|^flag||

```
test case
    : fred   ." yaba daba doo" ;  ok
    vocabulary french  ok
    french definitions  ok
    : fred   ." ooh la la" ;
    fred ooh la la ok
    vocabulary german  ok
    : wilma  ." oui oui" ;
    german definitions  ok
    : fred   ." ja ja yabadoo" ;
    fred ja ja yabadoo ok
    french fred ooh la la ok
    german fred ja ja yabadoo ok
```
#endif
pseek
    ldy #3
    jsr locals                  ; TOS = startnfa; N0 = searchname 
                                ; N1 = vocid; N2 = modeflag
    brk
    .byt sub | ACC
    .byt st | N4                ; set result = FALSE
    .byt ldi | N0               ; R0 = length of searchname
    .byt dcr | N0               ; fix pointer to searchname
    .byt rtn
pseek01
    jsr nfalen01
    beq pseek07                 ; end of list? exit with searchname/false
    eor r0                      ; check lengths, preserving C flag
    beq pseek20                 ; same length? proceed
    bit n+4                     ; sorted or unsorted?
    bmi pseek04                 ; unsorted. next!
pseek03                         ; okay, it's sorted
    eor r0                      ; restore length
    cmp r0                      ; end of sorted list?
    bcs pseek07                 ; went past it? exit with searchname/false
pseek04
    jsr nfaplus01               ; next!
    bne pseek01                 ; bra

pseek20
    ;lda #0
    dey                         ; just to set N flag, checking Smudge
                                ; there are no 0-length words, so won't
                                ; affect flag bits
    bmi pseek04                 ; smudged? next!
    ldy r0
    lda n+2                     ; are we looking in the Forth vocabulary?
    beq pseek02                 ; leave the carry flag alone
    bcc pseek04                 ; this word doesn't belong to a vocabulary? next!
    iny
    eor (tos),y                 ; check the vocabid
    bne pseek04                 ; mismatch vocabid?  next!
    dey
    clc
pseek02
    bcs pseek04                 ; this word belongs to a vocabulary? next!
    jsr strcomp                 ; compare names
    bne pseek04                 ; lengths match, 
                                ; vocabid matches, 
                                ; but names don't? next!
    ; winner!
    ;ldy #0
    lda (tos),y
    and #bit5
    adc #$e0                    ; C=1 if Immediate
    rol R14H                    ; propagate to Sweet16
    brk
    .byt popd | TOS             ; get the CFA
    .byt ldd | TOS              ; reget the CFA and fix TOS
    .byt dcr | N4
    .byt bnc , <(pseek10-*-2)
    .byt inr | N4
    .byt inr | N4
pseek10
    .byt push
    .byt ld | N4                ; return status flag
    .byt push
    .byt nxt

pseek07
    ; loser...
    brk
    .byt ld | N0
    .byt st | TOS
    .byt br , <(pseek10-*-2)                                

;--------------------------------------------------------------
#if 0
name=(VFIND)
stack=( name vocid -- nfa xfa flag )
tags=nosymbol,primitive
Trial search within a vocabulary, used by FIND and (CREATE)

~ this code could stand some tightening up, better commenting

```
: (vfind)   ( name vocid -- nfa xfa flag )
: (vfind)   ( name vocid -- nfa xfa flag )
    2dup 2>r  true symnew @ 2+ (seek)
    ?dup 0=
    if
( name name )
        2drop 2r@ false third pearson# 2* symtab @ + @ 2+ (seek)
    then
    rdrop rdrop ;
```
#endif
#include "align.i65"
_pvfind
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word true
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
    .word qdup
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pvfind01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word tworfetch
#include "page.i65"
    .word false
#include "page.i65"
    .word third
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word pseek
#include "page.i65"
pvfind01
    .word rdrop
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNDEFINE
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
Removes the most recently defined symbol in SYMNEW.  Used by
error recovery

```
: undefine   ( -- )
    latest 2-  dup symtail !  dup @ dp !  3 erase ;
```
#endif
#include "align.i65"
_undefine
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
* for duplicate names
** issues "EXISTS" warning message
** sets REDEFINED user variable
* new symbol table entry
** symbol cfa links back to HERE
** compiles page-aligned `JSR cfa` at HERE
```
: (create)   ( cfa -- )
    bl word dup c@ 0=
    if 2drop exit then
    current c@ (vfind) nip
    if
        [ RVSON ] cliteral emit
        dup id.
        redefined !
        ." [RVSOFF] EXISTS"
        here
    then
    ( cfa here )
    dup bloom# >bit bloom + cbit!       \ add to bloom filter
    ( cfa here )
    symtail @  dup>r  2+ dup newest !   \ set NEWEST
    ( cfa here symtail+2 ; symtail )
    over nfalen 1+
    ( cfa here symtail+2 nfalen+1 ; symtail )

    current @ ?dup
    if
    ( cfa here symtail+2 nfalen+1 current ; symtail )
        >r  here c@ $40 or here c!
    ( cfa here symtail+2 nfalen+1+1 ; current symtail )
        r> over here + c!  1+
    ( cfa here symtail+2 nfalen+1+1 ; symtail )
    then
    ( cfa here symtail+2 nfalen+1+voc ; symtail )

    2dup +
    ( cfa here symtail+2 len+1 len+symtail+3 ; symtail )
    dup symtail ! 3 erase              \ mark new symtail
    ( cfa here symtail+2 len+1 ; symtail )
    cmove cfa,
    ( cfa ; symtail )
    here 3- r> ! ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _word
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(pcreate03-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word exit
#include "page.i65"
pcreate03
    .word current
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word _pvfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word redefined
#include "page.i65"
    .word store
#include "page.i65"
    .word pdq
    .byt pcreate01-*-1
    .byt RVSOFF
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
pcreate02
    .word dup
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word tobit
#include "page.i65"
    .word bloom
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word newest
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pcreate04-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word here
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word orx
#include "page.i65"
    .word here
#include "page.i65"
    .word cstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
pcreate04
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (forget)   ( cfa -- )
    1- newdp !

    passbits 4 erase
    >syms 2+ pad  over
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat  drop

( nfa targ )
    32 1 do
        over
        i >bit passbits + cbit@
( nfa targ+ nfa+ flag )
        ?:  pass1 drop
( nfa targ+ )
    loop nip 3 erase
( )
    automem
( )
    pad 2+ >syms
( nfa targ )
    16 0 do
        2dup pass2 nip nip
    loop
    nip dup 3 erase dup symnew ! symtail !
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
pforget01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pforget02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(pforget01-*+1)
#include "pad.i65"
pforget02
    .word drop
#include "page.i65"
    .word bl
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
pforget03
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word pquerycolon
    .word pass1
    .word drop
#include "pad.i65"
    .word ploop
    .byt <(pforget03-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit















;                  --------------------------------------------
;                  --------------------------------------------
;obsolescent words --------------------------------------------
;                  --------------------------------------------
;--------------------------------------------------------------
#if 0
name=symcopy16
tags=nosymbol
Copies a string from (tos) to (n0) via the Y register.
Copies the 0th byte, and moves N0 beyond the copied string

* inputs
** TOS (R1) source base address
** N0 (R2) target base address
** N1 (R3) string length
* returns
** Y = FF

~ fix this to account for (V flag) inside a vocabulary
#endif
symcopy16
    jsr nfalen16a
    tay
    bvc symcopy16a
    iny                      ; string length
    sty n+2
symcopy16a
    lda (tos),y
    sta (n),y
    dey
    bpl symcopy16a
    sec
    lda n+2
    adc n
    sta n
    bcc symcopy16b
    inc n+1
symcopy16b
    rts

;--------------------------------------------------------------
#if 0
name=pearsonhash16
tags=interpreter,nosymbol
Sweet16 wrapper around Pearson hash function

* inputs
** ACC (R0) length
** TOS (R1) NFA
* returns
** ACC (R0) Pearson hash hexdigit

#endif
pearsonhash16
    ldy r0
    jsr pearsonhash02
    sty r0+1
    sta r0
    rts

;--------------------------------------------------------------
#if 0
name=nfalen16
tags=nosymbol
!!!Subroutine
Sweet16 wrapper around nfalen16a subroutine
Get name field length, ignoring flag bits

sets C flag if smudged

* inputs
** TOS = NFA pointer
* returns
** ACC = length of NFA
** C = smudge bit
** V = vocabulary bit
** R11L = length (copy of A)
** Y = 0

#endif
nfalen16
    jsr nfalen16a
    rol R14H
    sty R0H
    sta R0L
    sty R14L                    ; should be able to test length=0 without touching ACC first
    rts

nfalen16a                       ; used by several Forth primitives
    ldy #0
    lda (tos),y
nfalen16b
    sta r11
    asl                         ; set carry flag if smudge bit
    lda r11
    and #$1f                    ; return length in A
    bit r11                   ; set V flag = Vocabulary bit
    sta r11
    rts

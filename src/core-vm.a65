; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm,forth-83
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027a )
tags=const,vm
!!!Constant
base address of cassette buffer #1
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033a )
tags=const,vm
!!!Constant
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=>BBUF
stack=( var -- addr )
tags=vm,nosymbol
Returns the address of a buffer located [[B/BUF]] bytes below
the contents of the variable `var`


!!! pronounced: "to-b-buff"
#endif
_tobbuf
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.  

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"
#endif
_blkbuf
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word _tobbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLEBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K Run Length Encoding buffer

This buffer is used to run-length encode a data packet in the
block buffer [[BLKBUF]] or a screen packet at [[VIDRAM]].  It
floats [[B/BUF]] (1024) bytes below the virtual memory packet 
buffer [[VMBUF]]


!!! pronounced: "r-l-e-buff"
#endif
_rlebuf
#include "enter.i65"
    .word vmbuf
#include "page.i65"
    .word _tobbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- to size flag )
tags=vm,sweet16
encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100 
    ; n7    targ (pristine)
    ; n8    size (pristine)
    brk
    .byt ld | TOS       ; size
    .byt st | N1        ; size (in)
    .byt st | N3        ; size (out)
    .byt st | N8        ; size (pristine)
    .byt pull           ; to
    .byt st | N2        ; targ (out)
    .byt st | N7        ; targ (pristine)
    .byt pull           ; from -- TOS = src (pristine)
    .byt st | N0        ; src (pristine)
    .byt set | N6       ; constant used to initialize (max repeat counter)
    .word $100
rlencode01
    .byt ld | N6        ; also unfindable character
rlencode02
    .byt st | N5        ; prev character
    .byt ld | N1        
    .byt bz, <(rlencode06-*-2)      ; done with input?
    .byt ld | N3        
    .byt bm , <(rlencode07-*-2)     ; are we in the red?
    .byt ldi | N0       ; read input stream
    .byt dcr | N1
    .byt sti | N2       ; write output stream
    .byt dcr | N3
    .byt cpr | N5       ; compare to prev
    .byt bnz , <(rlencode02-*-2)    ; different? go get more
    .byt ld | N6
    .byt st | N4        ; count backwards from 256
    .byt dcr | N4       ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2)     ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2)     ; end of input?
    .byt ldi | N0       ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2)     ; same char? loop

    .byt dcr | N0       ; different char? 
    .byt inr | N1       ; un-get from input stream
rlencode04              ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2       ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06              ; win
    .byt ld | N7        ; return ( to size 0 )
    .byt st | TOS
    .byt ld | N8
    .byt sub | N3       ; size (out)
    .byt push
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07              ; lose - copy
    .byt ld | N8        ; return ( from size $4000 )
    .byt push
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt
    
;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    ldy #2
    jsr locals
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.HEAD
stack=( packet -- packet flags len )
tags=vm
Returns the packet length and flags from a packet header

pronounced: "packet-head"

```
: pkthead   ( packet -- packet flags len )
    dup @ dup $c000 and swap $7ff and ;
```
#endif
pkthead
    jsr slip
    dex
    dex
    ldy #1
    lda (tos),y
    and #$7
    sta stackh,x
    lda (tos),y
    and #$c0
    sta stackh+1,x
    dey
    sty stackl+1,x
    lda (tos),y
    sta stackl,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=PKT.LEN
stack=( packet -- packet len )
tags=vm
Returns the packet length from a packet header

pronounced: "packet-len"

```
: pkt.len   ( packet -- packet len )
    pkt.head nip ;
```
#endif
_pktlen
#include "enter.i65"
    .word pkthead
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- packet )
tags=vm,ext
Return the packet address of block N

```
: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over 0>
    while
        pktlen
        - -1 +under
    repeat
    nip ;
```
#endif
_topkt
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topkt01
    .word over
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(topkt02-*+1)
#include "pad.i65"
    .word _pktlen
#include "page.i65"
    .word minus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word branch
    .byt <(topkt01-*+1)
#include "pad.i65"
topkt02
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable
#endif
_editingq
#include "enter.i65"
    .word editing
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCRPKT?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the SCRPKT user variable, which describes whether the current
packet type is screen (true) or data (false)
#endif
_scrpktq
#include "enter.i65"
    .word scrpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ISSCREEN
stack=( -- vidram b/scr $8000 )
tags=vm,ext,nosymbol
Values for packing/unpacking to [[VIDRAM]]

```
: isscreen
    vidram b/scr bl ;
```
#endif
_isscreen
#include "enter.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word bl
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ISDATA
stack=( -- blkbuf b/buf 0 )
tags=vm,ext,nosymbol
Values for packing/unpacking to [[BLKBUF]]

```
: isdata
    blkbuf b/buf 0 ;
```
#endif
_isdata
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SRCTARG
stack=( -- buffer size flags )
tags=vm,ext,nosymbol
BLOCK packs from or unpacks to VIDRAM or BLKBUF, based on whether
or ot we are editing.

```
: srctarg
    editing? @ ?: isscreen isdata ;
```
#endif
_srctarg
#include "enter.i65"
    .word _editingq
#include "page.i65"
    .word pquerycolon
    .word _isscreen
    .word _isdata
#include "pad.i65"
    .word exit
    
;--------------------------------------------------------------
#if 0
name=ISPREV?
stack=( blk -- flag )
tags=vm,ext,nosymbol
Sets PREV to `blk`, and returns a flag

* TRUE if `blk` is loaded.
* FALSE if `blk` is not loaded

```
: isprev?
    prev  2dup @  <>  -rot ! ;
```
#endif
_isprevq
#include "enter.i65"
    .word prev
#include "page.i65"
    .word twodup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word eq
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word store
#include "page.i65"
    .word exit
    
;--------------------------------------------------------------
#if 0
name=MKPKTS
stack=( n -- )
tags=vm,ext,nosymbol
creates `n+1` new packets in the `VMBUF` area

```
: ?mkpkts   ( n -- )
    -1 do
        vmbuf @  editing? @
        if
            -1 -1 third 3- 3c!
            $8005 over !
            5 -
        else
            2 over !
            2-
        then
        dup off vmbuf !  #vmpkt 1+!
    loop 2drop ;
```
#endif
_mkpkts
#include "enter.i65"
    .word minusone
#include "page.i65"
    .word pdo
#include "page.i65"
mkpkts01
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _editingq
#include "page.i65"
    .word qbranch
    .byt <(mkpkts02-*+1)
#include "pad.i65"
    .word minusone
#include "page.i65"
    .word minusone
#include "page.i65"
    .word third
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word plit
    .word $8005
#include "pad.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word clit
    .byt 5
#include "pad.i65"
    .word minus
#include "page.i65"
    .word branch
    .byt <(mkpkts03-*+1)
#include "pad.i65"
mkpkts02
    .word two
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word twominus
#include "page.i65"
mkpkts03
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word ploop
    .byt <(mkpkts01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MKPKTS
stack=( blk -- )
tags=vm,ext,nosymbol

```
: ?mkpkts   ( blk -- )
    #vmpkt @ over - dup 0<
    ?: mkpkts drop ;
```
#endif
_qmkpkts
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word pquerycolon
    .word drop
    .word _mkpkts
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT@
stack=( screen? -- packet )
tags=vm,ext,nosymbol
Append a new packet to the bottom of [[VMBUF]], return its address
flag = false for data packet, true for editor packet

```
: pkt+   ( screen? -- packet )
                                ( screen? )
    >r vmbuf @ 14 r@ 9 and -      \ packet length editor=5 data=14
 ( vmtail size )
    2dup - dup third erase        \ clear packet and new tail
    dup 2+ 3 r@ fill              \ first 3 bytes of packet = flag
    vmbuf !                       \ update vmbuf to new tail
    VIDRAM r> and or over !       \ set packet length
    #vmpkt 1+! ;                  \ increment packet counter )
    ( vmbuf )                     \ packet address
```
#endif
_pktfetch
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ORONGE
stack=( n -- addr )
tags=vm,fig,forth-79,forth-83
`ORONGE` is the new `BLOCK`

In PETTIL, returns the address of the only block buffer in the system.  
If [[EDITING?]] , `BLOCK` returns [[VIDRAM]]
if not [[EDITING?]] , `BLOCK` returns [[BLKBUF]]
if this block is already in the buffer (same as [[PREV]]), `BLOCK` does not unpack it again.

```
: block   ( blk -- buffer )
    dup isprev?
    if
        drop
    else
        dup ?mkpkts  
        >pkt pkt.head  
        pkt@
    then 
    srctarg 2drop ;

```
#endif
_newblock
#include "enter.i65"
    .word dup
#include "page.i65"
    .word _isprevq
#include "page.i65"
    .word qbranch
    .byt <(newblock01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(newblock02-*+1)
#include "pad.i65"
newblock01
    .word dup
#include "page.i65"
    .word _qmkpkts
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word pkthead
#include "page.i65"
    .word _pktfetch
#include "page.i65"
newblock02
    .word _srctarg
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( screen? -- packet )
tags=vm,ext
Append a new packet to the bottom of [[VMBUF]], return its address
flag = false for data packet, true for editor packet

```
: pkt+   ( screen? -- packet )
                                ( screen? )
    >r vmbuf @ 14 r@ 9 and -      \ packet length editor=5 data=14
 ( vmtail size )
    2dup - dup third erase        \ clear packet and new tail
    dup 2+ 3 r@ fill              \ first 3 bytes of packet = flag
    vmbuf !                       \ update vmbuf to new tail
    VIDRAM r> and or over !       \ set packet length
    #vmpkt 1+! ;                  \ increment packet counter )
    ( vmbuf )                     \ packet address
```
#endif
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word clit
    .byt 9
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word third
#include "page.i65"
    .word _erase
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word three
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word fill
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNPKT
stack=( packet -- blkbuf )
tags=vm,ext,nosymbol
Given the address of a packet (its size/flags word, at the top)
this will unpack the packet to the block buffer and return
the address of the unpacked block. Distinguishes among
compressed/uncompressed and screen/data packets

```
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk !
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap dup b/buf blank
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf screen? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R; blkbuf )
    if
        cmove
    else
        rldecode
    then
   rfrom nip  lin on ;
```
#endif
_unpkt
#include "enter.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word scrpkt
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zlt
#include "page.i65"
    .word tor
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word duptor
#include "page.i65"
    .word rswap
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _scrpktq
#include "page.i65"
    .word qbranch
    .byt <(unpkt01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word third
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
unpkt01
    .word rot
#include "page.i65"
    .word twominus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(unpkt02-*+1)
#include "pad.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt03-*+1)
#include "pad.i65"
unpkt02
    .word rldecode
#include "page.i65"
unpkt03
    .word rfrom
#include "page.i65"
    .word nip
#include "page.i65"
    .word lin
#include "page.i65"
    .word on
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(BLOCK)
stack=( blk -- blkbuf new? )
tags=vm,ext,nosymbol
Retrieves or creates the VM block "blk" and returns the block
buffer address.  If the block was created, "new?" is true
flag is true if the block is new, false if it already exists
New packets are created as either empty data blocks (1024 nulls) or 
blank editor screens (3 bytes linewrap + 1000 spaces) based on
the EDITING? user variable

```
: (block)   ( blk -- blkbuf new? )
    dup dup prev ! 1+ #vmpkt @  >  dup>r
 ( blk new? )
    if
 ( blk )
        #vmpkt @ - 0
 ( howmany junk )
        begin
 ( howmany junk )
            drop 1-
 ( howmany )
            editing? @ pkt+
 ( howmany packet )
            over 0<
        until
 ( howmany packet )
        nip
 ( howmany packet )
    else
 ( blk )
        >pkt
 ( packet )
    then
 ( packet )
    unpkt  r> ;
 ( blkbuf new? )
```
#endif
_pblock
#include "enter.i65"
    .word dup
#include "page.i65"
    .word dup
#include "page.i65"
    .word prev
#include "page.i65"
    .word store
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word zero
#include "page.i65"
pblock01                        ; BEGIN
    .word drop
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word _editingq
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word over
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock02                        ; ELSE
    .word _topkt
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( n -- addr )
tags=vm,fig,forth-79,forth-83
In PETTIL, returns the address of the only block buffer in the system.  If
the block is already in the buffer, does not unpack it again.

```
: block   ( n -- addr )
    prev 2dup  @ =
    if
        2drop  blkbuf
    else
        under ! (block)  drop
    then ;
```
#endif
_block
#include "enter.i65"
    .word prev
#include "page.i65"
    .word twodup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(block01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word branch
    .byt <(block02-*+1)
#include "pad.i65"
block01
    .word under
#include "page.i65"
    .word store
#include "page.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
block02
    .word exit

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o,~wut?
Current filename

todo: Same thing as FILENAME ?
todo: All parameter and no code, maybe a string variable?
#endif
currname
    .byt (currname01-*-1)
    .asc "PETTILPACKETS"
currname01
    .asc "   "              ; pad buffer out to 16 characters

;--------------------------------------------------------------
#if 0
name=SETNAM
stack=( -- )
tags=vm,i/o,kernel,~wut?
Sets up filename and device# parameters before tape and disk I/O

todo: use labels instead of magic numbers for zero page addresses
todo: move DRV# setup to SETLFS
#endif
_setnam
#include "enter.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(setnam01-*+1)
#include "pad.i65"
    .word count
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt $da
#include "pad.i65"
    .word store
#include "page.i65"
setnam01
    .word clit
    .byt $d1
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d4
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#VMPKT!
stack=( -- )
tags=vm,nosymbol
Reset virtual memory user variables for LOAD-BUFFERS or EMPTY-BUFFERS

```
: #vmpkt!   ( -- )
    scr off  blk off  prev on  #vmpkt off  blkbuf 2-
    begin
        pktlen ?dup
    while
        #vmpkt 1+!
        -
    repeat
    drop ;

```
#endif
_numvmpktstore
#include "enter.i65"
    .word scr
#include "page.i65"
    .word off
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word prev
#include "page.i65"
    .word on
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numvmpktstore01
    .word _pktlen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(numvmpktstore02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "page.i65"
    .word branch
    .byt <(numvmpktstore01-*+1)
#include "pad.i65"
numvmpktstore02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2- off  #vmpkt! ;

```
#endif
_emptybuffers
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _numvmpktstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to VMBUF, replacing
what existed there before

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name

called by STOP-L in the editor
#endif
_loadbuffers
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
loadbuffers01
    lda $d1
    beq loadbuffers03
    jsr $f4d3                   ; search for a named tape header block
    bne loadbuffers04
loadbuffers02
    brk
    ;file not found
loadbuffers03
    jsr $f5e5                   ; load next tape header
    beq loadbuffers02
loadbuffers04
    cpx #1
    bne loadbuffers01
    jsr $f67b                   ; (fb)=start; (c9)=end
    jsr aloha2
    ldx n
#include "toforth.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; raw tape read, skips setting (fb) (c9)
    jsr aloha2
    ldx n

    ; pad blkbuf-size size cmove
#include "toforth.i65"
    .word _blkbuf
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _numvmpktstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(IOSETUP)
stack=( -- )
tags=vm,kernel,nosymbol

#endif
_piosetup
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word store
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area, from VMBUF to BLKBUF, out to a PRG file on cassette or disk

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name
fb = to
fd = from
(c9) = to

This is called by STOP-S in the editor
#endif
_savebuffers
#include "enter.i65"
    .word _piosetup
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr PERFORMSAVE             ; save
    jsr aloha2
    ldx n
    jmp exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm,i/o,kernel,~wut?
Verifies the virtual memory area following a write, from VMBUF to BLKBUF

* DRV# is the device number
* FILENAME is the filename

todo: change magic number to labels in cbm.def
#endif
_verifybuffers
#include "enter.i65"
    .word _piosetup
#include "page.i65"
    .word one
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word _setnam
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
verifybuffers01
    lda $d1
    beq verifybuffers03
    jsr $f4d3                   ; search for a named tape header block
    bne verifybuffers04
verifybuffers02
    brk
    ;file not found
verifybuffers03
    jsr $f5e5                   ; load next tape header
    beq verifybuffers02
verifybuffers04
    cpx #1
    bne verifybuffers01
    jsr $f67b                   ; (fb)=start; (c9)=end

    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; verify
    jsr aloha2
    ldx n

    ; pad blkbuf-size size cmove
#include "toforth.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pad.i65"
    .word pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pad.i65"
verifybuffers05
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies the block buffer to the packet buffer at BLK where it will be
saved to tape at the next SAVE-BUFFERS

```
: update   ( -- )
    scrpkt?
    if
        vidram dup b/scr -trailing
    else
        0 blkbuf b/buf
    then
    rlebuf swap rlencode ;
```
#endif
_update
#include "enter.i65"
    .word _scrpktq
#include "page.i65"
    .word _editingq
#include "page.i65"
    .word qbranch
    .byt <(update01-*+1)
#include "pad.i65"
    .word vidram
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
    .byt <(update02-*+1)
#include "pad.i65"
update01
    .word zero
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word bperbuf
#include "page.i65"
update02
    .word _rlebuf
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word exit

; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm,forth-83
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027a )
tags=const,vm
!!!Constant
base address of cassette buffer #1
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033a )
tags=const,vm
!!!Constant
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=>BBUF
stack=( var -- addr )
tags=vm
Returns the address of a buffer located [[B/BUF]] bytes below
the contents of the variable `var`


!!! pronounced: "to-b-buff"
#endif
_tobbuf
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.  

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"
#endif
_blkbuf
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word _tobbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLEBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K Run Length Encoding buffer

This buffer is used to run-length encode a data packet in the
block buffer [[BLKBUF]] or a screen packet at [[VIDRAM]].  It
floats [[B/BUF]] (1024) bytes below the virtual memory packet 
buffer [[VMBUF]]


!!! pronounced: "r-l-e-buff"
#endif
_rlebuf
#include "enter.i65"
    .word vmbuf
#include "page.i65"
    .word _tobbuf
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( srcaddr targaddr srclen -- targend flag )
tags=vm,sweet16
encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | N5   ; input counter - when this hits zero, we're done
    .byt st | N6   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | N4   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | N4    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | N5   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | N6   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | N5
    .byt sti | N1   ; write output stream
    .byt dcr | N6
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | N4
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | N5
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | N5
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | N5              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | N4
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | N6
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( srcaddr targaddr srclen -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    ldy #2
    jsr locals
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKTLEN
stack=( packet -- packet len )
tags=vm
Returns the packet length from a packet header

pronounced: "packet-len"

```
: pktlen   ( packet -- packet len )
    dup @ $7ff and ;
```
#endif
_pktlen
#include "enter.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- packet )
tags=vm,ext
Return the packet address of block N

```
: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over 0>
    while
        pktlen
        - -1 +under
    repeat
    nip ;
```
#endif
_topkt
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topkt01
    .word over
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(topkt02-*+1)
#include "pad.i65"
    .word _pktlen
#include "page.i65"
    .word minus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word branch
    .byt <(topkt01-*+1)
#include "pad.i65"
topkt02
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( screen? -- packet )
tags=vm,ext
Append a new packet to the bottom of [[VMBUF]], return its address
flag = false for data packet, true for editor packet

```
: pkt+   ( screen? -- packet )
                                ( screen? )
    >r vmbuf @ 14 r@ 9 and -      \ packet length editor=5 data=14
 ( vmtail size )
    2dup - dup third erase        \ clear packet and new tail
    dup 2+ 3 r@ fill              \ first 3 bytes of packet = flag
    vmbuf !                       \ update vmbuf to new tail
    VIDRAM r> and or over !       \ set packet length
    #vmpkt 1+! ;                  \ increment packet counter )
    ( vmbuf )                     \ packet address
```
#endif
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word clit
    .byt 9
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word third
#include "page.i65"
    .word _erase
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word three
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word fill
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT
stack=( packet -- blkbuf )
tags=vm,ext
Given the address of a packet (its size/flags word, at the top)
this will unpack the packet to the block buffer and return
the address of the unpacked block. Distinguishes among
compressed/uncompressed and screen/data packets

```
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk !
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap dup b/buf blank
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf screen? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R; blkbuf )
    if
        cmove
    else
        rldecode
    then
   rfrom nip  lin on ;
```
#endif
_unpkta

;--------------------------------------------------------------
#if 0
name=UNPKT
stack=( packet -- blkbuf )
tags=vm,ext
Given the address of a packet (its size/flags word, at the top)
this will unpack the packet to the block buffer and return
the address of the unpacked block. Distinguishes among
compressed/uncompressed and screen/data packets

```
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk !
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap dup b/buf blank
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf screen? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R; blkbuf )
    if
        cmove
    else
        rldecode
    then
   rfrom nip  lin on ;
```
#endif
_unpkt
#include "enter.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word screenq
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zlt
#include "page.i65"
    .word tor
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word duptor
#include "page.i65"
    .word rswap
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank
#include "page.i65"
    .word screenq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(unpkt01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word third
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
unpkt01
    .word rot
#include "page.i65"
    .word twominus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(unpkt02-*+1)
#include "pad.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt03-*+1)
#include "pad.i65"
unpkt02
    .word rldecode
#include "page.i65"
unpkt03
    .word rfrom
#include "page.i65"
    .word nip
#include "page.i65"
    .word lin
#include "page.i65"
    .word on
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(BLOCK)
stack=( blk -- blkbuf new? )
tags=vm,ext,nosymbol
Retrieves or creates the VM block "blk" and returns the block
buffer address.  If the block was created, "new?" is true
flag is true if the block is new, false if it already exists
New packets are created as either empty data blocks (1024 nulls) or 
blank editor screens (3 bytes linewrap + 1000 spaces) based on
the EDITING? user variable

```
: (block)   ( blk -- blkbuf new? )
    dup dup prev ! 1+ #vmpkt @  >  dup>r
 ( blk new? )
    if
 ( blk )
        #vmpkt @ - 0
 ( howmany junk )
        begin
 ( howmany junk )
            drop 1-
 ( howmany )
            editing? @ pkt+
 ( howmany packet )
            over 0<
        until
 ( howmany packet )
        nip
 ( howmany packet )
    else
 ( blk )
        >pkt
 ( packet )
    then
 ( packet )
    unpkt  r> ;
 ( blkbuf new? )
```
#endif
_pblock
#include "enter.i65"
    .word dup
#include "page.i65"
    .word dup
#include "page.i65"
    .word prev
#include "page.i65"
    .word store
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word zero
#include "page.i65"
pblock01                        ; BEGIN
    .word drop
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word editingq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word over
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock02                        ; ELSE
    .word _topkt
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( n -- addr )
tags=vm,fig,forth-79,forth-83
In PETTIL, returns the address of the only block buffer in the system.  If
the block is already in the buffer, does not unpack it again.

```
: block   ( n -- addr )
    prev 2dup  @ =
    if
        2drop  blkbuf
    else
        under ! (block)  drop
    then ;
```
#endif
_block
#include "enter.i65"
    .word prev
#include "page.i65"
    .word twodup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(block01-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word branch
    .byt <(block02-*+1)
#include "pad.i65"
block01
    .word under
#include "page.i65"
    .word store
#include "page.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
block02
    .word exit

;--------------------------------------------------------------
#if 0
name=DISC
stack=( -- )
tags=vm,unimplemented
To start a disk session, insert a blank formatted disk and type
#endif
_disc
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o,~wut?
Current filename

todo: Same thing as FILENAME ?
todo: All parameter and no code, maybe a string variable?
#endif
currname
    .byt (currname01-*-1)
    .asc "PETTILPACKETS"
currname01
    .asc "   "              ; pad buffer out to 16 characters

;--------------------------------------------------------------
#if 0
name=SETNAM
stack=( -- )
tags=vm,i/o,kernel,~wut?
Sets up filename and device# parameters before tape and disk I/O

todo: use labels instead of magic numbers for zero page addresses
todo: move DRV# setup to SETLFS
#endif
_setnam
#include "enter.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(setnam01-*+1)
#include "pad.i65"
    .word count
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt $da
#include "pad.i65"
    .word store
#include "page.i65"
setnam01
    .word clit
    .byt $d1
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d4
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#VMPKT!
stack=( -- )
tags=vm
Update the #VMPKT user variable after a LOAD-BUFFERS

```
: #vmpkt!   ( -- )
    blkbuf 2-
    begin
        pktlen ?dup
    while
        #vmpkt 1+!
        -
    repeat
    drop ;

```
#endif
_numvmpktstore
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numvmpktstore01
    .word _pktlen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(numvmpktstore02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "page.i65"
    .word branch
    .byt <(numvmpktstore01-*+1)
#include "pad.i65"
numvmpktstore02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to VMBUF, replacing
what existed there before

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name

called by STOP-L in the editor
#endif
_loadbuffers
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
loadbuffers01
    lda $d1
    beq loadbuffers03
    jsr $f4d3                   ; search for a named tape header block
    bne loadbuffers04
loadbuffers02
    brk
    ;file not found
loadbuffers03
    jsr $f5e5                   ; load next tape header
    beq loadbuffers02
loadbuffers04
    cpx #1
    bne loadbuffers01
    jsr $f67b                   ; (fb)=start; (c9)=end
    jsr aloha2
    ldx n
#include "toforth.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; raw tape read, skips setting (fb) (c9)
    jsr aloha2
    ldx n

    ; pad blkbuf-size size cmove
#include "toforth.i65"
    .word _blkbuf
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _numvmpktstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(IOSETUP)
stack=( -- )
tags=vm,kernel,nosymbol

#endif
_piosetup
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word store
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area, from VMBUF to BLKBUF, out to a PRG file on cassette or disk

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name
fb = to
fd = from
(c9) = to

This is called by STOP-S in the editor
#endif
_savebuffers
#include "enter.i65"
    .word _piosetup
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr PERFORMSAVE             ; save
    jsr aloha2
    ldx n
    jmp exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm,i/o,kernel,~wut?
Verifies the virtual memory area following a write, from VMBUF to BLKBUF

* DRV# is the device number
* FILENAME is the filename

todo: change magic number to labels in cbm.def
#endif
_verifybuffers
#include "enter.i65"
    .word _piosetup
#include "page.i65"
    .word one
#include "page.i65"
    .word clit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word _setnam
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
verifybuffers01
    lda $d1
    beq verifybuffers03
    jsr $f4d3                   ; search for a named tape header block
    bne verifybuffers04
verifybuffers02
    brk
    ;file not found
verifybuffers03
    jsr $f5e5                   ; load next tape header
    beq verifybuffers02
verifybuffers04
    cpx #1
    bne verifybuffers01
    jsr $f67b                   ; (fb)=start; (c9)=end

    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; verify
    jsr aloha2
    ldx n

    ; pad blkbuf-size size cmove
#include "toforth.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pad.i65"
    .word pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pad.i65"
verifybuffers05
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies the block buffer to the packet buffer at BLK where it will be
saved to tape at the next SAVE-BUFFERS

```
: update   ( -- )
    screen? @
    if
        vidram dup b/scr -trailing
    else
        0 blkbuf b/buf
    then
    rlebuf swap rlencode ;
```
#endif
_update
#include "enter.i65"
    .word screenq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word editingq
#include "page.i65"
    .word qbranch
    .byt <(update01-*+1)
#include "pad.i65"
    .word vidram
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
    .byt <(update02-*+1)
#include "pad.i65"
update01
    .word zero
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word bperbuf
#include "page.i65"
update02
    .word _rlebuf
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    #vmpkt off  scr off  
    blkbuf 2- dup off  vmbuf !  
    prev on ;

```
#endif
_emptybuffers
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word scr
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word prev
#include "page.i65"
    .word on
#include "page.i65"
    .word exit


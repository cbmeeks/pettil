; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
Constant, bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm,forth-83
Constant, Bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K block buffer on the system, and all
packets are retrieved and stored through it.  Copying a block
to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "block-buff"
#endif
_blkbuf
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( srcaddr targaddr srclen -- targend flag )
tags=vm,sweet16
encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R10   ; input counter - when this hits zero, we're done
    .byt st | R11   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R10   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R11   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R10
    .byt sti | N1   ; write output stream
    .byt dcr | R11
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R10
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | R10
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R10              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R11
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( srcaddr targaddr srclen -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    ldy #2
    jsr locals
    brk
    .byt set | R9
    .word $100
rldecode01
    .byt ld | R9
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | R9
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- packet )
tags=vm,ext
Return the packet address of block N

```
: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over 0>
    while
        dup @
        - swap 1- swap
    repeat
    swap drop ;

```
#endif
_topkt
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topkt01
    .word over
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(topkt02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word branch
    .byt <(topkt01-*+1)
#include "pad.i65"
topkt02
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( writable? -- packet )
tags=vm,ext
Append a new packet to the bottom of [[VMBUF]], return its address
flag = false for data packet, true for editor packet

```
: pkt+   ( editable? -- packet )
                                ( editable? )
    >r vmbuf @ 14 r@ 9 and -      \ packet length editor=5 data=14
 ( vmtail size )
    2dup - dup third erase        \ clear packet and new tail
    dup 2+ 3 r@ fill              \ first 3 bytes of packet = flag
    vmbuf !                       \ update vmbuf to new tail
    VIDRAM r> and or over !       \ set packet length
    #vmpkt 1+! ;                  \ increment packet counter )
    ( vmbuf )                     \ packet address

```
#endif
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word clit
    .byt 9
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word third
#include "page.i65"
    .word _erase
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word three
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word fill
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNPKT
stack=( packet -- blkbuf )
tags=vm,ext
Given the address of a packet (its size/flags word, at the top)
this will unpack the packet to the block buffer and return
the address of the unpacked block. Distinguishes among
compressed/uncompressed and editable/uneditable packets

```
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk !
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap dup b/buf blank
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf editable? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R; blkbuf )
    if
        cmove
    else
        rldecode
    then
   rfrom nip ;

```
#endif
_unpkt
#include "enter.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word writableq
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zlt
#include "page.i65"
    .word tor
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word duptor
#include "page.i65"
    .word rswap
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank
#include "page.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(unpkt01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word third
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
unpkt01
    .word rot
#include "page.i65"
    .word twominus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(unpkt02-*+1)
#include "pad.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt03-*+1)
#include "pad.i65"
unpkt02
    .word rldecode
#include "page.i65"
unpkt03
    .word rfrom
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(BLOCK)
stack=( blk -- blkbuf new? )
tags=vm,ext,nosymbol
Retrieves or creates the VM block "blk" and returns the block
buffer address.  If the block was created, "new?" is true
flag is true if the block is new, false if it already exists
New packets are created as data blocks (1024 zeroes) or as editor
screens (3 bytes linewrap + 1000 spaces) if EDITMODE is set

```
: (block)   ( blk -- blkbuf )
    dup 1+ #vmpkt @  >  dup>r
 ( blk new? )
    if
 ( blk )
        #vmpkt @ - 0
 ( howmany junk )
        begin
 ( howmany junk )
            drop 1-
 ( howmany )
            editmode @ pkt+
 ( howmany packet )
            over 0<
        until
 ( howmany packet )
        nip
 ( howmany packet )
    else
 ( blk )
        >pkt
 ( packet )
    then
 ( packet )
    unpkt  r> ;
 ( blkbuf new? )

```
#endif
_pblock
#include "enter.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word zero
#include "page.i65"
pblock01                        ; BEGIN
    .word drop
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word editingq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word over
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock02                        ; ELSE
    .word _topkt
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( n -- addr )
tags=vm,fig,forth-79,forth-83
In PETTIL, returns the address of the only block buffer in the system
#endif
_block
#include "enter.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DISC
stack=( -- )
tags=vm,unimplemented
To start a disk session, insert a blank formatted disk and type
#endif
_disc
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
Current filename

~wut? should probably be a string variable with docreate
#endif
currname
    .byt (currname01-*-1)
    .asc "PETTILPACKETS"
currname01
    .asc "   "              ; pad buffer out to 16 characters

;--------------------------------------------------------------
#if 0
name=SETNAM
stack=( -- )
tags=vm,i/o,kernel
Sets up filename and device# parameters before tape and disk I/O
#endif
_setnam
#include "enter.i65"
    .word filename
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(setnam01-*+1)
#include "pad.i65"
    .word count
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt $da
#include "pad.i65"
    .word store
#include "page.i65"
setnam01
    .word clit
    .byt $d1                    ; ~wut? fix these magic numbers in cbm.def
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word drvnum                ; ~wut? maybe belongs in SETLFS
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d4
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#VMPKT!
stack=( -- )
tags=vm
Update the #VMPKT user variable after a LOAD-BUFFERS

```
: #vmpkt!   ( -- )
    blkbuf 2-
    begin
        dup @ 7ff and ?dup
    while
        #vmpkt 1+!
        -
    repeat
    drop ;

```
#endif
_numvmpktstore
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numvmpktstore01
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(numvmpktstore02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "page.i65"
    .word branch
    .byt <(numvmpktstore01-*+1)
#include "pad.i65"
numvmpktstore02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to VMBUF, replacing
what existed there before

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name

called by STOP-L in the editor
#endif
_loadbuffers
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr $f695                   ; (d6) = 027a | 033a
    jsr $f857                   ; press play on tape #
    jsr $f449                   ; searching...
loadbuffers01
    lda $d1
    beq loadbuffers03
    jsr $f4d3                   ; search for a named tape header block
    bne loadbuffers04
loadbuffers02
    brk
    ;file not found
loadbuffers03
    jsr $f5e5                   ; load next tape header
    beq loadbuffers02
loadbuffers04
    cpx #1
    bne loadbuffers01
    jsr $f67b                   ; (fb)=start; (c9)=end
    jsr aloha2
    ldx n
#include "toforth.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    jsr $f46d                   ; print LOADING or VERIFYING
    jsr $f8a3                   ; raw tape read, skips setting (fb) (c9)
    jsr aloha2
    ldx n
    
    ; pad blkbuf-size size cmove
#include "toforth.i65"
    .word _blkbuf
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _numvmpktstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area, from VMBUF to BLKBUF, out to a PRG file on cassette or disk

* DRV# is the device number
* FILENAME is the filename

d4 = drv#
d1 = length
(da) = name
fb = to
fd = from
(c9) = to

This is called by STOP-S in the editor
#endif
_savebuffers
#include "enter.i65"
    .word _setnam
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $fb
#include "pad.i65"
    .word store
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word clit
    .byt $c9
#include "pad.i65"
    .word store
#include "page.i65"
    .word to6502
    stx n                       ; $ff (storex) gets messed up by save!  Use N
    jsr aloha2
    lda #2
    sta $78                     ; mess with CHRGET, sets direct mode
    jsr PERFORMSAVE             ; save
    jsr aloha2
    ldx n
    jmp exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies the block buffer to the packet buffer at BLK where it will be
saved to tape at the next SAVE-BUFFERS

```
: update   ( -- )
    blkbuf  vmbuf @ b/buf - dup>r  b/buf  rlencode
    ( targend )
    r@ - 
```
#endif
_update
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    #vmpkt off blkbuf 2- dup off vmbuf ! ;

```
#endif
_emptybuffers
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word exit


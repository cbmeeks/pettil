; core-device.a65
#echo .       core-device.a65           I/O

;--------------------------------------------------------------
;
;       IRQ^   ( eorvalue -- )
;
;
#if 0
name=IRQ^
stack=( eormask -- )
tags=device
Called by the editor (and anything else) to flip the IRQ vector
on and off between two different values
#endif
irqcaret
    jsr toggleirq
    jmp pops

;--------------------------------------------------------------
;
;       SPACE
;
; * 83 device
;
#if 0
name=SPACE
stack=( -- )
tags=forth-83,i/o
Emits a space character
#endif
_space
#include "enter.i65"
    .word bl
#include "page.i65"
    .word emit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SPACES
;
; * 83 device
;
#if 0
name=SPACES
stack=( n -- )
tags=forth-83,i/o
Emits "n" spaces
#endif
_spaces
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(spaces02-*+1)
#include "pad.i65"
spaces01
    .word _space
#include "page.i65"
    .word ploop
    .byt <(spaces01-*+1)
#include "pad.i65"
spaces02
    .word exit

;--------------------------------------------------------------
;
;       COUNT   ( addr1 -- addr2 n1 )
;
; * 83 nucleus
;
#if 0
name=COUNT
stack=( addr1 -- addr2 n1 )
tags=forth-83
Leaves the address, addr2 and the character count +n of text
beginning at addr1.  addr2 is addr1+1 and n1 is the length of
the counted string at addr1.  The byte at addr1 contains the
byte count +n.  Range of +n is {0...255}.
#endif
count
    ldy #0
    lda (tos),y
    inc tos
    bne count01
    inc tos+1
count01
    jmp pushya

;--------------------------------------------------------------
;
;       TYPE   ( addr count -- )
;
; * 83 device
;
#if 0
name=TYPE
stack=( addr count -- )
tags=forth-83,i/o
#endif
type
    ldy #1
    jsr locals
    clc
    lda tos
    ldy numout+3
    adc (up),y
    sta (up),y
    iny
    lda tos+1
    adc (up),y
    sta (up),y
    ldy #0
type01
    cpy tos
    bne type02
    dec tos+1
    bpl type02
    jmp pops
type02
    lda (n),y
    jsr CHROUT
    iny
    bne type01
    inc n+1
    bne type01

;--------------------------------------------------------------
;
;       (.")   ( -- )
;
; * headerless
;
; types the inline counted string from the dictionary and moves IP
; to just after the string, paging if necessary
;
#if 0
name=(.")
tags=nosymbol,inner,i/o
#endif
_pdq
#include "enter.i65"
    .word rfrom             ; ( cstring-2 )
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word twodup
#include "page.i65"
    .word type
#include "page.i65"
    .word plus
#include "page.i65"
    .word to6502
skipinline
    lda tos+1
    sta ip+1
    lda tos
    sta ip
    jsr slide
    lda #0
    jmp pad

;--------------------------------------------------------------
;
;       .S ( -- )
;
;
#if 0
name=.S
tags=i/o,stack,ext
Output the data stack
#endif
_dots
#include "enter.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word _pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit


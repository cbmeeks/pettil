;core-inner.a65
#echo .       core-inner.a65            Inner Interpreter

;--------------------------------------------------------------
; W register, used by EXECUTE
w1
    .word $dead             ; (for when you just need a W register)
    .word exit              ; 'fragment secondary' used by EXECUTE

;--------------------------------------------------------------
;
;       EXECUTE
;
; * 83 nucleus
;
; Executes the definition found at addr.
;
;"      : execute ( cfa --- )
;"              jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
;--------------------------------------------------------------
#if 0
name=EXECUTE
tags=inner
stack=( cfa -- )
Executes the word whose code field address is on the stack.
#endif
execute
    lda tos                 ; <-- code field address
    sta w1                  ; in direct-threaded models, this
    lda tos+1               ; contains code instead of a pointer
    sta w1+1                ; [SP] -> [W1]
    lda ip+1
    pha
    lda ip
    pha
    lda #<(w1-2)
    sta ip
    lda #>(w1-2)
    sta ip+1
    jmp pops

;--------------------------------------------------------------
#if 0
name=>6502
tags=inner
stack=( -- )
Drop down from high-level Forth to inline 6502
#endif
to6502
    ldy ip
    iny
    clc
    bne to650201
    sec
to650201
    lda ip+1
    adc #0
    pha
    tya
    pha
    rts     ; [15]


;--------------------------------------------------------------
#if 0
name=(ABORT")
tags=inner,nosymbol,control
stack=( flag -- )
tags=nosymbol
if the flag is nonzero, types the inline counted string from the
dictionary and executes the word in STARTUP.  Otherwise adjusts IP
to after the string, paging if necessary ~wut?
#endif
_pabortq
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word rot
#include "page.i65"
    .word qbranch
    .byt <(pabortq01-*+1)
#include "pad.i65"
pabortq02
    .word cmdoff
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
pabortq01
    .word plus
#include "page.i65"
    .word to6502
    jmp skipinline

;--------------------------------------------------------------
#if 0
name=(LIT)
tags=inner,nosymbol
stack=( -- n )
Runtime behavior of LITERAL, puts a number "n" on the stack
#endif
plit
    jsr slip
    ldy #3
    lda (ip),y
    inc ip
    ldy #1
    bne lithi ; bra

;--------------------------------------------------------------
#if 0
name=(CLIT)
tags=inner,nosymbol,control
stack=( -- n )
Runtime behavior of CLITERAL, puts the next byte "n" in the 
dictionary to the stack
#endif
clit
    jsr slip
    lda #0
    ldy #2
lithi
    sta tos+1
    lda (ip),y
    sta tos
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=HEX
tags=number,i/o,forth-83
stack=( -- )
Sets the system number base to hexadecimal
#endif
_hex
#include "enter.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECIMAL
stack=( -- )
tags=number,i/o,forth-83
Sets the system number base to decimal
#endif
_decimal
#include "enter.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(DOES)
tags=inner,nosymbol
stack=( -- )
tags=nosymbol,control
Runtime behavior of a word built with <BUILDS ... DOES>
#endif
dodoes       
    pla
    sta n
    pla
    sta n+1
    pla
    sta n+2
    pla
    sta n+3
    lda ip+1
    pha
    lda ip
    pha
    ldy n
    bne dodoes01
    dec n+1
dodoes01
    dey
    sty ip
    lda n+1
    sta ip+1
    ldy n+3
    inc n+2
    bne dodoes02
    iny
dodoes02
    lda n+2
    jmp pushya

;--------------------------------------------------------------
#if 0
name=?BRANCH
stack=( flag -- )
tags=inner,nosymbol,control
If the flag is zero, takes the branch
#endif
qbranch
    lda tos
    ora tos+1       ; check the flag
    ldy stackl,x
    sty tos
    ldy stackh,x
    sty tos+1
    inx             ; drop
    tay             ; to set the Z flag
    beq branch
bump
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=(?DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Performs a do-loop if end<>begin
#endif
pqdo
    ldy #1
    jsr locals               ; end -> N0
    lda tos
    eor n
    sta n+2
    lda tos+1
    eor n+1
    ora n+2                 ; are begin and end loop indices the same?
    beq pqdo02              ; yes, nada
    ldy #3
pqdo01
    lda zi,y                ; set up for a loop
    pha
    lda tos,y               ; tos & n must be adjacent in zeropage ~wut?
    sta zi,y
    dey
    bpl pqdo01              ; Y=FF means perform the loop
pqdo02
    jsr slide
    tya                     ; sets the Z flag
    bne bump                ; beanie bump!
;fall through   ;beq branch             ; zero means end = begin (no loop)

;--------------------------------------------------------------
#if 0
name=BRANCH
stack=( -- )
tags=inner,nosymbol,control
Compiles an unconditional branch operation.
When used in the form: COMPILE BRANCH
an unconditional branch operation is compiled.
A one-byte branch offset must immediately follow
this compilation address.  The branch address
is typically generated by following BRANCH
with <RESOLVE or >MARK .

IP = address of 'branch' (you are here)
IP+2 = relative address of the target, same as for 6502 branches
#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bmi branch01    ; [2|3]
    ldy #0          ; [2]
    .byt $2c        ; [4]
branch01
    ldy #$ff        ; [2]
    sec             ; [2]
    adc ip          ; [3]
    sta ip          ; [3]
    tya             ; [2]
    adc ip+1        ; [3]
    sta ip+1        ; [3]
    jmp nexto       ; [3]   [34 forward |31 backward]


;--------------------------------------------------------------
#if 0
name=(+LOOP)
stack=( n -- )
tags=inner,nosymbol,control
Add "n" to inner loop index.  If loop index exceeds loop limit,
then iterate to the (do), otherwise skip past the branch and
proceed
#endif
pploop
    clc
    lda tos
    adc zi
    sta zi
    lda tos+1
    adc zi+1
    sta zi+1
    lda zi+2
    cmp zi
    lda zi+3
    sbc zi+1
    ldy tos+1
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
    inx
    tay
    bcc pploop01
    eor #$80
pploop01
    bmi branch
    bpl bump

;--------------------------------------------------------------
#if 0
name=(LOOP)
stack=( -- )
tags=inner,nosymbol,control
#endif
ploop
    inc zi
    bne ploop01
    inc zi+1
ploop01
    lda zi+2
    eor zi
    bne branch
    lda zi+3
    eor zi+1
    bne branch
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    jmp bump

;--------------------------------------------------------------
#if 0
name=(DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Loops from "begin" to "end"
#endif
pdo
    lda stackh,x
    sta n+1
    lda stackl,x
    sta n                   ; end -> N0
    ldy #3
pdo01
    lda zi,y                ; set up for a loop
    pha
    lda tos,y               ; takes advantage of tos being
    sta zi,y                ; adjacent to zi area
    dey
    bpl pdo01
;--------------------------------------------------------------
#if 0
name=2DROP
stack=( d -- )
tags=stack,forth-83
Discard the top two items on the stack
#endif
twodrop
poptwo
    inx
;--------------------------------------------------------------
#if 0
name=DROP
tags=stack,forth-83
stack=( n -- )
Discard the top of stack
#endif
drop
pops
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=4DROP
stack=( a b c d -- )
tags=stack,ext
Discard the top four stack items
#endif
fourdrop
	inx
;--------------------------------------------------------------
#if 0
name=3DROP
stack=( a b c -- )
tags=stack,ext
Discard the top three stack items
#endif
threedrop
	inx
    bne poptwo

;--------------------------------------------------------------
#if 0
name=I
tags=control
stack=( -- index )
Push the inner loop index of a DO LOOP to the stack
#endif
i
    ldy zi+1
    lda zi
    ; pass YA = value to push/put on stack
pushya
    pha
    jsr slip
    pla
    jmp put

;--------------------------------------------------------------
#if 0
name=J
stack=( -- index )
tags=control
Push the outer loop index of a DO LOOP to the stack
#endif
j
    stx storex
    tsx
    ldy $0102,x
    lda $0101,x             ; ~ test this
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=(LEAVE)
stack=( -- )
tags=inner,control,nosymbol
tags=inner,control,nosymbol
Exit a do loop early
#endif
pleave
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    jmp branch

;--------------------------------------------------------------
#if 0
name=(?LEAVE)
stack=( flag -- )
tags=inner,control,nosymbol
If flag is nonzero, exit the do loop early
#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    bne pleave
    jmp bump

;--------------------------------------------------------------
#if 0
name=SP@
stack=( -- sp )
tags=fig
Fetches the current data stack pointer
#endif
spfetch
    txa
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SP!
stack=( -- )
tags=fig
Initializes the data stack pointer to the value in user 
variable SP0
#endif
spstore
    ldy #usersp0-userarea
    lda (up),y
    tax
    dex             ; because it's 1> to make ?stack faster
    jmp next

;--------------------------------------------------------------
#if 0
name=RP!
stack=( -- )
tags=fig
Ordinarily the 6502 machine stack (aka PETTIL return stack) is
initialized to $01ff by BASIC, but the value stored at RP0 defaults
to $01fe instead.  This is because the PET ROM stores a line of
input at $0200 (where TIB points) and INTERPRET will be storing a
count of the first word on the line at $01ff
#endif
rpstore
    stx storex
    ldy #userrp0-userarea
    lda (up),y
    tax
    txs
    ldx storex
    jmp next

;--------------------------------------------------------------
#if 0
name=EXIT
stack=( -- )
tags=inner,nosymbol
The runtime behavior of ; 
Exits a colon definition, unnesting to the next higher level of
the return stack
#endif
exit
    pla
    sta ip
    pla
    sta ip+1        ; [RP+] -> IP
    jmp next        ; NEXT

;--------------------------------------------------------------
#if 0
name=DOCREATE
stack=( -- addr )
tags=nosymbol,inner
The business end of words created by CREATE
#endif
docreate
    pla
    clc
    adc #1
    sta n
    pla
    tay
    bcc docreate01
    iny
docreate01
    lda n
    jmp pushya

;--------------------------------------------------------------
#if 0
name=ENTER
stack=( -- )
tags=nosymbol,inner
The business end of colon definition words, pushes the current
IP on the return stack and execues the word following it
#endif
enter
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta storex      ;[3]
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda storex      ;[3]
    sta ip+1        ;[3]
    iny             ;[2]
    beq enter02     ;[2]
enter01
    sty ip          ;[3]
    jmp nexto       ;[3]
enter02
    inc ip+1
    bne enter01     ; bra

;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- c )
tags=nosymbol,inner
Runtime behavior of a word defined by CCONSTANT
#endif
docconst
	clc
	.byt $24
;--------------------------------------------------------------
#if 0
name=DOCONST
stack=( -- n )
tags=nosymbol,inner
Runtime behavior of a word defined by CONSTANT
#endif
doconst
	sec
    pla
    sta n
    pla
    sta n+1
    ldy #1
	lda (n),y
	pha
	bcs doconst02
	bpl doconst01
	dey
doconst01
	dey
	bcc doconst03
doconst02
	iny
	lda (n),y
	tay
doconst03
	pla
	jmp pushya		; [30]

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of words defined by 2CONSTANT
#endif
do2const
#include "enter.i65"
	.word doconst
#include "page.i65"
	.word doconst
#include "page.i65"
	.word exit

;--------------------------------------------------------------
#if 0
name=!IRQ
stack=( -- )
tags=inner
Invert the 6502 interrupt flag
#endif
notirq
    php
    pla
    eor #$04        ; invert I flag
    pha
    plp
    jmp next

;--------------------------------------------------------------
#if 0
name=?STACK
stack=( -- )
tags=inner
Check the  data stack pointer for sanity, abort if trouble
#endif
qstack
    ldy #usersp0-userarea           ; 2 = stack full
    txa
    bmi error
    cmp (up),y
    dey                             ; 1 = stack empty
    bcs error       ; stack empty
    jmp next

;--------------------------------------------------------------
;--------------------------------------------------------------
#if 0
name=SYSERR
stack=( -- )
tags=nosymbol,inner
General-purpose error handler, callable from primitives, used
to print a system error message and abort
pass in the error # in Y
      1 stack empty
      2 stack full
#endif
error
    sty tos
    ldy #0
    sty tos+1
    lda #>(fail+2)
    pha
    lda #<(fail+2)    ; transfer control to FAIL
    pha
;--------------------------------------------------------------
#if 0
name=>FORTH
stack=( -- )
tags=vocabulary
Jump up to high-level Forth from inline 6502
#endif
toforth
    pla
    sta ip
    pla
    sta ip+1
    lda #1
;--------------------------------------------------------------
#if 0
name=DOPAGE
stack=( -- )
tags=nosymbol
Page boundary crossing is handled by the compiler inserting 'page'
when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
to occur, and indicates an error in the compiler.

pad is also used by LITERAL, string, and other words which
contain inline arguments to offset IP at runtime
#endif
pad
    clc                     ; pass A = offset added to IP
    adc ip
    bcs pagen               ; check for page boundary crossing
    cmp #$ff
    bne pado                ; check for xxFF at end of page
page
    lda #0
pagen
    inc ip+1                ; cross the page
pado
    sta ip
    jmp nexto

;--------------------------------------------------------------
#if 0
name=FAIL
stack=( error -- )
tags=inner
Print an error message and abort
: fail   ( err# -- )
    errmess @ ?dup
    if
        swap 2* + @ count type
    else
        ." ERROR#" .
    then
    startup @ execute ;
#endif
fail
#include "enter.i65"
	.word errmess
#include "page.i65"
	.word fetch
#include "page.i65"
	.word qdup
#include "page.i65"
	.word qbranch
	.byt <(fail01-*+1)
#include "pad.i65"
	.word swap
#include "page.i65"
	.word twostar
#include "page.i65"
	.word plus
#include "page.i65"
	.word twominus
#include "page.i65"
	.word fetch
#include "page.i65"
	.word count
#include "page.i65"
	.word type
#include "page.i65"
	.word branch
	.byt <(fail03-*+1)
#include "pad.i65"
fail01
	.word _pdq
	.byt (fail02-*-1)
	.asc "ERR# "
fail02
#include "pad.i65"
	.word _dot
#include "page.i65"
fail03
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute

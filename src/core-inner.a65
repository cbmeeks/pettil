;core-inner.a65
#echo .       core-inner.a65            Inner Interpreter

;--------------------------------------------------------------
#if 0
name=EXECUTE
tags=inner
stack=( cfa -- )
Executes the word whose code field address is on the stack.

#endif
execute
    lda tos+1       ; [3]
    pha             ; [4]
    lda tos         ; [3]
    pha             ; [4]
    jsr slide       ; [a lot]
    php             ; [4]
    rti             ; [7]

;--------------------------------------------------------------
#if 0
name=(ABORT")
tags=inner,nosymbol,control,wut
stack=( flag -- )
if the flag is nonzero, types the inline counted string from the
dictionary and executes the word in STARTUP.  Otherwise adjusts IP
to after the string, paging if necessary
#endif
#include "align.i65"
_pabortq
    jsr enter
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word rot
#include "page.i65"
    .word qbranch
    .byt <(pabortq01-*+1)
#include "pad.i65"
pabortq02
    .word cmdoff
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
pabortq01
    .word plus
#include "page.i65"
    .word skipinline

;--------------------------------------------------------------
#if 0
name=(LIT)
tags=inner,nosymbol
stack=( -- n )
Runtime behavior of LITERAL, puts a number "n" on the stack

~ fix bug when crossing page boundaries
#endif
plit
    jsr slip
    ldy #3
    lda (ip),y
    inc ip
    ldy #1
    bne lithi ; bra

    ; this might be more robust at page boundaries
;    ldy #2
;    lda (ip),y
;    pha
;    iny
;    lda (ip),y
;    tay
;    pla
;    jsr push6502
;    lda #4
;    jmp pad

;--------------------------------------------------------------
#if 0
name=(CLIT)
tags=inner,nosymbol,control
stack=( -- n )
Runtime behavior of `CLITERAL`. Pushes the single byte following IP
on the stack
#endif
clit
    jsr slip
    lda #0
    ldy #2
lithi
    sta tos+1
    lda (ip),y
    sta tos
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=(DOES)
tags=inner,nosymbol,control
stack=( -- )
Runtime behavior of a word built with `<BUILDS ... DOES>`
#endif
dodoes
    jsr slip        ; slip something onto the stack
    stx xsave
    pla
    tax
    pla
    tay
    pla
    sta tos
    pla
    sta tos+1       ; PFA to TOS
    jsr inctos      ; PFA was off by one because of what JSR pushes
    lda ip+1
    pha
    lda ip
    pha             ; IP to return stack (for EXIT)
    stx ip
    sty ip+1        ; set IP from calling child word
    ldx xsave
    jmp next1       ; this entry point into NEXT only single-increments IP
    
;dodoes
;    jsr slip
;    stx xsave
;    tsx
;    lda $0104,x
;    sta tos+1
;    lda $0103,x
;    sta tos             ; PFA to TOS
;    jsr inctos
;    lda ip+1
;    sta $0104,x
;    lda ip
;    sta $0103,x         ; IP to return stack (for EXIT)
;    ldx xsave
;    pla
;    sta ip
;    pla
;    sta ip+1
;    jmp next1

;--------------------------------------------------------------
#if 0
name=(")
stack=( -- addr )
tags=inner,nosymbol
Returns the address of a string literal in the dictionary
#endif
pquote
    clc
    .byt $29            ; AND #$18 to skip CLC instruction
                        ; fall through
;--------------------------------------------------------------
#if 0
name=(.")
stack=( -- )
tags=inner,nosymbol
Displays an inline string

~ consolidate things that increment IP
#endif
pdq
    ldy ip+1
    lda ip
    jsr push6502
    jsr tos2plus
    ldy #0
    lda (tos),y
    clc
    adc #1
    jsr padjust
    ldy #>(_stringdot)
    lda #<(_stringdot)
    jsr push6502
    jmp execute

;--------------------------------------------------------------
#if 0
name=HEX
tags=number,i/o,forth-83
stack=( -- )
Sets the system number base to hexadecimal
#endif
#include "align.i65"
_hex
    jsr enter
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECIMAL
stack=( -- )
tags=number,i/o,forth-83
Sets the system number base to decimal
#endif
#include "align.i65"
_decimal
    jsr enter
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(?:)
stack=( flag -- )
tags=control,inner,nosymbol
The runtime of [[?:]], invokes one of the two high-level Forth words
following this instruction
#endif
pquerycolon
    ldy #3
    lda tos
    ora tos+1                   ; evaluate the flag
    bne pquerycolon01           ; true?
    iny
    iny                         ; false.
pquerycolon01
    jsr slide
    lda (ip),y
    pha
    dey
    lda (ip),y
    pha
    lda #4
    jsr padjust
    php
    rti

;--------------------------------------------------------------
#if 0
name=(?LEAVE)
stack=( flag -- )
tags=inner,control,nosymbol
If flag is nonzero, exit the do loop early
#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    bne pleave
    jmp bump

;--------------------------------------------------------------
#if 0
name=?BRANCH
stack=( flag -- )
tags=inner,nosymbol,control
If the flag is zero, takes the branch
#endif
qbranch
    lda tos
    ora tos+1       ; check the flag
    ldy stackl,x
    sty tos
    ldy stackh,x
    sty tos+1
    inx             ; drop
    tay             ; to set the Z flag
    beq branch
bump
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=(?DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Performs a do-loop if end<>begin

~ the way this handles `ip` is a little dicey at page boundaries
#endif
pqdo
    inc ip              ; skip past branch byte
    jsr subeq
    bne pdo
pqdo02
    inx
    jsr slide
    dec ip              ; we need the branch byte
    ; fall through
;--------------------------------------------------------------
#if 0
name=BRANCH
stack=( -- )
tags=inner,nosymbol,control
Compiles an unconditional branch operation. When used in the form:
[[COMPILE]] [[BRANCH]] , an unconditional branch operation is compiled.
A one-byte signed offset follows the pointer to `BRANCH`.  These branch
offset values are typically generated with [[<RESOLVE]] or [[>MARK]] .

`IP` points to address of `BRANCH`
(`IP`)+2 = the offset to `IP`,  calculated the same as for 6502 branches.
#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bmi branch01    ; [2|3]
    ldy #0          ; [2]
    .byt $2c        ; [4]
branch01
    ldy #$ff        ; [2]
    sec             ; [2]
    adc ip          ; [3]
    sta ip          ; [3]
    tya             ; [2]
    adc ip+1        ; [3]
    sta ip+1        ; [3]
    jmp nexto       ; [3]   [34 forward |31 backward]


;--------------------------------------------------------------
#if 0
name=(LOOP)
stack=( -- )
tags=inner,nosymbol,control
Compiled by [[LOOP]], this is the runtime routine to increment
the inner loop index `zi`.  If loop index exceeds loop limit
`zlim`, iterate back to (do), otherwise exit the loop.

PETTIL uses four bytes of [[zero page|PETTIL Zero page memory map]] for the inner loop
index/limit (`zi` `zlim`), for speed
#endif
ploop
    inc zi
    bne ploop01
    inc zi+1
ploop01
    lda zi
    eor zlim
    bne branch
    lda zi+1
    eor zlim+1
    bne branch
    beq ploop02

;--------------------------------------------------------------
#if 0
name=(+LOOP)
stack=( n -- )
tags=inner,nosymbol,control
Add `n` to inner loop index.  If loop index exceeds loop limit,
then iterate back to (do), otherwise exit the loop.  PETTIL uses
four bytes of zero page for the inner loop index/limit, for speed

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]
#endif
pploop
    sec             ; [2]
    lda zi          ; [3]
    sbc zlim        ; [3]
    sta n           ; [3]
    lda zi+1        ; [3]
    sbc zlim+1      ; [3]
    eor #$80        ; [2]
    tay             ; [2]
    clc             ; [2]
    lda n           ; [3]
    adc tos         ; [3]
    tya             ; [2]
    adc tos+1       ; [3]
    php             ; [3]
    clc             ; [2]
    lda tos         ; [3]
    adc zi          ; [3]
    sta zi          ; [3]
    lda tos+1       ; [3]
    adc zi+1        ; [3]
    sta zi+1        ; [3]

    jsr slide       ;
    plp             ; [4]
    bvc branch      ; [2]

ploop02
;    pla                 ; unnest outer loop from return stack
;    sta zi
;    pla
;    sta zi+1
;    pla
;    sta zlim
;    pla
;    sta zlim+1
;    jmp bump
    sec
    .byt $29            ; AND #
;--------------------------------------------------------------
#if 0
name=(LEAVE)
stack=( -- )
tags=inner,control,nosymbol
Exit a do loop early
#endif
pleave
    clc
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    bcs bump
    bcc branch

;--------------------------------------------------------------
#if 0
name=(DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Loops from "begin" to "end"
#endif
pdo
    ldy #2
    jsr locals
    ldy #3
pdo01
    lda zi,y
    pha
    lda tos,y
    sta zi,y
    dey
    bpl pdo01
    dex
    ; fall through

;--------------------------------------------------------------
#if 0
name=2DROP
stack=( d -- )
tags=stack,forth-83
Discard the top two items on the stack
#endif
twodrop
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=DROP
tags=stack,forth-83
stack=( n -- )
Discard the top of stack
#endif
drop
    ldy stackh,x
    lda stackl,x
    inx
    bne put                     ; bra

;--------------------------------------------------------------
#if 0
name=4DROP
stack=( a b c d -- )
tags=stack,ext
Discard the top four stack items
#endif
fourdrop
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=3DROP
stack=( a b c -- )
tags=stack,ext
Discard the top three stack items
#endif
threedrop
    inx
    bne twodrop

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    sec         ; [2]
    .byt $29    ; [2] AND #$18 to skip CLC instruction without affecting C flag
stores
    clc
    ldy #0      ; [2]
    lda stackl,x    ; [4]
    sta (tos),y ; [6]
    iny         ; [2]
    lda stackh,x    ; [4]
    sta (tos),y ; [6]       ; MSB is stored last, this is important to EVENTS
    bcs twodrop ; [3]
    rts

;--------------------------------------------------------------
#if 0
name=I
tags=control
stack=( -- index )
Push the inner loop index of a DO LOOP to the stack
#endif
i
    ldy zi+1
    lda zi
    ; pass YA = value to push/put on stack
pushya
    pha
    jsr slip
    pla
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    sec
    .byt $29        ; AND #
;--------------------------------------------------------------
#if 0
name=C@
stack=( addr -- 8b )
tags=forth-79,nucleus,memory


!!! pronounced: "c-fetch"
 8b is the contents of the byte at addr.

#endif
cfetch
    clc
cfetch01
    ldy #0
    lda (tos),y
    bcc put
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put

;--------------------------------------------------------------
#if 0
name=DOCONST
stack=( -- c )
tags=nosymbol,inner
Runtime behavior of a word defined by CONSTANT
#endif
doconst
    sec
    .byt $29                ; AND # to skip the CLC
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT
#endif
docconst
    clc
    jsr slip
    pla
    tay
    pla
    sta tos+1
    iny
    bne docconst01
    inc tos+1
docconst01
    sty tos
    bne cfetch01            ; bra

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of words defined by 2CONSTANT
#endif
#include "align.i65"
do2const
    jsr enter
#include "page.i65"
    .word doconst
#include "page.i65"
    .word doconst
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=R@
stack=( -- n ) ( R; n -- n )
tags=forth-83,nucleus,stack
Copy the top of the return stack to the data stack

!!! pronounced: "r-fetch"
#endif
rfetch
                                ; you can call me rfetch, or you can call me j,
                                ; but you doesn't have to call me johnson
;--------------------------------------------------------------
#if 0
name=J
stack=( -- index )
tags=control
Push the outer loop index of a DO LOOP to the stack
#endif
j
    stx xsave   ; [3]
    tsx         ; [2]
    ldy $0102,x ; [4]
    lda $0101,x ; [4]
    ldx xsave   ; [3]
    jmp pushya ; [14|15]

;--------------------------------------------------------------
#if 0
name=SP@
stack=( -- sp )
tags=fig
Fetches the current data stack pointer
#endif
spfetch
    txa
push0a
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SP!
stack=( -- )
tags=fig
Initializes the data stack pointer to the value in user
variable SP0
#endif
spstore
    ldx uarea+usersp0-userarea
    dex             ; because it's 1> to make ?stack faster
    jmp next

;--------------------------------------------------------------
#if 0
name=RP!
stack=( -- )
tags=fig
Ordinarily the 6502 machine stack (aka PETTIL return stack) is
initialized to $01ff by BASIC, but the value stored at RP0 defaults
to $01fe instead.  This is because the PET ROM stores a line of
input at $0200 (where TIB points) and INTERPRET will be storing a
count of the first word on the line at $01ff
#endif
rpstore
    txa
    ldx uarea+userrp0-userarea
    txs
    tax
    jmp next

;--------------------------------------------------------------
#if 0
name=EXIT
stack=( -- )
tags=inner,nosymbol
The runtime behavior of ;
Exits a colon definition, unnesting to the next higher level of
the return stack
#endif
exit
    pla
    sta ip
    pla
    sta ip+1        ; [RP+] -> IP
    jmp next        ; NEXT

;--------------------------------------------------------------
#if 0
name=CALLER
stack=( -- n )
tags=ext
Used by the business end of defining words to retrieve the address of the child word from the return stack. 
#endif
#include "align.i65"
_caller
    jsr enter
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word twotor
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOCREATE
stack=( -- addr )
tags=nosymbol,inner
The business end of words created by CREATE
#endif
#include "align.i65"
docreate
    jsr enter
#include "page.i65"
    .word _caller
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ENTER
stack=( -- )
tags=nosymbol,inner
The business end of colon definition words, pushes the current
IP on the return stack and execues the word following it
#endif
enter
    pla             ; [4]
    tay             ; [2]
    pla             ; [4]
    sta xsave       ; [3]
    lda ip+1        ; [3]
    pha             ; [3]
    lda ip          ; [3]
    pha             ; [3]
    lda xsave       ; [3]
    sta ip+1        ; [3]
    iny             ; [2]
    sty ip          ; [3]
    jmp nexto       ; [3] [39]

;--------------------------------------------------------------
#if 0
name=!IRQ
stack=( -- )
tags=inner
Invert the 6502 interrupt flag
#endif
notirq
    php
    pla
    eor #$04        ; invert I flag
    pha
    plp
    jmp next

;--------------------------------------------------------------
#if 0
name=?STACK
stack=( -- )
tags=inner
Check the  data stack pointer for sanity, abort if trouble
#endif
qstack
    ldy #2                          ; 2 = stack full
    txa
    bmi error
    dey                             ; 1 = stack empty
    cmp uarea+usersp0-userarea
    bcs error
    jmp next

;--------------------------------------------------------------
#if 0
name=SYSERR
stack=( -- )
tags=nosymbol,inner
General-purpose error handler, callable from primitives, used
to print a system error message and abort
pass in the error # in Y
      1 stack empty
      2 stack full
#endif
error
    sty tos
    ldy #0
    sty tos+1
    lda #>(_fail+2)
    pha
    lda #<(_fail+2)    ; transfer control to FAIL
    pha
;--------------------------------------------------------------
#if 0
name=>FORTH
stack=( -- )
tags=vocabulary,nosymbol
Jump up to high-level Forth from inline 6502
#endif
toforth
    pla
    sta ip
    pla
    sta ip+1
    lda #1                  ; fall through
;--------------------------------------------------------------
#if 0
name=DOPAGE
stack=( -- )
tags=nosymbol
Page boundary crossing is handled by the compiler inserting 'page'
when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
to occur, and indicates an error in the compiler.

pad is also used by LITERAL, string, and other words which
contain inline arguments to offset IP at runtime
#endif
pad
    clc                     ; pass A = offset added to IP
    adc ip
    bcs pagen               ; check for page boundary crossing
    cmp #$ff
    bne pado                ; check for xxFF at end of page
page
    lda #0
pagen
    inc ip+1                ; cross the page
pado
    sta ip
    jmp nexto

;--------------------------------------------------------------
#if 0
name=FAIL
stack=( error -- )
tags=inner
Outputs an [[error message|Error messages]], then [[ABORT]]

```
: fail   ( err# -- )
    warning @ ?dup
    if
        swap 2* + @ count type
    else
        . ."?ERR"
    then
    startup @ execute ;
```
#endif
#include "align.i65"
_fail
    jsr enter
#include "page.i65"
    .word warning
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(fail01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word branch
    .byt <(fail03-*+1)
#include "pad.i65"
fail01
    .word _dot
#include "page.i65"
    .word pdq
    .byt (fail02-*-1)
    .asc "?ERR"
fail02
#include "pad.i65"
fail03
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute

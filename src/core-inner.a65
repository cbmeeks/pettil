;core-inner.a65
#echo .       core-inner.a65            Inner Interpreter

;--------------------------------------------------------------
#if 0
name=(?:)
stack=( flag -- )
tags=control,inner,nosymbol
The runtime of [[?:]], invokes one of the two high-level Forth words
following this instruction
#endif
pquerycolon
    ldy #3
    lda tos
    ora tos+1                   ; evaluate the flag
    bne pquerycolon01           ; true?
    ldy #5                      ; false.
pquerycolon01
    lda (ip),y
    sta tos+1
    dey
    lda (ip),y
    sta tos
    lda #3
    jsr padjust
    ; fall through
;--------------------------------------------------------------
#if 0
name=EXECUTE
tags=inner
stack=( cfa -- )
Executes the word whose code field address is on the stack.

#endif
execute
    lda tos+1       ; [3]
    pha             ; [4]
    lda tos         ; [3]
    pha             ; [4]
    jsr slide       ; [a lot]
    php             ; [4]
    rti             ; [7]

;--------------------------------------------------------------
#if 0
name=SP!
stack=( -- )
tags=fig
Initializes the data stack pointer to the value in user
variable SP0
#endif
spstore
    ldx uarea+usersp0-userarea
    dex             ; because it's 1> to make ?stack faster
spstoreo
    jmp next

;--------------------------------------------------------------
#if 0
name=HEX
tags=number,i/o,forth-83
stack=( -- )
Sets the system number base to hexadecimal
#endif
#include "align.i65"
_hex
    jsr enter
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECIMAL
stack=( -- )
tags=number,i/o,forth-83
Sets the system number base to decimal
#endif
#include "align.i65"
_decimal
    jsr enter
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(DOES)
tags=inner,nosymbol,control
stack=( -- )
Runtime behavior of a word built with `<BUILDS ... DOES>`
#endif
dodoes
    jsr slip        ; slip something onto the stack
    stx xsave
    pla
    tax
    pla
    tay
    pla
    sta tos
    pla
    sta tos+1       ; PFA to TOS
    jsr inctos      ; PFA was off by one because of what JSR pushes
    lda ip+1
    pha
    lda ip
    pha             ; IP to return stack (for EXIT)
    stx ip
    sty ip+1        ; set IP from calling child word
    ldx xsave
    jmp next1       ; this entry point into NEXT only single-increments IP

;--------------------------------------------------------------
#if 0
name=(")
stack=( -- addr )
tags=inner,nosymbol
Returns the address of a string literal in the dictionary

~ this is pretty ugly
#endif
pquote
    clc
    bcc pdq01
pquote01
    ldy #2
    lda #3
    adc (ip),y
    jmp pad

;--------------------------------------------------------------
#if 0
name=(.")
stack=( -- )
tags=inner,nosymbol
Displays an inline string
#endif
pdq
    sec
pdq01
    jsr slip
    ldy ip+1
    sty tos+1
    ldy ip
    iny
    iny
    sty tos
    bne pdq02
    inc tos+1
pdq02
    bcc pquote01
    lda #>(_stringdot-1)
    pha
    lda #<(_stringdot-1)
    pha
    ldy #0
    lda (tos),y             ; get length byte
    ; fall through
;--------------------------------------------------------------
#if 0
name=padjust
stack=( -- )
tags=nosymbol
!!!Subroutine
Called by primitives to adjust `IP` and properly cross a
page boundary.  This routine exists so words like [[."]] and [[?:]]
can function outside the normal [[pad|DOPAGE]]/[[page|DOPAGE]] routines.

|IP+A lo|IP lo|IP hi|
| C set| IP+A| +1|
||||
| < FD| IP+A| IP+A|
| FD| FE| +1|
| FE| FE| +1|
| FF| FE| +1|

There is probably a worst-case scenario where it is possible to
cross two page boundaries, e.g. with [[(.")]] printing a 255-byte
string, where the [[(.")]] was compiled at the very top of the page.

|$42FC-$42FD| [[(.")]] cfa |
|$42FE| $FF(length) |
|$42FF-$43FE| the string |
|$43FF| `NOP` |

In this worst-case scenarios, `IP` would be set after `padjust` to
$44FE and the next execution of [[NEXT|Zero page buffer and NEXT routine]]
would use $4400 as the address of the following instruction.
#endif
padjust
    sec                     ; pass A = offset to be added to IP
    adc ip
    bcc padjust01
    inc ip+1                ; cross the page
padjust01
    cmp #$fd
    bcc padjust02
    inc ip+1                ; cross the page
    cmp #$ff
    beq padjust02
    lda #$fe
padjust02
    sta ip
    rts

;--------------------------------------------------------------
#if 0
name=?STACK
stack=( -- )
tags=inner
Check the  data stack pointer for sanity, abort if trouble
#endif
qstack
    ldy #2                          ; 2 = stack full
    txa
    bmi error
    dey                             ; 1 = stack empty
    cmp uarea+usersp0-userarea
    bcc rpstore01
    ;fall through
;--------------------------------------------------------------
#if 0
name=SYSERR
stack=( -- )
tags=nosymbol,inner
General-purpose error handler, callable from primitives, used
to print a system error message and abort
pass in the error # in Y
      1 stack empty
      2 stack full
#endif
error
    sty tos
    ldy #0
    sty tos+1
    ldy #>(_fail+3)
    lda #<(_fail+3)    ; transfer control to FAIL
;--------------------------------------------------------------
#if 0
name=>FORTH
stack=( -- )
tags=vocabulary,nosymbol
Jump up to high-level Forth from inline 6502
#endif
toforth
    sta ip
    sty ip+1
    jmp nexto

;--------------------------------------------------------------
#if 0
name=RP!
stack=( -- )
tags=fig
Ordinarily the 6502 machine stack (aka PETTIL return stack) is
initialized to $01ff by BASIC, but the value stored at RP0 defaults
to $01fe instead.  This is because the PET ROM stores a line of
input at $0200 (where TIB points) and INTERPRET will be storing a
count of the first word on the line at $01ff
#endif
rpstore
    txa
    ldx uarea+userrp0-userarea
    txs
    tax
rpstore01
    jmp next

;--------------------------------------------------------------
#if 0
name=(CLIT)
tags=inner,nosymbol,control
stack=( -- n )
Runtime behavior of `CLITERAL`. Pushes the single byte following IP
on the stack
#endif
clit
    clc
    lda #0
    beq lit01               ; bra

;--------------------------------------------------------------
#if 0
name=(LIT)
tags=inner,nosymbol
stack=( -- n )
Runtime behavior of LITERAL, puts a number "n" on the stack

#endif
plit
    sec
    ldy #3
    lda (ip),y
lit01
    tay
    jsr slip
    sty tos+1
    ldy #2
    lda (ip),y
    sta tos
bump01
    lda #3                  ; ip+3 or ip+4 depending on Carry
    ; fall through
;--------------------------------------------------------------
#if 0
name=DOPAGE
stack=( -- )
tags=nosymbol
Page boundary crossing is handled by the compiler inserting 'page'
when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
to occur, and indicates an error in the compiler.

pad is also used by LITERAL, string, and other words which
contain inline arguments to offset IP at runtime

It is important that callers to `pad` set Carry
#endif
pad
    adc ip                  ; pass A = offset added to IP
    bcs branch02            ; check for page boundary crossing
    cmp #$ff
    bne branch03            ; check for xxFF at end of page
page
    lda #0
    beq branch02            ; bra

;--------------------------------------------------------------
#if 0
name=(?LEAVE)
stack=( flag -- )
tags=inner,control,nosymbol
If flag is nonzero, exit the do loop early
#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    bne pleave
    beq bump

;--------------------------------------------------------------
#if 0
name=?BRANCH
stack=( flag -- )
tags=inner,nosymbol,control
If the flag is zero, takes the branch
#endif
qbranch
    lda tos
    ora tos+1       ; check the flag
    ldy stackl,x
    sty tos
    ldy stackh,x
    sty tos+1
    inx             ; drop
    tay             ; to set the Z flag
    beq branch
bump
    ;lda #3         ; bump01 does this for us
    clc
    bcc bump01      ; bra

;--------------------------------------------------------------
#if 0
name=(?DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Performs a do-loop if end<>begin

~ the way this handles `ip` is a little dicey at page boundaries
#endif
pqdo
    inc ip              ; skip past branch byte
    jsr subeq
    bne pdo
pqdo02
    inx
    jsr slide
    dec ip              ; we need the branch byte
    ; fall through
;--------------------------------------------------------------
#if 0
name=BRANCH
stack=( -- )
tags=inner,nosymbol,control
Compiles an unconditional branch operation. When used in the form:
[[COMPILE]] [[BRANCH]] , an unconditional branch operation is compiled.
A one-byte signed offset follows the pointer to `BRANCH`.  These branch
offset values are typically generated with [[<RESOLVE]] or [[>MARK]] .

`IP` points to address of `BRANCH`
(`IP`)+2 = the offset to `IP`,  calculated the same as for 6502 branches.
#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bpl branch01    ; [2|3]
    dec ip+1        ; [5]
branch01
    sec             ; [2]
    adc ip          ; [3]
    bcc branch03    ; [2|3]
branch02
    inc ip+1        ; [5]
branch03
    sta ip          ; [3]
    jmp nexto       ; [3]

;--------------------------------------------------------------
#if 0
name=(LOOP)
stack=( -- )
tags=inner,nosymbol,control
Compiled by [[LOOP]], this is the runtime routine to increment
the inner loop index `zi`.  If loop index exceeds loop limit
`zlim`, iterate back to (do), otherwise exit the loop.

PETTIL uses four bytes of [[zero page|PETTIL Zero page memory map]] for the inner loop
index/limit (`zi` `zlim`), for speed
#endif
ploop
    inc zi
    bne ploop01
    inc zi+1
ploop01
    lda zi
    eor zlim
    bne branch
    lda zi+1
    eor zlim+1
    bne branch
    beq ploop02

;--------------------------------------------------------------
#if 0
name=(+LOOP)
stack=( n -- )
tags=inner,nosymbol,control
Add `n` to inner loop index.  If loop index exceeds loop limit,
then iterate back to (do), otherwise exit the loop.  PETTIL uses
four bytes of zero page for the inner loop index/limit, for speed

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]
#endif
pploop
    sec             ; [2]
    lda zi          ; [3]
    sbc zlim        ; [3]
    sta n           ; [3]
    lda zi+1        ; [3]
    sbc zlim+1      ; [3]
    eor #$80        ; [2]
    tay             ; [2]
    clc             ; [2]
    lda n           ; [3]
    adc tos         ; [3]
    tya             ; [2]
    adc tos+1       ; [3]
    php             ; [3]
    clc             ; [2]
    lda tos         ; [3]
    adc zi          ; [3]
    sta zi          ; [3]
    lda tos+1       ; [3]
    adc zi+1        ; [3]
    sta zi+1        ; [3]

    jsr slide       ;
    plp             ; [4]
    bvc branch      ; [2]

ploop02
    sec
    .byt $29            ; AND #
;--------------------------------------------------------------
#if 0
name=(LEAVE)
stack=( -- )
tags=inner,control,nosymbol
Exit a do loop early
#endif
pleave
    clc
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    bcs bump
    bcc branch

;--------------------------------------------------------------
#if 0
name=(DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Loops from "begin" to "end"


An untested rewrite of the inner interpreter stack jazz

```
pdo
    ldy #2
    jsr locals
    ldy #3
pdo01
    lda zi,y
    pha
    lda tos,y
    sta zi,y
    dey
    bpl pdo01
    dex
    ; fall through
twodrop
    inx                         ; fall through
    bne drop                    ; bra
i
    ldy zi+1
    lda zi
    ; pass YA = value to push/put on stack
pushya
    dex
    pha
    tya
pushsa
    sta stackh,x
pushs
    pla
    sta stackl,x
drop
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next
push0a
    ldy #0
    beq pushya

cfetch
    clc
    .byt $29
fetch
    sec
    ldy #0
    lda (tos),y
    bcc put
    pha
    iny
    lda (tos),y
    ;bcs pushsa     ; is [2] shorter
    tay
    pla
    bcs put
```
#endif
pdo
    ldy #2
    jsr locals
    ldy #3
pdo01
    lda zi,y
    pha
    lda tos,y
    sta zi,y
    dey
    bpl pdo01
    dex
    ; fall through

;--------------------------------------------------------------
#if 0
name=2DROP
stack=( d -- )
tags=stack,forth-83
Discard the top two items on the stack
#endif
twodrop
    inx                         ; fall through
    bne drop

;--------------------------------------------------------------
#if 0
name=4DROP
stack=( a b c d -- )
tags=stack,ext
Discard the top four stack items
#endif
fourdrop
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=3DROP
stack=( a b c -- )
tags=stack,ext
Discard the top three stack items
#endif
threedrop
    inx
    bne twodrop

;--------------------------------------------------------------
#if 0
name=?EXIT
stack=( flag -- )
tags=ext
Exits the calling word if the flag is true

```
: ?exit   ( flag -- )
    if rdrop then ;
```
#endif
#include "align.i65"
_qexit
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(qexit01-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
qexit01
    .word exit

;--------------------------------------------------------------
#if 0
name=C!
stack=( 8b addr -- )
tags=forth-83,nucleus,memory
 The least-significant 8 bits of 16b are stored into the byte
 at addr.

!!! pronounced: "c-store"
#endif
cstore
    clc
    .byt $29            ; AND #

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    sec
    ldy #0      ; [2]
    lda stackl,x    ; [4]
    sta (tos),y ; [6]
    bcc twodrop
    lda stackh,x    ; [4]
    iny         ; [2]       ; clear Z flag
    sta (tos),y ; [6]       ; MSB is stored last, this is important to EVENTS
    bne twodrop ; [3]       ; bra

;--------------------------------------------------------------
#if 0
name=I
tags=control
stack=( -- index )
Push the inner loop index of a DO LOOP to the stack
#endif
i
    ldy zi+1
    lda zi
    jmp pushya
drop
    ldy stackh,x
    lda stackl,x
    inx
    bne put
    ; pass YA = value to push/put on stack
pushya
    dex
    pha
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    pla
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=SP@
stack=( -- sp )
tags=fig
Fetches the current data stack pointer
#endif
spfetch
    txa
push0a
    ldy #0
    beq pushya

;--------------------------------------------------------------
#if 0
name=C@
stack=( addr -- 8b )
tags=forth-79,nucleus,memory

!!! pronounced: "c-fetch"
 8b is the contents of the byte at addr.

`cfetch01` code is also reused by CCONSTANT CONSTANT
#endif
cfetch
    clc
    .byt $29        ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    sec
    ldy #0
fetch0a
    lda (tos),y
    bcc push0a
                        ; out; YA = (tos),Y+1 (tos),Y
                        ; in; Y = offset
                        ; C = clear
                        ; A = low byte
fetchya
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

;--------------------------------------------------------------
#if 0
name=DOCONST
stack=( -- c )
tags=nosymbol,inner
Runtime behavior of a word defined by CONSTANT
#endif
doconst
    sec
    .byt $29                ; AND # to skip the CLC
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT
#endif
docconst
    clc
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    ldy #1
    lda (tos),y
    bcc push0a
    bcs fetchya            ; bra

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of words defined by 2CONSTANT
#endif
#include "align.i65"
do2const
    jsr enter
#include "page.i65"
    .word doconst
#include "page.i65"
    .word doconst
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=R@
stack=( -- n ) ( R; n -- n )
tags=forth-83,nucleus,stack
Copy the top of the return stack to the data stack

!!! pronounced: "r-fetch"
#endif
rfetch
                                ; you can call me rfetch, or you can call me j,
                                ; but you doesn't have to call me johnson
;--------------------------------------------------------------
#if 0
name=J
stack=( -- index )
tags=control
Push the outer loop index of a DO LOOP to the stack
#endif
j
    stx xsave   ; [3]
    tsx         ; [2]
    ldy $0102,x ; [4]
    lda $0101,x ; [4]
    ldx xsave   ; [3]
    jmp pushya ; [14|15]

;--------------------------------------------------------------
#if 0
name=EXIT
stack=( -- )
tags=inner,nosymbol
The runtime behavior of ;
Exits a colon definition, unnesting to the next higher level of
the return stack
#endif
exit
    pla
    sta ip
    pla
    sta ip+1        ; [RP+] -> IP
    jmp next        ; NEXT

;--------------------------------------------------------------
#if 0
name=CALLER
stack=( -- n )
tags=ext
Used by the business end of defining words to retrieve the address of the child word from the return stack.
#endif
#include "align.i65"
_caller
    jsr enter
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word twotor
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOCREATE
stack=( -- addr )
tags=nosymbol,inner
The business end of words created by CREATE, returns the address
of the calling word plus 1
#endif
#include "align.i65"
docreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

;--------------------------------------------------------------
#if 0
name=ENTER
stack=( -- )
tags=nosymbol,inner
The business end of colon definition words, pushes the current
IP on the return stack and execues the word following it
#endif
enter
    pla             ; [4]
    tay             ; [2]
    pla             ; [4]
    sta xsave       ; [3]
    lda ip+1        ; [3]
    pha             ; [3]
    lda ip          ; [3]
    pha             ; [3]
    lda xsave       ; [3]
    sta ip+1        ; [3]
    iny             ; [2]
    sty ip          ; [3]
    jmp nexto       ; [3] [39]

;--------------------------------------------------------------
#if 0
name=!IRQ
stack=( -- )
tags=inner
Invert the 6502 interrupt flag
#endif
notirq
    php
    pla
    eor #$04        ; invert I flag
    pha
    plp
    jmp next

;--------------------------------------------------------------
#if 0
name=FAIL
stack=( error -- )
tags=inner
Outputs an [[error message|Error messages]], then [[ABORT]]

```
: fail   ( err# -- )
    warning @ ?dup
    if
        swap 2* + @ count type
    else
        . ."?ERR"
    then
    startup @ execute ;
```
#endif
#include "align.i65"
_fail
    jsr enter
#include "page.i65"
    .word warning
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(fail01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word branch
    .byt <(fail03-*+1)
#include "pad.i65"
fail01
    .word _dot
#include "page.i65"
    .word pdq
    .byt (fail02-*-1)
    .asc "?ERR"
fail02
#include "pad.i65"
fail03
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute

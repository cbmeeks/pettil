;core-inner.a65
#echo .       core-inner.a65            Inner Interpreter

;--------------------------------------------------------------
#if 0
name=EXECUTE
tags=inner
stack=( cfa -- )
Executes the word whose code field address is on the stack.

#endif
execute
    lda tos+1       ; [3]
    pha             ; [4]
    lda tos         ; [3]
    pha             ; [4]
    jsr slide       ; [a lot]
    php             ; [4]
    rti             ; [7]

;--------------------------------------------------------------
#if 0
name=>6502
tags=inner
stack=( -- )
Drop down from high-level Forth to inline 6502.  Relies on the compiler
to handle page boundary crossings.

~ Should this be called `;CODE` ?
#endif
to6502
    lda ip+1        ; [3]
    pha             ; [3]
    ldy ip          ; [3]
    iny             ; [2]
    tya             ; [2]
    pha             ; [3]
    rts             ; [6]

;--------------------------------------------------------------
#if 0
name=(ABORT")
tags=inner,nosymbol,control,wut
stack=( flag -- )
if the flag is nonzero, types the inline counted string from the
dictionary and executes the word in STARTUP.  Otherwise adjusts IP
to after the string, paging if necessary
#endif
_pabortq
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word rot
#include "page.i65"
    .word qbranch
    .byt <(pabortq01-*+1)
#include "pad.i65"
pabortq02
    .word cmdoff
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
pabortq01
    .word plus
#include "page.i65"
    .word to6502
    jmp skipinline

;--------------------------------------------------------------
#if 0
name=(LIT)
tags=inner,nosymbol,~wut?
stack=( -- n )
Runtime behavior of LITERAL, puts a number "n" on the stack

todo: What would happen after `inc ip` if IP=$ff (at a page boundary) before?
#endif
plit
    jsr slip
    ldy #3
    lda (ip),y
    inc ip
    ldy #1
    bne lithi ; bra

;--------------------------------------------------------------
#if 0
name=(CLIT)
tags=inner,nosymbol,control
stack=( -- n )
Runtime behavior of `CLITERAL`. Pushes the single byte following IP
on the stack
#endif
clit
    jsr slip
    lda #0
    ldy #2
lithi
    sta tos+1
    lda (ip),y
    sta tos
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=(")
stack=( -- addr )
tags=inner,nosymbol
Returns the address of a string literal in the dictionary
#endif
pquote
    clc
    .byt $29            ; AND #$18 to skip CLC instruction
                        ; fall through
;--------------------------------------------------------------
#if 0
name=(.")
stack=( -- )
tags=inner,nosymbol

~ get rid of the dependency on `perform`, use [[EXECUTE]] instead
#endif
pdq
    sec
    ldy ip+1
    lda ip
    jsr push6502
    jsr tos2plus                ; tos points to string's length byte
    bcc pdq01
    ldy #>(_stringdot)
    lda #<(_stringdot)
    jsr perform
    clc
pdq01
    ldy #2
    lda (ip),y
    adc #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=HEX
tags=number,i/o,forth-83
stack=( -- )
Sets the system number base to hexadecimal
#endif
_hex
#include "enter.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECIMAL
stack=( -- )
tags=number,i/o,forth-83
Sets the system number base to decimal
#endif
_decimal
#include "enter.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(DOES)
tags=inner,nosymbol,control
stack=( -- )
Runtime behavior of a word built with <BUILDS ... DOES>
#endif
dodoes
    pla
    sta n
    pla
    sta n+1
    pla
    sta n+2
    pla
    sta n+3
    lda ip+1
    pha
    lda ip
    pha
    ldy n
    bne dodoes01
    dec n+1
dodoes01
    dey
    sty ip
    lda n+1
    sta ip+1
    ldy n+3
    inc n+2
    bne dodoes02
    iny
dodoes02
    lda n+2
    jmp pushya

;--------------------------------------------------------------
#if 0
name=(?:)
stack=( flag -- )
tags=control,inner,nosymbol
The runtime of [[?:]], invokes one of the two high-level Forth words
following this instruction
#endif
pquerycolon
    ldy #3
    lda tos
    ora tos+1                   ; evaluate the flag
    bne pquerycolon01           ; true?
    iny
    iny                         ; false.
pquerycolon01
    jsr slide
    lda (ip),y
    pha
    dey
    lda (ip),y
    pha
    lda #4
    jsr padjust
    php
    rti

;--------------------------------------------------------------
#if 0
name=?BRANCH
stack=( flag -- )
tags=inner,nosymbol,control
If the flag is zero, takes the branch
#endif
qbranch
    lda tos
    ora tos+1       ; check the flag
    ldy stackl,x
    sty tos
    ldy stackh,x
    sty tos+1
    inx             ; drop
    tay             ; to set the Z flag
    beq branch
bump
    lda #3
    jmp pad

;--------------------------------------------------------------
#if 0
name=(?DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Performs a do-loop if end<>begin
#endif
pqdo
    ldy #1
    jsr locals               ; end -> N0
    lda tos
    eor n
    sta n+2
    lda tos+1
    eor n+1
    ora n+2                 ; are begin and end loop indices the same?
    beq pqdo02              ; yes, nada
    ldy #3
pqdo01
    lda zi,y                ; set up for a loop
    pha
    lda tos,y               ; tos & n must be adjacent in zeropage
    sta zi,y
    dey
    bpl pqdo01              ; Y=FF means perform the loop
pqdo02
    jsr slide
    tya                     ; sets the Z flag
    bne bump                ; beanie bump!
    ;beq branch             ;fall through   if end = begin (no loop)   
;--------------------------------------------------------------
#if 0
name=BRANCH
stack=( -- )
tags=inner,nosymbol,control
Compiles an unconditional branch operation.
When used in the form: COMPILE BRANCH
an unconditional branch operation is compiled.
A one-byte branch offset must immediately follow
this compilation address.  The branch address
is typically generated by following BRANCH
with <RESOLVE or >MARK .

IP = address of 'branch' (you are here)
IP+2 = relative address of the target, same as for 6502 branches
#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bmi branch01    ; [2|3]
    ldy #0          ; [2]
    .byt $2c        ; [4]
branch01
    ldy #$ff        ; [2]
    sec             ; [2]
    adc ip          ; [3]
    sta ip          ; [3]
    tya             ; [2]
    adc ip+1        ; [3]
    sta ip+1        ; [3]
    jmp nexto       ; [3]   [34 forward |31 backward]


;--------------------------------------------------------------
#if 0
name=(+LOOP)
stack=( n -- )
tags=inner,nosymbol,control
Add `n` to inner loop index.  If loop index exceeds loop limit,
then iterate back to (do), otherwise exit the loop.  PETTIL uses
four bytes of zero page for the inner loop index/limit, for speed

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]
#endif
pploop
    clc
    lda tos
    sta n
    adc zi
    sta zi
    lda tos+1
    adc zi+1
    sta zi+1
    jsr slide

    clc
    lda zlim
    sbc zi
    lda zlim+1
    sbc zi+1
    eor n
    and #$80
    beq branch
ploop02
    pla                 ; unnest outer loop from return stack
    sta zi
    pla
    sta zi+1
    pla
    sta zlim
    pla
    sta zlim+1
    jmp bump

;--------------------------------------------------------------
#if 0
name=(LOOP)
stack=( -- )
tags=inner,nosymbol,control
Increment inner loop index.  If loop index exceeds loop limit,
then iterate back to (do), otherwise exit the loop.  PETTIL uses
four bytes of zero page for the inner loop index/limit, for speed
#endif
ploop
    lda #1
    ldy #0
    jsr push6502
    jmp pploop

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    sec         ; [2]
    .byt $29    ; [2] AND #$18 to skip CLC instruction without affecting C flag
stores
    clc
    ldy #0      ; [2]
    lda stackl,x    ; [4]
    sta (tos),y ; [6]
    iny         ; [2]
    lda stackh,x    ; [4]
    sta (tos),y ; [6]
    bcs poptwo  ; [3]
    rts

;--------------------------------------------------------------
#if 0
name=(DO)
stack=( end begin -- )
tags=inner,nosymbol,control
Loops from "begin" to "end"
#endif
pdo
    lda stackh,x
    sta n+1
    lda stackl,x
    sta n                      
    ldy #3
pdo01
    lda zi,y                    ; set up for a loop
    pha
    lda tos,y                   ; takes advantage of tos being
    sta zi,y                    ; adjacent to zi area
    dey
    bpl pdo01                   ; fall through
;--------------------------------------------------------------
#if 0
name=2DROP
stack=( d -- )
tags=stack,forth-83
Discard the top two items on the stack
#endif
twodrop
poptwo
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=DROP
tags=stack,forth-83
stack=( n -- )
Discard the top of stack
#endif
drop
pops
    ldy stackh,x
    lda stackl,x
    inx
    bne put                     ; bra

;--------------------------------------------------------------
#if 0
name=4DROP
stack=( a b c d -- )
tags=stack,ext
Discard the top four stack items
#endif
fourdrop
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=3DROP
stack=( a b c -- )
tags=stack,ext
Discard the top three stack items
#endif
threedrop
    inx
    bne poptwo

;--------------------------------------------------------------
#if 0
name=I
tags=control
stack=( -- index )
Push the inner loop index of a DO LOOP to the stack
#endif
i
    ldy zi+1
    lda zi
    ; pass YA = value to push/put on stack
pushya
    pha
    jsr slip
    pla
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    sec         ; [2]
    .byt $29    ; [2] AND #$18 to skip CLC instruction without affecting C flag
fetchya
    clc         
    ldy #1      ; [2]
    lda (tos),y ; [5]
    sta n       ; [3]
    dey         ; [2]
    lda (tos),y ; [5]
    ldy n       ; [3]
    bcs put     ; [3] [36 = 27+9]
    rts

;--------------------------------------------------------------
#if 0
name=R@
stack=( -- n ) ( R; n -- n )
tags=forth-83,nucleus,stack
Copy the top of the return stack to the data stack

!!! pronounced: "r-fetch"
#endif
rfetch
                                ; you can call me rfetch, or you can call me j, 
                                ; but you doesn't have to call me johnson
;--------------------------------------------------------------
#if 0
name=J
stack=( -- index )
tags=control
Push the outer loop index of a DO LOOP to the stack
#endif
j
    stx storex  ; [3]
    tsx         ; [2]
    ldy $0102,x ; [4]
    lda $0101,x ; [4]
    ldx storex  ; [3]
    jmp pushya ; [14|15]

;--------------------------------------------------------------
#if 0
name=(LEAVE)
stack=( -- )
tags=inner,control,nosymbol
Exit a do loop early
#endif
pleave
    pla
    sta zi
    pla
    sta zi+1
    pla
    sta zi+2
    pla
    sta zi+3
    jmp branch

;--------------------------------------------------------------
#if 0
name=(?LEAVE)
stack=( flag -- )
tags=inner,control,nosymbol
If flag is nonzero, exit the do loop early
#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    bne pleave
    jmp bump

;--------------------------------------------------------------
#if 0
name=SP@
stack=( -- sp )
tags=fig
Fetches the current data stack pointer
#endif
spfetch
    txa
push0a
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SP!
stack=( -- )
tags=fig
Initializes the data stack pointer to the value in user
variable SP0
#endif
spstore
    ldx uarea+usersp0-userarea
    dex             ; because it's 1> to make ?stack faster
    jmp next

;--------------------------------------------------------------
#if 0
name=RP!
stack=( -- )
tags=fig
Ordinarily the 6502 machine stack (aka PETTIL return stack) is
initialized to $01ff by BASIC, but the value stored at RP0 defaults
to $01fe instead.  This is because the PET ROM stores a line of
input at $0200 (where TIB points) and INTERPRET will be storing a
count of the first word on the line at $01ff
#endif
rpstore
    txa
    ldx uarea+userrp0-userarea
    txs
    tax
    jmp next

;--------------------------------------------------------------
#if 0
name=EXIT
stack=( -- )
tags=inner,nosymbol
The runtime behavior of ;
Exits a colon definition, unnesting to the next higher level of
the return stack
#endif
exit
    pla
    sta ip
    pla
    sta ip+1        ; [RP+] -> IP
    jmp next        ; NEXT

;--------------------------------------------------------------
#if 0
name=DOCREATE
stack=( -- addr )
tags=nosymbol,inner
The business end of words created by CREATE
#endif
docreate
    pla
    clc
    adc #1
    sta n
    pla
    tay
    bcc docreate01
    iny
docreate01
    lda n
    jmp pushya

;--------------------------------------------------------------
#if 0
name=ENTER
stack=( -- )
tags=nosymbol,inner
The business end of colon definition words, pushes the current
IP on the return stack and execues the word following it
#endif
enter
    pla             ; [4]
    tay             ; [2]
    pla             ; [4]
    sta storex      ; [3]
    lda ip+1        ; [3]
    pha             ; [3]
    lda ip          ; [3]
    pha             ; [3]
    lda storex      ; [3]
    sta ip+1        ; [3]
    iny             ; [2]
    sty ip          ; [3]
;    cpy #$ff       ; unnecessary because CFA, page-aligns secondaries
;    beq enter02
;enter01
    jmp nexto       ; [3] [39]
;enter02
;    inc ip+1
;    bne enter01

;    stx storex      ; [3]
;    pla             ; [4]
;    tax             ; [2]
;    pla             ; [4]
;    tay             ; [2]
;    lda ip+1        ; [3]
;    pha             ; [3]
;    lda ip          ; [3]
;    pha             ; [3]
;    inx             ; [2]
;    stx ip          ; [3]
;    beq enter02     ; [2]
;enter01
;    sty ip+1        ; [3]
;    ldx storex      ; [3]
;    jmp nexto       ; [3] [43]
;enter02
;    iny
;    bne enter01


;    stx storex      ; [3]
;    tsx             ; [2]
;    ldy $0101,x     ; [4]
;    lda ip          ; [3]
;    sta $0101,x     ; [5]
;    iny             ; [2]
;    sty ip          ; [3]
;    beq enter02     ; [2]
;    ldy $0102,x     ; [4]
;enter01
;    lda ip          ; [3]
;    sta $0102,x     ; [5]
;    sty ip+1        ; [3]
;    ldx storex      ; [3]
;    jmp nexto       ; [3] [45]
;enter02
;    ldy $0102,x
;    iny
;    bne enter01
    
;    pla             ;[4]
;    tay             ;[2]
;    pla             ;[4]
;    sta storex      ;[3]
;    lda ip+1        ;[3]
;    pha             ;[3]
;    lda ip          ;[3]
;    pha             ;[3]
;    lda storex      ;[3]
;    sta ip+1        ;[3]
;    iny             ;[2]
;    beq enter02     ;[2]
;enter01
;    sty ip          ;[3]
;    jmp nexto       ;[3] [41]
;enter02
;    inc ip+1
;    bne enter01     ; bra

;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- c )
tags=nosymbol,inner
Runtime behavior of a word defined by CCONSTANT
#endif
docconst
    sec
    .byt $29                ; AND # to skip the SEC
;    clc
;    .byt $24                    ; bit zp to skip the sec
;--------------------------------------------------------------
#if 0
name=DOCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CONSTANT
#endif
doconst
    clc
    pla
    sta n
    pla
    sta n+1
    ldy #2
doconst01
    lda (n),y
    bcc doconst02
    clc
    lda #0
doconst02
    pha
    dey
    bne doconst01
    jmp rfrom      ; 25 bytes

;    clc
;    pla
;    sta n
;    pla
;    sta n+1
;    ldy #1
;    lda (n),y
;    dey
;    bcs doconst01
;    pha
;    ldy #2
;    lda (n),y
;    tay
;    pla
;doconst01
;    jmp pushya      ; 26 bytes

;    clc
;    pla
;    sta n
;    pla
;    sta n+1
;    ldy #1
;    lda (n),y
;    pha
;    bcs doconst01
;    iny
;    lda (n),y
;    tay
;    .byt $24            ; BIT zp to skip DEY
;doconst01
;    dey
;    pla
;    jmp pushya      ; 26 bytes

    
;    sec
;    pla
;    sta n
;    pla
;    sta n+1
;    ldy #1
;    lda (n),y
;    bcc doconst01
;    pha
;    iny                         ; Y=2
;    lda (n),y
;    tay
;    pla
;    .byt $24                    ; bit zp to skip the dey
;doconst01
;    dey                         ; Y=0
;    jmp pushya

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of words defined by 2CONSTANT
#endif
do2const
#include "enter.i65"
    .word doconst
#include "page.i65"
    .word doconst
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!IRQ
stack=( -- )
tags=inner
Invert the 6502 interrupt flag
#endif
notirq
    php
    pla
    eor #$04        ; invert I flag
    pha
    plp
    jmp next

;--------------------------------------------------------------
#if 0
name=?STACK
stack=( -- )
tags=inner
Check the  data stack pointer for sanity, abort if trouble
#endif
qstack
    ldy #2                          ; 2 = stack full
    txa
    bmi error
    dey                             ; 1 = stack empty
    cmp uarea+usersp0-userarea
    bcs error
    jmp next

;--------------------------------------------------------------
#if 0
name=SYSERR
stack=( -- )
tags=nosymbol,inner
General-purpose error handler, callable from primitives, used
to print a system error message and abort
pass in the error # in Y
      1 stack empty
      2 stack full
#endif
error
    sty tos
    ldy #0
    sty tos+1
    lda #>(fail+2)
    pha
    lda #<(fail+2)    ; transfer control to FAIL
    pha
;--------------------------------------------------------------
#if 0
name=>FORTH
stack=( -- )
tags=vocabulary,nosymbol
Jump up to high-level Forth from inline 6502
#endif
toforth
    pla
    sta ip
    pla
    sta ip+1
    lda #1
;--------------------------------------------------------------
#if 0
name=DOPAGE
stack=( -- )
tags=nosymbol
Page boundary crossing is handled by the compiler inserting 'page'
when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
to occur, and indicates an error in the compiler.

pad is also used by LITERAL, string, and other words which
contain inline arguments to offset IP at runtime
#endif
pad
    clc                     ; pass A = offset added to IP
    adc ip
    bcs pagen               ; check for page boundary crossing
    cmp #$ff
    bne pado                ; check for xxFF at end of page
page
    lda #0
pagen
    inc ip+1                ; cross the page
pado
    sta ip
    jmp nexto

;--------------------------------------------------------------
#if 0
name=FAIL
stack=( error -- )
tags=inner
Outputs an [[error message|Error messages]], then [[ABORT]]

```
: fail   ( err# -- )
    warning @ ?dup
    if
        swap 2* + @ count type
    else
        . ."?ERR"
    then
    startup @ execute ;
```
#endif
fail
#include "enter.i65"
    .word warning
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(fail01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word branch
    .byt <(fail03-*+1)
#include "pad.i65"
fail01
    .word _dot
#include "page.i65"
    .word pdq
    .byt (fail02-*-1)
    .asc "?ERR"
fail02
#include "pad.i65"
fail03
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute

;core-inner.a65
#echo .       core-inner.a65            Inner Interpreter

;--------------------------------------------------------------
#if 0
name=(?:)
stack=( flag -- )
tags=inner,nosymbol
The runtime of [[?:]], invokes one of the two high-level Forth words
following this instruction
#endif
pquerycolon
    ldy #3
    lda tos
    ora tos+1                   ; evaluate the flag
    bne pquerycolon01           ; true?
    ldy #5                      ; false.
pquerycolon01
    lda (ip),y
    sta tos+1
    dey
    lda (ip),y
    sta tos
    lda #3
    jsr padjust
    ; fall through
;--------------------------------------------------------------
#if 0
name=EXECUTE
tags=inner
stack=( cfa -- )
Executes the word whose code field address is on the stack.

#endif
execute
    lda tos+1       ; [3]
    pha             ; [4]
    lda tos         ; [3]
    pha             ; [4]
    jsr slide       ; [a lot]   (slide always clears Z flag)
    php             ; [4]
    rti             ; [7]

;--------------------------------------------------------------
#if 0
name=SP!
stack=( -- )
tags=fig
Initializes the data stack pointer to the value in user
variable SP0
#endif
spstore
    ldx uarea+usersp0-userarea
    dex             ; because it's 1> to make ?stack faster
spstoreo
    jmp next

;--------------------------------------------------------------
#if 0
name=HEX
tags=number,i/o,forth-83
stack=( -- )
Sets the system number base to hexadecimal
#endif
#include "align.i65"
_hex
    jsr enter
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECIMAL
stack=( -- )
tags=number,i/o,forth-83
Sets the system number base to decimal
#endif
#include "align.i65"
_decimal
    jsr enter
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word base
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(")
stack=( -- addr )
tags=inner,nosymbol
Returns the address of a string literal in the dictionary

~ this is pretty ugly
#endif
pquote
    clc
    bcc pdq01
pquote01
    ldy #2
    lda #3
    adc (ip),y
    jmp pad

;--------------------------------------------------------------
#if 0
name=(.")
stack=( -- )
tags=inner,nosymbol
Displays an inline string
#endif
pdq
    sec
pdq01
    jsr slip        ; [.]
    ldy ip+1        ; [3]
    sty tos+1       ; [3]
    ldy ip          ; [3]
    iny             ; [2]
    iny             ; [2]
    sty tos         ; [3]
    bne pdq02       ; [3]
    inc tos+1       ; [2]
pdq02
    bcc pquote01
    lda #>(_stringdot-1)
    pha
    lda #<(_stringdot-1)
    pha
    ldy #0
    lda (tos),y             ; get length byte
    ; fall through
;--------------------------------------------------------------
#if 0
name=padjust
stack=( -- )
tags=nosymbol
!!!Subroutine
Called by primitives to adjust `IP` and properly cross a
page boundary.  This routine exists so words like [[."]] and [[?:]]
can function outside the normal [[pad|DOPAGE]]/[[page|DOPAGE]] routines.

|IP+A lo|IP lo|IP hi|
| C set| IP+A| +1|
||||
| < FD| IP+A| IP+A|
| FD| FE| +1|
| FE| FE| +1|
| FF| FE| +1|

There is probably a worst-case scenario where it is possible to
cross two page boundaries, e.g. with [[(.")]] printing a 255-byte
string, where the [[(.")]] was compiled at the very top of the page.

|$42FC-$42FD| [[(.")]] cfa |
|$42FE| $FF(length) |
|$42FF-$43FE| the string |
|$43FF| `NOP` |

In this worst-case scenarios, `IP` would be set after `padjust` to
$44FE and the next execution of [[NEXT|Zero page buffer and NEXT routine]]
would use $4400 as the address of the following instruction.
#endif
padjust
    sec                     ; pass A = offset to be added to IP
    adc ip
    bcc padjust01
    inc ip+1                ; cross the page
padjust01
    cmp #$fd
    bcc padjust02
    inc ip+1                ; cross the page
    cmp #$ff
    beq padjust02
    lda #$fe
padjust02
    sta ip
    rts

;--------------------------------------------------------------
#if 0
name=(DOES)
tags=inner,nosymbol
stack=( -- )
Runtime behavior of a word built with `<BUILDS ... DOES>`

|before|<|after|<|h
|^data<br/>stack|^return<br/>stack|^data<br/>stack|^return<br/>stack|h
|||||
#endif
dodoes
    pla             ; [4]
    tay             ; [2]
    pla             ; [4]
    sta z           ; [3]
    jsr slip        ; [.]
    pla             ; [4]
    sta tos         ; [3]
    pla             ; [4]
    sta tos+1       ; [3]
    jsr inctos      ; [.]
jmp enter01

;--------------------------------------------------------------
#if 0
name=ENTER
stack=( -- )
tags=nosymbol,inner
The business end of colon definition words, pushes the current
IP on the return stack and executes the word following it
#endif
enter
    pla             ; [4]
    tay             ; [2]
    pla             ; [4]
    sta z           ; [3]
enter01
    lda ip+1        ; [3]
    pha             ; [3]
    lda ip          ; [3]
    pha             ; [3]
    lda z           ; [3]
    bne exit01      ; [3] bra

;--------------------------------------------------------------
#if 0
name=(LOOP)
stack=( -- )
tags=inner,nosymbol
Compiled by [[LOOP]], this is the runtime routine to increment
the inner loop index `zi`.  If loop index exceeds loop limit
`zlim`, iterate back to (do), otherwise exit the loop.

PETTIL uses four bytes of [[zero page|PETTIL Zero page memory map]] for the inner loop
index/limit (`zi` `zlim`), for speed
#endif
ploop
    inc zi
    bne ploop01
    inc zi+1
ploop01
    lda zi
    eor zlim
    bne branch
    lda zi+1
    eor zlim+1
    bne branch
    ;fall through
;--------------------------------------------------------------
#if 0
name=UNLOOP
stack=( -- )
tags=nosymbol,inner,control
Exits from a [[DO]]-[[LOOP]], either because the index exceeded the limit, or
early exit due to [[LEAVE]] or [[?LEAVE]]
#endif
unloop
    ldy #$fc
unloop01
    pla
    sta zi-$fc,y  ; effective address wraps around
    iny
    bne unloop01
    ;fall through
;--------------------------------------------------------------
#if 0
name=EXIT
stack=( -- )
tags=inner,nosymbol
The runtime behavior of ;
Exits a colon definition, unnesting to the next higher level of
the return stack
#endif
exit
    sec             ; [2]
    pla             ; [4]
    adc #0          ; [2]
    tay             ; [2]
    pla             ; [3]
exit01
    iny             ; [2]

;--------------------------------------------------------------
#if 0
name=>FORTH
stack=( -- )
tags=vocabulary,nosymbol
Jump up to high-level Forth from inline 6502

|Register|<|
|Y|low byte|
|A|high byte|
#endif
toforth
exit00
    sta ip+1        ; [3]
exit03
    sty ip          ; [3]
    jmp nexto       ; [3]

;--------------------------------------------------------------
#if 0
name=?EXIT
stack=( flag -- )
tags=ext
Exits the calling word if the flag is true

```
: ?exit   ( flag -- )
    if rdrop then ;
```
#endif
#include "align.i65"
_qexit
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(qexit01-*+1)
#include "pad.i65"
    .word rdrop
#include "page.i65"
qexit01
    .word exit

;--------------------------------------------------------------
#if 0
name=?STACK
stack=( -- )
tags=inner
Check the  data stack pointer for sanity, abort if trouble
#endif
qstack
    ldy #2                          ; 2 = stack full
    txa
    bmi error
    dey                             ; 1 = stack empty
    cmp uarea+usersp0-userarea
    bcc rpstore01
    ;fall through
;--------------------------------------------------------------
#if 0
name=SYSERR
stack=( -- )
tags=nosymbol,inner
General-purpose error handler, callable from primitives, used
to print a system error message and abort
pass in the error # in Y
      1 stack empty
      2 stack full
#endif
error
    sty tos
    ldy #0
    sty tos+1
    ldy #<(_fail+3)    ; transfer control to FAIL
    lda #>(_fail+3)
    bne exit00      ; bra

;--------------------------------------------------------------
#if 0
name=RP!
stack=( -- )
tags=fig
Ordinarily the 6502 machine stack (aka PETTIL return stack) is
initialized to $01ff by BASIC, but the value stored at RP0 defaults
to $01fe instead.  This is because the PET ROM stores a line of
input at $0200 (where TIB points) and INTERPRET will be storing a
count of the first word on the line at $01ff
#endif
rpstore
    txa
    ldx uarea+userrp0-userarea
    txs
    tax
rpstore01
    jmp next

;--------------------------------------------------------------
#if 0
name=(CLIT)
tags=inner,nosymbol
stack=( -- n )
Runtime behavior of `CLITERAL`. Pushes the single byte following IP
on the stack
#endif
clit
    clc
    lda #0
    beq lit01               ; bra

;--------------------------------------------------------------
#if 0
name=(LIT)
tags=inner,nosymbol
stack=( -- n )
Runtime behavior of LITERAL, puts a number "n" on the stack

#endif
plit
    sec
    ldy #3
    lda (ip),y
lit01
    tay
    jsr slip
    sty tos+1
    ldy #2
    lda (ip),y
    sta tos
    .byt $29                ; AND # to skip CLC instruction
bump
    clc
bump01
    lda #3                  ; ip+3 or ip+4 depending on Carry
    ; fall through
;--------------------------------------------------------------
#if 0
name=DOPAGE
stack=( -- )
tags=nosymbol
Page boundary crossing is handled by the compiler inserting 'page'
when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
to occur, and indicates an error in the compiler.

pad is also used by LITERAL, string, and other words which
contain inline arguments to offset IP at runtime

It is important that callers to `pad` set Carry

```
pad
    adc ip          ; pass A = offset added to IP
    bcs branch02    ; check for page boundary crossing
    cmp #$ff
    bne branch03    ; check for xxFF at end of page
page
    lda #0
    beq branch02    ; bra
```
#endif
pad
    adc ip
    tay
    iny
    beq branch05
    bne branch04
page
    inc ip+1
    ldy #0
    beq exit03      ; bra

;--------------------------------------------------------------
#if 0
name=?BRANCH
stack=( flag -- )
tags=inner,nosymbol
If the flag is zero, takes the branch
#endif
qbranch
    lda tos
    ldy stackl,x
    sty tos
    ldy stackh,x
    inx
    ora tos+1
    sty tos+1
    bne bump
    ; fall through

;--------------------------------------------------------------
#if 0
name=BRANCH
stack=( -- )
tags=inner,nosymbol
Compiles an unconditional branch operation. When used in the form:
[[COMPILE]] [[BRANCH]] , an unconditional branch operation is compiled.
A one-byte signed offset follows the pointer to `BRANCH`.  These branch
offset values are typically generated with [[<RESOLVE]] or [[>MARK]] .

`IP` points to address of `BRANCH`
(`IP`)+2 = the offset to `IP`,  calculated the same as for 6502 branches.

```
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]   get the offset
    bpl branch01    ; [2|3]
    dec ip+1        ; [5]
branch01
    sec             ; [2]
    adc ip          ; [3]
    bcc branch03    ; [2|3]
branch02
    inc ip+1        ; [5]
branch03
    sta ip          ; [3]
    jmp nexto       ; [3]

```
#endif
branch
    ldy #2          ; [2]
    lda (ip),y      ; [5]
    bpl branch01    ; [2|3]
    dec ip+1        ; [5]
branch01
    sec             ; [2]
    adc ip          ; [3]
branch04
    tay             ; [2]
branch05
    lda ip+1        ; [3]
    adc #0          ; [2]
    bcc exit00      ; [3] bra /18/

;--------------------------------------------------------------
#if 0
name=(+LOOP)
stack=( n -- )
tags=inner,nosymbol
Add `n` to inner loop index.  If loop index exceeds loop limit,
then iterate back to (do), otherwise exit the loop.  PETTIL uses
four bytes of zero page for the inner loop index/limit, for speed

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]
#endif
pploop
    sec             ; [2]
    lda zi          ; [3]
    sbc zlim        ; [3]
    sta n           ; [3]
    lda zi+1        ; [3]
    sbc zlim+1      ; [3]
    eor #$80        ; [2]
    tay             ; [2]
    clc             ; [2]
    lda n           ; [3]
    adc tos         ; [3]
    tya             ; [2]
    adc tos+1       ; [3]
    php             ; [3]
    clc             ; [2]
    lda tos         ; [3]
    adc zi          ; [3]
    sta zi          ; [3]
    lda tos+1       ; [3]
    adc zi+1        ; [3]
    sta zi+1        ; [3]

    jsr slide       ;
    plp             ; [4]
    bvc branch      ; [2]
    ;bvs punloop
wups
    jmp wups

;--------------------------------------------------------------
#if 0
name=(?LEAVE)
stack=( flag -- )
tags=inner,nosymbol
If flag is nonzero, exit the do loop early
#endif
pqleave
    lda tos
    ora tos+1
    php
    jsr slide
    plp
    ;bne punloop
    jmp next

;--------------------------------------------------------------
#if 0
name=(?DO)
stack=( end begin -- )
tags=inner,nosymbol
Performs a do-loop if end<>begin

#endif
pqdo
    sec
    .byt $29            ; AND# to skip CLC instruction
                        ; fall through
;--------------------------------------------------------------
#if 0
name=(DO)
stack=( end begin -- )
tags=inner,nosymbol
Loops from "begin" to "end"

d;m 0 8f;m 1f0 1ff;m 2180 21af;z

#endif
pdo
    clc
    rol z           ; [5] save C flag as low bit of Z    
    ldy #2          ; [2] set up for EXIT
    lda (ip),y      ; [5] forward branch offset
    clc             ; [2]
    adc ip          ; [3]
    tay             ; [2]
    dey             ; [2]
    lda ip+1        ; [3]
    adc #0          ; [2]
    pha             ; [3]
    tya             ; [2]
    pha             ; [3]
    lda #0          ; [2]
    jsr padjust     ; [.] skip branch offset
    ror z           ; [3]
    bcc pdo01       ; [2|3] (DO) vs (?DO)
    ;sec             ; [2] tell subeq to exit with RTS
    jsr subeq       ; [.] (?DO), test loop start/limit
    bne pdo01       ; [2|3]
    inx             ; [2] loop indices are identical
    jsr slide       ; [.] 2drop
    jmp exit        ; [3] don't iterate
pdo01
    jsr locals2
    ldy #3
pdo02
    lda zi,y
    pha
    lda tos,y
    sta zi,y
    dey
    bpl pdo02
    bne drop                ; bra

;--------------------------------------------------------------
#if 0
name=4DROP
stack=( a b c d -- )
tags=stack,ext
Discard the top four stack items
#endif
fourdrop
    inx                         ; fall through
;--------------------------------------------------------------
#if 0
name=3DROP
stack=( a b c -- )
tags=stack,ext
Discard the top three stack items
#endif
threedrop
    inx
    bne twodrop

;--------------------------------------------------------------
#if 0
name=I
tags=inner
stack=( -- index )
Push the inner loop index of a DO LOOP to the stack
#endif
i
    ldy zi+1
    lda zi
    ; fall through
;--------------------------------------------------------------
#if 0
name=PUSHYA
stack=( --  n )
tags=stack,forth-83,nosymbol
pass YA = value to push on stack
#endif
pushya
    pha
    dex
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    pla
    jmp put

;--------------------------------------------------------------
#if 0
name=C!
stack=( 8b addr -- )
tags=forth-83,nucleus,memory
 The least-significant 8 bits of 16b are stored into the byte
 at addr.

!!! pronounced: "c-store"
#endif
cstore
    clc
    .byt $29            ; AND #

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    sec
    ldy #0      ; [2]
    lda stackl,x    ; [4]
    sta (tos),y ; [6]
    bcc twodrop
    lda stackh,x    ; [4]
    iny         ; [2]
    sta (tos),y ; [6]       ; MSB is stored last, this is important to EVENTS
    ; fall through
;--------------------------------------------------------------
#if 0
name=2DROP
stack=( d -- )
tags=stack,forth-83
Discard the top two items on the stack
#endif
twodrop
    inx                         ; fall through

;--------------------------------------------------------------
#if 0
name=DROP
stack=( n -- )
tags=stack,forth-83
Discard the top item on the stack
#endif
drop
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=SP@
stack=( -- sp )
tags=fig
Fetches the current data stack pointer
#endif
spfetch
    txa
push0a
    ldy #0
    beq pushya

;--------------------------------------------------------------
#if 0
name=C@
stack=( addr -- 8b )
tags=forth-79,nucleus,memory

!!! pronounced: "c-fetch"
 8b is the contents of the byte at addr.

`cfetch01` code is also reused by CCONSTANT CONSTANT
#endif
cfetch
    clc
    .byt $29        ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    sec
    ldy #0
fetch0a
    lda (tos),y
    bcc put
                        ; out; YA = (tos),Y+1 (tos),Y
                        ; in; Y = offset
                        ; C = clear
                        ; A = low byte
fetchya
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

;--------------------------------------------------------------
#if 0
name=DOCONST
stack=( -- c )
tags=nosymbol,inner
Runtime behavior of a word defined by CONSTANT
#endif
doconst
    sec
    .byt $29                ; AND # to skip the CLC
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT
#endif
docconst
    clc
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    ldy #1
    lda (tos),y
    bcc push0a
    bcs fetchya            ; bra

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of words defined by 2CONSTANT
#endif
#include "align.i65"
dotwoconst
    jsr slip
    dex
    pla
    sta n
    pla
    sta n+1
    ldy #5
    lda (n),y
    sta tos+1
    dey
    lda (n),y
    sta tos
    dey
    lda (n),y
    sta stackh,x
    dey
    lda (n),y
    sta stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=R@
stack=( -- n ) ( R; n -- n )
tags=forth-83,nucleus,stack
Copy the top of the return stack to the data stack

!!! pronounced: "r-fetch"
#endif
rfetch
                                ; you can call me rfetch, or you can call me j,
                                ; but you doesn't have to call me johnson
;--------------------------------------------------------------
#if 0
name=J
stack=( -- index )
tags=inner
Push the outer loop index of a DO LOOP to the stack (alias for [[R@]])
#endif
j
    stx z       ; [3]
    tsx         ; [2]
    ldy $0102,x ; [4]
    lda $0101,x ; [4]
    ldx z       ; [3]
    jmp pushya ; [14|15]

;--------------------------------------------------------------
#if 0
name=CALLER
stack=( -- n )
tags=ext
Used by the business end of defining words to retrieve the address of the child
word from the return stack.
#endif
#include "align.i65"
_caller
    jsr enter
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word twotor
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOCREATE
stack=( -- addr )
tags=nosymbol,inner
The business end of words created by CREATE, returns the address
of the calling word plus 1
#endif
#include "align.i65"
docreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

;--------------------------------------------------------------
#if 0
name=FAIL
stack=( error -- )
tags=inner
Outputs an [[error message|Error messages]], then [[ABORT]]

```
: fail   ( err# -- )
    warning @ ?dup
    if
        swap 2* + @ count type
    else
        . ."?ERR"
    then
    startup @ execute ;
```
#endif
#include "align.i65"
_fail
    jsr enter
#include "page.i65"
    .word warning
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(fail01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word twostar
#include "page.i65"
    .word plus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word branch
    .byt <(fail03-*+1)
#include "pad.i65"
fail01
    .word _dot
#include "page.i65"
    .word pdq
    .byt (fail02-*-1)
    .asc "?ERR"
fail02
#include "pad.i65"
fail03
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute

; cbm.def
#echo .       cbm.def                   Symbols only -- Commodore PET ROM, I/O, Zero page and character set

;"mostly from http://zimmers.net/cbmpics/cbm/PETx/petmem.txt
;zero page

;"Pointer: Highest Address Used by  BASIC
; Pointer to highest address used by BASIC (top of RAM)
#define MEMSIZ      $34
; Temporary storage for FLPT value.
#define TEMPF1      $54
; Real-Time Jiffy Clock (approx) 1/60 Sec, lowest zeropage used by kernel
#define TIME        $8d
;"Vector: Hardware Interrupt [3: E62E, 4: E455]
#define CINV        $90
;"Vector: BRK Instr. Interrupt [3: FD17, 4: D478]
#define CBINV       $92
;"Vector: Non-Maskable Interrupt [3:C389,4: B3FF]
#define NMINV       $94
; Kernel I/O Status byte (ST)
#define STATUS      $96
; Current Key Pressed 255 = No Key
#define LSTX        $97
; flag - print shifted chars.
#define SDFX        $98
;"Flag: STOP key / RVS key
#define STKEY       $9b
; Flag 0 = Load, 1 = Verify (Kernel & BASIC)
#define VERCK       $9d
; No. of Chars. in keyboard Buffer (Queue)
#define NDX         $9e
; Pointer End of Logical Line for INPUT
#define INDX        $a1
; Key Image
#define KEYIMG      $a6
; Cursor blink enable 0=flash cursor
#define BLNSW       $a7
; Timer countdown to toggle cursor
#define BLNCT       $a8
; True character under cursor
#define GDBLN       $a9
; Flag - last cursor blink on/off
#define BLNON       $aa
; Flag INPUT or GET from Keyboard
#define CRSW        $ac
; No. of Open Files / Index to File Table
#define LDTND       $ae
; Default Input Device (0)
#define DFLTN       $af
; Default Output Device (3)
#define DFLTO       $b0
; Tape buffer leading character (eg 1=PRG 2=DATA 3= 4=SEQ 5=EOT)
#define TAPEID      $b4
; Cassette Write/Sync Countdown (64=00A5)
#define CNTDN       $ba
; "Pointer: Tape I/O Buffer #1 (00-C0)
#define BUFPNT      $bb
; $bc  "Pointer: Tape I/O Buffer #2 (00-C0)
; "Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
#define RIPRTY      $c3
; pointer current screen line address
#define PNT         $c4
; Cursor Column on Current Line
#define PNTR        $c6
; pointer - tape buffer/screen scrolling
#define SAL         $c7
; Tape End Addresses/End of Program
#define EAL         $c9
; Quote flag, 0=direct cursor, else printable ctrl chars
#define QTSW        $cd
; Length of Current File Name
#define FNLEN       $d1
; Current Logical File Number
#define LA          $d2
; Current Secondary Address
#define SA          $d3
; First Address (current device number)
#define FA          $d4
; Length of current line (39 or 79)
#define LNMX        $d5
; ..d7 pointer - start of tape buffer (027a or 033a)
#define TAPE1       $d6
; Current Cursor Physical Line Number
#define TBLX        $d8
; Current Character to Print
#define DATAX       $d9
; file name address
#define FNADR       $da
; 25-byte screen wrap table
#define LDTB1       $e0
#define TI65SPEED   $f8 ; counter to speed ti by 6/5
#define CAS1        $f9 ; cassette tape motor interlock #1
#define CAS2        $fa ; cassette tape motor interlock #2
; I/O Start Address
#define STAL        $fb
; System input buffer 0200-0250
#define BUF         $200
#define KEYD        $026f ; Keyboard Buffer Queue (FIFO)
#define CAS1BUF     $027a
#define CAS2BUF     $033a
WRAPLO      = $e798     ; $e798 or e65b for the EROM on my PET
VIDRAM      = $8000

;Miscellaneous ROM routines, PET BASIC 4
; keyboard decode table
#define KEYDECODE   $e60b
; Table of 25 low bytes which mark the end of each screen line
#define WRAPTBLO    $e65b

; low-level tape i/o entry points
; (load/verify) rest of program
#define READDATA    $f3f8
; (load/verify) named header - search for a named tape header block
#define READHEAD    $f4d3
; (save)
; write file header
#define SAVEHEAD    $f619
; copy tape buffer start/end to SAL(c7) / EAL(c9) / STAL(fb)
#define SETEALSTAL  $f66e
; copy tape buffer start/end to SAL(c7) / EAL(c9) / STAL(fb)
#define TAPEPTR     $f67b
; copy tape buffer start SAL (c7) to STAL(fb)
#define SETSTAL     $f68c
; set TAPE1 to cassette buffer address for tape device in FA
; copy cassette buffer addresses to STAL/EAL
#define SETCASBUF   $f6ab
; write arbitrary data to tape
#define SAVEDATA    $f8ce
; see "Programming The PET/CBM" p. 384
PIA1        = $e810
PIA1PORTA   = PIA1+0
PIA1CRA     = PIA1+1
PIA1PORTB   = PIA1+2
PIA1CRB     = PIA1+3

PIA2        = $e820
PIA2PORTA   = PIA2+0
PIA2CRA     = PIA2+1
PIA2PORTB   = PIA2+2
PIA2CRB     = PIA2+3

VIA     = $e840
VIAORB      = VIA+0     ; internal to PET
VIAORA      = VIA+1     ; data with handshake
VIAPDRB     = VIA+2
VIADDRA     = VIA+3     ; data direction
VIAT1LW     = VIA+4
VIAT1CH     = VIA+5
VIAT1LL     = VIA+6
VIAT1LH     = VIA+7
VIAT2LW     = VIA+8
VIAT2CH     = VIA+9
VIASR       = VIA+$a    ; shift register
VIAACR      = VIA+$b    ; auxilliary control
VIAPCR      = VIA+$c    ; peripheral control
VIAIFR      = VIA+$d    ; interrupt flags
VIAIER      = VIA+$e    ; interrupt enable
VIAORAN     = VIA+$f    ; data no handshake

; new ROM only
#ifdef PET_ROM4
; Open Space in Memory
#define BLTU        $b350
#define DORTI       $e600
; call entry to monitor
#define TIMCALL     $d472
; BRK call to monitor
#define TIMBRK      $d478
#define CONCAT      $ff93
#define DOPEN       $ff96
#define DCLOSE      $ff99
#define RECORD      $ff9c
#define HEADER      $ff9f
#define COLLECT     $ffa2
#define BACKUP      $ffa5
#define COPY        $ffa8
#define APPEND      $ffab
#define DSAVE       $ffae
#define DLOAD       $ffb1
#define DIRECTORY   $ffb4
#define RENAME      $ffb7
#define SCRATCH     $ffba
#define UNKNOWN     $ffbd
; ($ffc0)+3 skips over the BASIC param setup
#define OPEN        $f563
; ($ffc3)+3 skips over param setup
#define CLOSE       $f2e0
; print out a system message
#define MSGOUT      $f185

; factory IRQ vector for ($0090)
MAINIRQ = $e455


;"http://wiki.nesdev.com/w/index.php/6502_assembly_optimisations#Test_bits_without_destroying_the_accumulator
#define RTI_INSTR   $e605   ; opcode $40, bit $e605 will test smudge (bit4)
#define FIX_CHR     $e606   ; set character at cursor position

#define KBDECODE    $e60b   ; keyboard decode table (80 characters)
                            ; Table of 25 low bytes marking the end of each line
#define SCRLINLO    $e65b
#define DLSTRUN     $e673   ; dL"*<cr>run<cr>



#endif

; all ROMs
#define CHKIN       $ffc6   ; Set input device
#define CHKOUT      $ffc9   ; Set output device
#define CLRCHN      $ffcc   ; Restore default I/0 devices
#define CHRIN       $ffcf   ; Input character
#define CHROUT      $ffd2   ; Output character
#define LOAD        $ffd5
#define SAVE        $ffd8
#define SETTIM      $ffdb ; VERIFY in original ROM ~ Is this still VERIFY?
#define RDTIM       $ffde ; SYS in original ROM ~ Is this still SYS?
#define STOP        $ffe1 ; GETSTOP in original ROM
#define GETIN       $ffe4   ; Get character
#define CLALL       $ffe7
#define UDTIM       $ffea

NMI     = $fffa
RES     = $fffc
IRQ     = $fffe


;graphic and control character set
#define INSERT      $94
#define DELETE      $14
#define SPACE       $20
#define CR          $0d
#define CLR         $93
#define HOME        $13
#define CRSRDOWN    $11
#define CRSRUP      $91
#define CRSRRIGHT   $1d
#define CRSRLEFT    $9d
#define RVSON       $12
#define RVSOFF      $92
#define STOPKEY     $03
#define RUNKEY      $83
#define QUOTE       $22
#define VBAR2       $b4
#define VBAR3       $b5
#define VBAR6       $b6
#define VBAR7       $aa
#define HBAR2       $b7
#define HBAR3       $b8
#define HBAR5       $b9
#define HBAR6       $af
#define VLINE1      $a5
#define VLINE2      $d4
#define VLINE3      $c7
#define VLINE4      $c2
#define VLINE5      $dd
#define VLINE6      $c8
#define VLINE7      $d9
#define VLINE8      $a7
#define HLINE1      $a3
#define HLINE2      $c5
#define HLINE3      $c4
#define HLINE4      $c3
#define HLINE5      $c0
#define HLINE6      $c6
#define HLINE7      $d2
#define HLINE8      $a4
#define SHADE       $a6
#define HSHADE      $a8
#define VSHADE      $dc
#define TRIUL       $a9
#define TRIUR       $df
#define CORNERUL    $b0
#define CORNERUR    $ae
#define CORNERLL    $ad
#define CORNERLR    $bd
#define ROUNDUL     $d5
#define ROUNDUR     $c9
#define ROUNDLL     $ca
#define ROUNDLR     $cb
#define BOXUL       $cf
#define BOXUR       $d0
#define BOXLL       $cc
#define BOXLR       $ba
#define BLOCK0      $a0
#define BLOCK1      $be
#define BLOCK2      $bc
#define BLOCK4      $bb
#define BLOCK8      $ac
#define BLOCK9      $bf
#define TEEUP       $b1
#define TEEDN       $b2
#define TEELF       $b3
#define TEERT       $ab
#define CROSS       $db
#define DIAG        $ce
#define BACKDIAG    $cd
#define DOUBLEDIAG  $d6
#define SPADE       $c1
#define HEART       $d3
#define DIAMOND     $da
#define CLUB        $d8
#define CIRCLEFILL  $d1
#define CIRCLEEMPTY $d7
#define PI          $de

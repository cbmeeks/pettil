; pettil-forget.a65
#echo .       pettil-forget.a65         Symbol table restructuring

;--------------------------------------------------------------
#if 0
name=PASSFILTER
stack=( symbols -- )
tags=interpreter,nosymbol
During the first half of [[REHASH]], it is unnecessary to make
a pass through the entire symbol table searching for names of a
given length, if none of that length exist.  This is a bloom
filter to eliminate extra symbol table passes.

```
: passfilter   ( symbols -- )
    passbits 4 erase
    ( nfa )
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat drop ;
```
#endif
#include "align.i65"
_passfilter
    jsr enter
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
passfilter01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(passfilter02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(passfilter01-*+1)
#include "page.i65"
passfilter02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=forgotten16
tags=nosymbol

* inputs
** TOS (R1) NFA
* returns
** R11 CFA
** C true if in either dictionary
#endif
forgotten16
    jsr forgotten16a
    rol R14H
    rts

forgotten16a
    jsr tos2minus
    ldy #0
    lda (tos),y
    sta r11
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sta r11+1
    sbc uarea+usertdict-userarea+1
    bcs forgotten16c            ; word is in TDICT
    dey
forgotten16b
    lda uarea+usernewdp-userarea
    cmp (tos),y
    iny
    lda uarea+usernewdp-userarea+1
    sbc (tos),y
forgotten16c
    rts

;--------------------------------------------------------------
#if 0
name=intdictq16
tags=nosymbol
Checks if the current CFA is in the transient dictionary.  Sets N5
to the NFA

#endif
intdictq16
    jsr tos2minus
    ldy #0
    lda (tos),y
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sbc uarea+usertdict-userarea+1
    jsr tos2plus
    bcc intdictq16b
    lda tos
    sta n+10
    lda tos+1
    sta n+11                    ; N5
intdictq16b
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=wakeup16
tags=nosymbol
Wakes up an ancestor when a descendant is forgotten

* inputs
** ACC (R0) NFA of ancestor

* returns

#endif
wakeup16
    ldy #0
    lda (r0),y
    eor #bit5
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=descendant16
tags=nosymbol

* inputs
** TOS (R1) pointer to NFA
* returns
** N2 (R4) adds NFA to descendant list if it's active
#endif
descendant16
    ldy #2
    lda (tos),y
    and #bit5                   ; check smudge bit
    bne descendant16b
    dey
    sec
    lda n+4
    sbc #2
    sta n+4
    bcs descendant16a
    dec n+5
descendant16a
    lda tos,y
    sta (n+4),y
    dey
    bpl descendant16a
descendant16b
    rts

;--------------------------------------------------------------
#if 0
name=?MIGRATE1
stack=( src targ vmbuf i -- targ+ )
tags=interpreter,nosymbol
#endif
qmigrate1
    brk
    .byt ld | TOS
    .byt st | N1                ; I
    .byt pull
    .byt st | N2                ; descendants
    .byt st | N8                ; vmbuf
    .byt pull
    .byt st | N7                ; targ0
    .byt st | N0                ; targ
    .byt pull
qmigrate1a
    .byt ext
    .word nfalen16
    .byt bz , <(qmigrate1d-*-2) ; are we done?
    .byt cpr | N1
    .byt bnz , <(qmigrate1c-*-2)    ; not what we are looking for?
; we have one of the right length
; is it in bounds?
    .byt ext
    .word forgotten16
    .byt bc , <(qmigrate1b-*-2)     ; not forgotten, migrate it
    .byt ext
    .word descendant16
    .byt br , <(qmigrate1c-*-2)     ; next

qmigrate1b
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+

qmigrate1c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1a-*-2)

qmigrate1d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate1e
    .byt ld | N2
    .byt cpr | N8                   ; any descendants?
    .byt bz , <(qmigrate1i-*-2)     ; nope
    .byt ld | N1
    .byt st | N3
    .byt sub | ACC
    .byt st | N1                    ; no ancestor
    .byt st | N4                    ; zero highest-so-far
    .byt st | N5                    ; zero tdict-maybe

    .byt ldd | N2                   ; get the address of the CFA, which is pretty worthless.
    .byt st | N0
    .byt inr | N0
    .byt inr | N0                   ; this is the descendant NFA
    .byt ld | N7                    ; rewind the list for this size
    .byt push
    .byt ldd | TOS                  ; get the CFA
    .byt st | N6
qmigrate1h
    .byt ext
    .word nfalen16
    .byt cpr | N3
    .byt bnz , <(qmigrate1g-*-2)    ; done with this size list, check out
    .byt ext
    ;.word strcomp
    .byt bnc , <(qmigrate1f-*-2)    ; that's not it
    .byt ext
    .word intdictq16
    .byt bc , <(qmigrate1f-*-2)
    .byt ld | N6
    .byt cpr | N4
    .byt bnc , <(qmigrate1f-*-2)
    .byt st | N4                    ; highest-so-far
    .byt ld | TOS
    .byt st | N1                    ; keep a copy of NFA to go with the highest-so-far
qmigrate1f
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1h-*-2)

qmigrate1g
    .byt pull
    .byt ld | N1
    .byt bnz , <(qmigrate1j-*-2)
    .byt ld | N5
    .byt bz , <(qmigrate1e-*-2)
qmigrate1j
    .byt ext                        ; activate the highest-so-far or maybe-tdict word
    .word wakeup16
    .byt br , <(qmigrate1e-*-2)

qmigrate1i
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH1)
stack=( -- lastsym )
tags=interpreter,nosymbol
Phase 1 of REHASH

* Make a pass through SYMTAB + SYMNEW, create Bloom filter of sizes
* For each size 1..31
** If it has members, merge SYMTAB + SYMNEW to PAD, ordered by length
** tack on three zeroes at the end
** Make a pass through PAD at that size
*** If active and between CFA..HERE
**** Make a pass through PAD at current size
**** Reawaken youngest ancestor less than CFA (or in TDICT)
* set DP = cfa
* Return the last symbol at PAD for automatic memory allocation

```
: (rehash1)   ( -- )
    >syms 2+ pad   over passfilter
    32 1 do
        i >bit passbits + cbit@
        if
            under  vmbuf @  i
 ( src src targ vmbuf i )
            ?migrate1
            dup 3 erase
 ( src targ+ )
        then
    loop nip ;                  \ automem wants the next address at PAD, targ+
```
#endif
#include "align.i65"
_prehash1
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word _passfilter
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
prehash101
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(prehash102-*+1)
#include "pad.i65"
    .word under
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate1
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
prehash102
    .word ploop
    .byt <(prehash101-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MIGRATE2
stack=( src targ -- targ+ )
tags=nosymbol,interpreter
#endif
qmigrate2
    brk
    .byt ld | TOS
    .byt st | N3                ; I
    .byt pull
    .byt st | N0                ; targ
    .byt pull                   ; src
    .byt ext
    .word tos2plus
qmigrate2a
    .byt ext
    .word nfalen16
    .byt st | N1
    .byt bz , <(qmigrate2d-*-2) ; are we done?

    .byt ext
    .word pearsonhash16         ; ~ this should go
    .byt cpr | N3
    .byt bnz , <(qmigrate2c-*-2)    ; not what we are looking for?
; we have one of the right hashcode
    .byt ext
    .word tos2minus
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+
    .byt ext
    .word bloomhash16               ; set the bloom filter bit

qmigrate2c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate2a-*-2)

qmigrate2d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate2e
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH2)
stack=( -- )
tags=nosymbol,interpreter
Phase 2 of REHASH

* symtab 32 erase
* bloom 8 erase
* target = symtab+32
* For each hashcode 0..15
** set symtab+i*2 = target
** run all the symbols
*** if hashcode matches, and it's alive, append it to target
* set symnew = symtail = target
* symnew 3 erase
```
: (rehash2)   ( -- )
    symtab @ 32 erase
    bloom 8 erase
    pad >syms
    16 0 do
        dup i 2* symtab @ + !
        under i  migrate2
    loop
( target )
    dup symnew ! dup symtail !
    3 erase ;
```
#endif
#include "align.i65"
_prehash2
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word _erase
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
prehash201
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word under
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate2
#include "page.i65"
    .word ploop
    .byt <(prehash201-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (rehash)   ( cfa -- )
    1- newdp !
    (rehash1)
    automem
    (rehash2)
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_prehash
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word _prehash1
#include "page.i65"
    .word _automem
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word 1024*3
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _prehash2
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word _info
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit















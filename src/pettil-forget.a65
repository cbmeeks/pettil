; pettil-forget.a65
#echo .       pettil-forget.a65         Symbol table restructuring

;--------------------------------------------------------------
#if 0
name=PASSBITS
stack=( -- addr )
tags=ext,interpreter,nosymbol
32-bit wide Bloom filter for skipping [[REHASH]] passes if there
are no words of a particular length
#endif
passbits
    jsr docreate
    .word 0,0

;--------------------------------------------------------------
#if 0
name=PASSFILTER
stack=( symbols -- )
tags=interpreter,nosymbol
During the first half of [[REHASH]], it is unnecessary to make
a pass through the entire symbol table searching for names of a
given length, if none of that length exist.  This is a bloom
filter to eliminate extra symbol table passes.

```
: passfilter   ( symbols -- )
    passbits 4 erase
    ( nfa )
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat drop ;
```
#endif
#include "align.i65"
_passfilter
    jsr enter
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
passfilter01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(passfilter02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(passfilter01-*+1)
#include "page.i65"
passfilter02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=forgotten16
tags=nosymbol

* inputs
** TOS (R1) NFA
* returns
** R11 CFA
** C true if in either dictionary
#endif
forgotten16
    jsr forgotten16a
    rol R14H
    rts

forgotten16a
    jsr tos2minus
    ldy #0
    lda (tos),y
    sta r11
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sta r11+1
    sbc uarea+usertdict-userarea+1
    bcs forgotten16c            ; word is in TDICT
    dey
forgotten16b
    lda uarea+usernewdp-userarea
    cmp (tos),y
    iny
    lda uarea+usernewdp-userarea+1
    sbc (tos),y
forgotten16c
    rts

;--------------------------------------------------------------
#if 0
name=intdictq16
tags=nosymbol
Checks if the current CFA is in the transient dictionary.  Sets N5
to the NFA

#endif
intdictq16
    jsr tos2minus
    ldy #0
    lda (tos),y
    cmp uarea+usertdict-userarea
    iny
    lda (tos),y
    sbc uarea+usertdict-userarea+1
    jsr tos2plus
    bcc intdictq16b
    lda tos
    sta n+10
    lda tos+1
    sta n+11                    ; N5
intdictq16b
    rol R14H
    rts

;--------------------------------------------------------------
#if 0
name=wakeup16
tags=nosymbol
Wakes up an ancestor when a descendant is forgotten

* inputs
** ACC (R0) NFA of ancestor

* returns

#endif
wakeup16
    ldy #0
    lda (r0),y
    eor #bit5
    sta (r0),y
    rts

;--------------------------------------------------------------
#if 0
name=descendant16
tags=nosymbol

* inputs
** TOS (R1) pointer to NFA
* returns
** N2 (R4) adds NFA to descendant list if it's active
#endif
descendant16
    ldy #2
    lda (tos),y
    and #bit5                   ; check smudge bit
    bne descendant16b
    dey
    sec
    lda n+4
    sbc #2
    sta n+4
    bcs descendant16a
    dec n+5
descendant16a
    lda tos,y
    sta (n+4),y
    dey
    bpl descendant16a
descendant16b
    rts

;--------------------------------------------------------------
#if 0
name=?MIGRATE1
stack=( src targ vmbuf i -- targ+ )
tags=interpreter,nosymbol
#endif
qmigrate1
    brk
    .byt ld | TOS
    .byt st | N1                ; I
    .byt pull
    .byt st | N2                ; descendants
    .byt st | N8                ; vmbuf
    .byt pull
    .byt st | N7                ; targ0
    .byt st | N0                ; targ
    .byt pull
qmigrate1a
    .byt ext
    .word nfalen16
    .byt bz , <(qmigrate1d-*-2) ; are we done?
    .byt cpr | N1
    .byt bnz , <(qmigrate1c-*-2)    ; not what we are looking for?
; we have one of the right length
; is it in bounds?
    .byt ext
    .word forgotten16
    .byt bc , <(qmigrate1b-*-2)     ; not forgotten, migrate it
    .byt ext
    .word descendant16
    .byt br , <(qmigrate1c-*-2)     ; next

qmigrate1b
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+

qmigrate1c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1a-*-2)

qmigrate1d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate1e
    .byt ld | N2
    .byt cpr | N8                   ; any descendants?
    .byt bz , <(qmigrate1i-*-2)     ; nope
    .byt ld | N1
    .byt st | N3
    .byt sub | ACC
    .byt st | N1                    ; no ancestor
    .byt st | N4                    ; zero highest-so-far
    .byt st | N5                    ; zero tdict-maybe

    .byt ldd | N2                   ; get the address of the CFA, which is pretty worthless.
    .byt st | N0
    .byt inr | N0
    .byt inr | N0                   ; this is the descendant NFA
    .byt ld | N7                    ; rewind the list for this size
    .byt push
    .byt ldd | TOS                  ; get the CFA
    .byt st | N6
qmigrate1h
    .byt ext
    .word nfalen16
    .byt cpr | N3
    .byt bnz , <(qmigrate1g-*-2)    ; done with this size list, check out
    .byt ext
    ;.word strcomp
    .byt bnc , <(qmigrate1f-*-2)    ; that's not it
    .byt ext
    .word intdictq16
    .byt bc , <(qmigrate1f-*-2)
    .byt ld | N6
    .byt cpr | N4
    .byt bnc , <(qmigrate1f-*-2)
    .byt st | N4                    ; highest-so-far
    .byt ld | TOS
    .byt st | N1                    ; keep a copy of NFA to go with the highest-so-far
qmigrate1f
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate1h-*-2)

qmigrate1g
    .byt pull
    .byt ld | N1
    .byt bnz , <(qmigrate1j-*-2)
    .byt ld | N5
    .byt bz , <(qmigrate1e-*-2)
qmigrate1j
    .byt ext                        ; activate the highest-so-far or maybe-tdict word
    .word wakeup16
    .byt br , <(qmigrate1e-*-2)

qmigrate1i
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH1)
stack=( -- lastsym )
tags=interpreter,nosymbol
Phase 1 of REHASH

* Make a pass through SYMTAB + SYMNEW, create Bloom filter of sizes
* For each size 1..31
** If it has members, merge SYMTAB + SYMNEW to PAD, ordered by length
** tack on three zeroes at the end
** Make a pass through PAD at that size
*** If active and between CFA..HERE
**** Make a pass through PAD at current size
**** Reawaken youngest ancestor less than CFA (or in TDICT)
* set DP = cfa
* Return the last symbol at PAD for automatic memory allocation

```
: (rehash1)   ( -- )
    >syms 2+ pad   over passfilter
    32 1 do
        i >bit passbits + cbit@
        if
            under  vmbuf @  i
 ( src src targ vmbuf i )
            ?migrate1
            dup 3 erase
 ( src targ+ )
        then
    loop nip ;                  \ automem wants the next address at PAD, targ+
```
#endif
#include "align.i65"
_prehash1
    jsr enter
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word _passfilter
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
prehash101
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(prehash102-*+1)
#include "pad.i65"
    .word under
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate1
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
prehash102
    .word ploop
    .byt <(prehash101-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MIGRATE2
stack=( src targ -- targ+ )
tags=nosymbol,interpreter
#endif
qmigrate2
    brk
    .byt ld | TOS
    .byt st | N3                ; I
    .byt pull
    .byt st | N0                ; targ
    .byt pull                   ; src
    .byt ext
    .word tos2plus
qmigrate2a
    .byt ext
    .word nfalen16
    .byt st | N1
    .byt bz , <(qmigrate2d-*-2) ; are we done?

    .byt ext
    .word pearsonhash16         ; ~ this should go
    .byt cpr | N3
    .byt bnz , <(qmigrate2c-*-2)    ; not what we are looking for?
; we have one of the right hashcode
    .byt ext
    .word tos2minus
    .byt ldd | TOS
    .byt std | N0                   ; copy the CFA
    .byt ext
    .word symcopy16                 ; copy the CFA, symbol/size/flags, bump targ+
    .byt ext
    .word bloomhash16               ; set the bloom filter bit

qmigrate2c
    .byt ext
    .word nfaplus01
    .byt br , <(qmigrate2a-*-2)

qmigrate2d
    .byt ld | N0
    .byt st | TOS                   ; return targ+
qmigrate2e
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(REHASH2)
stack=( -- )
tags=nosymbol,interpreter
Phase 2 of REHASH

* symtab 32 erase
* bloom 8 erase
* target = symtab+32
* For each hashcode 0..15
** set symtab+i*2 = target
** run all the symbols
*** if hashcode matches, and it's alive, append it to target
* set symnew = symtail = target
* symnew 3 erase
```
: (rehash2)   ( -- )
    symtab @ 32 erase
    bloom 8 erase
    pad >syms
    16 0 do
        dup i 2* symtab @ + !
        under i  migrate2
    loop
( target )
    dup symnew ! dup symtail !
    3 erase ;
```
#endif
#include "align.i65"
_prehash2
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl    ; 32
#include "page.i65"
    .word _erase
#include "page.i65"
    .word bloom
#include "page.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
prehash201
    .word dup
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
    .word under
#include "page.i65"
    .word i
#include "page.i65"
    .word qmigrate2
#include "page.i65"
    .word ploop
    .byt <(prehash201-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AUTOMEM
stack=( lastpad -- )
tags=nosymbol,ext
Automatically move symbol table and vmbuf to someplace that leaves
at least 512 bytes for symbol table growth

The `lastpad` address points to the null byte at the end of the
sorted-by-size symbol table copy at pad

```
: automem   ( addr -- )
    pad - tdict @ swap - $ff00 and $200 -
( newsymtab -- )
    dup symtab @ -  swap symtab !
( delta -- )
    #vmpkt @
    if
        vmbuf @
        symtab @
        third
        +move
        vmbuf over +!
    else
        drop blkbuf
        2- dup off vmbuf !
    then ;

```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word plit
    .word $ff00
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word $200
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word over
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(automem02-*+1)
#include "pad.i65"
automem01
    .word drop
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
automem02
    .word exit

;--------------------------------------------------------------
#if 0
name=(REHASH)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (rehash)   ( cfa -- )
    1- newdp !
    (rehash1)
    automem
    (rehash2)
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_prehash
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word _prehash1
#include "page.i65"
    .word _automem
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word 1024*3
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word _prehash2
#include "page.i65"
    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word _info
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,ext
rebuilds the symbol table in high memory.

```
: rehash  ( -- )
    here (rehash) ;   \ effectively a FORGET nil

```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word exit














;--------------------------------------------------------------
#if 0
name=?SYMCOPY
tags=forget
stack=( nfa targ flag -- nfa+ targ+ )
If the flag is true, copy the symbol to `targ` and move `targ`
past the copy. Always does NFA+
#endif
qsymcopy
    brk
    .byt ld | TOS
    .byt st | N2            ; flag
    .byt pull
    .byt st | N0            ; targ
    .byt pull
    .byt ld | N2            ; test flag
    .byt bz , <qsymcopy01
    .byt popd | TOS
    .byt inr | TOS
    .byt inr | TOS
    .byt std | N0
qsymcopy01
    .byt rtn
    jsr nfalen16a
    tay
    bvc qsymcopy02
    iny                 ; vocab byte
qsymcopy02
    lda n+4
    ora n+5
    sty n+6             ; length+vocid
    sta n+7             ; add to targ
    beq qsymcopy04      ; test flag
    sty n+7
    inc n+7
    inc n+7
qsymcopy03
    lda (tos),y
    sta (n),y
    dey
    bpl qsymcopy03
qsymcopy04
    jsr nfaplus01
    clc
    lda n+7
    adc n
    ldy n+1
    bcc qsymcopy05
    iny
qsymcopy05
    jmp pushya

;qsymcopy
;    ldy #2
;    jsr locals                  ; tos = flag; n0 = targ; n1 = nfa
;    lda tos
;    ora tos+1
;    php
;    lda n+2
;    sta tos
;    lda n+3
;    sta tos+1                   ; tos <- nfa
;    jsr nfalen16a
;    tay
;    bvc qsymcopy01
;    iny                         ; vocab byte
;qsymcopy01
;    sty n+2
;    plp
;    beq qsymcopy03
;
;    jsr tos2minus
;    iny
;    iny                         ; also copy cfa
;qsymcopy02
;    lda (tos),y
;    sta (n),y
;    dey
;    bpl qsymcopy02
;    jsr tos2plus
;
;    clc
;    lda #2
;    adc n+2
;    ;clc                        ; A is never > 33
;    adc n
;    sta n
;    bcc qsymcopy03
;    inc n+1
;
;qsymcopy03
;    clc
;    lda n+2
;    adc tos
;    sta tos
;    bcc qsymcopy04
;    inc tos+1
;qsymcopy04
;    ldy n+1
;    lda n
;    jmp pushya

;--------------------------------------------------------------
#if 0
name=TWIN16
stack=( nfa -- nfa )
tags=nosymbol,interpreter,ext
Does all the Sweet16 register setup for a [[PASS1]] symbol


#endif
#include "align.i65"
twin16
    rts

;--------------------------------------------------------------
#if 0
name=YIN16
stack=( nfa -- nfa )
tags=interpreter,ext
Does all the Sweet16 register setup for a [[PASS1]] symbol

|purpose|register|notes|h
|^return|^R0|^ACC|0 means skip this one<br>-1 for candidate|
|nfa+|^R1|^TOS||
|^targ+|^R2|^N0|pile up output here|
|^nfa|^R3|^N1|^temp storage used<br>for twin search<br>symcomp16 compares TOS vs N1|
|name length|^R4|^N2|length of fraternal twins|
|^symbol length|^R5|^N3|^length of identical twins<br>name+vocid|
||^R6|^N4||
||^R7|^N5||
||^R8|^N6||
|newdp|^R9|^N7|^discard CFAs between<br>these addresses|
|tdict|^R10|^N8|~|
||^R11|^EXT||
||^R12|^SP||
||^R13|^CPR||
||^R14|^ST||
||^R15|^PC||
#endif
#include "align.i65"
yin16
    jsr nfalen16
    tax
    bvc yin16a
    inx                     ; add 1 for vocid
yin16a
    ;ldy #0                 ; return 0 = wrong length -- thanks, nfalen16
    cmp i
    bne yin16c
yin16b
    sty n+5                 ; length of name only
    sta n+4
    sty n+7
    stx n+6                 ; name+vocid
    dey                     ; return -1 = right length
yin16c
    sty r0
    sty r0+1
    rts

;--------------------------------------------------------------
#if 0
name=PASS1
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Copying from [[SYMTAB]] down to [[PAD]], this passes over every
available name length resulting in all names sorted by ascending
size at [[PAD]].


bing bong ding dong king kong ping pong sing song

```
: pass1   ( targ nfa+ -- targ+ )
    begin
        nfalen ?dup
    while
        yin
( nfa targ nfa+ flag )
        ?symcopy
( nfa targ nfa+ targ+ )
    repeat
    nip nip ;
```
#endif
#include "align.i65"
pass1
    brk
    .byt set | N0
    .word uarea+usernewdp-userarea
    .byt ldd | N0
    .byt st | N7            ; NEWDP
    .byt ldd | N0
    .byt st | N8            ; TDICT
pass1a                      ; for each name in symtab...symtail
    .byt sub | ACC
    .byt st | N0            ; turn off twin search
    .byt ext
    .word nfalen16
    .byt bnz , <(pass1b-*-2) ; end of the chain
    .byt rtn
    inx
    inx
    jmp next
pass1b
    .byt ext
    .word yin16
    .byt bnc, <(pass1d-*-2) ; smudge bit?  resolve twins
    .byt ld | TOS
    .byt st | N1
    .byt ld | N0            ; mark our place for later
    .byt push
    .byt ld | N1
    .byt push
pass1twinfinder
    .byt ext
    .word strcomp             ; is TOS a twin of N1?  ~ may need a sweet16 wrapper
    .byt bc , <(pass1next-*-2)     ; yes, further investigation
pass1c
    .byt popd | TOS             ; get CFA

                                ; find/copy all identical twins that are
                                ; in range
                                ; if a twin is active, mark it inactive
                                ; then mark the top twin active
                                ; (it might be the same twin)
                                ; begin
                                ;   compare TOS.name (newtwin) vs N1.name (candidate)
                                ;   identical?
                                ;   if !(newdp < newtwin.cfa < tdict)  (keep newtwin?)
                                ;   N1 = targ+2 (replace candidate with newtwin)
                                ;   append newtwin to targ
                                ;   unsmudge newtwin in symtab so it won't trigger a search
                                ;   was newtwin active before we just activated it?  (we are done)
                                ; until
                                ; N1.unsmudge (activate the candidate)
    .byt pull                   ; return to the original place
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt sub | ACC
    .byt st | N1            ; turn off twin search

    .byt ext
    .word twin16
    .byt bz, <(pass1z-*-2)
    .byt st | N2        ; pointer to CFA
    .byt popd | N2      ; get the CFA
    .byt cpr | N3       ; compare CFA to TDICT
    .byt bp , <(pass1b-*-2) ; don't forget things above TDICT
    .byt cpr | N4       ; compare CFA to NEWDP
    .byt bp , <(pass1e-*-2) ; don't forget things below NEWDP

;    are we done?

pass1d
    ; we get here when we find a smudged symbol.
    ; This will always be the first-defined (original) twin

    ; twins for purposes of deduplication have the same name+vocid (identical)
    ; each original twin will be processed only once with its identical twins
    ; continue from here through the end of the symbol table
    ; twins for purposes of copying have the same name (fraternal)
    ; only one identical twin may be active
    ; multiple fraternal twins may be active
    ; always copy twin with CFA in TDICT
    ; copy all identical twins with CFA < NEWDP (smudged or active)
    ; - unsmudge all identical twins after copying so we won't return here later
    ; all twins will be in the same sorted thread in SYMTAB
    ; all unsorted twins will be ascending by order defined in SYMNEW
    ; the active twin will be the last one found
    ; the active twin trades places with the last smudged twin copied
pass1e
pass1z
                            ; next!
pass1next
    .byt ext
    .word nfaplus01             ; no, next symbol at TOS
    .byt ext
    .word nfalen16
    .byt bnz , <(pass1twinfinder-*-2)
    .byt pull
    .byt st | N1
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt rs


    .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pass1b-*+1)
#include "pad.i65"
    .word i
#include "page.i65"
    .word eq
#include "page.i65"
    .word rot
#include "page.i65"
    .word qsymcopy
#include "page.i65"
    .word branch
    .byt <(pass1-*+1)
#include "pad.i65"
pass1f
    .word nip
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nosymbol,interpreter,ext
Rebuilds the symbol table at [[SYMTAB]]

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA`|
|name| length| +1|
|vocid| 1| +length+1|
* Symbols with identical names are called `twins`
** CFA is always different
** `vocid` may be different
** flags may be different
* copy all names from [[SYMTAB]] down to [[PAD]]
** discarding names that have higher address than `cfa` passed to `(REHASH)`
* at halftime, run [[AUTOMEM]] to resize [[SYMTAB]]
* [[AUTOMEM]] also moves [[VMBUF]]
* copy everything from [[PAD]] back up to [[SYMTAB]]
* At [[COLD]] start
** there are no twins, so no names are discarded
** [[SYMTAB]] is completely unsorted
* When [[REHASH]] is invoked
** there may be twins, but [[DP]] doesn't move so none are discarded
* [[COLD]] kicks off a [[REHASH]] (effectively a `FORGET` to `HERE`) to sort everything
* [[REHASH]] empties [[SYMNEW]]
* [[SYMTAB]]...[[SYMNEW]]...[[SYMTAIL]] may be treated as a single chain
* duplicate names are permitted
* Pearson hash disregards flag bits and vocid byte
* all duplicate names have same Pearson hash value
* within a hashed list, twins are to be ordered by descending CFA
** But any CFA in [[TDICT]] comes last (dups are found last)
** [[TDICT]] contains code for at most one twin
* within an unhashed list, only the most recent is unsmudged
* [[SYMNEW]] (unhashed) is searched first by [[FIND]], then [[FORTH]] (hashed)

```
: (forget)   ( cfa -- )
    1- newdp !
    passbits 4 erase
    >syms 2+ pad  over
    begin
        dup nfalen ?dup
    while
        >bit passbits + cbit!
        nfa+
    repeat drop
( nfa targ )
    32 1 do
        over
        i >bit passbits + cbit@
( nfa targ+ nfa+ flag )
        ?:  pass1 drop
( nfa targ+ )
    loop nip 3 erase
    automem
    pad 2+ >syms
( nfa targ )
    16 0 do
        2dup pass2 nip nip
    loop
    nip dup 3 erase dup symnew ! symtail !
    newdp @ 1+ dp ! ;
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word newdp
#include "page.i65"
    .word store
#include "page.i65"
    .word passbits
#include "page.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
pforget01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(pforget02-*+1)
#include "pad.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(pforget01-*+1)
#include "pad.i65"
pforget02
    .word drop
#include "page.i65"
    .word bl
#include "page.i65"
    .word one
#include "page.i65"
    .word pdo
#include "page.i65"
pforget03
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word tobit
#include "page.i65"
    .word passbits
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word pquerycolon
    .word pass1
    .word drop
#include "pad.i65"
    .word ploop
    .byt <(pforget03-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"



    .word newdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NEWF
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, moves DP, sorts symbol table

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (rehash) ;

no FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:07 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4027 Jun  5 22:07 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2286 Jun  5 22:07 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 12502 Jun  5 22:07 ./tmp/pettil.obj


old FORGET

-rw-r--r-- 1 chitselb chitselb 6189 Jun  5 22:09 ./tmp/pettil-core.obj
-rw-r--r-- 1 chitselb chitselb 4650 Jun  5 22:09 ./tmp/pettil-tdict.obj
-rw-r--r-- 1 chitselb chitselb 2407 Jun  5 22:09 ./tmp/pettil.sym
-rw-r--r-- 1 chitselb chitselb 13246 Jun  5 22:09 ./tmp/pettil.obj

```
#endif
#include "align.i65"
_newf
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _qerror               ; CAN'T FORGET BELOW FENCE
#include "page.i65"
    .word _pforget
#include "page.i65"
    .word exit

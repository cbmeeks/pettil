; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
; wrapper to build PETTIL core dictionary

; include debugging logic
#define DEBUG

; target machine, pick one
#define PET4_ROM
;#define PET2_ROM
;#define C64_ROM
;#define VIC_ROM

#include "inc/cbm.def"
#include "inc/pettil.def"

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================

#define basic $0401
*=basic-2
#print basic
;--------------------------------------------------------------
#if 0
name=PETBASIC
tags=system,nosymbol
! BASIC bootstrap `$0401`

PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to launch the system.  During the build, Core and tdict are assembled separately and concatenated, with the symbol table appended to the end.  [[LAUNCH]] is the code that moves the tdict and symbol table to their proper locations brings up the system by executing [[COLD]], which in turn executes [[WARM]] and brings up the outer interpreter.

|^pettil-core|^load address|<|<|^`$0401`<br/><br/>|^Program load address|<|
|~|^bootstrap|<|^12 bytes|^`10 sys1037`<br/><br/>|^Enter or reenter PETTIL from BASIC|^$0401|
|~|^pettillaunch|<|^3 bytes|^`jmp launch`<br/><br/>|^BASIC startup vector|^$040D|
|~|^zpbuf|^sweet16 registers|^32 bytes|<|^Sweet16 registers overlapping PETTIL work area|^$0410|
|~|~|^stack|^96 bytes|<|^Data stack, split into high and low sections|^$0430|
|~|~|^zi<br/>zlim<br/>up<br/>|^6 bytes|<|^loop index<br/>loop limit<br/>user pointer<br/>|^$0490|
|~|~|^zpnext|^7 bytes|^` inc ip`<br/>` inc ip`<br/>` jmp ($FACE)`<br/><br/>|^copy of [[NEXT]] routine|^$0496|
|~|^power2|<|^8 bytes|^`$80` `$40` `$20` `$10` `$08` `$04` `$02` `$01`<br/><br/>|^powers of 2 table|^$049D|
|~|^[[plugh]]|<|^1 byte|^` rts`<br/><br/>|^VICE debugger breakpoint|^$04A5|
|~| 165 total bytes |<|<|<|<|<|
|~| <br/>''*** Sweet16 page alignment required ***''<br/><br/> |<|<|<|<|<|
|~|^sweet16|<|^438 bytes|<|^//rtn bp bm bz bnz bm1 bnm1 nxt push pull br ext bs rs bc bnc set ld st ld@ st@ ldd@ std@ pop stpat add sub popd cpr inr dcr//|^`$04A6`|
|~|^zpmode|<|^1 byte|<|^flag, PETTIL or BASIC occupies the lower z.p.|^$065B|
|~|^user area||<|<|^[[COLD]]/[[WARM]] initialization values and user variables||
|~|~|^userwarm|^4 bytes|^<br/>//sp0//<br/>//rp0//|^warm start initialization values<br/>data stack (X)<br/>return stack (SP)|^$065E|
|~|~|^usercold|^14 bytes|^<br/>//fence//<br/>//dp//<br/>//startup//<br/>//memsiz//<br/>//filename//<br/>//sanum//<br/>//drvnum//|^cold start initialization values<br/>[[FENCEPOST]]<br/>[[FENCEPOST]]<br/>[[ABORT]]<br/>set by [[ONCE]]<br/>"PETTILPACKETS"<br/>0<br/>cassette tape #1|^$0662|
|~|~|^uarea|^60 bytes|^live user variables|^user variables|^$0670|
|~|~|^irqtoggle|^2 bytes|^`$0000`|^XOR between PETTIL and BASIC IRQ service vectors|^$06BE|
|~|^core|^//user//<br/>//subroutines//<br/>//inner//<br/>//nucleus//<br/>//double//<br/>//io//<br/>//vm//<br/>//extra//|^~20 pages|<|^Core dictionary|^$06C0|
|~|~|[[WARM]]|^40 bytes|<||$1A55|
|~|~|[[COLD]]|^40 bytes|<|||
|~|userfence|<|<|<|<|<|
|~||^[[ONCE]]|||^one-time initialization code||
|~||^[[LIFTOFF]]|^80 bytes||^one-time initialization code||
|~||^[[BANNERMSG]]|^~80 bytes||^banner message displayed at startup||
|^pettil-tdict|^load address||^2 bytes|^`$68EF`<br/><br/>|^where tdict was compiled to|^$6900|
|~|^tdict size||^2 bytes|`$1630`|^size of tdict||
|~||^[[LAUNCH]]|^80 bytes||^one-time initialization code||
|~|upper fence|<|<|<|<|<|
|~|^tdict|^//user<br/>dictionary<br/>interpreter<br/>compiler<br/>utils<br/>editor<br/>assembler//|^~22 pages|^`$68EF`<br/><br/>|^transient dictionary, begins at a page boundary |^`$6900`|
#endif
petbasic
    .word basic                 ; this will be the load address
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp once

;--------------------------------------------------------------
#if 0
name=ZPBUF
tags=system,nosymbol,startup,self-modifying
!Zero page buffer and NEXT routine `$0410`


PETTIL swaps the bottom half (everything from $00 up to [[TIME]]) of zero page
with the BASIC edition of it from when PETTIL was loaded and run.  [[MON]] and
any cassette I/O both switch BASIC back in.

This buffer holds an image at load time of zero page between
`$00..$8C`. PETTIL start/restart will call the `aloha` routine to
exchange it with the BASIC zero page on entry or exit.

''please note: this includes all Sweet16 registers, even SP!!''

PETTIL's 15-clock inner interpreter is here, consisting of
just three instructions.  Whoa.  It's fast!
#endif
zpbuf
;==============================================================
;==== zero page buffer and user area                       ====
;==============================================================
;
;
;$00
;
    .word $0000,$1001,$2002,$3003   ; overlapping
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack
;$80
    .word 0, 0, uarea               ; zi, zlim, up
;
;       NEXT
;               +IP
;               [IP] -> PC
;
; Minimalist NEXT, gets copied to zero page
;
; PETTIL's NEXT and ENTER both put the responsibility for page
; alignment on the compiler, greatly improving code execution
; speed over a more conventional design at a cost of complicating
; things somewhat.
;
;$86
zpnext
    inc ip                  ; [5] (next)
    inc ip                  ; [5] (next1)
;ip = *+1
    jmp ($cafe)             ; [5] (nexto)

                            ;[15] cycles total
;$8D TIME                   ; end of zero page buffer, Jiffy clock is here

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $80,$40,$20,$10,$08,$04,$02,$01

;--------------------------------------------------------------
#if 0
name=PLUGH
tags=nosymbol
An isolated RTS instruction, useful for debugging assembler or Sweet-16 in VICE

```
    .byt ld | N0
    .byt std | N2
    .byt ext        ; invoking VICE debugger from Sweet16
    .word plugh     ;
    .byt ld | N3
    .byt nxt

    jsr something
    jsr somethingelse
    sta anyplace
    jsr plugh       ; invoking VICE debugger from 6502 assembler
    ldx anyplace
```
#endif
plugh
    rts

; Before this point should be exactly 156($9C) bytes of code beginning at $0401

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

#if (* <> $04A6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04A6 (1190).  This is a problem.
#endif (sweet16 address check)
#echo .       program counter just before Sweet16 should be $1190, is:
#print *

#include "inc/sweet16.def"
#include "sweet16.a65"
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

;--------------------------------------------------------------
#if 0
name=ZPMODE
stack=( -- )
tags=system,uservar,nosymbol,todo
A byte used as a semaphore to indicate whether BASIC or PETTIL are using
the bottom half of zero page.

todo: This is mostly here to align [[UAREA]] at $0670, no code has been
implemented to modify or test this flag.

initialized to one for [[ONCE]]
#endif
zpmode
    .byt 1

;--------------------------------------------------------------
#if 0
name=UAREA
stack=( -- )
tags=system,uservar,nosymbol,todo
!User Area

Storage for user variables and initialization data for some of them
#endif
userarea
usersp0         .word bos+1     ;
userrp0         .word $01fe     ;
userwarm

; COLD
userfence       .word fencepost ;
userdp          .word fencepost ;
userstartup     .word _liftoff  ;
usermemsiz      .word 0         ; calculated at startup
                                ; keep the next three uservars together
userfilename    .word currname  ; counted string, default filename
                                ; is "PETTILPACKETS"
usersanum       .word 0         ; secondary address is 0, (PRG file)
userdrvnum      .word 1         ; cassette #1 is default device

usernumvoc      .word 1         ; number of additional vocabularies (ASSEMBLER)

usercold

; SOFT
; everything below initializes to 0 at COLD and is untouched by WARM
;
; memory pointers, in descending order
usercurrent     = usercold+0
usernewdp       = usercold+2    ; / FORGET relies on NEWDP being
usertdict       = usercold+4    ; \ adjacent to TDICT in uarea
usertdp         = usercold+6
usersymtab      = usercold+8
usersymnew      = usercold+10

usersymtail     = usercold+12
uservmbuf       = usercold+14
usernumvmpkt    = usercold+16
userblk         = usercold+18
userscr         = usercold+20
userlin         = usercold+22
useratlin       = usercold+24
usernumlin      = usercold+26

userscrpkt      = usercold+28
userediting     = usercold+30
usernewest      = usercold+34
userredefined   = usercold+36
userwarning     = usercold+38
userbase        = usercold+40

userdpl         = usercold+42
userhld         = usercold+44
usertoin        = usercold+46   ; todo - could move next to BLK for LOAD
userspan        = usercold+48
usernumline     = usercold+50   ; / CR relies on #LINE being
usernumout      = usercold+52   ; \ adjacent to #OUT in uarea
userstate       = usercold+54
usercsp         = usercold+56
uservsource     = usercold+58

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+60,0

    ; grow this string to test page-alignment
    .byt ""

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;--------------------------------------------------------------
#if 0
name=COREBASE
tags=nosymbol
! Core includes

These are the source files included in [[PETTIL-CORE]].  When adding/removing
these files, also modify `xap.rb`
#endif
corebase
#print *
#include "core-user.a65"
#print *
#include "core-subroutines.a65"
#print *
#include "core-inner.a65"
#print *
#include "core-nucleus.a65"
#print *
#include "core-double.a65"
#print *
#include "core-io.a65"
#print *
#include "core-vm.a65"
#print *
#include "core-extra.a65"
#print *
;#include "../../mmm/src/mmm-nucleus.a65"
;#print *

;--------------------------------------------------------------
#if 0
name=RESTART
stack=( -- )
tags=system,startup,nosymbol
Performs the startup word

```
: restart   ( -- )
    startup @  execute ;
#endif
#include "align.i65"
_restart
    jsr enter
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "pass.i65"
    .word execute

;--------------------------------------------------------------
#if 0
name=COLD
stack=( -- )
tags=system,startup
Resets the dictionary to [[FENCE]] and [[warm|WARM]]-starts PETTIL

PETTIL also arrives here after initialization by [[ONCE]]

!!Tasks

* aloha
** swap zero page with zpbuf
** switch Sweet16<-->TIM BRK vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* print start message CR,"WELCOME TO PETTIL!",CR
* STARTUP @ EXECUTE
#endif
cold
;   jsr plugh
    lda #usercold-userarea-1    ; init both cold and warm uservariables
    .byt $2C                    ; fall through to WARM
;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=system,startup,self-modifying
Issues the message `WELOME TO PETTIL` and invokes [[STARTUP]] word

PETTIL also arrives here after a warm restart from BASIC, e.g.

```
MON
*B
     PC  IRQ  SR AC XR YR SP
.;  1943 E455 32 78 30 00 FC
.X
READY.
RUN

WELCOME TO PETTIL!

_
```

Dropping to BASIC also occurs when cassette I/O fails or is interrupted by
the [[STOP]] key, or just sometimes when things go wrong.

!!Tasks

* check zpmode
* aloha
** swap zero page with zpbuf
** switch Sweet16<-->TIM BRK vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* `DECIMAL`
* `EMPTY-BUFFERS`
* print start message CR,"WELCOME TO PETTIL!",CR
* `STARTUP @ EXECUTE`
#endif
warm
    lda #userwarm-userarea-1    ; init only warm uservariables
    pha
    lda zpmode
    bne warm01
    jsr aloha
warm01
    lda #<uarea                 ; initialize user variables
    sta up
    lda #>uarea
    sta up+1
    pla
    tay
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
    ldy #<(warm03)
    lda #>(warm03)              ; load Y last to clear Z flag
    jmp toforth
#include "page.i65"
warm03
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word decimal
#include "page.i65"
    .word _emptybuffers
#include "pass.i65"
    .word _pdq
    .byt launch01-*-1
    .asc CR,"WELCOME TO PETTIL!",CR
launch01
#include "pass.i65"
    .word _restart          ; does LIFTOFF once, later ABORT

;--------------------------------------------------------------
#if 0
name=FENCEPOST
tags=system,startup,nosymbol
Marker (without code) of where [[FENCE]] gets its starting value

the Abyss...
#endif
fencepost

;--------------------------------------------------------------
#if 0
name=BANNERMSG
tags=system,nosymbol,startup
The message of the day.  In pre-beta, I like to put a "this day
in history" in the welcome banner.  The end of this message marks
the end of [[core]] immediately after initial load.  It is followed
in the program image by the [[]]


The size of this word is large because the next thing after it
is [[LAUNCH]] in the transient dictionary.  Adding the sizes of
[[bannermsg]]+[[HOT]]+[[COLD]] together will accurately reflect the
available RAM for the symbol table, virtual memory buffers, and
user code.
#endif
bannermsg
    .byt (bannermsg01-*-1)            ; length of bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    RVSON,"HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION ALPHA 2017-04-23",CR
    .asc    "1985 COCA-COLA ANNOUNCES THAT IT HAS",CR
    .asc    "     CHANGED ITS FORMULA, INTRODUCES",CR
    .asc    "     NEW COKE.",CR
            ;123456789.123456789.123456789.123456789.
bannermsg01

;--------------------------------------------------------------
#if 0
name=ONCE
tags=system,startup,nosymbol

Initialization code after load.

This is where FENCE points

This code will be overwritten by user activity

!!Initialization tasks

!!!Aloha tasks

* swap zero page with zpbuf
* switch Sweet16<-->TIM BRK vector

!!![[ONCE]] tasks

* display bannermessage
* aloha
* set top of memory address
* transfer to [[COLD]]

!!![[COLD]] tasks

* move cold start variables to uarea
* fall through to [[WARM]]

!!![[WARM]] tasks

* move warm start variables to uarea
* reset Forth return stack (machine stack)
* reset Forth data stack
* STARTUP @ EXECUTE

!!![[LIFTOFF]] tasks

* `TDICT CMOVE`

!!![[LAUNCH]] tasks

* `HERE (FORGET)`

tests:
`HERE FENCE ! COLD`
#endif
once
    nop
    nop
    nop
    nop
    lda #<(bannermsg+1)         ; display a banner
    sta TEMPF1
    lda #>(bannermsg+1)
    sta TEMPF1+1
    ldy #0
once01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg
    bne once01
    lda MEMSIZ                  ; set top of memory address from BASIC
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1
    jsr aloha                   ; switch in PETTIL, switch out BASIC
    lda #<warm
    sta pettillaunch+1
    lda #>warm
    sta pettillaunch+2
    jmp cold


;--------------------------------------------------------------
#if 0
name=LIFTOFF
tags=system,startup,nosymbol
Reorganizes TDICT and SYMTAB at initial startup. This is
invoked after [[ONCE]] [[COLD]] [[WARM]] by the `STARTUP @ EXECUTE` hook

* move [[TDICT]]
* set [[SYMTAB]]
* perform [[LAUNCH]]

d;m 0 8f;m 1f0 21f;m 1c60 1c8f;z

```
: liftoff   ( -- )
    [ there ] literal
    @+ dup>r
    over @+
    ( there+2 loadaddr there+4 size ; loadaddr )
    2dup + symtab !
    nip 2+ cmove
    [ fencepost ] literal  fence !
    r> 2+  execute ;
```
#endif
#include "align.i65"
_liftoff
    jsr enter
#include "page.i65"
    .word plit
    .word there
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word over
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word bl
#include "pass.i65"
    .word minus
#include "pass.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word nip
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "pass.i65"
    .word execute

there

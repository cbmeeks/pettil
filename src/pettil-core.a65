; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
; wrapper to build PETTIL core dictionary

; include debugging logic
#define DEBUG

; target machine, pick one
#define PET_ROM4
;#define PET_ROM2
;#define C64_ROM

#include "inc/cbm.def"
#include "inc/pettil.def"

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================

#define basic $0401
*=basic-2
#print basic
;--------------------------------------------------------------
#if 0
name=~ BASIC bootstrap
tags=system,nosymbol
PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to launch the system.  During the build, Core and tdict are assembled separately and concatenated, with the symbol table appended to the end.  [[LAUNCH]] is the code that moves the tdict and symbol table to their proper locations brings up the system by executing [[COLD]], which in turn executes [[WARM]] and brings up the outer interpreter.

is [[LAUNCH]]
There are five sections within
the PETTIL object code:

|^pettil-core|^load address|<|<|^`$0401`<br/><br/>|^Program load address|
|~|^bootstrap|<|^12 bytes|^`10 sys1037`<br/><br/>|^Enter or reenter PETTIL from BASIC|
|~|^pettillaunch|<|^3 bytes|^`jmp launch`<br/><br/>|startup vector|
|~|^zpbuf|^sweet16 registers|^32 bytes|<|^Sweet16 registers overlapping PETTIL work area|
|~|~|^stack|^96 bytes|<|^Data stack, split into high and low sections|
|~|~|^zi<br/>zlim<br/>up<br/>|^6 bytes|<|^loop index<br/>loop limit<br/>user pointer<br/>|
|~|~|^zpnext|^7 bytes|^` inc ip`<br/>` inc ip`<br/>` jmp ($FACE)`<br/><br/>|^copy of [[NEXT]] routine|
|~|^power2|<|^8 bytes|^`$80` `$40` `$20` `$10` `$08` `$04` `$02` `$01`<br/><br/>|^powers of 2 table|
|~|^[[plugh]]|<|^1 byte|^` rts`<br/><br/>|^enter or reenter PETTIL from BASIC|
|~| 165 total bytes |<|<|<|<|
|~| ''*** Sweet16 page alignment required ***''|<|<|<|`$04A6`<br/><br/>|
|~|^sweet16|<|^438 bytes|<|^Woz' Sweet16 emulator, extended|
|~|^user area|<|^122 bytes|<|^[[COLD]]/[[WARM]] initialization values and user variables|
|~|^core|^//user//<br/>//subroutines//<br/>//inner//<br/>//nucleus//<br/>//double//<br/>//io//<br/>//vm//<br/>//extra//|^~20 pages|<|^Core dictionary|
|~|^launch||^core side initialization code|<|<|
|~|~| * aloha<br/> * aloha<br/> * aloha<br/> * aloha<br/>|z|||
|~|~||z|||
|~|~||z|||
|~|~||z|||
|~|~||z|||
|^pettil-tdict|~||^2 bytes|^`$68EF`<br/><br/>|^load addr of tdict|
|~|~||^2 bytes|^`$1630`<br/><br/>|^size of tdict|
|~|~||^2 bytes|^`$1630`<br/><br/>|^|
|~|tdict||^42 bytes|^[[LAUNCH]]<br/><br/>|^|
||^symbols|||//cfa//<br/>//len//<br/>`name`<br/>...<br/><br/>`00` `00` `00`<br/><br/>|^for each symbol<br/><br/><br/><br/><br/>end of symbols<br/><br/>|

|^bootstrap|^pettil-core|
|^core|~|
|~|~|
|~|~|
|~|~|
|~|~|
|~|~|
|^launch|~|
|~|~|
|~|^pettil-tdict|
|~|^load address|
|^tdict<br/>|~|
|^symbols|^pettil.sym|

|^pettil-core|load address|`$0401`|^bootstrap|^//2 bytes//|
|~|basic start|`10 sys1037`|~|^//12 bytes//|
|~|A||~|^//12 bytes//|
|~|B||^core||
|~|C||^launch||
|^pettil-tdict|D||~||
|~|E||^tdict<br/>||
|^pettil.sym|F||^symbols||

# basic bootstrap
# core
# launch
# tdict
# symbols


!!!//PETTIL.OBJ// image map
|^//PETTIL.OBJ//|^description|^contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|^size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|h
|^//PETTIL-CORE.OBJ//|^load address|^`$0401`<br/><br/>|^2 bytes|
|~|^BASIC bootstrap|^`10 sys1037`<br/><br/>|^12 bytes|
|~|^pettillaunch|^` jmp cold`<br/><br/>|^3 bytes|
|~|^zpbuf|^sweet16 registers|^32 bytes|
|~|~|^stackl|^96 bytes|
|~|~|^stackh|~|
|~|~|^zi|^6 bytes|
|~|~|^zlim|~|
|~|~|^up|~|
|~|~|^zpnext<br/>`inc ip`<br/>`inc ip`<br/>`jmp ($face)`<br/><br/>|^7 bytes|
|~|^power2|^`$80` `$40` `$20` `$10` `$08` `$04` `$02` `$01`<br/><br/>|^8 bytes|
|~|^[[plugh]]|`rts`<br/><br/>|^1 byte|
|~|^sweet16|^//rtn bp bm bz bnz bm1 bnm1 nxt push pull br ext bs rs bc bnc set ld st ld@ st@ ldd@ std@ pop stpat add sub popd cpr inr dcr//|^439 bytes|
|~|^userarea|||
|~|^core modules|^//user<br/>subroutines<br/>inner<br/>nucleus<br/>double<br/>io<br/>vm<br/>extra//||
|~|^tdict modules|^//user<br/>dictionary<br/>interpreter<br/>compiler<br/>utils<br/>editor<br/>assembler//||
|~||||
|~||||

|~||||
|^//PETTIL-TDICT.OBJ//||||
|~||||
|~||||
|~||||
|~||||
|~||||
|~||||

|^//PETTIL.SYM//||||
|~||||
|~||||
|~||||
|~||||
|~||||
|~||||

!!!//PETTIL.OBJ// program image

|//PETTIL.OBJ//|^name|^description|^contents|^size|h
|^//PETTIL-CORE.OBJ//||^BASIC launch|^10 sys1037|^14 bytes|
|~|^sweet16|^PETTIL Sweet16 core<br/>preceded by spacing|^pettillaunch<br/>zpbuf<br/>zpnext<br/>power2<br/>sweet16<br/>user variables|^~3 pages|
|~|^core|^PETTIL core dictionary|user<br/>subroutines<br/>inner<br/>nucleus<br/>double<br/>io<br/>vm<br/>extra|^~20 pages|
|~|^startup|^one time initialization|^[[COLD]]<br/>[[HOT]]<br/>[[bannermsg]]|^1 page|
|^//PETTIL-TDICT.OBJ//|^|^tdict load address||^2 bytes|
|~|^|^size of tdict in bytes||^2 bytes|
|~|^tdict|^PETTIL transient dictionary|^user<br/>dictionary<br/>interpreter<br/>compiler<br/>utils<br/>editor<br/>assembler|^~22 pages|
|^//PETTIL.SYM//|^symtab|^PETTIL symbol table|^[address]<br/>[size]<br/>`NAME`<br/>...|^~13 pages|
|~||^end of symbol table|00 00 00|^3 bytes|




PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to launch the system.  There are four parts of
the object code:

# basic bootstrap
#

!!!//PETTIL.OBJ// image map
|^//PETTIL.OBJ//|^description|^contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|^size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|h
|^//PETTIL-CORE.OBJ//|^load address|^`$0401`<br/><br/>|^2 bytes|
|~|^BASIC bootstrap|^`10 sys1037`<br/><br/>|^12 bytes|
|~|^pettillaunch|^` jmp cold`<br/><br/>|^3 bytes|
|~|^zpbuf|^sweet16 registers|^32 bytes|
|~|~|^stackl|^96 bytes|
|~|~|^stackh|~|
|~|~|^zi|^6 bytes|
|~|~|^zlim|~|
|~|~|^up|~|
|~|~|^zpnext<br/>`inc ip`<br/>`inc ip`<br/>`jmp ($face)`<br/><br/>|^7 bytes|
|~|^power2|^`$80` `$40` `$20` `$10` `$08` `$04` `$02` `$01`<br/><br/>|^8 bytes|
|~|^[[plugh]]|`rts`<br/><br/>|^1 byte|
|~|^sweet16|^//rtn bp bm bz bnz bm1 bnm1 nxt push pull br ext bs rs bc bnc set ld st ld@ st@ ldd@ std@ pop stpat add sub popd cpr inr dcr//|^439 bytes|
|~|^userarea|||
|~|^core modules|^//user<br/>subroutines<br/>inner<br/>nucleus<br/>double<br/>io<br/>vm<br/>extra//||
|~|^tdict modules|^//user<br/>dictionary<br/>interpreter<br/>compiler<br/>utils<br/>editor<br/>assembler//||
|~||||
|~||||

|~||||
|^//PETTIL-TDICT.OBJ//||||
|~||||
|~||||
|~||||
|~||||
|~||||
|~||||

|^//PETTIL.SYM//||||
|~||||
|~||||
|~||||
|~||||
|~||||
|~||||

!!!//PETTIL.OBJ// program image

|//PETTIL.OBJ//|^name|^description|^contents|^size|h
|^//PETTIL-CORE.OBJ//||^BASIC launch|^10 sys1037|^14 bytes|
|~|^sweet16|^PETTIL Sweet16 core<br/>preceded by spacing|^pettillaunch<br/>zpbuf<br/>zpnext<br/>power2<br/>sweet16<br/>user variables|^~3 pages|
|~|^core|^PETTIL core dictionary|user<br/>subroutines<br/>inner<br/>nucleus<br/>double<br/>io<br/>vm<br/>extra|^~20 pages|
|~|^startup|^one time initialization|^[[COLD]]<br/>[[HOT]]<br/>[[bannermsg]]|^1 page|
|^//PETTIL-TDICT.OBJ//|^|^tdict load address||^2 bytes|
|~|^|^size of tdict in bytes||^2 bytes|
|~|^tdict|^PETTIL transient dictionary|^user<br/>dictionary<br/>interpreter<br/>compiler<br/>utils<br/>editor<br/>assembler|^~22 pages|
|^//PETTIL.SYM//|^symtab|^PETTIL symbol table|^[address]<br/>[size]<br/>`NAME`<br/>...|^~13 pages|
|~||^end of symbol table|00 00 00|^3 bytes|
#endif
petbasic
    .word basic                 ; this will be the load address
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold
;--------------------------------------------------------------
#if 0
name=~ Zero page buffer and NEXT routine
tags=system,nosymbol
This buffer holds an image at load time of zero page between
$00..$8D. PETTIL cold start calls the `zpswap` routine to
exchange it with the BASIC zero page on entry or exit.

Please note that `R12` is the Sweet-16 stack pointer, used by the
`BS` and `RS` opcodes.  It grows upward, and is initialized here to $0100
Changing this value will move Sweet-16's stack to somewhere else.
Any code that alters the value of `R12` will also move Sweet-16's stack
to a new area of memory, perhaps allowing Sweet-16 to overwrite
memory in unintended locations. Alter `R12` with care.

At $0086 is PETTIL's 15-clock inner interpreter consisting of
just three instructions.  Whoa.  It's fast.
#endif
zpbuf
;==============================================================
;==== zero page buffer and user area                       ====
;==============================================================
;
;
;$00
;
    .word $0000,$1001,$2002,$3003   ; overlapping
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack
;$80
    .word 0, 0, uarea               ; zi, zlim, up
;
;       NEXT
;               +IP
;               [IP] -> PC
;
; Minimalist NEXT, gets copied to zero page
;
; PETTIL's NEXT and ENTER both put the responsibility for page
; alignment on the compiler, greatly improving code execution
; speed over a more conventional design at a cost of complicating
; things somewhat.
;
;$86
zpnext
    inc ip                  ; [5] (next)
    inc ip                  ; [5] (next1)
;ip = *+1
    jmp ($cafe)             ; [5] (nexto)

                            ;[15] cycles total
;$8D TIME                   ; end of zero page buffer, Jiffy clock is here

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $80,$40,$20,$10,$08,$04,$02,$01

;--------------------------------------------------------------
#if 0
name=plugh
tags=nosymbol
An isolated RTS instruction, useful for debugging assembler or Sweet-16 in VICE

```
    .byt ld | N0
    .byt std | N2
    .byt ext        ; invoking VICE debugger from Sweet16
    .word plugh     ;
    .byt ld | N3
    .byt nxt

    jsr something
    jsr somethingelse
    sta anyplace
    jsr plugh       ; VICE debugger from 6502 assembler
    ldx anyplace
```
#endif
plugh
    rts

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

#if (* <> $04a6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04a6 (1190).  This is a problem.
#endif (sweet16 address check)
#echo .       program counter just before Sweet16 should be 1190, is:
#print *

#include "inc/sweet16.def"
#include "sweet16.a65"
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================


;--------------------------------------------------------------
#if 0
name=~ User Area
stack=( -- )
tags=system,uservar,nosymbol
Storage for user variables and initialization data for some of them
#endif
userarea
; uarea initialization data
; WARM
userup          .word uarea     ;
usersp0         .word bos+1     ;
userrp0         .word $01fe     ;
userwarm

; COLD
userfence       .word cold      ;
userdp          .word cold      ;
userstartup     .word _hot      ;
usermemsiz      .word 0         ; calculated at startup
                                ; keep the next three uservars together
userfilename    .word currname  ; counted string, default filename
                                ; is "PETTILPACKETS"
usersanum       .word 0         ; secondary address is 0, (PRG file)
userdrvnum      .word 1         ; cassette #1 is default device
usercold

; SOFT
; everything below initializes to 0 at COLD and is untouched by WARM
;
; memory pointers, in descending order
usercurrent     = usercold+0
usernewdp       = usercold+2    ; / FORGET relies on NEWDP being
usertdict       = usercold+4    ; \ adjacent to TDICT in uarea
usertdp         = usercold+6
usersymtab      = usercold+8
usersymnew      = usercold+10

usersymtail     = usercold+12
uservmbuf       = usercold+14
usernumvmpkt    = usercold+16
userblk         = usercold+18
userscr         = usercold+20
userlin         = usercold+22
useratlin       = usercold+24
usernumlin      = usercold+26

userscrpkt      = usercold+28
userediting     = usercold+30
usernumvoc      = usercold+32
usernewest      = usercold+34
userredefined   = usercold+36
userwarning     = usercold+38
userbase        = usercold+40
userdpl         = usercold+42

userhld         = usercold+44
usertoin        = usercold+46
userspan        = usercold+48
usernumline     = usercold+50   ; / CR relies on #LINE being
usernumout      = usercold+52   ; \ adjacent to #OUT in uarea
userstate       = usercold+54
usercsp         = usercold+56
uservsource     = usercold+58

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+80,0

    ; grow this string to test page-alignment
    .byt ""

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;--------------------------------------------------------------
#if 0
name=~ Core includes
tags=nosymbol
These are the source files included in [[PETTIL-CORE]].  The
other place to modify when adding/removing source files is
`xap.rb`
#endif
corebase
#print *
#include "core-user.a65"
#print *
#include "core-subroutines.a65"
#print *
#include "core-inner.a65"
#print *
#include "core-nucleus.a65"
#print *
#include "core-double.a65"
#print *
#include "core-io.a65"
#print *
#include "core-vm.a65"
#print *
#include "core-extra.a65"
#print *
;#include "../../mmm/src/mmm-nucleus.a65"
;#print *

;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=system,nosymbol
Dropping out to BASIC can be accomplished on purpose with MON
(to get to TIM), then .X to get to BASIC.  It also will happen
by mistake if cassette i/o is interrupted by the STOP key or
any tape error.  There may be other ways.  WARM should be able
to bring the system back to a usable state.

!!Tasks

* aloha
* - swap zero page with zpbuf
* - switch Sweet16<-->TIM BRK vector
* - switch PETTIL<-->BASIC IRQ vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* print start message CR,"WELCOME TO PETTIL!",CR
* STARTUP @ EXECUTE
#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
    ldy #<(warm03)
    lda #>(warm03)              ; load Y last to clear Z flag
    jmp toforth
#include "page.i65"
warm03
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word decimal
#include "pass.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "page.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "pass.i65"
    .word execute
;#include "pass.i65"
;   .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable

;--------------------------------------------------------------
#if 0
name=COLD
stack=( -- )
tags=system,nosymbol

In the core, everything beyond [[COLD]] disappears following initial
startup, so [[COLD]] = [[HERE]] immediately after loading PETTIL


One-time only (then disappear) system bootstrap initialization.
Runs once after "pettil.obj" loads, to prepare a development
environment.  The size of COLD doesn't really matter.  As
the final word in the core dictionary, COLD will FORGET
itself and its address becomes the value of FENCE.
It's a little hairy, I hope my comments will explain.

!!The pieces at load time
```
* 0400-040F   BASIC bootstrap (10 SYS 1037)
* 0410-       Core dictionary
              (about 6K of code)
* WARM        last permanent word in core dictionary
              <--FENCE -->
* HERE        COLD  initialize Forth
              HOT   more initialization in high-level Forth
              bannermsg

* there       2-byte load address of transient dictionary
              2-byte size of transient dictionary
* LAUNCH      first word in Transient dictionary
              Transient dictionary
              (about 5K of code}

              Symbol table
              (about 2K of headers)
* ($C9)       end of program
```
!!!COLD tasks

* change the [[pettillaunch|BASIC bootstrap]] vector from [[COLD]] to [[WARM]]
* set [[MEMSIZ]] from BASIC $34-35
* set [[SYMTAB]] as an offset from [[MEMSIZ]]
* set [[TDICT]] as the load address + 2 of part 2 (found at 'there')
* display a [[banner|bannermsg]]
* set STARTUP uservariable to [[LAUNCH]]
* move transient dictionary to [[TDICT]]
* move symbol table to [[SYMTAB]]
* set [[FENCE]]
* call [[WARM]] to put us in Forth mode

There is no knowledge in the core dictionary (at the bottom of memory)
of what is in the transient dictionary or where it resides.  To kick
things off upstairs, WARM starts Forth, then executes the word LAUNCH
in the upper dictionary, via the STARTUP uservariable.  The requirement
is that the first thing in tdict must be the executable CFA of LAUNCH
That's where we will pick things up.

Transient dictionary and symbols are built separately
as ~PETTIL-TDICT.OBJ and PETTIL.SYM.

The true load address of `pettil-tdict.obj` is offset by -2.
That's because there are two bytes stuffed in the front (the file size)
which are not part of the [[TDICT]] code.  It's done this way so
the cold start can figure out where the transient dictionary ends
and where the symbol table begins.  ($C9) in zero page tells the
cold start the last address in the file load, which is the end of the
symbol table.
#endif
cold
    nop                         ; make it easy to find here
    nop
    nop
    nop
    lda #<(bannermsg+1)         ; display a banner
    sta TEMPF1
    lda #>(bannermsg+1)
    sta TEMPF1+1
    ldy #0
cold01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg
    bne cold01

    lda #<warm                  ; Overwrite the BASIC hook
    sta pettillaunch+1          ; change +1037 JMP COLD to +1037 JMP WARM
    lda #>warm                  ; for reentry
    sta pettillaunch+2

    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1

    jmp cold2warm               ; start Forth, run HOT next

;--------------------------------------------------------------
#if 0
name=HOT
stack=( -- )
tags=system,nosymbol
[[COLD]] does enough to kickstart Forth, then HOT is next.

* sets [[TDICT]] and [[SYMTAB]] user variables
* copy the transient dictionary to [[TDICT]]
* copy the symbols to [[SYMTAB]]+32
* [[EMPTYBUFFERS]]
* execute [[LAUNCH]] (first word at the first address in [[TDICT]])

```
: hot   ( -- )
    ['] there literal
    dup 4 +under @
    2+ dup tdict ! dup 4096 - symtab !
    over 2- @
    third over + @
    bl + EAL @
    third -
    cmove
    cmove
    empty-buffers
    tdict @ execute ;
```
#endif
#include "align.i65"
_hot
    jsr enter
#include "pass.i65"
    .word plit
    .word there
#include "page.i65"
    .word dup
#include "page.i65"
    .word four
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word tdict
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "pass.i65"
    .word plit
    .word 4096
#include "page.i65"
    .word minus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word plus
#include "pass.i65"
    .word clit
    .byt EAL
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _emptybuffers
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute               ; launch

;--------------------------------------------------------------
#if 0
name=bannermsg
tags=system,nosymbol
The message of the day.  In pre-beta, I like to put a "this day
in history" in the welcome banner.  The end of this message marks
the end of [[core]] immediately after initial load.  It is followed
in the program image by the [[]]


The size of this word is large because the next thing after it
is [[LAUNCH]] in the transient dictionary.  Adding the sizes of
[[bannermsg]]+[[HOT]]+[[COLD]] together will accurately reflect the
available RAM for the symbol table, virtual memory buffers, and
user code.
#endif
bannermsg
    .byt (there-*-1)            ; length of bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION ALPHA 2017-03-17",CR
    .asc    "461AD  ST PATRICKS DAY",CR
            ;123456789.123456789.123456789.123456789.
there

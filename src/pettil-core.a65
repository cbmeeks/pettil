; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
; wrapper to build PETTIL core dictionary

; include debugging logic
#define DEBUG

; target machine
#define PET_ROM4

; PET target memory size
#define PETRAM 32

#include "inc/cbm.def"
#include "inc/pettil.def"

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================

#define basic $0401
*=basic-2
;--------------------------------------------------------------
#if 0
name=BASIC bootstrap
tags=system,nosymbol
PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to kick off the cold start routine
#endif
petbasic
    .word basic                 ; this will be the load address
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold
;--------------------------------------------------------------
#if 0
name=Zero page buffer and NEXT routine
tags=system,nosymbol
This buffer holds an image at load time of zero page between
$00..$8D. PETTIL cold start calls the `zpswap` routine to
exchange it with the BASIC zero page on entry or exit.

At $86 is PETTIL's 15-clock inner interpreter consisting of
just three instructions.  Whoa.  It's fast.
#endif
zpbuf
;==============================================================
;==== zero page buffer and user area                       ====
;==============================================================
;
;
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,uarea,$3003   ; overlapping
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ;
    nop                     ; see "RANDU" for how it works
    nop                     ;
;
;       NEXT
;               +IP
;               [IP] -> PC
;
; minimalist NEXT
;$86
zpnext
    inc ip                  ; [5]
    inc ip                  ; [5]
;ip = *+1
    jmp ($cafe)             ; [5]

                            ;[15] cycles total
;$8D TIME                   ; end of zero page buffer, Jiffy clock is here

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $80,$40,$20,$10,$08,$04,$02,$01

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================
    nop                         ; fine tune position of Sweet16

#if (* <> $04a6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04a6 (1190).  This is a problem.
#endif (sweet16 address check)
#echo .       program counter just before Sweet16 should be 1190, is:
#print *

#include "sweet16.a65"
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================


;--------------------------------------------------------------
#if 0
name=User Area
stack=( -- )
tags=system,uservar,nosymbol
Storage for user variables and initialization data for some of them
#endif
userarea
; uarea initialization data
; WARM
userup          .word uarea     ;
usersp0         .word bos+1     ;
userrp0         .word $01fe     ;
userwarm

; COLD
userfence       .word cold      ;
userdp          .word cold      ;
userstartup     .word _hot      ; bootstrap COLD->HOT->LAUNCH
usermemsiz      .word 0
userdrvnum      .word 1         ; cassette #1 is default device
userfilename    .word currname  ; counted string, default filename
usercold

; SOFT
; everything below initializes to 0 at COLD and is untouched by WARM
;
; memory pointers, in descending order
usercontext     = usercold+0
usercurrent     = usercold+2
usertdict       = usercold+4
usersymtail     = usercold+6
usersymnew      = usercold+8
usersymtab      = usercold+10
uservmbuf       = usercold+12
usernumvmpkt    = usercold+14
userblk         = usercold+16
userwordvec     = usercold+18
userdoneq       = usercold+20
userscr         = usercold+22
userlin         = usercold+24
usercurrlin     = usercold+26
usereditingq    = usercold+28
userwritableq   = usercold+30
usernumvoc      = usercold+32
usernewest      = usercold+34
usernewdp       = usercold+36
userwarning     = usercold+38
userbase        = usercold+40
userdpl         = usercold+42
userhld         = usercold+44
usertoin        = usercold+46
userspan        = usercold+48
usernumtib      = usercold+50
usernumout      = usercold+52
usernumline     = usercold+54
userstate       = usercold+56
usercsp         = usercold+58

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+80,0

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;--------------------------------------------------------------
#if 0
name=Core includes
tags=nosymbol
These are the source files included in [[PETTIL-CORE]]
#endif
corebase
#include "core-subroutines.a65"
#include "core-user.a65"
#include "core-inner.a65"
#include "core-nucleus.a65"
#include "core-device.a65"
#include "core-pet.a65"
#include "core-numword.a65"
#include "core-double.a65"
#include "core-string.a65"
#include "core-vm.a65"

;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=system,nosymbol
Dropping out to BASIC can be accomplished on purpose with MON
(to get to TIM), then .X to get to BASIC.  It also will happen
by mistake if cassette i/o is interrupted by the STOP key or
any tape error.  There may be other ways.  WARM should be able
to bring the system back to a usable state.

!!Tasks

* aloha
* - swap zero page with zpbuf
* - switch Sweet16<-->TIM BRK vector
* - switch PETTIL<-->BASIC IRQ vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* print start message CR,"WELCOME TO PETTIL!",CR
* STARTUP @ EXECUTE
#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
#include "toforth.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable

;--------------------------------------------------------------
#if 0
name=COLD
stack=( -- )
tags=system,nosymbol
One-time only (then disappear) system bootstrap initialization.
Runs once after "pettil.obj" loads, to prepare a development
environment.  The size of COLD doesn't really matter.  As
the final word in the core dictionary, COLD will FORGET
itself and its address becomes the value of FENCE.
It's a little hairy, I hope my comments will explain.

!!The pieces at load time
```
* 0400-040F   BASIC bootstrap (10 SYS 1037)
* 0410-       Core dictionary
              (about 6K of code)
* WARM        last permanent word in core dictionary
              <--FENCE -->
* HERE        COLD  initialize Forth
              HOT   more initialization in high-level Forth
              bannermsg

* there       2-byte load address of transient dictionary
              2-byte size of transient dictionary
* LAUNCH      first word in Transient dictionary
              Transient dictionary
              (about 5K of code}

              Symbol table
              (about 2K of headers)
* ($C9)       end of program
```
!!!COLD tasks

* change the [[pettillaunch|BASIC bootstrap]] vector from [[COLD]] to [[WARM]]
* set [[MEMSIZ]] from BASIC $34-35
* set [[SYMTAB]] as an offset from [[MEMSIZ]]
* set [[TDICT]] as the load address + 2 of part 2 (found at 'there')
* display a [[banner|bannermsg]]
* set STARTUP uservariable to [[LAUNCH]]
* move transient dictionary to [[TDICT]]
* move symbol table to [[SYMTAB]]
* set [[FENCE]]
* call [[WARM]] to put us in Forth mode

There is no knowledge in the core dictionary (at the bottom of memory)
of what is in the transient dictionary or where it resides.  To kick
things off upstairs, WARM starts Forth, then executes the word LAUNCH
in the upper dictionary, via the STARTUP uservariable.  The requirement
is that the first thing in tdict must be the executable CFA of LAUNCH
That's where we will pick things up.

Transient dictionary and symbols are built separately
as ~PETTIL-TDICT.OBJ and PETTIL.SYM.

The true load address of `pettil-tdict.obj` is offset by -2.
That's because there are two bytes stuffed in the front (the file size)
which are not part of the [[TDICT]] code.  It's done this way so
the cold start can figure out where the transient dictionary ends
and where the symbol table begins.  ($C9) in zero page tells the
cold start the last address in the file load, which is the end of the
symbol table.
#endif
cold
    nop                         ; make it easy to find here
    nop
    nop
    nop
    lda #<bannermsg             ; display a banner
    sta TEMPF1
    lda #>bannermsg
    sta TEMPF1+1
    ldy #0
cold01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg-1
    bne cold01

    lda #<warm                  ; Overwrite the BASIC hook
    sta pettillaunch+1          ; change +1037 JMP COLD to +1037 JMP WARM
    lda #>warm                  ; for reentry
    sta pettillaunch+2

    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1

    jmp cold2warm               ; start Forth, run HOT next

;--------------------------------------------------------------
#if 0
name=HOT
stack=( -- )
tags=system,nosymbol
[[COLD]] does enough to kickstart Forth, then HOT is next.

* sets [[TDICT]] and [[SYMTAB]] user variables
* copy the transient dictionary to [[TDICT]]
* copy the symbols to [[SYMTAB]]+32
* execute [[LAUNCH]] (first word at the first address in [[TDICT]])
#endif
_hot
#include "enter.i65"
    .word plit
    .word there
#include "pad.i65"
    .word dup
#include "page.i65"
    .word four
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word tdict
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 4096
#include "pad.i65"
    .word minus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word plus
#include "page.i65"
    .word clit
    .byt EAL
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word cmove
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute               ; launch

    .byt (there-*-1)            ; length of bannermsg
;--------------------------------------------------------------
#if 0
name=bannermsg
tags=system,nosymbol
The message of the day.  In pre-beta, I like to put a "this day
in history" sort of note on the git commits, which appears at
startup in the welcome banner.  This message does not occupy
any precious RAM after startup completes.

The size of this word is large because the next thing after it
is [[LAUNCH]] in the transient dictionary.  Adding the sizes of
[[bannermsg]]+[[HOT]]+[[COLD]] together will accurately reflect the
available RAM for the symbol table, virtual memory buffers, and
user code.
#endif
bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-07-03",CR
    .asc    "1844 THE GREAT AUK BECOMES EXTINCT",CR
            ;123456789.123456789.123456789.123456789.
there

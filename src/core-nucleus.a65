; core-nucleus.a65
#echo .       core-nucleus.a65          Nucleus
;--------------------------------------------------------------
#if 0
name=UM*
stack=( u1 u2 -- ud )
tags=nucleus,math,forth-83
"ud" is the unsigned product of "u1" times "u2".  All values and
arithmetic are unsigned.

A proper 6502 assembler solution.

Features

* multiplies two 8-bit numbers with 16 bit result
* inner loop of only 17 clock cycles per iteration
* worst case behaviour of 40 clock cycles per iteration
* minimizes number of iterations
* total execution time 25 - 320 cycles

(i.e. only 3x slower (worst case) than MUL on Intel 8088)

* 43 bytes size
* relocatable to about anywhere in address space
* uses C64-friendly memory locations

 INPUT  = op1 in A, op2 in X

 OUTPUT = low byte in X, high byte in Y

 memory locations used as temp space = $fb, $fc, $fd

```
;You beat me to the punch, but there is some unnecessary code in there (you don't need to clear the carry before a LSR). And trashing X is unnecessary since you can test for zero just as fast with LDA $02. Or with some crazy jujitsu to save a byte...
;Here's my version, handles 8-bit operands:
;--$00 holds operand 1
;--$01 (low byte) and $02 (high byte) hold operand 2
;--$03 (low byte) and $04 (high byte) hold product
;       cld
;Loop
;    lsr $00
;    bcc NoAdd
;    clc
;    lda $03
;    adc $01
;    sta $03
;    lda $04
;    adc $02
;    sta $04
;    .byte $2C
;NoAdd
;    beq Done
;    asl $01
;    rol $02
;    bcc Loop        ;this assumes that operand 2 is 8-bit
;Done
;
;A proper 6502 assembler solution.
;
;Features
;- multiplies two 8-bit numbers with 16 bit result
;- inner loop of only 17 clock cycles per iteration
;- worst case behaviour of 40 clock cycles per iteration
;- minimizes number of iterations
;- total execution time 25 - 320 cycles
;(i.e. only 3x slower (worst case) than MUL on Intel 8088)
;- 43 bytes size
;- relocatable to about anywhere in address space
;- uses C64-friendly memory locations
; INPUT  = op1 in A, op2 in X
; OUTPUT = low byte in X, high byte in Y
; memory locations used as temp space = $fb, $fc, $fd
;    stx $fc    ; save op2
;    cmp $fc    ; compare both operands
;    bcc noswap ; swap them unless op1 < op2
;    sta $fc    ; save op1 instead of op2
;    txa        ; swap op2 for op1
;noswap
;    ldx #$00   ; prepare result low byte
;    stx $fd    ; clear high byte of op2
;    ldy #$00   ; prepare result high byte
;    beq begin  ; skip shift of op2 for first iteration
;loop
;    asl $fc    ; multiply op2 by 2, low byte
;    rol $fd    ; multiply op2 by 2, high byte
;begin
;    lsr        ; divide op1 by 2
;    bcs add    ; if op1 was odd before division, add op2
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;add
;    sta $fb    ; save current value of op1
;    clc        ; prepare addition
;    txa        ; fetch low byte
;    adc $fc    ; add op2, low byte
;    tax        ; store low byte
;    tya        ; fetch high byte
;    adc $fd    ; add op2, high byte
;    tay        ; store high byte
;    lda $fb    ; restore op1
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;

    stx $fc    ; save op2
    cmp $fc    ; compare both operands
    bcc noswap ; swap them unless op1 < op2
    sta $fc    ; save op1 instead of op2
    txa        ; swap op2 for op1
noswap
    ldx #$00   ; prepare result low byte
    stx $fd    ; clear high byte of op2
    ldy #$00   ; prepare result high byte
    beq begin  ; skip shift of op2 for first iteration
loop
    asl $fc    ; multiply op2 by 2, low byte
    rol $fd    ; multiply op2 by 2, high byte
begin
    lsr        ; divide op1 by 2
    bcs add    ; if op1 was odd before division, add op2
    bne loop   ; if op1 is not zero repeat loop
    rts        ; otherwise return result
add
    sta $fb    ; save current value of op1
    clc        ; prepare addition
    txa        ; fetch low byte
    adc $fc    ; add op2, low byte
    tax        ; store low byte
    tya        ; fetch high byte
    adc $fd    ; add op2, high byte
    tay        ; store high byte
    lda $fb    ; restore op1
    bne loop   ; if op1 is not zero repeat loop
    rts        ; otherwise return result

```
check http://6502.org/source/ for multiply and divide and stuff
#endif
umstar
    lda stackl,x
    sta n+4
    lda stackh,x            ;multiplicand in tos
    sta n+5                 ;multiplier in N2
    jsr multiply            ;16 bit unsigned multiply
    lda n
    sta stackl,x
    lda n+1
    sta stackh,x
    lda n+2
    sta tos
    lda n+3
    sta tos+1
    jmp next

multiply
    lda #0                  ; unsigned multiply tos*N2 destroys tos
    sta n+2                 ;clear upper half of product
    sta n+3
    ldy #16
rshift
    lsr tos+1
    ror tos
    bcc rrot                ;Go rotate right if c = 0
    clc                     ; and add multiplicand to
    lda n+2                 ;Get upper half of product
    adc n+4                 ; it
    sta n+2
    lda n+3
    adc n+5
rrot
    ror                     ;shift partial product right
    sta n+3
    ror n+2
    ror n+1
    ror n
    dey                     ;Decrement bit count and
    bne rshift
    rts

;--------------------------------------------------------------
#if 0
name=UD/MOD
stack=( d1 n1 -- n2 d2 )
tags=nucleus
 d2 is the double quotient of d1/n1.  n2 is the remainder.  All
 values are unsigned.
 ~ make this 32-bit divisor?
 ~ fix for /0
#endif
udslashmod
    ldy #2
    jsr locals               ; udlo -> N0; udhi -> N1
    jsr divmod              ; (unsigned) u31/u16 -> quo31 rem16
    dex
    lda n+1
    sta stackh,x
    lda n
    sta stackl,x            ; remainder
    lda n+9
    sta tos+1
    lda n+8
    sta tos
    ldy n+11
    lda n+10
    jmp pushya

divmod
    stx storex
    ldx #7
divmod00
    sty n+4,x               ; zero the divisor & quotient
    dex
    bpl divmod00
    ldx storex
    lda tos+1
    ora tos
    beq divmod05            ; error division by zero
    ldy #33
divmod01
    lsr tos+1
    ror tos                 ; divisor = divisor/2
    ror n+7
    ror n+6                 ; shift it in until we hit zero
    ror n+5
    ror n+4
    dey
    lda tos+1
    ora tos
    bne divmod01
divmod02
    asl n+8
    rol n+9                 ; quotient low
    rol n+10
    rol n+11                ; double the quotient here
    sec
    lda n
    sbc n+4
    pha
    lda n+1
    sbc n+5
    pha
    lda n+2
    sbc n+6
    pha
    lda n+3
    sbc n+7
    bcc divmod03
    sta n+3
    pla
    sta n+2
    pla
    sta n+1
    pla
    sta n
    inc n+8                 ; add 1 to quotient
    bcs divmod04            ; bra
divmod03
    pla
    pla
    pla                     ; discard result of subtraction
divmod04
    lsr n+7
    ror n+6
    ror n+5
    ror n+4                 ; divisor /2
    dey
    bne divmod02
divmod05
    rts

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
Perform a divide by 40 and a modulo 40, for
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
slmod40
    stx storex
    lda #0
    ldx #7
slmod40a
    sta n,x
    dex
    bpl slmod40a                ; zero n+0..n+7
    ldx #2
slmod40b
    clc
    lda n                       ; addend = n*3
    adc tos
    sta n
    lda n+1
    adc tos+1
    sta n+1
    bcc slmod40c
    inc n+2
slmod40c
    dex
    bpl slmod40b
    lda #4
    sta n+8
slmod40d
    clc
    lda n+0
    adc n+4
    sta n+4
    lda n+1
    adc n+5
    sta n+5
    lda n+2
    adc n+6
    sta n+6
    lda n+3
    adc n+7
    sta n+7                     ; sum += addend

    ldy #4
slmod40e
    asl n
    rol n+1
    rol n+2
    rol n+3                     ; addend << 4
    dey
    bne slmod40e
    dec n+8                     ; repeat 4x (3+48+768+12288 = 13107)
    bne slmod40d

    clc
    lda n+4
    adc #<13100
    sta n+4
    lda n+5
    adc #>13100
    sta n+5
    bcc slmod40f
    inc n+6
    bne slmod40f
    inc n+7                     ; sum += 13100 (fudge factor)
slmod40f
    lda n+7                     ; (n+6) is now u/5
    lsr
    ror n+6
    lsr
    ror n+6
    lsr
    ror n+6
    sta n+7                     ; (n+6) = u/40

    lda n+6
    sta n+0
    lda n+7
    sta n+1
    sty n+2
    sty n+3
    asl n
    rol n+1
    asl n
    rol n+1                     ; n = u/40*4
    ;clc
    lda n
    adc n+6
    sta n
    lda n+1
    adc n+7
    sta n+1                     ; n = u/40*5
    asl n
    rol n+1
    asl n
    rol n+1
    asl n
    rol n+1                     ; n = u/40*5*8
    sec
    lda tos
    sbc n
    sta tos
    lda tos+1
    sbc n+1
    sta tos+1                   ; tos =  u % 40
    lda n+6
    ldy n+7                     ; push   u / 40
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=UM/MOD
stack=( ud u -- rem quot )
tags=forth-83,nucleus
Perform an unsigned division of the 16-bit "u" into the double
"ud", leaving the 16-bit unsigned remainder and quotient on
the stack

      http://6502.org/source/integers/ummodfix/ummodfix.htm

!!! pronounced: "u-m slash mod"
#endif
_umslashmod
#include "enter.i65"
    .word udslashmod
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AND
stack=( n1 n2 -- n1&n2 )
tags=forth-83,nucleus,boolean
#endif
andx
    lda tos+1
    and stackh,x
    tay
    lda tos
    and stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=OR
stack=( n1 n2 -- n1|n2 )
tags=forth-83,nucleus,boolean
#endif
orx
    lda tos+1
    ora stackh,x
    tay
    lda tos
    ora stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=XOR
stack=( n1 n2 -- n1^n2 )
tags=forth-83,nucleus,boolean
#endif
xor
    lda tos+1
    eor stackh,x
    tay
    lda tos
    eor stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=NOT
stack=( n -- !n )
tags=forth-83,nucleus,boolean
#endif
not
    jsr invert
    jmp next

;--------------------------------------------------------------
#if 0
name=>R
stack=( n -- ) ( R; -- n )
tags=forth-83,nucleus,stack
Move the top element of the data stack to the return stack

!!! pronounced: "to-r"
#endif
tor
    lda tos+1
    pha
    lda tos
    pha
    jmp pops

;--------------------------------------------------------------
#if 0
name=R>
stack=( -- n ) ( R; n -- )
tags=forth-83,nucleus,stack
Remove the top value from the return stack and leave it on the
        computation stack. See >R and R@

!!! pronounced: "r-from"
#endif
rfrom
    pla
    sta storex
    pla
    tay
    lda storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=DUP>R
stack=( n -- n ) ( R; -- n )
tags=nucleus,stack
Copy the top of the data stack to the return stack

!!! pronounced: "dupe to-r"
#endif
duptor
    jsr slip
    jmp tor

;--------------------------------------------------------------
#if 0
name=RSWAP
stack=( -- ) ( R; a b -- b a )
tags=nucleus,stack
Swap the top two items on the return stack

!!! pronounced: "r-swap"
#endif
rswap
    stx storex
    tsx
    ldy $0102,x
    lda $0104,x
    sta $0102,x
    tya
    sta $0104,x
    ldy $0101,x
    lda $0103,x
    sta $0101,x
    tya
    sta $0103,x
    ldx storex
    jmp next

;--------------------------------------------------------------
#if 0
name=RDROP
stack=( -- ) ( R; a -- )
tags=nucleus,stack
Drop the top item on the return stack

!!! pronounced: "r-drop"
#endif
rdrop
    pla
    pla
    jmp next

;--------------------------------------------------------------
#if 0
name=0>
stack=( n -- flag )
tags=forth-83,nucleus,relational


#endif
zgt
    ldy #0
    lda tos+1
    bmi zgt01                   ; check the sign
    ora tos                     ; check for nonzero
    beq zgt01
    dey
zgt01
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=OFF
stack=( addr -- )
tags=nucleus,memory
Store 0 at "addr"
#endif
off
    lda #$00
    .byt $2c                    ; BIT xxxx falls through to ON
;--------------------------------------------------------------
#if 0
name=ON
stack=( addr -- )
tags=nucleus,memory
Store -1 at "addr"
#endif
on
    lda #$ff
on1
    ldy #0
    sta (tos),y
    iny
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
#if 0
name=+
stack=( n1 n2 -- sum )
tags=forth-83,nucleus,math,fig,forth-79
Leave the sum of n1+n2

!!! pronounced: "plus"
#endif
plus
    clc
    lda tos
    adc stackl,x
    sta tos
    lda tos+1
    adc stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=ABS
stack=( n -- u )
tags=forth-83,nucleus,math,fig,forth-79
Leave the absolute value of n as u.
#endif
abs
    bit tos+1
    bpl negate01
;--------------------------------------------------------------
#if 0
name=NEGATE
stack=( n -- -n )
tags=forth-83,nucleus,math

#endif
negate
    jsr donegate
negate01
    jmp next
donegate
    sec
neg2
    lda #0
    sbc tos
    sta tos
    lda #0
    sbc tos+1
    sta tos+1
    rts

;--------------------------------------------------------------
#if 0
name=OVER
stack=( n1 n2 -- n1 n2 n1 )
tags=forth-83,nucleus,stack

#endif
over
    ldy stackh,x
    lda stackl,x
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SWAP
stack=( n1 n2 -- n2 n1 )
tags=forth-83,nucleus,stack,fig,forth-79
Exchange the top two values on the stack.
#endif
swap
    ldy tos+1
    lda stackh,x
    sta tos+1
    sty stackh,x
    ldy tos
    lda stackl,x
    sta tos
    sty stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=TUCK
stack=( n1 n2 -- n2 n1 n2 )
tags=forth-83,nucleus,stack
Insert the top item on the stack beneath the second.
#endif
tuck
    dex
    jsr tuckdashrot
    jmp next

tuckdashrot
    lda stackh+1,x
    sta stackh,x
    lda stackl+1,x
    sta stackl,x
    lda tos+1
    sta stackh+1,x
    lda tos
    sta stackl+1,x
    rts

;--------------------------------------------------------------
#if 0
name=-ROT
stack=( a b c -- c a b )
tags=nucleus,stack

#endif
dashrot
    ldy stackh,x
    lda stackl,x        ; b
    pha
    jsr tuckdashrot
    pla
    jmp put             ; b -> c

;--------------------------------------------------------------
#if 0
name=NIP
stack=( n1 n2 -- n2 )
tags=nucleus,stack
Remove the second item from the stack
#endif
nip
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=DUP
stack=( n -- n n )
tags=forth-83,nucleus,stack,forth-79,fig
Duplicate the value on the stack.

!!! pronounced: "dupe"
#endif
dup
    jsr slip
    jmp next

;--------------------------------------------------------------
#if 0
name=+!
stack=( n addr -- )
tags=forth-83,nucleus,fig,forth-79
Add "n" to the value at "addr"

!!! pronounced: "plus-store"
#endif
plusstore
    ldy #0
    clc
    lda stackl,x
    adc (tos),y
    sta (tos),y
    iny
    lda stackh,x
    adc (tos),y
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=TOGGLE
stack=( addr bitmask -- )
tags=nucleus,boolean,fig
Complement the contents of addr by the bit pattern b.
#endif
toggle
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1
    ldy #0
    lda (n),y
    eor tos
    sta (n),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    ldy #0
    lda stackl,x
    sta (tos),y
    iny
    lda stackh,x
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=!+
stack=( addr n -- addr+2 )
tags=nucleus

 Stores n at addr, returns the following address

!!! pronounced: "store-plus"
#endif
_storeplus
#include "enter.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C!
stack=( 8b addr -- )
tags=forth-83,nucleus,memory
 The least-significant 8 bits of 16b are stored into the byte
 at addr.

!!! pronounced: "c-store"
#endif
cstore
    lda stackl,x
    ldy #0
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=C!+
stack=( addr c -- addr+1 )
tags=nucleus,memory,primitive
The least-significant 8 bits of c are stored into the byte
at addr, and addr is incremented by one

!!!pronounced: "c-store-plus"
#endif
cstoreplus
    lda tos
    pha
    jsr slide
    ldy #0
    pla
    sta (tos),y
    jsr inctos
    jmp next

;--------------------------------------------------------------
#if 0
name=C@+
stack=( addr -- addr+1 c )
tags=nucleus,memory,primitive
Fetches the byte at addr, increments addr

!!!pronounced: "c-fetch-plus"
#endif
cfetchplus
    ldy #0
    lda (tos),y
    jsr inctos
    jmp pushya

;--------------------------------------------------------------
#if 0
name=CBIT!
stack=( mask addr -- )
tags=nucleus,boolean,memory

 turn on the mask bits in the byte at address

!!! pronounced: "c-bit-store"
#endif
cbitstore
    ldy #0
    lda (tos),y
    ora stackl,x
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=CBIT@
stack=( mask addr -- flag )
tags=nucleus

 test the mask bits in the byte at address

#endif
cbitfetch
    ldy #0
    lda (tos),y
    and stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=TIB
stack=( -- addr )
tags=nucleus,const
The address of the text input buffer.  This buffer is used
to hold characters when the input stream is coming from the
current input device.  The minimum capacity of TIB is 80
characters.

!!!pronounced: "t-i-b"
#endif
tib
    jsr doconst
    .word BUF       ; $0200

;--------------------------------------------------------------
#if 0
name=-2
stack=( -- -2 )
tags=nucleus,const

#endif
minustwo
    jsr doconst
    .word -2

;--------------------------------------------------------------
#if 0
name=1
stack=( -- 1 )
tags=nucleus,const

#endif
one
    jsr docconst
    .byt 1

;--------------------------------------------------------------
#if 0
name=2
stack=( -- 2 )
tags=nucleus

#endif
two
    jsr docconst
    .byt 2

;--------------------------------------------------------------
#if 0
name=3
stack=( -- 3 )
tags=nucleus

#endif
three
    jsr docconst
    .byt 3

;--------------------------------------------------------------
#if 0
name=4
stack=( -- 4 )
tags=nucleus

#endif
four
    jsr docconst
    .byt 4

;--------------------------------------------------------------
#if 0
name=BL
stack=( -- n )
tags=nucleus,const

#endif
bl
    jsr docconst
    .byt $20

;--------------------------------------------------------------
#if 0
name=FORTY
stack=( -- 40 )
tags=nucleus,const

#endif
forty
    jsr docconst
    .byt 40

;--------------------------------------------------------------
#if 0
name=EIGHTY
stack=( -- 80 )
tags=nucleus,const

#endif
eighty
    jsr docconst
    .byt 80

;--------------------------------------------------------------
#if 0
name=-1
stack=( -- -1 )
tags=nucleus

#endif
minusone
                ; fall through to true
;--------------------------------------------------------------
#if 0
name=TRUE
stack=( -- -1 )
tags=nucleus

#endif
true
    lda #$ff
true01
    tay
    jmp pushya

;--------------------------------------------------------------
#if 0
name=0
stack=( -- 0 )
tags=nucleus

#endif
zero
                ; fall through to false
;--------------------------------------------------------------
#if 0
name=FALSE
stack=( -- 0 )
tags=nucleus

#endif
false
    lda #0
    beq true01

;--------------------------------------------------------------
#if 0
name=0=
stack=( n -- flag )
tags=forth-83,nucleus


#endif
zeq
    ldy #$00
    lda tos
    ora tos+1
    bne zeq02
zeq01
    dey
zeq02
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=0<
stack=( n -- flag )
tags=forth-83,nucleus


#endif
zlt
    ldy #0
    bit tos+1
    bmi zeq01
    bpl zeq02

;--------------------------------------------------------------
#if 0
name=0<>
stack=( n -- flag )
tags=nucleus

#endif
zne
    ldy #0
    lda tos
    ora tos+1
    bne zeq01
    beq zeq02

;--------------------------------------------------------------
#if 0
name=1+
stack=( n -- n+1 )
tags=forth-83,nucleus


#endif
oneplus
    jsr inctos
    jmp next

;--------------------------------------------------------------
#if 0
name=1-
stack=( n -- n-1 )
tags=forth-83,nucleus


#endif
oneminus
    jsr dectos
    jmp next

;--------------------------------------------------------------
#if 0
name=3-
stack=( n -- n-3 )
tags=nucleus

#endif
threeminus
    lda #$fd
    .byt $2c ; BIT absolute instruction, fall through to twominus
;--------------------------------------------------------------
#if 0
name=2-
stack=( n -- n-2 )
tags=nucleus

#endif
twominus
    lda #$fe
    dec tos+1
    .byt $2c ; BIT absolute instruction, fall through to twoplus
;--------------------------------------------------------------
#if 0
name=2+
stack=( n -- n+2 )
tags=nucleus,math,~wut?
Increment top of stack by 2

todo: code golf this together with slower tos2plus subroutine?
#endif
twoplus
    lda #2
nplus
    clc
    adc tos
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next
;--------------------------------------------------------------
#if 0
name=3+
stack=( n -- n+3 )
tags=nucleus

#endif
threeplus
    lda #3
    bne nplus                   ; bra

;--------------------------------------------------------------
#if 0
name=2/
stack=( n -- n/2 )
tags=forth-83,nucleus


#endif
twoslash
    lsr tos+1
    ror tos
    jmp next

;--------------------------------------------------------------
#if 0
name=2*
stack=( n -- n*2 )
tags=nucleus

#endif
twostar
    asl tos
    rol tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=-
stack=( a b -- a-b )
tags=forth-83,nucleus


#endif
minus
    jsr donegate
    jmp plus

;--------------------------------------------------------------
#if 0
name=<>
stack=( n1 n2 -- flag )
tags=nucleus,relational
Leave a true flag if "n1" does not equal "n2".
#endif
ne
    ldy #$ff                    ; assume inequality
    .byt $2c                    ; BIT abs instruction
;--------------------------------------------------------------
#if 0
name==
stack=( n1 n2 -- flag )
tags=forth-83,nucleus,relational
Leave a true flag if "n1" does is equal to "n2".
#endif
eq
    ldy #0
;ne entry point
    lda tos
    eor stackl,x
    bne cmpout02
    lda tos+1
    eor stackh,x
    bne cmpout02
cmpout01
    tya
    eor #$ff
    tay
cmpout02
    tya
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=U<
stack=( n1 n2 -- flag )
tags=forth-83,nucleus


#endif
ult
    jsr cmp16
    bcs cmpout02
    bcc cmpout01

;--------------------------------------------------------------
#if 0
name=<
stack=( n1 n2 -- flag )
tags=forth-83,nucleus


#endif
lt
    jsr cmp16
sgntst
    bvc lt01
    eor #bit7
lt01
    bpl cmpout02
    bmi cmpout01

cmp16
    ldy #0
    lda stackl,x
    cmp tos
    lda stackh,x
    sbc tos+1
    rts

;--------------------------------------------------------------
#if 0
name=>
stack=( n1 n2 -- flag )
tags=forth-83,nucleus

 V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
#endif
gt
    ldy #0
    lda tos
    cmp stackl,x
    lda tos+1
    sbc stackh,x
    jmp sgntst

;--------------------------------------------------------------
#if 0
name=BETWEEN?
stack=( x a b -- flag )
tags=nucleus

 returns true iff a < x < b, unsigned

#endif
betweenq
    inx
    jsr cmp16
    dex
;    ldy #0
;    lda stackl+1,x
;    cmp tos
;    lda stackh+1,x
;    sbc tos+1
    bcs betweenq01
    lda stackl,x
    cmp stackl+1,x
    lda stackh,x
    sbc stackh+1,x
    bcs betweenq01
    dey
betweenq01
    inx
    inx
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=ROT
stack=( a b c -- b c a )
tags=forth-83,nucleus


#endif
rot
    ldy stackh+1,x
    lda stackh,x
    sta stackh+1,x
    lda tos+1
    sta stackh,x
    sty tos+1
    ldy stackl+1,x
    lda stackl,x
    sta stackl+1,x
    lda tos
    sta stackl,x
    sty tos
    jmp next

;--------------------------------------------------------------
#if 0
name=THIRD
stack=( n1 n2 n3 -- n1 n2 n3 n1 )
tags=forth-83,nucleus


#endif
third
    lda stackl+1,x
    ldy stackh+1,x
    jmp pushya

;--------------------------------------------------------------
#if 0
name=3DUP
stack=( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )
tags=nucleus

 Copy top three elements on the stack onto top of stack.

#endif
threedup
    dex
    dex
    dex
    lda tos+1
    sta stackh+2,x
    lda tos
    sta stackl+2,x
    lda stackh+4,x
    sta stackh+1,x
    lda stackl+4,x
    sta stackl+1,x
    lda stackh+3,x
    sta stackh,x
    lda stackl+3,x
    sta stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=UNDER
stack=( n1 n2 -- n1 n1 n2 )
tags=nucleus

 Make a duplicate of the second stack element

#endif
under
    dex
    ldy stackh+1,x
    lda stackl+1,x
    sty stackh,x
    sta stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=+UNDER
stack=( n1 n2 n3 -- n1+n3 n2 )
tags=nucleus

 Add the top of stack to item underneath the second on stack

#endif
plusunder
    clc
    lda tos
    adc stackl+1,x
    sta stackl+1,x
    lda tos+1
    adc stackh+1,x
    sta stackh+1,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=?DUP
stack=( 0 -- 0 | n -- n n )
tags=forth-83,nucleus


 DUP if top of stack is nonzero
#endif
qdup
    lda tos
    ora tos+1
    beq qdup01
    lda tos
    ldy tos+1
    jmp pushya
qdup01
    jmp next

;--------------------------------------------------------------
#if 0
name=3C@
stack=( addr -- d )
tags=nucleus

 fetches three bytes as a double.  Useful for retrieving screen
 linewrap bits from the beginning of the block buffer or the jiffy
 clock

 msb addr+0

 2sb addr+1

 lsb addr+2

```
: 3c@   ( addr -- d )
     dup 1+ @ swap c@ ;

```
#endif
threecfetch
    jsr slip
    ldy #2
    lda (tos),y         ; msb
    sta stackl,x
    dey
    lda (tos),y
    sta stackh,x
                                ; fall through
;--------------------------------------------------------------
#if 0
name=C@
stack=( addr -- 8b )
tags=forth-79,nucleus,memory


!!! pronounced: "c-fetch"
 8b is the contents of the byte at addr.

#endif
cfetch
    ldy #0
    lda (tos),y
    jmp put

;--------------------------------------------------------------
#if 0
name=3C!
stack=( d addr -- )
tags=nucleus
 store low 3 bytes of d at addr in jiffy clock order

 msb addr

 2sb addr+1

 lsb addr+2

```
: 3c!    ( d addr -- )
    2dup c!  nip 1+ ! ;

```
#endif
threecstore
    ldy #0
    lda stackl,x                ; msb
    sta (tos),y
    iny
    lda stackh+1,x              ; 2sb
    sta (tos),y
    iny
    lda stackl+1,x              ; lsb
    sta (tos),y
    inx                         ; discard 3 cells
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=FILL
stack=( addr howmany value -- )
tags=forth-83,nucleus


 howmany has an upper limit of 32K bytes

#endif
fill
    ldy #2
    jsr locals      ; addr -> N0; howmany -> N1
    ;clc            ; C cleared by setup
    ;ldy #0
    lda tos
fill01
    dec n+3
    bpl fill02
    sec             ; fill a partial page then exit
    ldy n+2
    beq fill03      ; nothing to do?
fill02
    dey
    sta (n),y
    bne fill02
    inc n+1
    bcc fill01
fill03
    jmp pops

;--------------------------------------------------------------
#if 0
name=ERASE
stack=( addr howmany -- )
tags=nucleus

#endif
_erase
#include "enter.i65"
    .word zero
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLANK
stack=( addr howmany -- )
tags=nucleus

#endif
_blank
#include "enter.i65"
    .word bl
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-TRAILING
stack=( addr +n1 -- addr +n2 )
tags=nucleus

 The character count +n1 of a text string beginning at addr
 is adjusted to exclude trailing spaces.  If +n1 is zero,
 then +n2 is also zero.  If the entire string consists of
 spaces, then +n2 is zero.

": -trailing   ( addr n1 -- addr n2 )
     dup 0
     ?do
         2dup + 1- c@
         bl <>
     ?leave
         1-
     loop ;

#endif
dashtrailing
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1                     ; N0 = addr
   ldy tos
    lda tos+1
    beq dashtrailing01
    clc
    adc n+1
    sta n+1
dashtrailing01
    dey
    cpy #$ff
    bne dashtrailing02
    dec n+1
    lda tos+1
    beq dashtrailing03
    dec tos+1
dashtrailing02
    lda (n),y
    eor #' '
    beq dashtrailing01
dashtrailing03
    iny
    tya
    ldy tos+1
    jmp put

;--------------------------------------------------------------
#if 0
name=CMOVE
stack=( from to howmany -- )
tags=forth-83,nucleus,memory


"~ see http://6502.org/source/general/memory_move.html
#endif
cmove
    ldy #2          ; pull two items off the data stack
    jsr locals      ; howmany = TOS, from = N0, to = N1
    ;clc
    ;ldy #0         ; locals returns Y=0 C=0
    stx storex      ; stash the data stack pointer
    ldx #0          ; X,Y=0
cmove01
    dec tos+1
    bpl cmove02     ; do a whole page
    ldx tos         ; last page
    beq cmove03     ; none at all?
    sec             ; exit after this iteration
cmove02
    lda (n),y
    sta (n+2),y
    iny
    dex
    bne cmove02
    inc n+1
    inc n+3
    bcc cmove01
cmove03
    ldx storex      ; revive the data stack pointer
    jmp pops    ; [37]

;--------------------------------------------------------------
#if 0
name=CMOVE>
stack=( from to howmany -- )
tags=forth-83,nucleus,memory
 Move the u bytes beginning at address addr1 to
 addr2.  The move begins by moving the byte at
 (addr1 plus u minus 1) to (addr2 plus u minus 1)
 and proceeds to successively lower addresses
 for u bytes.  If u is zero nothing is moved.
 Useful for sliding a string towards higher addresses.

#endif
cmovegt
    ldy #2
    jsr locals
    stx storex
    ldx tos+1
    clc
    txa
    adc n+1
    sta n+1
    clc
    txa
    lda n+3
    sta n+3
    inx
    ldy tos
    beq cmovegt03
    dey
    beq cmovegt02
cmovegt01
    lda (n),y
    sta (n+2),y
    dey
    bne cmovegt01
cmovegt02
    lda (n),y
    sta (n+2),y
cmovegt03
    dey
    dec n+1
    dec n+3
    dex
    bne cmovegt01
    ldx storex
    jmp pops

;--------------------------------------------------------------
#if 0
name=MOVE
stack=( from to howmany -- )
tags=nucleus,memory
 Move the `howmany` bytes beginning at `from` to
 `to`.  Designed to prevent clobber if both memory regions
 overlap.

```
: move   ( from to howmany -- )
     >r 2dup u< r> swap
     if
         cmove>
     else
         cmove
     then ;

```
#endif
_move
#include "enter.i65"
    .word tor
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(move01-*+1)
#include "pad.i65"
    .word cmovegt
#include "page.i65"
    .word branch
    .byt <(move02-*+1)
#include "pad.i65"
move01
    .word cmove
#include "page.i65"
move02
    .word exit

;--------------------------------------------------------------
#if 0
name=+MOVE
stack=( start end delta -- )
tags=nucleus

 Move a block of memory between start and end (inclusive) to
 a new address calculated by adding the signed delta to start

```
 for example, x = (5 of each letter)     AAAAABBBBBCCCCCDDDDD
 after  x 8 + x 11 + -7 +move, x becomes ABBCCBBBBBCCCCCDDDDD
 vidram dup 3+ 3+ 12 +move

: +move   ( start end delta -- )
 ( start end delta )
     >r over - 1+
 ( start howmany )
     over r> + swap move ;

```
#endif
_plusmove
#include "enter.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word swap
#include "page.i65"
    .word _move
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=HERE
stack=( -- addr )
tags=nucleus

#endif
here
    lda uarea+userdp-userarea
    ldy uarea+userdp-userarea+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=PAD
stack=( -- addr )
tags=nucleus

 The lower address of a scratch area used to hold data for
 intermediate processing.  The address or contents of PAD may
 change and the data lost if the address of the next
 available dictionary location is changed.  The minimum
 capacity of PAD is 84 characters.

#endif
_pad
#include "enter.i65"
    .word here
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=S>D
stack=( n -- d )
tags=nucleus

#endif
_stod
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SGN
stack=( n -- -1|0|1 )
tags=nucleus

 return the sign of n

#endif
sgn
    ldy #$ff
    lda tos+1
    bmi sgn01       ; negative
    iny
    ora tos
    beq sgn01       ; zero
    lda #1          ; positive
    .byt $24        ; BIT zp to skip over tya
sgn01
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=RANDU
stack=( -- r )
tags=nucleus

 return a random number in the range 0..255
 from the [[First Book of KIM-1|http://users.telenet.be/kim1-6502/6502/fbok.html]]

#endif
randu
    stx storex
    sec
    lda rnd+1
    adc rnd+4
    adc rnd+5
    sta rnd
    ldx #4
rpl
    lda rnd,x
    sta rnd+1,x
    dex
    bpl rpl
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=1+!
stack=( n -- )
tags=nucleus

 increments the word addressed by n

#endif
oneplusstore
    ldy #$FF
    lda #0
    sec
oneplusstore01
    iny
    adc (tos),y
    sta (tos),y
    tya
    beq oneplusstore01
    jmp pops

;--------------------------------------------------------------
#if 0
name=1-!
stack=( n -- )
tags=nucleus

 decrements the word addressed by n

#endif
oneminusstore
    ldy #$ff
    clc
oneminusstore01
    iny
    lda (tos),y
    sbc #0
    sta (tos),y
    tya
    beq oneminusstore01
    jmp pops

;--------------------------------------------------------------
#if 0
name=MIN
stack=( n1 n2 -- n )
tags=forth-83,nucleus
Returns the lesser of the two arguments

```
: min   ( n1 n2 -- n )
    2dup >  ?: nip drop ;
```
#endif
_min
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word gt
#include "page.i65"
    .word pquerycolon
    .word nip
    .word drop
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MAX
stack=( n1 n2 -- n )
tags=forth-83,nucleus


#endif
_max
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(max01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
max01
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=M*
stack=( n1 n2 -- d )
tags=nucleus

 multiply two signed words, leaving the double product on the stack
#endif
mstar
    jsr mult
    jmp next
mult
    lda stackl,x
    sta n+4
    lda stackh,x
    sta n+5
    eor tos+1
    php                     ; we only care about the sign bit
    bit tos+1
    bpl mult01
    jsr donegate
mult01
    bit n+5
    bpl mult02
    sec
    lda #0
    sbc n+4
    sta n+4
    lda #0
    sbc n+5
    sta n+5
mult02
    jsr multiply
    lda n+1
    sta stackh,x
    lda n
    sta stackl,x
    lda n+3
    sta tos+1
    lda n+2
    sta tos
    plp
    bpl mult03
    jmp dodnegate
mult03
    rts

;--------------------------------------------------------------
#if 0
name=M/
stack=( d n -- rem quotient )
tags=nucleus

#endif
mslash
    jsr domslash
    jmp next
domslash
    cpx #$6f
    bcc domslash02
domslash01
    ldx #bos
    ;       sty stack,x
    ;       sty stack+1,x
    tya
    rts
domslash02
    ;      lda stack,x
    ;       ora stack+1,x
    beq domslash01
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    ;       lda stack+1,x
    ;       eor stack+3,x
    pha
    ;       lda stack+1,x
    pha
    bpl domslash03
    jsr donegate
domslash03
    ;       lda stack+3,x
    bpl domslash04
    inx
    inx
    jsr dnegate
    dex
    dex
domslash04
    jsr divmod
    pla
    bpl domslash05
    jsr remult
domslash05
    pla
    bpl domslash07
    jsr donegate
    ;       lda stack+2,x
    ;       ora stack+3,x
    beq domslash07
    ;       lda stack,x
    bne domslash06
    ;       dec stack+1,x
domslash06
    ;       dec stack,x
    jsr remult
    clc
    pla
    ;       adc stack+2,x
    ;       sta stack+2,x
    pla
    ;       adc stack+3,x
    ;       sta stack+3,x
    rts
domslash07
    pla
    pla
    rts
remult
    inx
    inx
    jsr donegate
    dex
    dex
    rts

;--------------------------------------------------------------
#if 0
name=M*/
stack=( n1 n2 n3 -- d )
tags=nucleus

 multiplies n1*n2 giving an intermediate 16-bit value, and divides
 that by n3 yielding a 16-bit quotient.  Remainder is ignored,
 all values are signed.

#endif
mstarslash

;--------------------------------------------------------------
#if 0
name=*
stack=( n1 n2 -- n1*n2 )
tags=forth-83,nucleus

 multiply two signed words
#endif
star
    jsr mult
    jmp pops

;--------------------------------------------------------------
#if 0
name=/MOD
stack=( n1 n2 -- n3 n4 )
tags=forth-83,nucleus,~wut?

 n3 is the remainder and n4 the floor of the
 quotient of n1 divided by the divisor n2.  n3
 has the same sign as n2 or is zero.  An error
 condition results if the divisor is zero or if
 the quotient falls outside the range {-32,768
 ... 32,676}.
todo: should probably use ud/mod and then set signs
todo: division/modulo/multiplication words are kind of a mess
#endif
slashmod
    jsr doslashmod
    jmp next
doslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    ;       lda stack+3,x
    bpl doslashmod01
    dey
doslashmod01
    ;       sty stack,x
    ;       sty stack+1,x
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
    ldy #0
    jmp domslash

;--------------------------------------------------------------
#if 0
name=/
stack=( n1 n2 -- n3 )
tags=forth-83,nucleus

 n3 is the floor of the quotient of n1 divided
 by the divisor n2.  An error condition results
 if the divisor is zero or if the quotient falls
 outside the range {-32,768 ... 32,767}.
#endif
slash
    jsr doslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=MOD
stack=( n1 n2 -- n3 )
tags=forth-83,nucleus

 n3 is the remainder after dividing n1 by the
 divisor n2.  n3 has the same sign as n2 or is
 zero.  An error condition results if the
 divisor is zero or if the quotient falls out-
 side the range {32,768...32,768}.

#endif
mod
    jsr doslashmod
    jmp pops

;--------------------------------------------------------------
#if 0
name=*/MOD
stack=( n1 n2 n3 -- n4 n5 )
tags=forth-83,nucleus

 n1 is first multiplied by n2 producing an inter-
 mediate 32 bit result.  n4 is the remainder and
 n5 is the floor of the quotient of the inter-
 mediate 32-bit result divided by the divisor
 n3.  A 32-bit intermediate product is used for
 */ .  n4 has the same sign as n3 or is zero.
 An error condition results if the divisor is
 zero or if the quotient falls outside of the
 range {-32,768...32,767}.

#endif
starslashmod
    jsr dostarslashmod
    jmp next
dostarslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    inx
    inx
    jsr mult
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
    jmp domslash

;--------------------------------------------------------------
#if 0
name=*/
stack=( n1 n2 n3 -- n4 )
tags=forth-83,nucleus

 n1 is first multiplied by n2 producing an inter-
 mediate 32-bit result.  n4 is the floor of the
 quotient of the intermediate 32-bit result
 divided by the divisor n3.  The product of n1
 times n2 is maintained as an intermediate 32-
 bit result for greater precision than the other-
 wise equivalent sequence n1 n2 * n3 / .  An
 error condition results if the divisor is zero
 or if the quotient falls outside the range
 {-32,768...32,767}.

#endif
starslash
    jsr dostarslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=M/MOD
stack=( d n1 -- n2 n3 )
tags=nucleus


 n2 is the remainder and n3 is the floor of the
 quotient after dividing d by the divisor n1.
 All values and arithmetic are unsigned.  An er-
 ror condition results if the divisor is zero or
 if the quotient lies outside the range
 {-32,768...32,767}.

#endif
mslashmod
    ldy #2
    jsr locals       ; udhi -> N0; udlo -> N1
    lda tos+1
    pha
    bpl mslashmod01
    jsr donegate
mslashmod01
    pla
    eor n+1         ; xor the sign bits
    sta n+7
    lda n+1
    sta n+6         ; original sign of divisor
    bpl mslashmod02
    jsr dnegaten    ; negate the double at n..n+3
mslashmod02
    jsr divmod
    sty n+1
    sta n           ; stash the quotient
    lda n+6
    bpl mslashmod03
    jsr donegate
mslashmod03
    lda n+7
    bpl mslashmod04
    jsr dnegaten
mslashmod04
    ldy n+1
    lda n
    jmp pushya

;--------------------------------------------------------------
#if 0
name=PICK
stack=( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
tags=forth-83,nucleus


 0 pick = same as dup
 1 pick = same as over
#endif
pick
    txa
    clc
    adc tos
    tay
    lda stackl,y
    sta tos
    lda stackh,y
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=ROLL
stack=( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
tags=forth-83,nucleus


 remove the nth stack element (excluding n itself) to TOS, dropping n

 2 roll = rot
 1 roll = swap
 0 roll has no effect

#endif
roll
    stx storex
    txa
    clc
    adc tos
    tax
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
roll01
    cpx storex
    beq roll02
    lda stackh-1,x
    sta stackh,x
    lda stackl-1,x
    sta stackl,x
    dex
    bne roll01
roll02
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=DEPTH
stack=( -- n )
tags=forth-83,nucleus
Returns the depth of the data stack
#endif
depth
    txa
    eor #$ff
    sec
    adc #<bos
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=>BIT
stack=( n -- mask offset )
tags=nucleus,ext
transform an integer into a bitmask and offset, suitable for
addressing a bloom filter or other bit field

mask = 2^(n%8)

offset = n/8

```
: >bit   ( n -- mask offset )
        dup 7 and power2 + c@
        swap 2/ 2/ 2/ ;
```
#endif
tobit
    dex
    lda tos
    and #7
    tay
    lda power2,y
    sta stackl,x
    lda #0
    sta stackh,x
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos             ; /8
    lda tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=$!
stack=( addr2 size addr2 -- )
tags=string,nucleus,ext

#endif
_dolstore
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ANYKEY
stack=( -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting
#endif
_anykey
#include "enter.i65"
    .word pdq
    .byt <(anykey01-*-1)
    .asc CR,"PRESS ANY KEY",CR
anykey01
#include "pad.i65"
    .word key
#include "page.i65"
    .word exit

; core-nucleus.a65
#echo .       core-nucleus.a65          Nucleus
;--------------------------------------------------------------
#if 0
name=UM*
stack=( u1 u2 -- ud )
tags=nucleus,math,forth-83
"ud" is the unsigned product of "u1" times "u2".  All values and
arithmetic are unsigned.

A proper 6502 assembler solution.

Features

* multiplies two 8-bit numbers with 16 bit result
* inner loop of only 17 clock cycles per iteration
* worst case behaviour of 40 clock cycles per iteration
* minimizes number of iterations
* total execution time 25 - 320 cycles

(i.e. only 3x slower (worst case) than MUL on Intel 8088)

* 43 bytes size
* relocatable to about anywhere in address space
* uses C64-friendly memory locations

 INPUT  = op1 in A, op2 in X

 OUTPUT = low byte in X, high byte in Y

 memory locations used as temp space = $fb, $fc, $fd

```
;You beat me to the punch, but there is some unnecessary code in there (you don't need to clear the carry before a LSR). And trashing X is unnecessary since you can test for zero just as fast with LDA $02. Or with some crazy jujitsu to save a byte...
;Here's my version, handles 8-bit operands:
;--$00 holds operand 1
;--$01 (low byte) and $02 (high byte) hold operand 2
;--$03 (low byte) and $04 (high byte) hold product
;       cld
;Loop
;    lsr $00
;    bcc NoAdd
;    clc
;    lda $03
;    adc $01
;    sta $03
;    lda $04
;    adc $02
;    sta $04
;    .byte $2C
;NoAdd
;    beq Done
;    asl $01
;    rol $02
;    bcc Loop        ;this assumes that operand 2 is 8-bit
;Done
;
;A proper 6502 assembler solution.
;
;Features
;- multiplies two 8-bit numbers with 16 bit result
;- inner loop of only 17 clock cycles per iteration
;- worst case behaviour of 40 clock cycles per iteration
;- minimizes number of iterations
;- total execution time 25 - 320 cycles
;(i.e. only 3x slower (worst case) than MUL on Intel 8088)
;- 43 bytes size
;- relocatable to about anywhere in address space
;- uses C64-friendly memory locations
; INPUT  = op1 in A, op2 in X
; OUTPUT = low byte in X, high byte in Y
; memory locations used as temp space = $fb, $fc, $fd
;    stx $fc    ; save op2
;    cmp $fc    ; compare both operands
;    bcc noswap ; swap them unless op1 < op2
;    sta $fc    ; save op1 instead of op2
;    txa        ; swap op2 for op1
;noswap
;    ldx #$00   ; prepare result low byte
;    stx $fd    ; clear high byte of op2
;    ldy #$00   ; prepare result high byte
;    beq begin  ; skip shift of op2 for first iteration
;loop
;    asl $fc    ; multiply op2 by 2, low byte
;    rol $fd    ; multiply op2 by 2, high byte
;begin
;    lsr        ; divide op1 by 2
;    bcs add    ; if op1 was odd before division, add op2
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;add
;    sta $fb    ; save current value of op1
;    clc        ; prepare addition
;    txa        ; fetch low byte
;    adc $fc    ; add op2, low byte
;    tax        ; store low byte
;    tya        ; fetch high byte
;    adc $fd    ; add op2, high byte
;    tay        ; store high byte
;    lda $fb    ; restore op1
;    bne loop   ; if op1 is not zero repeat loop
;    rts        ; otherwise return result
;

    stx $fc    ; save op2
    cmp $fc    ; compare both operands
    bcc noswap ; swap them unless op1 < op2
    sta $fc    ; save op1 instead of op2
    txa        ; swap op2 for op1
noswap
    ldx #$00   ; prepare result low byte
    stx $fd    ; clear high byte of op2
    ldy #$00   ; prepare result high byte
    beq begin  ; skip shift of op2 for first iteration
loop
    asl $fc    ; multiply op2 by 2, low byte
    rol $fd    ; multiply op2 by 2, high byte
begin
    lsr        ; divide op1 by 2
    bcs add    ; if op1 was odd before division, add op2
    bne loop   ; if op1 is not zero repeat loop
    rts        ; otherwise return result
add
    sta $fb    ; save current value of op1
    clc        ; prepare addition
    txa        ; fetch low byte
    adc $fc    ; add op2, low byte
    tax        ; store low byte
    tya        ; fetch high byte
    adc $fd    ; add op2, high byte
    tay        ; store high byte
    lda $fb    ; restore op1
    bne loop   ; if op1 is not zero repeat loop
    rts        ; otherwise return result

```
check http://6502.org/source/ for multiply and divide and stuff
#endif
umstar
    lda stackl,x
    sta n+4
    lda stackh,x            ;multiplicand in tos
    sta n+5                 ;multiplier in N2
    jsr multiply            ;16 bit unsigned multiply
    lda n
    sta stackl,x
    lda n+1
    sta stackh,x
    lda n+2
    ldy n+3
    jmp put

multiply
    lda #0                  ; unsigned multiply tos*N2 destroys tos
    sta n+2                 ;clear upper half of product
    sta n+3
    ldy #16
rshift
    lsr tos+1
    ror tos
    bcc rrot                ;Go rotate right if c = 0
    clc                     ; and add multiplicand to
    lda n+2                 ;Get upper half of product
    adc n+4                 ; it
    sta n+2
    lda n+3
    adc n+5
rrot
    ror                     ;shift partial product right
    sta n+3
    ror n+2
    ror n+1
    ror n
    dey                     ;Decrement bit count and
    bne rshift
    rts

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=40/MODY
stack=( u -- u%40 u/40 )
tags=math,test
[[Y - Mike's take 1|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
ylmod40
    jsr slip
    lda #0
    ldy #16
ylmod40b
    asl tos
    rol tos+1
    rol
    cmp #40
    bcc ylmod40c
    sbc #40
    inc tos
ylmod40c
    dey
    bne ylmod40b
    sta stackl,x
    sty stackh,x
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODZ
stack=( u -- u%40 u/40 )
tags=math,test
[[Z - Mike's take 2, slightly faster & smaller|http://forum.6502.org/viewtopic.php?f=2&t=3051#p36767]]

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
zlmod40
        jsr slip	; make room for the remainder
        lda #0
        ldy #16
zlmod40b
        cmp #20
        bcc zlmod40c
        sbc #20
zlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne zlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=40MOD
stack=( u -- u%40 )
tags=math,test
[[X - Bogax|http://forum.6502.org/viewtopic.php?f=2&t=3051&sid=bdc673ded3a873ad58c77e63ea92aeea&start=15#p37056]]

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
mod_40
    lda tos+1
    asl
    asl
    asl
    asl
    clc
    adc tos
    bcc mod40b
    adc #$0F
mod40b
    sta n
    lda tos+1
    and #$F0
    adc n
    bcc mod40c
    adc #$0F
mod40c
    sec
div_loop
    sbc #$28
    bcs div_loop
    adc #$28
    sta tos
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=%40B
stack=( u -- u%40 )
tags=math,test
[[V - Omegamatrix' enhancement|http://forum.6502.org/viewtopic.php?f=2&t=3051&sid=bdc673ded3a873ad58c77e63ea92aeea&start=15#p37116]]

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
mod_40b
    lda tos+1
    and #$f0
    sta n
    eor tos+1
    asl
    asl
    asl
    asl
    adc tos
    bcc skipAdd16A
    adc #$0f
skipAdd16A
    adc n
    bcc skipAdd16B
    adc #$0F
skipAdd16B
    sec
div_loopMod
    sbc #40
    bcs div_loopMod
    adc #40
    sta tos
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=40/MODW
stack=( u -- u%40 u/40 )
tags=math,test
W - uses JSR with N preloaded with the divisor, so the divisor could be
something other than 40 (e.g. BASE @), based on 
[[Y - Mike's take 1|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]

Perform a divide by 40 and a modulo 40, useful for screen positioning and 
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
wlmodn
    jsr slip
    lda #40
    sta n
    sta stackl,x
    sta stackh,x
    jsr wlmodna	; any way to skip the first 16 iterations, all 0s?
    sta stackl,x
    sty stackh,x
    jmp next

; unsigned 32/8 division for 40/mod and '#'
wlmodna
    ldy #32
    lda #0
wlmodnb
    asl stackl,x
    rol stackh,x
    rol tos
    rol tos+1
    rol
    cmp n
    bcc wlmodnc
    sbc n
    inc stackl,x
wlmodnc
    dey
    bne wlmodnb
    rts




;--------------------------------------------------------------
#if 0
name=UM/MODB
stack=( ud1 u2 -- u3 ud4 )
tags=numword
; - - - - - - - - - - - - - - - - - - - - - - - - - - -
; UM/MOD  ( ud u1 -- u2 u3 )
; Dividend ud is 32-bits unsigned.  Divisor u1,
; Remainder u2 and Quotient u3 are 16-bits unsigned
; Invalid inputs and/or outputs are silently ignored
; 1823 cycles (+ NEXT) best case (zero quotient)
; 2239 cycles (+ NEXT) worst case (zero divisor)
;
#endif
umdivmod
    jsr xudivmod   ; (do the dirty work)
    inx            ; NIP
    jmp swap       ; SWAP

;--------------------------------------------------------------
#if 0
name=UD/MODB
stack=( ud1 u2 -- u3 ud4 )
tags=numword

http://www.bradrodriguez.com/papers/camel09.txt
\   High level: numeric output                   (c) 31mar95 bjr
: UD/MOD      \ ud1 u2 -- u3 ud4     32/16->32 divide
    >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT ;

; - - - - - - - - - - - - - - - - - - - - - - - - - - -
; UD/MOD  ( ud1 u1 -- u2 ud2 )
; Dividend ud1 and Quotient ud2 are 32-bits unsigned
; Divisor u1 and Remainder u2 are 16-bits unsigned
; Invalid inputs and/or outputs are silently ignored
; 1856 cycles (+ NEXT) best case (zero quotient)
; 2272 cycles (+ NEXT) worst case (zero divisor)
;
#endif
uddivmod
    jsr xudivmod   ; (do the dirty work)
    jmp dashrot    ; -ROT

; - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Internal divmod routine used by UM/MOD and UD/MOD
; ( ud1 u1 -- ud2 u2 )
; ud1 is dividend, u1 is divisor
; ud2 is quotient, u2 is remainder
xudivmod
    ldy #32        ;[2] init loop counter
    lda #0         ;[2] init partial remainder
    sta n          ;[3]   in N-A (h-l)
xudm2
    asl stackl+1,x ;[6] dividend in NOS-3OS (h-l)
    rol stackh+1,x ;[6]   is gradually replaced
    rol stackl,x   ;[6]   with the quotient
    rol stackh,x   ;[6]
    rol            ;[2] N-A is gradually replaced
    rol n          ;[5]   with the remainder
    pha            ;[3]
    cmp tos        ;[3] TOS holds divisor
    lda n          ;[3] partial remainder >= TOS?
    sbc tos+1      ;[3]
    bcc xudm3      ;[3]*
    sta n          ;[3]   yes--update the partial
    pla            ;[4]     remainder and set the
    sbc tos        ;[3]     low bit in the partial
    inc stackl+1,x ;[6]     quotient
    .byt $c9       ;[2]*  cmp# naked opcode
xudm3
    pla            ;[4]*
    dey            ;[2] loop 32 times
    bne xudm2      ;[3]*
    sta tos        ;[3]
    ldy n          ;[3]
    sty tos+1      ;[3]
    rts            ;[6]



;--------------------------------------------------------------
#if 0
name=UD/MODC
stack=( ud1 u2 -- u3 ud4 )
tags=numword

[[Mike's take 2|http://forum.6502.org/viewtopic.php?f=9&t=1652&start=30#p36933]]
; - - - - - - - - - - - - - - - - - - - - - - - - - - -
; UD/MOD  ( ud1 u1 -- u2 ud2 )
; Dividend ud1 and Quotient ud2 are 32-bits unsigned
; Divisor u1 and Remainder u2 are 16-bits unsigned
; Invalid inputs and/or outputs are silently ignored
;
#endif
udsm
    ldy #32        ; init loop counter
    lda #0         ; init partial remainder
    sta n          ;   in N-A (h-l)
udsm2
    asl stackl+1,x ; dividend in NOS-3OS (h-l)
    rol stackh+1,x ;   is gradually replaced
    rol stackl,x   ;   with the quotient
    rol stackh,x
    rol            ; N-A is gradually replaced
    rol n          ;   with the remainder
    pha
    cmp tos        ; TOS holds the divisor
    lda n          ; partial remainder >= TOS?
    sbc tos+1
    bcc udsm3
    sta n          ;   yes--update the partial
    pla            ;     remainder and set the
    sbc tos        ;     low bit in the partial
    pha            ;     quotient
    inc stackl+1,x
udsm3
    pla
    dey
    bne udsm2      ; loop 32 times
    ldy n
    jmp pushya
    ;needs a -rot here




;--------------------------------------------------------------
#if 0
name=UD/MODD
stack=( ud1 u2 -- u3 ud4 )
tags=numword

[[Mike's take 3|http://forum.6502.org/viewtopic.php?f=9&t=1652&start=30#p36941]]
; - - - - - - - - - - - - - - - - - - - - - - - - - - -
; UD/MOD  ( ud1 u1 -- u2 ud2 )
; Dividend ud1 and Quotient ud2 are 32-bits unsigned
; Divisor u1 and Remainder u2 are 16-bits unsigned
; Invalid inputs and/or outputs are silently ignored
;
#endif
udsmd
    ldy #32        ; init loop counter
    lda #0         ; init partial remainder
    sta n          ;   in N-A (h-l)
udsmd2
    asl stackl+1,x ; dividend in NOS-3OS (h-l)
    rol stackh+1,x ;   is gradually replaced
    rol stackl,x   ;   with the quotient
    rol stackh,x
    rol            ; N-A is gradually replaced
    rol n          ;   with the remainder
    pha
    cmp tos        ; TOS holds the divisor
    lda n          ; partial remainder >= TOS?
    sbc tos+1
    bcc udsmd3
    sta n          ;   yes--update the partial
    pla            ;     remainder and set the
    sbc tos        ;     low bit in the partial
    inc stackl+1,x ;     quotient
    .byt $24       ;   BIT zp naked opcode
udsmd3
    pla
    dey
    bne udsmd2     ; loop 32 times
    ldy n
    jmp pushya
    ; needs stack -rot here







;--------------------------------------------------------------
#if 0
name=UD/MOD
stack=( ud1 u2 -- u3 ud4 )
tags=numword

http://www.bradrodriguez.com/papers/camel09.txt
\   High level: numeric output                   (c) 31mar95 bjr
: UD/MOD      \ ud1 u2 -- u3 ud4     32/16->32 divide
    >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT ;

#endif
udslashmod
        ldy #2
        jsr locals        ; dividend to n0..n3
        ;clc
        ;ldy #0           ; locals does this for us
        stx storex
        ldx #33
        tya
        beq udslashmodb   ; bra to initialization code
udslashmoda
        rol n+4           ; [5] I don't know what this 2-bytes is called
        rol n+5           ; [5] trial minuend or something like that
        sec               ; [2]
        lda n+4           ; [3]
        sbc tos           ; [3]
        tay               ; [2]
        lda n+5           ; [3]
        sbc tos+1         ; [3]
        bcc udslashmodc   ; save or abandon the trial subtraction
udslashmodb
        sty n+4           ; [2+3+3] or [3]?
        sta n+5           ; treating this as [~6] clocks on average
udslashmodc
        rol n+0           ; [5]
        rol n+1           ; [5]
        rol n+2           ; [5]
        rol n+3           ; [5]
        dex               ; [2]
        bne udslashmoda   ; [3] 
                ; [54] or [59] clocks for 33x main loop = [1839]
        ldx storex
; this is the end [22-bytes]
        ldy n+5
        sty tos+1
        lda n+4
        sta tos           ; put remainder on stack
        ldy n+1
        lda n+0
        jsr push6502      ; push quotient(lo) on stack
        ldy n+3
        lda n+2
        jmp pushya        ; push quotient(hi) on stack

; alternate ending [8-bytes]
;        brk
;        .byt ld | N2
;        .byt st | TOS
;        .byt ld | N0
;        .byt push
;        .byt ld | N1
;        .byt push
;        .byt nxt

;--------------------------------------------------------------
#if 0
name=UM/MOD
stack=( ud u -- rem quot )
tags=forth-83,nucleus
Perform an unsigned division of the 16-bit "u" into the double
"ud", leaving the 16-bit unsigned remainder and quotient on
the stack

      http://6502.org/source/integers/ummodfix/ummodfix.htm

!!! pronounced: "u-m slash mod"
#endif
umslashmod
    lda stackl,x
    cmp tos
    lda stackh,x
    sbc tos+1
    bcs umslashmodx
umslashmoda
    lda #17
    sta n       ; counter
umslashmodb
    rol stackl+1,x
    rol stackh+1,x
    dec n
    beq umslashmodz
    rol stackl,x
    rol stackh,x
    lda #$80
    rol
    sta n+1         ; carry
    ;sec
    lda stackl,x
    sbc tos
    sta n+2
    lda stackh,x
    sbc tos+1
    tay
    lda n+1
    sbc #0
    bcc umslashmodb

    lda n+2
    sta stackl,x
    sty stackh,x
    bcs umslashmodb
    
umslashmodx
    lda #$ff
    sta stackl,x
    sta stackh,x
    sta stackh+1,x
    sta stackl+1,x
umslashmodz
    jsr slide
    jmp swap

;--------------------------------------------------------------
#if 0
name=40/
stack=( u -- u/40 )
tags=nucleus,text
#endif
slash40
    lda #0
    sta n
    sta n+1
    sta n+2
    sta n+3

    jsr slash40c
    jsr slash40c
    jsr slash40c

    lda #5
    adc n+1
    lda #0
    adc n+2
    pha
    lda #0
    adc n+3
    tay
    pla

    jmp put

slash40c
    jsr slash40b
    jsr slash40b
    jsr slash40a
    jmp slash40a

slash40a
    lda tos
    adc n
    sta n
    lda tos+1
    adc n+1
    sta n+1
slash40b
    asl n
    rol n+1
    rol n+2
    rol n+3
    rts

;--------------------------------------------------------------
#if 0
name=33*
stack=( u -- u*$3333 )
tags=nucleus,test
#endif
times33
    stx storex
    lda tos             ; [3]  n..n+3 = u*$0003
    asl                 ; [2]  n+4..n+7 = u*$3333
    sta n+3             ; [3]
    lda tos+1           ; [3]
    rol                 ; [2]      ABCD*2
    sta n+2             ; [3]
    lda #0              ; [2]
    sta n+8             ; [3]
    rol                 ; [2]
    ;clc
    sta n+1             ; [3]
    lda n+3             ; [3]     +ABCD
    adc tos             ; [3]
    sta n+3             ; [3]
    lda n+2             ; [3]
    adc tos+1           ; [3]
    sta n+2             ; [3]
    bcc times33c        ; [3]     =ABCD*3
    inc n+1
    clc                         ; [44]
times33c
    lda n+3             ; [3]         3 AB CD
    sta n+7             ; [3]     +3 AB CD 00
    adc n+2             ; [3]     =ABCD*0303
    sta n+6             ; [3]
    lda n+2             ; [3]
    adc n+1             ; [3]
    sta n+5             ; [3]
    lda n+1             ; [3]
    adc #0              ; [2]
    sta n+4             ; [3]   ; [29] u*$0303
    ;clc
    
    ;   89abcdef
    ; + 90b0d0f0
    ldx #3              ; [2]
times33d
    lda n+4,x           ; [4]
    and #$0f            ; [2]
    tay                 ; [2]
    lda timeses,y       ; [4]
    adc n+4,x           ; [4]
    sta n,x             ; [4]
    dex                 ; [2]
    bpl times33d        ; [3]       ; [25]*4
    ;clc


    ;   89abcdef
    ;   +a0c0e00
    ldx #3              ; [2]
times33e
    php                 ; [3]
    lda n+5,x           ; [4]
    lsr                 ; [2]
    lsr                 ; [2]
    lsr                 ; [2]
    lsr                 ; [2]
    plp                 ; [4]
    adc n,x             ; [4]
    sta n,x             ; [4]
    dex                 ; [2]
    bpl times33e        ; [3]       [32]*4

    lsr tos+1
    ror tos

    lda tos+1
    lsr
    pha
    lda tos
    ror
    adc n+3
    pla
    bcc times33g
    adc n+2
    bcc times33g
    inc n+1
    bne times33g
    inc n
times33g
    lda n+1
    lsr n
    ror
    lsr n
    ror
    lsr n
    ror
    ldy n
    ldx storex
    jmp put
;3332cccd    
timeses
    .byt 0,$10,$20,$30,$40,$50,$60,$70,$80,$90,$a0,$b0,$c0,$d0,$e0,$f0

;--------------------------------------------------------------
#if 0
name=5/
stack=( u -- u*$3333 )
tags=nucleus,test
#endif
fiveslash
                        ; +4 +5 +6 +7
                        ;       AB CD
                        ;    0A
                        ;          D0 
                        ;       0C 
                        ;       B0
                        ;-------------
                        ;    00 00 00..
                        ;  ..10 FF EF       = * $11
                        ;                     *   3
                        ; 
    stx storex          ; [3]
    lda tos+1
    lsr
    lsr
    lsr
    lsr
    sta n+5

    lda tos+1
    and #$0f
    tax
    lda timeses,x
    sta n+6

    lda tos
    lsr
    lsr
    lsr
    lsr
    ora n+6
    tay

    lda tos
    and #$0f
    tax
    lda timeses,x
    clc
    adc tos
    sta n+7
    
    tya
    adc tos+1
    sta n+6
    bcc fivesla
    clc
    inc n+5
fivesla
                        ; * $11
    lda n+7
    asl
    php
    clc
    adc n+7
    sta n+7

    lda n+6
    rol
    bcc fiveslb
    inc n+5
fiveslb
    plp
    adc n+6
    sta n+6
    bcc fiveslc
    clc
    inc n+5
fiveslc
                        ; +4 +5 +6 +7
                        ;     x AB CD
                        ;  x AB CD
                        ;-------------

    lda n+7
    sta tos
    ;clc
    adc n+6
    sta tos+1
    lda n+6
    adc n+5
    pha
    lda n+5
    adc #0
    tay
    pla
    ldx storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=AND
stack=( n1 n2 -- n1&n2 )
tags=forth-83,nucleus,boolean
#endif
andx
    lda tos+1
    and stackh,x
    tay
    lda tos
    and stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=OR
stack=( n1 n2 -- n1|n2 )
tags=forth-83,nucleus,boolean
#endif
orx
    lda tos+1
    ora stackh,x
    tay
    lda tos
    ora stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=XOR
stack=( n1 n2 -- n1^n2 )
tags=forth-83,nucleus,boolean
#endif
xor
    lda tos+1
    eor stackh,x
    tay
    lda tos
    eor stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=NOT
stack=( n -- !n )
tags=forth-83,nucleus,boolean
#endif
not
    jsr invert
    jmp next

;--------------------------------------------------------------
#if 0
name=>R
stack=( n -- ) ( R; -- n )
tags=forth-83,nucleus,stack
Move the top element of the data stack to the return stack

!!! pronounced: "to-r"
#endif
tor
    lda tos+1
    pha
    lda tos
    pha
    jmp pops

;--------------------------------------------------------------
#if 0
name=R>
stack=( -- n ) ( R; n -- )
tags=forth-83,nucleus,stack
Remove the top value from the return stack and leave it on the
        computation stack. See >R and R@

!!! pronounced: "r-from"
#endif
rfrom
    pla
    sta storex
    pla
    tay
    lda storex
    jmp pushya

;--------------------------------------------------------------
#if 0
name=DUP>R
stack=( n -- n ) ( R; -- n )
tags=nucleus,stack
Copy the top of the data stack to the return stack

!!! pronounced: "dupe to-r"
#endif
duptor
    jsr slip
    jmp tor

;--------------------------------------------------------------
#if 0
name=RSWAP
stack=( -- ) ( R; a b -- b a )
tags=nucleus,stack
Swap the top two items on the return stack

!!! pronounced: "r-swap"
#endif
rswap
    pla ; [4]
    sta n ; [3]                   ; b-lo
    pla ; [4]
    sta n+1 ; [3]             ; b-hi
    pla ; [4]
    sta n+2 ; [3]             ; a-lo
    pla ; [4]
    tay ; [2]                     ; a-hi
    lda n+1 ; [3]
    pha ; [3]
    lda n ; [3]
    pha ; [3]
    tya ; [2]
    pha ; [3]
    lda n+2 ; [3]
    pha ; [3]
    jmp next ; [3] [53]
    
;--------------------------------------------------------------
#if 0
name=RDROP
stack=( -- ) ( R; a -- )
tags=nucleus,stack
Drop the top item on the return stack

!!! pronounced: "r-drop"
#endif
rdrop
    pla
    pla
    jmp next

;--------------------------------------------------------------
#if 0
name=0>
stack=( n -- flag )
tags=forth-83,nucleus,relational


#endif
zgt
    ldy #0
    lda tos+1
    bmi zgt01                   ; check the sign
    ora tos                     ; check for nonzero
    beq zgt01
    dey
zgt01
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=OFF
stack=( addr -- )
tags=nucleus,memory
Store 0 at "addr"
#endif
off
    lda #$00
    .byt $2c                    ; BIT xxxx falls through to ON
;--------------------------------------------------------------
#if 0
name=ON
stack=( addr -- )
tags=nucleus,memory
Store -1 at "addr"
#endif
on
    lda #$ff
on1
    ldy #0
    sta (tos),y
    iny
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
#if 0
name=+
stack=( n1 n2 -- sum )
tags=forth-83,nucleus,math,fig,forth-79
Leave the sum of n1+n2

!!! pronounced: "plus"
#endif
plus
    clc
    lda tos
    adc stackl,x
    sta tos
    lda tos+1
    adc stackh,x
    sta tos+1
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=ABS
stack=( n -- u )
tags=forth-83,nucleus,math,fig,forth-79
Leave the absolute value of n as u.
#endif
abs
    bit tos+1
    bpl negate01
;--------------------------------------------------------------
#if 0
name=NEGATE
stack=( n -- -n )
tags=forth-83,nucleus,math

#endif
negate
    jsr donegate
negate01
    jmp next
donegate
    sec
neg2
    lda #0
    sbc tos
    sta tos
    lda #0
    sbc tos+1
    sta tos+1
    rts

;--------------------------------------------------------------
#if 0
name=OVER
stack=( n1 n2 -- n1 n2 n1 )
tags=forth-83,nucleus,stack

#endif
over
    ldy stackh,x
    lda stackl,x
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SWAP
stack=( n1 n2 -- n2 n1 )
tags=forth-83,nucleus,stack,fig,forth-79
Exchange the top two values on the stack.
#endif
swap
    ldy tos+1
    lda stackh,x
    sta tos+1
    sty stackh,x
    ldy tos
    lda stackl,x
    sta tos
    sty stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=TUCK
stack=( n1 n2 -- n2 n1 n2 )
tags=forth-83,nucleus,stack
Insert the top item on the stack beneath the second.
#endif
tuck
    dex
    jsr tuckdashrot
    jmp next

tuckdashrot
    lda stackh+1,x
    sta stackh,x
    lda stackl+1,x
    sta stackl,x
    lda tos+1
    sta stackh+1,x
    lda tos
    sta stackl+1,x
    rts

;--------------------------------------------------------------
#if 0
name=-ROT
stack=( a b c -- c a b )
tags=nucleus,stack

#endif
dashrot
    ldy stackh,x
    lda stackl,x        ; b
    pha
    jsr tuckdashrot
    pla
    jmp put             ; b -> c

;--------------------------------------------------------------
#if 0
name=NIP
stack=( n1 n2 -- n2 )
tags=nucleus,stack
Remove the second item from the stack
#endif
nip
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=DUP
stack=( n -- n n )
tags=forth-83,nucleus,stack,forth-79,fig
Duplicate the value on the stack.

!!! pronounced: "dupe"
#endif
dup
    jsr slip
    jmp next

;--------------------------------------------------------------
#if 0
name=+!
stack=( n addr -- )
tags=forth-83,nucleus,fig,forth-79
Add "n" to the value at "addr"

!!! pronounced: "plus-store"
#endif
plusstore
    ldy #0
    clc
    lda stackl,x
    adc (tos),y
    sta (tos),y
    iny
    lda stackh,x
    adc (tos),y
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=TOGGLE
stack=( addr bitmask -- )
tags=nucleus,boolean,fig
Complement the contents of addr by the bit pattern b.
#endif
toggle
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1
    ldy #0
    lda (n),y
    eor tos
    sta (n),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=@
stack=( addr -- 16b )
tags=forth-79,nucleus,memory,fig,forth-83
Leave the 16 bit contents of address.

!!! pronounced:"fetch"
  16b is the value at addr.
#endif
fetch
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put

;--------------------------------------------------------------
#if 0
name=!
stack=( n addr -- )
tags=forth-83,nucleus,fig,memory

Store 16 bits of n at address.

!!! pronounced "store"
#endif
store
    ldy #0
    lda stackl,x
    sta (tos),y
    iny
    lda stackh,x
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=!+
stack=( addr n -- addr+2 )
tags=nucleus

 Stores n at addr, returns the following address

!!! pronounced: "store-plus"
#endif
_storeplus
#include "enter.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C!
stack=( 8b addr -- )
tags=forth-83,nucleus,memory
 The least-significant 8 bits of 16b are stored into the byte
 at addr.

!!! pronounced: "c-store"
#endif
cstore
    lda stackl,x
    ldy #0
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=C!+
stack=( addr c -- addr+1 )
tags=nucleus,memory,primitive
The least-significant 8 bits of c are stored into the byte
at addr, and addr is incremented by one

!!!pronounced: "c-store-plus"
#endif
cstoreplus
    lda tos
    pha
    jsr slide
    ldy #0
    pla
    sta (tos),y
    jsr inctos
    jmp next

;--------------------------------------------------------------
#if 0
name=C@+
stack=( addr -- addr+1 c )
tags=nucleus,memory,primitive
Fetches the byte at addr, increments addr

!!!pronounced: "c-fetch-plus"
#endif
cfetchplus
    ldy #0
    lda (tos),y
    jsr inctos
    jmp pushya

;--------------------------------------------------------------
#if 0
name=CBIT!
stack=( mask addr -- )
tags=nucleus,boolean,memory

 turn on the mask bits in the byte at address

!!! pronounced: "c-bit-store"
#endif
cbitstore
    ldy #0
    lda (tos),y
    ora stackl,x
    sta (tos),y
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=CBIT@
stack=( mask addr -- flag )
tags=nucleus

 test the mask bits in the byte at address

#endif
cbitfetch
    ldy #0
    lda (tos),y
    and stackl,x
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=TIB
stack=( -- addr )
tags=nucleus,const
The address of the text input buffer.  This buffer is used
to hold characters when the input stream is coming from the
current input device.  The minimum capacity of TIB is 80
characters.

!!!pronounced: "t-i-b"
#endif
tib
    jsr doconst
    .word BUF       ; $0200

;--------------------------------------------------------------
#if 0
name=-2
stack=( -- -2 )
tags=nucleus,const

#endif
minustwo
    jsr doconst
    .word -2

;--------------------------------------------------------------
#if 0
name=1
stack=( -- 1 )
tags=nucleus,const

#endif
one
    jsr docconst
    .byt 1

;--------------------------------------------------------------
#if 0
name=2
stack=( -- 2 )
tags=nucleus

#endif
two
    jsr docconst
    .byt 2

;--------------------------------------------------------------
#if 0
name=3
stack=( -- 3 )
tags=nucleus

#endif
three
    jsr docconst
    .byt 3

;--------------------------------------------------------------
#if 0
name=4
stack=( -- 4 )
tags=nucleus

#endif
four
    jsr docconst
    .byt 4

;--------------------------------------------------------------
#if 0
name=BL
stack=( -- n )
tags=nucleus,const

#endif
bl
    jsr docconst
    .byt $20

;--------------------------------------------------------------
#if 0
name=FORTY
stack=( -- 40 )
tags=nucleus,const

#endif
forty
    jsr docconst
    .byt 40

;--------------------------------------------------------------
#if 0
name=EIGHTY
stack=( -- 80 )
tags=nucleus,const

#endif
eighty
    jsr docconst
    .byt 80

;--------------------------------------------------------------
#if 0
name=-1
stack=( -- -1 )
tags=nucleus

#endif
minusone
                ; fall through to true
;--------------------------------------------------------------
#if 0
name=TRUE
stack=( -- -1 )
tags=nucleus

#endif
true
    lda #$ff
true01
    tay
    jmp pushya

;--------------------------------------------------------------
#if 0
name=0
stack=( -- 0 )
tags=nucleus

#endif
zero
                ; fall through to false
;--------------------------------------------------------------
#if 0
name=FALSE
stack=( -- 0 )
tags=nucleus

#endif
false
    lda #0
    beq true01

;--------------------------------------------------------------
#if 0
name=0=
stack=( n -- flag )
tags=forth-83,nucleus


#endif
zeq
    ldy #$00
    lda tos
    ora tos+1
    bne zeq02
zeq01
    dey
zeq02
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=0<
stack=( n -- flag )
tags=forth-83,nucleus


#endif
zlt
    ldy #0
    bit tos+1
    bmi zeq01
    bpl zeq02

;--------------------------------------------------------------
#if 0
name=0<>
stack=( n -- flag )
tags=nucleus

#endif
zne
    ldy #0
    lda tos
    ora tos+1
    bne zeq01
    beq zeq02

;--------------------------------------------------------------
#if 0
name=1+
stack=( n -- n+1 )
tags=forth-83,nucleus


#endif
oneplus
    jsr inctos
    jmp next

;--------------------------------------------------------------
#if 0
name=1-
stack=( n -- n-1 )
tags=forth-83,nucleus


#endif
oneminus
    jsr dectos
    jmp next

;--------------------------------------------------------------
#if 0
name=3-
stack=( n -- n-3 )
tags=nucleus

#endif
threeminus
    lda #$fd
    .byt $2c ; BIT absolute instruction, fall through to twominus
;--------------------------------------------------------------
#if 0
name=2-
stack=( n -- n-2 )
tags=nucleus

#endif
twominus
    lda #$fe
    dec tos+1
    .byt $2c ; BIT absolute instruction, fall through to twoplus
;--------------------------------------------------------------
#if 0
name=2+
stack=( n -- n+2 )
tags=nucleus,math,~wut?
Increment top of stack by 2

todo: code golf this together with slower tos2plus subroutine?
#endif
twoplus
    lda #2
nplus
    clc
    adc tos
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next
;--------------------------------------------------------------
#if 0
name=3+
stack=( n -- n+3 )
tags=nucleus

#endif
threeplus
    lda #3
    bne nplus                   ; bra

;--------------------------------------------------------------
#if 0
name=2/
stack=( n -- n/2 )
tags=forth-83,nucleus


#endif
twoslash
    lsr tos+1
    ror tos
    jmp next

;--------------------------------------------------------------
#if 0
name=2*
stack=( n -- n*2 )
tags=nucleus

#endif
twostar
    asl tos
    rol tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=-
stack=( a b -- a-b )
tags=forth-83,nucleus


#endif
minus
    jsr donegate
    jmp plus

;--------------------------------------------------------------
#if 0
name=<>
stack=( n1 n2 -- flag )
tags=nucleus,relational
Leave a true flag if "n1" does not equal "n2".
#endif
ne
    ldy #$ff                    ; assume inequality
    .byt $2c                    ; BIT abs instruction
;--------------------------------------------------------------
#if 0
name==
stack=( n1 n2 -- flag )
tags=forth-83,nucleus,relational
Leave a true flag if "n1" does is equal to "n2".
#endif
eq
    ldy #0
;ne entry point
    lda tos
    eor stackl,x
    bne cmpout02
    lda tos+1
    eor stackh,x
    bne cmpout02
cmpout01
    tya
    eor #$ff
    tay
cmpout02
    tya
    inx
    jmp put

;--------------------------------------------------------------
#if 0
name=U<
stack=( n1 n2 -- flag )
tags=forth-83,nucleus


#endif
ult
    jsr cmp16
    bcs cmpout02
    bcc cmpout01

;--------------------------------------------------------------
#if 0
name=<
stack=( n1 n2 -- flag )
tags=forth-83,nucleus


#endif
lt
    jsr cmp16
sgntst
    bvc lt01
    eor #bit7
lt01
    bpl cmpout02
    bmi cmpout01

cmp16
    ldy #0
    lda stackl,x
    cmp tos
    lda stackh,x
    sbc tos+1
    rts

;--------------------------------------------------------------
#if 0
name=>
stack=( n1 n2 -- flag )
tags=forth-83,nucleus

 V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
#endif
gt
    ldy #0
    lda tos
    cmp stackl,x
    lda tos+1
    sbc stackh,x
    jmp sgntst

;--------------------------------------------------------------
#if 0
name=BETWEEN?
stack=( x a b -- flag )
tags=nucleus

 returns true iff a < x < b, unsigned

#endif
betweenq
    inx
    jsr cmp16
    dex
;    ldy #0
;    lda stackl+1,x
;    cmp tos
;    lda stackh+1,x
;    sbc tos+1
    bcs betweenq01
    lda stackl,x
    cmp stackl+1,x
    lda stackh,x
    sbc stackh+1,x
    bcs betweenq01
    dey
betweenq01
    inx
    inx
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=ROT
stack=( a b c -- b c a )
tags=forth-83,nucleus


#endif
rot
    ldy stackh+1,x
    lda stackh,x
    sta stackh+1,x
    lda tos+1
    sta stackh,x
    sty tos+1
    ldy stackl+1,x
    lda stackl,x
    sta stackl+1,x
    lda tos
    sta stackl,x
    sty tos
    jmp next

;--------------------------------------------------------------
#if 0
name=THIRD
stack=( n1 n2 n3 -- n1 n2 n3 n1 )
tags=forth-83,nucleus


#endif
third
    lda stackl+1,x
    ldy stackh+1,x
    jmp pushya

;--------------------------------------------------------------
#if 0
name=3DUP
stack=( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )
tags=nucleus

 Copy top three elements on the stack onto top of stack.

#endif
threedup
    dex
    dex
    dex
    lda tos+1
    sta stackh+2,x
    lda tos
    sta stackl+2,x
    lda stackh+4,x
    sta stackh+1,x
    lda stackl+4,x
    sta stackl+1,x
    lda stackh+3,x
    sta stackh,x
    lda stackl+3,x
    sta stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=UNDER
stack=( n1 n2 -- n1 n1 n2 )
tags=nucleus

 Make a duplicate of the second stack element

#endif
under
    dex
    ldy stackh+1,x
    lda stackl+1,x
    sty stackh,x
    sta stackl,x
    jmp next

;--------------------------------------------------------------
#if 0
name=+UNDER
stack=( n1 n2 n3 -- n1+n3 n2 )
tags=nucleus

 Add the top of stack to item underneath the second on stack

#endif
plusunder
    clc
    lda tos
    adc stackl+1,x
    sta stackl+1,x
    lda tos+1
    adc stackh+1,x
    sta stackh+1,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=?DUP
stack=( 0 -- 0 | n -- n n )
tags=forth-83,nucleus


 DUP if top of stack is nonzero
#endif
qdup
    lda tos
    ora tos+1
    beq qdup01
    lda tos
    ldy tos+1
    jmp pushya
qdup01
    jmp next

;--------------------------------------------------------------
#if 0
name=3C@
stack=( addr -- d )
tags=nucleus

 fetches three bytes as a double.  Useful for retrieving screen
 linewrap bits from the beginning of the block buffer or the jiffy
 clock

 msb addr+0

 2sb addr+1

 lsb addr+2

```
: 3c@   ( addr -- d )
     dup 1+ @ swap c@ ;

```
#endif
threecfetch
    jsr slip
    ldy #2
    lda (tos),y         ; msb
    sta stackl,x
    dey
    lda (tos),y
    sta stackh,x
                                ; fall through
;--------------------------------------------------------------
#if 0
name=C@
stack=( addr -- 8b )
tags=forth-79,nucleus,memory


!!! pronounced: "c-fetch"
 8b is the contents of the byte at addr.

#endif
cfetch
    ldy #0
    lda (tos),y
    jmp put

;--------------------------------------------------------------
#if 0
name=3C!
stack=( d addr -- )
tags=nucleus
 store low 3 bytes of d at addr in jiffy clock order

 msb addr

 2sb addr+1

 lsb addr+2

```
: 3c!    ( d addr -- )
    2dup c!  nip 1+ ! ;

```
#endif
threecstore
    ldy #0
    lda stackl,x                ; msb
    sta (tos),y
    iny
    lda stackh+1,x              ; 2sb
    sta (tos),y
    iny
    lda stackl+1,x              ; lsb
    sta (tos),y
    inx                         ; discard 3 cells
    jmp poptwo

;--------------------------------------------------------------
#if 0
name=FILL
stack=( addr howmany value -- )
tags=forth-83,nucleus


 howmany has an upper limit of 32K bytes

#endif
fill
    ldy #2
    jsr locals      ; addr -> N0; howmany -> N1
    ;clc            ; C cleared by setup
    ;ldy #0
    lda tos
fill01
    dec n+3
    bpl fill02
    sec             ; fill a partial page then exit
    ldy n+2
    beq fill03      ; nothing to do?
fill02
    dey
    sta (n),y
    bne fill02
    inc n+1
    bcc fill01
fill03
    jmp pops

;--------------------------------------------------------------
#if 0
name=ERASE
stack=( addr howmany -- )
tags=nucleus

#endif
_erase
#include "enter.i65"
    .word zero
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLANK
stack=( addr howmany -- )
tags=nucleus

#endif
_blank
#include "enter.i65"
    .word bl
#include "page.i65"
    .word fill
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-TRAILING
stack=( addr +n1 -- addr +n2 )
tags=nucleus

 The character count +n1 of a text string beginning at addr
 is adjusted to exclude trailing spaces.  If +n1 is zero,
 then +n2 is also zero.  If the entire string consists of
 spaces, then +n2 is zero.

": -trailing   ( addr n1 -- addr n2 )
     dup 0
     ?do
         2dup + 1- c@
         bl <>
     ?leave
         1-
     loop ;

#endif
dashtrailing
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1                     ; N0 = addr
   ldy tos
    lda tos+1
    beq dashtrailing01
    clc
    adc n+1
    sta n+1
dashtrailing01
    dey
    cpy #$ff
    bne dashtrailing02
    dec n+1
    lda tos+1
    beq dashtrailing03
    dec tos+1
dashtrailing02
    lda (n),y
    eor #' '
    beq dashtrailing01
dashtrailing03
    iny
    tya
    ldy tos+1
    jmp put

;--------------------------------------------------------------
#if 0
name=CMOVE
stack=( from to howmany -- )
tags=forth-83,nucleus,memory


"~ see http://6502.org/source/general/memory_move.html
#endif
cmove
    ldy #2          ; pull two items off the data stack
    jsr locals      ; howmany = TOS, from = N0, to = N1
    ;clc
    ;ldy #0         ; locals returns Y=0 C=0
    stx storex      ; stash the data stack pointer
    ldx #0          ; X,Y=0
cmove01
    dec tos+1
    bpl cmove02     ; do a whole page
    ldx tos         ; last page
    beq cmove03     ; none at all?
    sec             ; exit after this iteration
cmove02
    lda (n),y
    sta (n+2),y
    iny
    dex
    bne cmove02
    inc n+1
    inc n+3
    bcc cmove01
cmove03
    ldx storex      ; revive the data stack pointer
    jmp pops    ; [37]

;--------------------------------------------------------------
#if 0
name=CMOVE>
stack=( from to howmany -- )
tags=forth-83,nucleus,memory
 Move the u bytes beginning at address addr1 to
 addr2.  The move begins by moving the byte at
 (addr1 plus u minus 1) to (addr2 plus u minus 1)
 and proceeds to successively lower addresses
 for u bytes.  If u is zero nothing is moved.
 Useful for sliding a string towards higher addresses.

#endif
cmovegt
    ldy #2
    jsr locals
    stx storex
    ldx tos+1
    clc
    txa
    adc n+1
    sta n+1
    clc
    txa
    adc n+3
    sta n+3
    inx
    ldy tos
    beq cmovegt03
    dey
    beq cmovegt02
cmovegt01
    lda (n),y
    sta (n+2),y
    dey
    bne cmovegt01
cmovegt02
    lda (n),y
    sta (n+2),y
cmovegt03
    dey
    dec n+1
    dec n+3
    dex
    bne cmovegt01
    ldx storex
    jmp pops

;--------------------------------------------------------------
#if 0
name=MOVE
stack=( from to howmany -- )
tags=nucleus,memory
 Move the `howmany` bytes beginning at `from` to
 `to`.  Designed to prevent clobber if both memory regions
 overlap.

```
: move   ( from to howmany -- )
     >r 2dup u< r> swap
     if
         cmove>
     else
         cmove
     then ;

```
#endif
_move
#include "enter.i65"
    .word tor
#include "page.i65"
    .word twodup
#include "page.i65"
    .word ult
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(move01-*+1)
#include "pad.i65"
    .word cmovegt
#include "page.i65"
    .word branch
    .byt <(move02-*+1)
#include "pad.i65"
move01
    .word cmove
#include "page.i65"
move02
    .word exit

;--------------------------------------------------------------
#if 0
name=+MOVE
stack=( start end delta -- )
tags=nucleus

 Move a block of memory between start and end (inclusive) to
 a new address calculated by adding the signed delta to start

```
 for example, x = (5 of each letter)     AAAAABBBBBCCCCCDDDDD
 after  x 8 + x 11 + -7 +move, x becomes ABBCCBBBBBCCCCCDDDDD
 vidram dup 3+ 3+ 12 +move

: +move   ( start end delta -- )
    ?dup
    if
        >r over - 1+
        over r> + swap move
    else
        2drop
    then ;
```
#endif
_plusmove
#include "enter.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(plusmove01-*+1)
#include "pad.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus               ; ( from howmany ) ( R; delta )
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word swap                  ; ( from to howmany )
#include "page.i65"
    .word _move
#include "page.i65"
    .word branch
    .byt <(plusmove02-*+1)
#include "pad.i65"
plusmove01
    .word twodrop
#include "page.i65"
plusmove02
    .word exit

;--------------------------------------------------------------
#if 0
name=HERE
stack=( -- addr )
tags=nucleus

#endif
here
    lda uarea+userdp-userarea
    ldy uarea+userdp-userarea+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=PAD
stack=( -- addr )
tags=nucleus

 The lower address of a scratch area used to hold data for
 intermediate processing.  The address or contents of PAD may
 change and the data lost if the address of the next
 available dictionary location is changed.  The minimum
 capacity of PAD is 84 characters.

#endif
_pad
#include "enter.i65"
    .word here
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=S>D
stack=( n -- d )
tags=nucleus

#endif
_stod
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SGN
stack=( n -- -1|0|1 )
tags=nucleus

 return the sign of n

#endif
sgn
    ldy #$ff
    lda tos+1
    bmi sgn01       ; negative
    iny
    ora tos
    beq sgn01       ; zero
    lda #1          ; positive
    .byt $24        ; BIT zp to skip over tya
sgn01
    tya
    jmp put

;--------------------------------------------------------------
#if 0
name=RANDU
stack=( -- r )
tags=nucleus

 return a random byte in the range 0..255
 from the [[First Book of KIM-1|http://users.telenet.be/kim1-6502/6502/fbok.html]]

#endif
randuc
    ldy #0
    beq randu2

;--------------------------------------------------------------
#if 0
name=RND
stack=( -- r )
tags=nucleus

 return a random number in the range 0..65535
 from the [[First Book of KIM-1|http://users.telenet.be/kim1-6502/6502/fbok.html]]

#endif
rnd
    jsr randu
    tay
randu2
    jsr randu
    jmp pushya

randu
    stx storex
    sec
    lda randbuff+1
    adc randbuff+4
    adc randbuff+5
    sta randbuff
    ldx #4
rpl
    lda randbuff,x
    sta randbuff+1,x
    dex
    bpl rpl
    ldx storex
    rts

;--------------------------------------------------------------
#if 0
name=RANDOM
stack=( -- a )
tags=nucleus

 Returns the address of the 6-byte random number buffer

#endif
random
    jsr docreate
randbuff
    .byt $08,$12,$b3,$16,$29,$62        ; random number seed

;--------------------------------------------------------------
#if 0
name=1+!
stack=( n -- )
tags=nucleus

 increments the word addressed by n

#endif
oneplusstore
    ldy #$FF
    lda #0
    sec
oneplusstore01
    iny
    adc (tos),y
    sta (tos),y
    tya
    beq oneplusstore01
    jmp pops

;--------------------------------------------------------------
#if 0
name=1-!
stack=( n -- )
tags=nucleus

 decrements the word addressed by n

#endif
oneminusstore
    ldy #$ff
    clc
oneminusstore01
    iny
    lda (tos),y
    sbc #0
    sta (tos),y
    tya
    beq oneminusstore01
    jmp pops

;--------------------------------------------------------------
#if 0
name=MIN
stack=( n1 n2 -- n )
tags=forth-83,nucleus
Returns the lesser of the two arguments

```
: min   ( n1 n2 -- n )
    2dup >  ?: nip drop ;
```
#endif
_min
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word gt
#include "page.i65"
    .word pquerycolon
    .word nip
    .word drop
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MAX
stack=( n1 n2 -- n )
tags=forth-83,nucleus


#endif
_max
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(max01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
max01
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=M*
stack=( n1 n2 -- d )
tags=nucleus

 multiply two signed words, leaving the double product on the stack
#endif
mstar
    jsr mult
    jmp next
mult
    lda stackl,x
    sta n+4
    lda stackh,x
    sta n+5
    eor tos+1
    php                     ; we only care about the sign bit
    bit tos+1
    bpl mult01
    jsr donegate
mult01
    bit n+5
    bpl mult02
    sec
    lda #0
    sbc n+4
    sta n+4
    lda #0
    sbc n+5
    sta n+5
mult02
    jsr multiply
    lda n+1
    sta stackh,x
    lda n
    sta stackl,x
    lda n+3
    sta tos+1
    lda n+2
    sta tos
    plp
    bpl mult03
    jmp dodnegate
mult03
    rts

;--------------------------------------------------------------
#if 0
name=M*/
stack=( n1 n2 n3 -- d )
tags=nucleus

 multiplies n1*n2 giving an intermediate 16-bit value, and divides
 that by n3 yielding a 16-bit quotient.  Remainder is ignored,
 all values are signed.

#endif
mstarslash

;--------------------------------------------------------------
#if 0
name=*
stack=( n1 n2 -- n1*n2 )
tags=forth-83,nucleus

 multiply two signed words
#endif
star
    jsr mult
    jmp pops

;--------------------------------------------------------------
#if 0
name=/MOD
stack=( n1 n2 -- n3 n4 )
tags=forth-83,nucleus,~wut?

 n3 is the remainder and n4 the floor of the
 quotient of n1 divided by the divisor n2.  n3
 has the same sign as n2 or is zero.  An error
 condition results if the divisor is zero or if
 the quotient falls outside the range {-32,768
 ... 32,676}.
todo: should probably use ud/mod and then set signs
todo: division/modulo/multiplication words are kind of a mess
#endif
slashmod
    jsr doslashmod
    jmp next
doslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    ;       lda stack+3,x
    bpl doslashmod01
    dey
doslashmod01
    ;       sty stack,x
    ;       sty stack+1,x
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
    ldy #0
;    jmp domslash

;--------------------------------------------------------------
#if 0
name=/
stack=( n1 n2 -- n3 )
tags=forth-83,nucleus

 n3 is the floor of the quotient of n1 divided
 by the divisor n2.  An error condition results
 if the divisor is zero or if the quotient falls
 outside the range {-32,768 ... 32,767}.
#endif
slash
    jsr doslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=MOD
stack=( n1 n2 -- n3 )
tags=forth-83,nucleus

 n3 is the remainder after dividing n1 by the
 divisor n2.  n3 has the same sign as n2 or is
 zero.  An error condition results if the
 divisor is zero or if the quotient falls out-
 side the range {32,768...32,768}.

#endif
mod
    jsr doslashmod
    jmp pops

;--------------------------------------------------------------
#if 0
name=*/MOD
stack=( n1 n2 n3 -- n4 n5 )
tags=forth-83,nucleus

 n1 is first multiplied by n2 producing an inter-
 mediate 32 bit result.  n4 is the remainder and
 n5 is the floor of the quotient of the inter-
 mediate 32-bit result divided by the divisor
 n3.  A 32-bit intermediate product is used for
 */ .  n4 has the same sign as n3 or is zero.
 An error condition results if the divisor is
 zero or if the quotient falls outside of the
 range {-32,768...32,767}.

#endif
starslashmod
    jsr dostarslashmod
    jmp next
dostarslashmod
    ;       lda stack+1,x
    pha
    ;       lda stack,x
    pha
    inx
    inx
    jsr mult
    dex
    dex
    pla
    ;       sta stack,x
    pla
    ;       sta stack+1,x
;    jmp domslash

;--------------------------------------------------------------
#if 0
name=*/
stack=( n1 n2 n3 -- n4 )
tags=forth-83,nucleus

 n1 is first multiplied by n2 producing an inter-
 mediate 32-bit result.  n4 is the floor of the
 quotient of the intermediate 32-bit result
 divided by the divisor n3.  The product of n1
 times n2 is maintained as an intermediate 32-
 bit result for greater precision than the other-
 wise equivalent sequence n1 n2 * n3 / .  An
 error condition results if the divisor is zero
 or if the quotient falls outside the range
 {-32,768...32,767}.

#endif
starslash
    jsr dostarslashmod
    ;       lda stack,x
    ;       sta stack+2,x
    ;       lda stack+1,x
    ;       sta stack+3,x
    jmp pops

;--------------------------------------------------------------
#if 0
name=PICK
stack=( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
tags=forth-83,nucleus


 0 pick = same as dup
 1 pick = same as over
#endif
pick
    txa
    clc
    adc tos
    tay
    lda stackh,y
    sta tos+1
    lda stackl,y
    sta tos
    jmp next

;--------------------------------------------------------------
#if 0
name=ROLL
stack=( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
tags=forth-83,nucleus


 remove the nth stack element (excluding n itself) to TOS, dropping n

 2 roll = rot
 1 roll = swap
 0 roll has no effect

#endif
roll
    stx storex
    txa
    clc
    adc tos
    tax
    lda stackh,x
    sta tos+1
    lda stackl,x
    sta tos
roll01
    cpx storex
    beq roll02
    lda stackh-1,x
    sta stackh,x
    lda stackl-1,x
    sta stackl,x
    dex
    bne roll01
roll02
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=DEPTH
stack=( -- n )
tags=forth-83,nucleus
Returns the depth of the data stack
#endif
depth
    txa
    eor #$ff
    sec
    adc #<bos
    ldy #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=>BIT
stack=( n -- mask offset )
tags=nucleus,ext
transform an integer into a bitmask and offset, suitable for
addressing a bloom filter or other bit field

mask = 2^(n%8)

offset = n/8

```
: >bit   ( n -- mask offset )
        dup 7 and power2 + c@
        swap 2/ 2/ 2/ ;
```
#endif
tobit
    dex
    lda tos
    and #7
    tay
    lda power2,y
    sta stackl,x
    lda #0
    sta stackh,x
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos
    lsr tos+1
    ror tos             ; /8
    jmp next

;--------------------------------------------------------------
#if 0
name=$!
stack=( addr2 size addr2 -- )
tags=string,nucleus,ext

#endif
_dolstore
#include "enter.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ANYKEY
stack=( -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting
#endif
_anykey
#include "enter.i65"
    .word pdq
    .byt <(anykey01-*-1)
    .asc CR,"PRESS ANY KEY",CR
anykey01
#include "pad.i65"
    .word key
#include "page.i65"
    .word exit

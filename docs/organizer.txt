2017-04-15T01:55:30-04:00
first pomodoro: set up dual environment
step through _word in working/broken environments




."
"
/mod
/
*/mod
-->
\


[ ] find relevant places where strings are moved
[x]		locate where _pword and _word are referenced
[x] 	locate where cmove and _move are referenced
[ ] 	locate (),y addressing
[ ] isolate parsing logic


words to look at:
$>pad
(create)
symcopy16


compiling
" add it to dictionary (")
." add it to dictionary (.")
interpreting
" copy it to pad
." display it

<<<<<<< HEAD

2017-05-02
=======
<<<<<<< Updated upstream
<<<<<<< Updated upstream
2017-05-02 
=======
2017-05-02
>>>>>>> Stashed changes
>>>>>>> f10e7bcb2a9257d3409ef820a85ee4e2d0069d50

0 load ( nope )

1 load ( ok )

( 1 test screen )
: foo   7 88 - . ;
3 load
2 load
foo baz
bletch

( 2 test screen )
: baz   7 88 + . ;

( 3 test screen )
: bletch   65 2 - . ;

1 load bletch baz baz foo  -81 95 63 63 95 95 -81  ok




BLK
>IN


: LOAD
\ check the block number to ensure 0 < `screen` < `#blk`+1
dup 0 #blk @ 1+ between?  if
?dup 0= ?exit blk# @ over < ?exit

\ push current i/o context to return stack
blk 2@ 2>r

\ retrieve the block and unpack it to BLKBUF
block

\ reset screen to top left corner
>in off

\ invoke INTERPRET
interpret

\ restore previous pointers to keyboard or other screen
2r> blk 2!

then ;


: STREAM!
* set 'STREAM vector based on BLK being 0 or non-zero


: 'STREAM
* a vector to point to 'STREAM.TIB or 'STREAM.SCR

: (WORD)

: WORD

: INTERPRET

*

: LOAD   ( screen -- )





in the midst of parsing a WORD , >in must be within the range 0..79
 (because it's a PET) but certainly within the range 0.255

Outside the boundaries of WORD, >IN contains #LIN in the high byte and >IN
in the low byte, so only four return stack bytes are required. This way,
2@ 2>r 2r> 2! may be used for economy.

Whenever block is nonzero
	if we're in WORD , >IN is the offset from 	CAS2BUF (position on the
	line) and #LIN tracks the physical line on the screen 0..24

	when leaving WORD , >IN 's high order byte becomes the line number
	0..24 in #LIN

When entering WORD , if

BLOCK is invoked to load blocks initially
BLOCK is invoked to reload blocks when returning from LOAD.  The 2r> blk 2! will also include #LIN information as the high byte of >IN


Whenever


initially, >IN is 0 (because LOAD)

'STREAM.SCR will see a 0 in #LIN and invoke BLOCK to reload BLKBUF
'STREAM.TIB will echo ' OK' when each line is exhausted, unless COMPILING?


<<<<<<< HEAD

=======
<<<<<<< Updated upstream
=======
>>>>>>> f10e7bcb2a9257d3409ef820a85ee4e2d0069d50
?REFILL
	\ block?  when BLK <> 0 and >IN == 0
	\ line?  when >IN == 0


SKIP

SCAN

: WORD   ( char -- $ )

: INTERPRET   ( -- )
;

: LOAD   ( blk -- )
;
<<<<<<< HEAD

=======
>>>>>>> Stashed changes
=======
: source.scr
begin
  refill?
while
  refill
repeat
cas2buf #lin @ ;

: source.tib
begin
  refill?
while
  refill
repeat
tib span @ ;


write these words as two regular forth, duplicate code, then refactor
shared
  blk
  >in


scr
  #lin
>in 0= if
blk @ block #lin off then

tib
  span
  tib
\ is the keyboard buffer empty?
>in @ 0= if
80 expect span ! then




load
interpret
word
	scr?




	tib?
		\ tib and other CHRIN-based input should also
		\ work with other devices, e.g. serial files


		buffer empty? ( >in @ 0= if )
		get a new line from keyboard ( 80 expect )
		( then )










2017-04-15T01:55:30-04:00
first pomodoro: set up dual environment
step through _word in working/broken environments




."
"
/mod
/
*/mod
-->
\


[ ] find relevant places where strings are moved
[x]   locate where _pword and _word are referenced
[x]   locate where cmove and _move are referenced
[ ]   locate (),y addressing
[ ] isolate parsing logic


words to look at:
$>pad
(create)
symcopy16


compiling
" add it to dictionary (")
." add it to dictionary (.")
interpreting
" copy it to pad
." display it

2017-05-02

0 load ( nope )

1 load ( ok )

( 1 test screen )
: foo   7 88 - . ;
3 load
2 load
foo baz
bletch

( 2 test screen )
: baz   7 88 + . ;

( 3 test screen )
: bletch   65 2 - . ;

1 load bletch baz baz foo  -81 95 63 63 95 95 -81  ok





blk >in


load interpret word 'stream skip scan? refill expect 

: LOAD
\ check the block number to ensure 0 < `screen` < `#blk`+1
dup 0 #blk @ 1+ between?  if
?dup 0= ?exit blk# @ over < ?exit

\ push current i/o context to return stack
blk 2@ 2>r

\ retrieve the block and unpack it to BLKBUF
block

\ reset screen to top left corner
>in off

\ invoke INTERPRET
interpret

\ restore previous pointers to keyboard or other screen
2r> blk 2!

then ;


: STREAM!
* set 'STREAM vector based on BLK being 0 or non-zero


: 'STREAM
* a vector to point to 'STREAM.TIB or 'STREAM.SCR

: (WORD)

: WORD

: INTERPRET

*

: LOAD   ( screen -- )





in the midst of parsing a WORD , >in must be within the range 0..79
 (because it's a PET) but certainly within the range 0.255

Outside the boundaries of WORD, >IN contains #LIN in the high byte and >IN
in the low byte, so only four return stack bytes are required. This way,
2@ 2>r 2r> 2! may be used for economy.

Whenever block is nonzero
  if we're in WORD , >IN is the offset from   CAS2BUF (position on the
  line) and #LIN tracks the physical line on the screen 0..24

  when leaving WORD , >IN 's high order byte becomes the line number
  0..24 in #LIN

When entering WORD , if

BLOCK is invoked to load blocks initially
BLOCK is invoked to reload blocks when returning from LOAD.  The 2r> blk 2! will also include #LIN information as the high byte of >IN


Whenever


initially, >IN is 0 (because LOAD)

'STREAM.SCR will see a 0 in #LIN and invoke BLOCK to reload BLKBUF
'STREAM.TIB will echo ' OK' when each line is exhausted, unless COMPILING?


: source.scr
begin
  refill?
while
  refill
repeat
cas2buf #lin @ ;

: source.tib
begin
  refill?
while
  refill
repeat
tib span @ ;


write these words as two regular forth, duplicate code, then refactor
shared
  blk
  >in


scr
  #lin

\ need a new line?
>in @ 0= if
  \ need a new screen?
  #lin 0= if
    blk @ block
  then
then

tib
  span
  tib
\ is the keyboard buffer empty?
>in @ 0= if
80 expect span ! then
: WORD   ( char -- )
  'stream
;



: INTERPRET   ( -- )
  begin
    ?stack  bl word   ( addr )
    dup c@
  while
    \ figure out if it's a word or number, compile or execute it
    find ?dup
    if        ( cfa findflag )
        \               find -1    find +1
        \             ____________________
        \ state -1   | compile     execute
        \ state 0    | execute     execute
        compiling? <>  ?: execute ,xt
    else      ( here )
        number
        jumptable  dpl @ 0< 2*  compiling? + 2* -
        @ execute
    then
  repeat
;
jumptable
    .word next
    .word _dlit
    .word drop
    .word _droplit

: LOAD   ( blk -- )
  \ stash blk & >in on return stack
  blk 2@ 2>r
  \ set >in = 0/0 to force a block fetch in word
    blk ! >in off interpret
  \ restore >in & blk from return stack
  2r> blk 2!
;


refill.scr
>>>>>>> f10e7bcb2a9257d3409ef820a85ee4e2d0069d50

: blk+   ( -- packet )
        vmbuf @ 14 2dup 2dup -      ( vmbuf 14 vmbuf 14 vmbuf-14 )
        tuck vmbuf !  erase  ! ;    ( vmbuf )

: block   ( n -- addr )
                            ( n )
dup vmsiz @
                            ( n n vmsiz )
<
                            ( n flag )
if                          ( block exists, get the packet addr )
                            ( n )
    blk@
                            ( packet )
else                        ( block does not exist, create it )
                            ( n )
    0 swap 1+ vmsiz @
                            ( 0 n+1 vmsiz )
    do
                            ( 0 )
        drop
                            ( )
        blk+
                            ( packet )
    loop
                            ( packet )
then ;


: blk@   ( n -- packet )
    blkbuf 2-
                            ( n packet0 )
    begin
        over 0>
                            ( n packet flag )
    while
                            ( n packet )
        dup @
                            ( n packet size )
        -
                            ( n packet' )
        swap 1- swap
                            ( n-1 packet' )
    repeat
    swap drop ;

: scr@   ( scr -- )
    dup scr ! (block)
                            ( blkbuf flag )
    scrwrite? !
                            ( blkbuf )
    b/buf over scr?
                            ( blkbuf 1024 flag )
    if
        over 3c@ wrap!
        3 - swap 3 + swap   ( blkbuf+3 1021 )
    then
    vidram swap cmove ;

: scr@   ( scr -- )
    dup scr ! (block)
    scrwrite? !
    b/buf over scr?
    if
        over 3c@ wrap!
        3 - swap 3 + swap
    then
    vidram swap cmove ;

: scr@   ( scr -- )
    dup scr ! (block)
    dup scrwrite? !
    if
        scrwrite? on
        CLR emit
    else
        b/buf over scr?
        dup scrwrite? !
        if
            over 3c@ wrap!
            3 - swap 3 + swap
        then
        vidram swap cmove ;
    then ;


;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; store the current screen in the block buffer.
;
: scr!   ( scr -- )
    25 wrapabove
                                    ( scr d )
    blkbuf dup 3 + >r 3c!
                                    ( scr ) ( R; blkbuf+3 )
    vidram r> 1000 rlencode
                                    ( scr targend )
    blkbuf - >r
                                    ( scr ) ( R; size )
    blk@                        
                                    ( packet ) ( R; size )
    vmbuf dup r@ - r@
                                    ( packet vmbuf vmbuf-size size )
    cmove>
                                    ( packet )
    r@ - blkbuf swap r>
                                    ( blkbuf packet-size size )
    cmove ;
    

    dup scr ! (block)
    dup scrwrite? !
    if
        CLR emit
        drop
    else
        b/buf over scr?
        if
            scrwrite? on
            over 3c@ wrap!
            3 - swap 3 + swap
        then
        vidram swap cmove ;
    then ;
;
;scrstorelfa
;    .byt $de,$ad
;    .byt (_scrstore-*-1)|bit7
;    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit



: scrdel   ( scr -- packet )
                                    ( scr )
    blk@
                                    ( packet )
    dup @ 
                                    ( packet size )
    vmbuf 2dup +
                                    ( packet size vmbuf vmbuf+size )
    dup
                                    ( packet size vmbuf vmbuf+size vmbuf+size )
    vmbuf ! rot
                                    ( packet vmbuf vmbuf+size size  )
    cmove
                                    ( packet )
    vmsiz 1-! ;
                                    ( packet )


;                                     ( scr d )
;     blkbuf dup 3 + >r 3c!



put linewrap in the first 3 bytes of blkbuf
rlencode vidram...vidram+1000 into blkbuf+3
get target size
find target address
insert size bytes


: scrins   ( scr -- )
    25 wrapabove
                                ( scr d )
    blkbuf dup dup 3 + >r 3c!
                                ( scr blkbuf ) ( R; blkbuf+3 )
    vidram @ r> 1000 rlencode
                                ( scr blkbuf targend )
    swap - >r
                                ( scr ) ( R; size )
    blk@                        
                                ( packet ) ( R; size )
    vmbuf dup r@ - r@
                                ( packet vmbuf vmbuf-size size ) ( R; size )
    cmove>
                                ( packet ) ( R; size )
    r@ over !
                                ( packet ) ( R; size )
    r@ - 2+ blkbuf swap r>
                                ( blkbuf packet-size+2 size )
    cmove 
                                ( )
    vmsiz 1+! ;

;": scrins   ( scr -- )
;     25 wrapabove
;     blkbuf dup dup 3 + >r 3c!
;     vidram @ r> 1000 rlencode
;     swap - >r
;     blk@                        
;     vmbuf dup r@ - r@
;     cmove>
;     r@ over !
;     r@ - 2+ blkbuf swap r>
;     cmove 
;     vmsiz 1+! ;
;
; insert the current screen into the packet buffer.
: scrins   ( scr -- )
    25 wrapabove
                                ( scr d )
    blkbuf dup dup 3 + swap >r >r 3c!
                                ( scr ) ( R; blkbuf blkbuf+3 )
    vidram r> 1000 rlencode
                                ( scr targend ) ( R; blkbuf )
    r> - >r
                                ( scr ) ( R; size )
    blk@                        
                                ( packet ) ( R; size )
    vmbuf dup r@ - r@
                                ( 
    cmove>
                                ( 
    r@ over !
                                ( 
    r@ - 2+ blkbuf swap r>
                                ( 
    cmove 
                                ( 
    vmsiz 1+! ;
                                ( 






; move virtual memory between the bottom of the buffer (vmbuf @) 
; and the bottom of the packet being replaced
; e.g. if we're changing a 100 byte packet into a 300 byte packet,
; all the packets below it in memory will have to move down 200 bytes
; conversely, if we're changing a 300 byte packet into a 10 byte
; packet, all packets below it have to move upward 290 bytes
; The packet is presumed to exist
;
: mvvm   ( blk# newsize -- )

vmbuf vmbuf+oldsize-newsize packet-oldsize+2-vmbuf cmove



swap (block) 0=
                                ( newsize packet packet-exists? )
if                              ( block exists )
                                ( newsize packet )
    >r r@ @ >r
                                ( newsize ) ( R; packet oldsize )
    r@ swap -
                                ( oldsize-newsize ) ( R; packet oldsize )
    r> r>
                                ( oldsize-newsize oldsize packet )
    swap - 2+
                                ( oldsize-newsize packet-oldsize+2 )
    vmbuf @ >r r@ -
                                ( oldsize-newsize packet-oldsize+2-vmbuf ) ( R; vmbuf )
    swap r@ + swap
                                ( vmbuf+oldsize-newsize packet-oldsize+2-vmbuf ) ( R; vmbuf )
    r> -rot 
                                ( vmbuf vmbuf+oldsize-newsize packet-oldsize+2-vmbuf )
    cmove

else
    8 fail                      ( block out of range ) 
then ;

6000  6000+300-10 




;--------------------------------------------------------------
;
;       BLETCH ( -- )
;
;
;
;
bletchlfa
    .byt $de,$ad
    .byt (bletch-*-1)|bit7
    .asc "BLETC","H"|bit7
bletch
#include "enter.i65"
    .word plit
    .word 64000
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
bletch01
    .word i
#include "page.i65"
    .word zero
#include "page.i65"
    .word clit
    .byt 40
#include "pad.i65"
    .word _umslashmod
#include "page.i65"
    .word _udot
#include "page.i65"
    .word _udot
#include "page.i65"
    .word cr
#include "page.i65"
    .word ploop
    .byt <(bletch01-*+1)
#include "pad.i65"
    .word exit

r50special      .byt ',','-','?'

;--------------------------------------------------------------
;
;       R50CHAR   ( d -- d2 c )
;
; Unpack and translate a single character in radix-50
;
;r50charlfa
;    .byt $de,$ad
;    .byt (r50char-*-1)|bit7
;    .asc "RAD5","0"|bit7
_r50char
#include "enter.i65"
    .word clit
    .byt 40
#include "pad.i65"
    .word starslashmod
#include "page.i65"
    .word qbranch
    .byt <(r50char01-*+1)
#include "pad.i65"
    .word bl
#include "page.i65"
    .word branch
    .byt <(r50char06-*+1)
#include "pad.i65"
r50char01
    .word clit
    .byt 10
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(r50char02-*+1)
#include "pad.i65"
    .word clit
    .byt '0'+9
#include "pad.i65"
    .word plus
#include "page.i65"
    .word qbranch
    .byt <(r50char02-*+1)
#include "pad.i65"
r50char02
    .word clit
    .byt 26
#include "pad.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(r50char03-*+1)
#include "pad.i65"
    .word clit
    .byt '@'+26
#include "pad.i65"
    .word plus
#include "page.i65"
    .word qbranch
    .byt <(r50char02-*+1)
#include "pad.i65"
r50char03
    .word plit
    .word r50special
#include "pad.i65"
    .word plus
#include "page.i65"
    .word cfetch
#include "page.i65"
r50char06
    .word exit

;--------------------------------------------------------------
;
;       RAD50   ( r -- c1 c2 c3 )
;
;"http://en.wikipedia.org/wiki/DEC_Radix-50
; Unpack a rad-50 (base 40) encoded word into three characters
; space, 0, 1, 2, 3, 4, 5, 6,
; 7, 8, 9, a, b, c, d, e
; f, g, h, i, j, k, l, m,
; n, o, p, q, r, s, t, u,
; v, w, x, y, z, comma, dash, question
;
rad50lfa
    .byt $de,$ad
    .byt (_rad50-*-1)|bit7
    .asc "RAD5","0"|bit7
_rad50
#include "enter.i65"
    .word _r50char
#include "page.i65"
    .word tor
#include "page.i65"
    .word _r50char
#include "page.i65"
    .word tor
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

MOVEDOWN LDY #0
         LDX SIZEH
         BEQ MD2
MD1      LDA (FROM),Y ; move a page at a time
         STA (TO),Y
         INY
         BNE MD1
         INC FROM+1
         INC TO+1
         DEX
         BNE MD1
MD2      LDX SIZEL
         BEQ MD4
MD3      LDA (FROM),Y ; move the remaining bytes
         STA (TO),Y
         INY
         DEX
         BNE MD3
MD4      RTS

original
cmove
    ldy #2
    jsr locals       ; from -> N0; to -> N1
    stx storex
    inc tos+1
    ldx tos
    beq cmove03
cmove01
    lda (n),y
    sta (n+2),y
    iny
    bne cmove02
    inc n+1
    inc n+3
cmove02
    dex
    bne cmove01
cmove03
    dec tos+1
    bne cmove01
    ldx storex
    jmp pops ; [36]

new
cmove
    ldy #2          ; pull two items off the data stack
    jsr locals      ; howmany = TOS, from = N0, to = N1
    ;clc
    ;ldy #0         ; locals returns Y=0 C=0
    stx storex      ; stash the data stack pointer
    ldx #0          ; X,Y=0
cmove01
    dec tos+1
    bpl cmove02     ; do a whole page
    ldx tos         ; last page
    beq cmove03     ; none at all?
    sec             ; exit after this iteration
cmove02
    lda (n),y
    sta (n+2),y
    iny
    dex
    bne cmove02
    inc n+1
    inc n+3
    bcc cmove01
cmove03
    ldx storex      ; revive the data stack pointer
    jmp pops    ; [32]


original
cmovegt
    ldy #2
    jsr locals               ; from -> N0; to -> N1
    stx storex
    lda tos+1
    ora tos
    beq cmovegt05
    lda tos+1
    pha
    clc
    adc n+1
    sta n+1
    pla
    clc
    adc n+3
    sta n+3
    ldy tos
    beq cmovegt02
cmovegt01
    dey
    lda (n),y
    sta (n+2),y
    cpy #0
    bne cmovegt01
cmovegt02
    ldx tos+1
    beq cmovegt05
cmovegt03
    dec n+1
    dec n+3
cmovegt04
    dey
    lda (n),y
    sta (n+2),y
    cpy #0
    bne cmovegt04
    dex
    bne cmovegt03
cmovegt05
    ldx storex
    jmp pops

cmovegt
    ldy #2
    jsr locals
    ;clc
    ;ldy #0
    stx storex
    ldx #0
cmovegt01
    dec tos+1
    bpl cmovegt03
cmovegt02       ; last page
    ldx tos
    beq cmovegt04
    sec
cmovegt03
    lda (n),y
    sta (n+2),y
    dey
    dex
    bne cmovegt03
    dec n+1
    dec n+3
    bcc cmovegt01
cmovegt04
    ldx storex
    jmp pops

original
cmovegt
    ldy #2
    jsr locals               ; from -> N0; to -> N1
    stx storex
    lda tos+1
    ora tos
    beq cmovegt05
    lda tos+1
    pha
    clc
    adc n+1
    sta n+1
    pla
    clc
    adc n+3
    sta n+3
    ldy tos
    beq cmovegt02
cmovegt01
    dey
    lda (n),y
    sta (n+2),y
    cpy #0
    bne cmovegt01
cmovegt02
    ldx tos+1
    beq cmovegt05
cmovegt03
    dec n+1
    dec n+3
cmovegt04
    dey
    lda (n),y
    sta (n+2),y
    cpy #0
    bne cmovegt04
    dex
    bne cmovegt03
cmovegt05
    ldx storex
    jmp pops



faking out CHRIN to use phantom screen
    lda #3
    sta $af     ; DFLTN Default Input Device = 3
    lda #$0
    sta $c4
    sta $c6
    lda #$7c
    sta $c5
    jsr CHRIN
    cmp #$0d


: scr!   ( scr -- )
    pkt@ blkbuf dup >r mkpkt    ( pkt blkbuf newsize ) ( R; blkbuf )
    >r over @                   ( pkt blkbuf oldsize ) ( R; blkbuf newsize )
    

    dup @ vmbuf @               ( blkbuf pkt oldsize vmbuf ) ( R; newsize )
    2dup +                      ( blkbuf pkt oldsize vmbuf vmbuf+oldsize ) ( R; newsize )
    r@ -                        ( blkbuf pkt oldsize vmbuf vmbuf+oldsize-newsize ) ( R; newsize )

pkt-oldsize-vmbuf
|                |
aaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbb ccccccccccc | ddddd
|           aaaaaaaaaaaaaaaaaa ddddd ccccccccccc | ddddd
vmbuf       |
            vmbuf+oldsize-newsize
                               |
                        blkbuf pkt-newsize+2 newsize move

vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf 
move

blkbuf pkt-newsize+2 newsize
move


;--------------------------------------------------------------
;
;       >PASTE   ( paste screen 40|80 -- paste+ screen+ )
;
; append the line on the screen to the paste buffer 
;
;": >paste
;     >r swap r@ over c!   ( screen paste ; 40|80 )
;     1+ 2dup r@ cmove   ( screen paste+1 ) 
;     r@ + dup off swap r> + ; [37]
;
_topaste
#include "enter.i65"
    .word tor
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit



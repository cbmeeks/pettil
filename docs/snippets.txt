; xor of two vectors, to switch between Sweet16 and TIM
brktoggle       .word TIMBRK^SW16
    
;--------------------------------------------------------------
;
;       MON    ( -- )
;
monlfa
    .byt $de,$ad
    .byt (mon-*-1)|bit7
    .asc "MO","N"|bit7
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
;~wut? this only works the first time
mon
    jsr swapzp      ; restore BASIC zpage
sw16
    ldy #2
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne sw16+2
    brk
    .byt rtn
plover          ; if we get here, it's unimplemented
xyzzy
    jmp next        ; used as a breakpoint in secondaries




;--------------------------------------------------------------
;
;       SETIRQ   ( newirq -- oldirq )
;
; Safely changes the IRQ vector at $90-$91 to the new value,
; leaving the previous value on the stack
setirqlfa
    .byt $de,$ad
    .byt (setirq-*-1)|bit7
    .asc "SETIR","Q"|bit7
setirq
    sei
    ldy 1+CINV
    lda CINV                ; old IRQ --> ya
    pha
    lda tos+1
    sta 1+CINV
    lda tos
    sta CINV                ; tos --> IRQ
    pla
    cli
    jmp put



;--------------------------------------------------------------
;
;       FOO ( -- )
;
; hooks/unhooks the IRQ
;
;
foolfa   
    .byt $de,$ad
    .byt (foo-*-1)|bit7
    .asc "FO","O"|bit7
foo
#include "enter.i65"
    .word plit
    .word foostash          ; ( new )
#include "pad.i65"
    .word dup               ; ( new new )
#include "page.i65"
    .word fetch             ; ( new newirq )
#include "page.i65"
    .word clit
    .byt $90                ; ( new newirq live )
#include "pad.i65"
    .word fetch             ; ( new newirq liveirq )
#include "page.i65"
    .word rot               ; ( newirq liveirq new )
#include "page.i65"
    .word store             ; ( newirq )
#include "pad.i65"
    .word setirq
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit
foostash  
    .word fooirq
fooirq    
    ldy #2
fooirq01  
    lda TIME,y
    sta VIDRAM+37,y
    dey
    bpl fooirq01
    jmp (foostash)


;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    brk
    .byt ld | TOS
    .byt st | N0        ; make a copy of the vector address
    .byt ldd | TOS      ; fetch the current target
    .byt pull           ; get the delta
    .byt ext
    .word xor16
    .byt std | N0
    .byt rtn
    cli
    jmp pops            ; [15]


;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
    sei
    jsr toforth
    .word dup
    .word tor
    .word fetch
    .word xor
    .word rfrom
    .word store
    .word to6502
    cli
    jmp next            ; [22]




;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    ldy #0
    lda (tos),y
    eor stackl,x
    sta (tos),y
    iny
    lda (tos),y
    eor stackh,x
    sta (tos),y
    cli
    jmp poptwo          ; [20]

;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    ldy #1
    jsr setup       ; eorvalue to N0
    sei
    iny             ; Y=1
toggleirq01
    lda (tos),y
    eor n,y
    sta (tos),y
    dey
    bpl toggleirq01
    cli
    jmp pops          ; [21]

;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    brk
    .byt ld | TOS
    .byt st | N0
    .byt ldd | TOS
    .byt pull
    .byt rtn
    ldy #1
toggleirq01
    lda r0,y
    eor tos,y
    sta (n),y
    dey
    bpl toggleirq01
    cli
    jmp pops            ; [24]



;--------------------------------------------------------------
;
;       SETIRQ   ( newvalue -- )
;
    sei
    lda tos
    sta $90
    lda tos+1
    sta $91
    cli
    jmp nxt             ; [13]

;--------------------------------------------------------------
;
;       SETIRQ   ( newvalue -- )
;
    sei
    brk
    .byt set | N0
    .word $90
    .byt ld | tos
    .byt std | N0
    .byt rtn
    cli
    jmp next            ; [12]




;--------------------------------------------------------------
;
;       EDITQ   ( -- )
;
; editor quit
;
;editqlfa
;    .byt $de,$ad
;    .byt (editq-*-1)|bit7
;    .asc "EDIT","?"|bit7
editq
    ldx storex      ; restore data stack pointer
    lda #$55
    sta $90
    lda #$e4
    sta $91         ; restore factory IRQ
    dex
    lda #8
    sta stackl,x
    ldy #0
    sty stackh,x

    lda #<fail
    sta tos
    lda #>fail
    sta tos+1
    cli
    jmp execute     ; drop out to Forth



memory move routine (west p. 355)
.C:b357  38          SEC
.C:b358  A5 57       LDA $57
.C:b35a  E5 5C       SBC $5C
.C:b35c  85 1F       STA $1F
.C:b35e  A8          TAY
.C:b35f  A5 58       LDA $58
.C:b361  E5 5D       SBC $5D
.C:b363  AA          TAX
.C:b364  E8          INX
.C:b365  98          TYA
.C:b366  F0 23       BEQ $B38B
.C:b368  A5 57       LDA $57
.C:b36a  38          SEC
.C:b36b  E5 1F       SBC $1F
.C:b36d  85 57       STA $57
.C:b36f  B0 03       BCS $B374
.C:b371  C6 58       DEC $58
.C:b373  38          SEC
.C:b374  A5 55       LDA $55
.C:b376  E5 1F       SBC $1F
.C:b378  85 55       STA $55
.C:b37a  B0 08       BCS $B384
.C:b37c  C6 56       DEC $56
.C:b37e  90 04       BCC $B384
.C:b380  B1 57       LDA ($57),Y
.C:b382  91 55       STA ($55),Y
.C:b384  88          DEY
.C:b385  D0 F9       BNE $B380
.C:b387  B1 57       LDA ($57),Y
.C:b389  91 55       STA ($55),Y
.C:b38b  C6 58       DEC $58
.C:b38d  C6 56       DEC $56
.C:b38f  CA          DEX
.C:b390  D0 F2       BNE $B384
.C:b392  60          RTS



EROM IRQ routine
.C:e442  48          PHA
.C:e443  8A          TXA
.C:e444  48          PHA
.C:e445  98          TYA
.C:e446  48          PHA
.C:e447  BA          TSX
.C:e448  BD 04 01    LDA $0104,X
.C:e44b  29 10       AND #$10
.C:e44d  F0 03       BEQ $E452
.C:e44f  6C 92 00    JMP (.CBINV)
.C:e452  6C 90 00    JMP ($0090)
.C:e455  20 68 F7    JSR $F768      ; bump jiffy clock
; cursor blink
.C:e458  A5 A7       LDA $A7
.C:e45a  D0 18       BNE $E474      ; is cursor winking?
.C:e45c  C6 A8       DEC $A8        ; cursor flash countdown
.C:e45e  D0 14       BNE $E474
.C:e460  A9 14       LDA #$14
.C:e462  85 A8       STA $A8        ; reset cursor blink countdown
.C:e464  A4 C6       LDY $C6        ; position of cursor along line
.C:e466  46 AA       LSR $AA        ; cursor blink toggle
.C:e468  B1 C4       LDA ($C4),Y    ; pointer to screen char
.C:e46a  B0 04       BCS $E470
.C:e46c  E6 AA       INC $AA        ; cursor in blink phase =1, else 0
.C:e46e  85 A9       STA $A9        ; true character at cursor position
.C:e470  49 80       EOR #$80       ; blink it
.C:e472  91 C4       STA ($C4),Y

.C:e474  A2 FF       LDX #$FF
.C:e476  86 A6       STX $A6        ; copy of keypress #ff=no key
.C:e478  E8          INX            ; x=0
.C:e479  86 98       STX $98        ; shift key pressed? 0 = no
.C:e47b  A2 50       LDX #$50
.C:e47d  AD 10 E8    LDA .PIA1PORTA
.C:e480  29 F0       AND #$F0
.C:e482  8D 10 E8    STA .PIA1PORTA
.C:e485  A0 00       LDY #$00
.C:e487  AD 10 E8    LDA .PIA1PORTA
.C:e48a  0A          ASL A
.C:e48b  0A          ASL A
.C:e48c  0A          ASL A
.C:e48d  10 06       BPL $E495      ; check cassette #1 sense
.C:e48f  84 F9       STY $F9        ; cassette #1 flags
.C:e491  A9 3D       LDA #$3D
.C:e493  D0 06       BNE $E49B
.C:e495  A5 F9       LDA $F9
.C:e497  D0 05       BNE $E49E
.C:e499  A9 35       LDA #$35
.C:e49b  8D 13 E8    STA .PIA1CRB   ; tape motor #1
.C:e49e  90 09       BCC $E4A9
.C:e4a0  84 FA       STY $FA
.C:e4a2  AD 40 E8    LDA .VIAORB
.C:e4a5  09 10       ORA #$10
.C:e4a7  D0 09       BNE $E4B2
.C:e4a9  A5 FA       LDA $FA
.C:e4ab  D0 08       BNE $E4B5
.C:e4ad  AD 40 E8    LDA .VIAORB
.C:e4b0  29 EF       AND #$EF
.C:e4b2  8D 40 E8    STA .VIAORB    ; tape motor #2
;keyboard scanner loop
.C:e4b5  A0 08       LDY #$08
.C:e4b7  AD 12 E8    LDA .PIA1PORTB
.C:e4ba  CD 12 E8    CMP .PIA1PORTB
.C:e4bd  D0 F6       BNE $E4B5
.C:e4bf  4A          LSR A
.C:e4c0  B0 1C       BCS $E4DE
.C:e4c2  48          PHA
.C:e4c3  BD 0A E6    LDA $E60A,X    ; keyboard decoding table (e60b)
.C:e4c6  D0 06       BNE $E4CE
.C:e4c8  A9 01       LDA #$01
.C:e4ca  85 98       STA $98        ; set shift key pressed
.C:e4cc  D0 0F       BNE $E4DD
.C:e4ce  C9 FF       CMP #$FF
.C:e4d0  F0 0B       BEQ $E4DD
.C:e4d2  C9 3C       CMP #$3C
.C:e4d4  D0 05       BNE $E4DB
.C:e4d6  2C 11 E8    BIT .PIA1CRA
.C:e4d9  30 02       BMI $E4DD
.C:e4db  86 A6       STX $A6
.C:e4dd  68          PLA
.C:e4de  CA          DEX
.C:e4df  F0 08       BEQ $E4E9
.C:e4e1  88          DEY
.C:e4e2  D0 DB       BNE $E4BF
.C:e4e4  EE 10 E8    INC .PIA1PORTA ; next keyboard row
.C:e4e7  D0 CC       BNE $E4B5

.C:e4e9  A5 A6       LDA $A6        ; copy of keypress or #ff
.C:e4eb  C5 97       CMP $97
.C:e4ed  F0 1C       BEQ $E50B
.C:e4ef  85 97       STA $97        ; new key pressed
.C:e4f1  AA          TAX
.C:e4f2  30 17       BMI $E50B
.C:e4f4  BD 0A E6    LDA $E60A,X
.C:e4f7  46 98       LSR $98        ; check shift key
.C:e4f9  90 02       BCC $E4FD
.C:e4fb  09 80       ORA #$80
.C:e4fd  A6 9E       LDX $9E        ; number of characters in keyboard buffer
.C:e4ff  9D 6F 02    STA $026F,X    ; add new key to keyboard buffer
.C:e502  E8          INX
.C:e503  E0 0A       CPX #$0A       ; maximum size 9 characters
.C:e505  D0 02       BNE $E509
.C:e507  A2 00       LDX #$00       ; clear keyboard buffer on wraparound
.C:e509  86 9E       STX $9E        ; set keyboard buffer size
.C:e50b  4C 00 E6    JMP $E600

.C:e600  68          PLA
.C:e601  A8          TAY
.C:e602  68          PLA
.C:e603  AA          TAX
.C:e604  68          PLA
.C:e605  40          RTI

.C:e606  A4 C6       LDY $C6
.C:e608  91 C4       STA ($C4),Y
.C:e60a  60          RTS


.C:f768  E6 99       INC $99
.C:f76a  A5 99       LDA $99
.C:f76c  D0 02       BNE $F770
.C:f76e  E6 9A       INC $9A
.C:f770  C9 6F       CMP #$6F
.C:f772  D0 06       BNE $F77A
.C:f774  A5 9A       LDA $9A
.C:f776  C9 02       CMP #$02
.C:f778  F0 21       BEQ $F79B
.C:f77a  E6 8F       INC $8F
.C:f77c  D0 06       BNE $F784
.C:f77e  E6 8E       INC $8E
.C:f780  D0 02       BNE $F784
.C:f782  E6 8D       INC $8D
.C:f784  A2 00       LDX #$00
.C:f786  B5 8D       LDA .TIME,X
.C:f788  DD AC F7    CMP $F7AC,X
.C:f78b  90 14       BCC $F7A1
.C:f78d  E8          INX
.C:f78e  E0 03       CPX #$03
.C:f790  D0 F4       BNE $F786
.C:f792  A9 00       LDA #$00
.C:f794  95 8C       STA $8C,X
.C:f796  CA          DEX
.C:f797  D0 FB       BNE $F794
.C:f799  F0 06       BEQ $F7A1
.C:f79b  A9 00       LDA #$00
.C:f79d  85 99       STA $99
.C:f79f  85 9A       STA $9A
.C:f7a1  AD 12 E8    LDA .PIA1PORTB
.C:f7a4  CD 12 E8    CMP .PIA1PORTB
.C:f7a7  D0 F8       BNE $F7A1
.C:f7a9  85 9B       STA $9B
.C:f7ab  60          RTS
(C:$f7ac) m f7ac
>C:f7ac  4f 1a 01 

; initialize I/O on PIAs, VIA, set clock to 0, set cursor, etc
.C:e000  A9 7F       LDA #$7F
.C:e002  8D 4E E8    STA .VIAIER
.C:e005  A2 6D       LDX #$6D
.C:e007  A9 00       LDA #$00
.C:e009  95 8D       STA .TIME,X
.C:e00b  CA          DEX
.C:e00c  10 FB       BPL $E009
.C:e00e  A9 55       LDA #$55
.C:e010  85 90       STA $90
.C:e012  A9 E4       LDA #$E4
.C:e014  85 91       STA $91
.C:e016  A9 03       LDA #$03
.C:e018  85 B0       STA $B0
.C:e01a  A9 0F       LDA #$0F
.C:e01c  8D 10 E8    STA .PIA1PORTA
.C:e01f  0A          ASL A
.C:e020  8D 40 E8    STA .VIAORB
.C:e023  8D 42 E8    STA .VIAPDRB
.C:e026  8E 22 E8    STX .PIA2PORTB
.C:e029  8E 45 E8    STX .VIAT1CH
.C:e02c  A9 3D       LDA #$3D
.C:e02e  8D 13 E8    STA .PIA1CRB
.C:e031  2C 12 E8    BIT .PIA1PORTB
.C:e034  A9 3C       LDA #$3C
.C:e036  8D 21 E8    STA .PIA2CRA
.C:e039  8D 23 E8    STA .PIA2CRB
.C:e03c  8D 11 E8    STA .PIA1CRA
.C:e03f  8E 22 E8    STX .PIA2PORTB
.C:e042  A9 0C       LDA #$0C
.C:e044  8D 4C E8    STA .VIAPCR
.C:e047  85 A8       STA $A8
.C:e049  85 A7       STA $A7
; clear screen
.C:e04b  A0 83       LDY #$83
.C:e04d  A2 18       LDX #$18
.C:e04f  94 E0       STY $E0,X      ; line wrap table $e0-$f8
.C:e051  E0 14       CPX #$14
.C:e053  F0 08       BEQ $E05D
.C:e055  E0 0D       CPX #$0D
.C:e057  F0 04       BEQ $E05D
.C:e059  E0 07       CPX #$07
.C:e05b  D0 01       BNE $E05E
.C:e05d  88          DEY
.C:e05e  CA          DEX
.C:e05f  10 EE       BPL $E04F
.C:e061  84 C5       STY $C5        ; top line of screen high byte
.C:e063  E8          INX
.C:e064  86 9F       STX $9F        ; screen reverse flag 0=normal 12=reversed
.C:e066  86 C4       STX $C4        ; top left corner of screen
.C:e068  A9 20       LDA #$20
.C:e06a  9D 00 80    STA .VIDRAM,X
.C:e06d  9D 00 81    STA $8100,X
.C:e070  9D 00 82    STA $8200,X
.C:e073  9D 00 83    STA $8300,X
.C:e076  CA          DEX
.C:e077  D0 F1       BNE $E06A
.C:e079  A0 00       LDY #$00
.C:e07b  84 C6       STY $C6        ; position of cursor along line
.C:e07d  84 D8       STY $D8        ; screen line of cursor
.C:e07f  A6 D8       LDX $D8
.C:e081  B5 E0       LDA $E0,X
.C:e083  09 80       ORA #$80
.C:e085  85 C5       STA $C5
.C:e087  BD 5B E6    LDA $E65B,X    ; table of linewrap low bytes for left edge
.C:e08a  85 C4       STA $C4
.C:e08c  A9 27       LDA #$27
.C:e08e  85 D5       STA $D5
.C:e090  E0 18       CPX #$18
.C:e092  F0 08       BEQ $E09C
.C:e094  B5 E1       LDA $E1,X
.C:e096  30 04       BMI $E09C
.C:e098  A9 4F       LDA #$4F
.C:e09a  85 D5       STA $D5
.C:e09c  A5 C6       LDA $C6
.C:e09e  C9 28       CMP #$28
.C:e0a0  90 04       BCC $E0A6
.C:e0a2  E9 28       SBC #$28
.C:e0a4  85 C6       STA $C6
.C:e0a6  60          RTS
.C:e0a7  AC 6F 02    LDY $026F
.C:e0aa  A2 00       LDX #$00
.C:e0ac  BD 70 02    LDA $0270,X
.C:e0af  9D 6F 02    STA $026F,X
.C:e0b2  E8          INX
.C:e0b3  E4 9E       CPX $9E
.C:e0b5  D0 F5       BNE $E0AC
.C:e0b7  C6 9E       DEC $9E
.C:e0b9  98          TYA
.C:e0ba  58          CLI
.C:e0bb  60          RTS
.C:e0bc  20 02 E2    JSR $E202
.C:e0bf  A5 9E       LDA $9E
.C:e0c1  85 A7       STA $A7
.C:e0c3  F0 FA       BEQ $E0BF
.C:e0c5  78          SEI
.C:e0c6  A5 AA       LDA $AA
.C:e0c8  F0 09       BEQ $E0D3
.C:e0ca  A5 A9       LDA $A9
.C:e0cc  A0 00       LDY #$00
.C:e0ce  84 AA       STY $AA
.C:e0d0  20 06 E6    JSR $E606
.C:e0d3  20 A7 E0    JSR $E0A7
.C:e0d6  C9 83       CMP #$83
.C:e0d8  D0 10       BNE $E0EA
.C:e0da  78          SEI
.C:e0db  A2 09       LDX #$09
.C:e0dd  86 9E       STX $9E
.C:e0df  BD 73 E6    LDA $E673,X
.C:e0e2  9D 6E 02    STA $026E,X
.C:e0e5  CA          DEX
.C:e0e6  D0 F7       BNE $E0DF
.C:e0e8  F0 D5       BEQ $E0BF
.C:e0ea  C9 0D       CMP #$0D
.C:e0ec  D0 CE       BNE $E0BC
.C:e0ee  A4 D5       LDY $D5
.C:e0f0  84 AC       STY $AC
.C:e0f2  B1 C4       LDA ($C4),Y
.C:e0f4  C9 20       CMP #$20
.C:e0f6  D0 03       BNE $E0FB
.C:e0f8  88          DEY
.C:e0f9  D0 F7       BNE $E0F2
.C:e0fb  C8          INY
.C:e0fc  84 A1       STY $A1
.C:e0fe  A0 00       LDY #$00
.C:e100  84 C6       STY $C6
.C:e102  84 CD       STY $CD
.C:e104  A5 A3       LDA $A3
.C:e106  30 16       BMI $E11E
.C:e108  C5 D8       CMP $D8
.C:e10a  D0 12       BNE $E11E
.C:e10c  A5 A4       LDA $A4
.C:e10e  85 C6       STA $C6
.C:e110  C5 A1       CMP $A1
.C:e112  90 0A       BCC $E11E
.C:e114  B0 2B       BCS $E141
.C:e116  98          TYA
.C:e117  48          PHA
.C:e118  8A          TXA
.C:e119  48          PHA
.C:e11a  A5 AC       LDA $AC
.C:e11c  F0 A1       BEQ $E0BF
.C:e11e  A4 C6       LDY $C6
.C:e120  B1 C4       LDA ($C4),Y
.C:e122  85 D9       STA $D9
.C:e124  29 3F       AND #$3F
.C:e126  06 D9       ASL $D9
.C:e128  24 D9       BIT $D9
.C:e12a  10 02       BPL $E12E
.C:e12c  09 80       ORA #$80
.C:e12e  90 04       BCC $E134
.C:e130  A6 CD       LDX $CD
.C:e132  D0 04       BNE $E138
.C:e134  70 02       BVS $E138
.C:e136  09 40       ORA #$40
.C:e138  E6 C6       INC $C6
.C:e13a  20 67 E1    JSR $E167
.C:e13d  C4 A1       CPY $A1
.C:e13f  D0 17       BNE $E158
.C:e141  A9 00       LDA #$00
.C:e143  85 AC       STA $AC
.C:e145  A9 0D       LDA #$0D
.C:e147  A6 AF       LDX $AF
.C:e149  E0 03       CPX #$03
.C:e14b  F0 06       BEQ $E153
.C:e14d  A6 B0       LDX $B0
.C:e14f  E0 03       CPX #$03
.C:e151  F0 03       BEQ $E156
.C:e153  20 02 E2    JSR $E202
.C:e156  A9 0D       LDA #$0D
.C:e158  85 D9       STA $D9
.C:e15a  68          PLA
.C:e15b  AA          TAX
.C:e15c  68          PLA
.C:e15d  A8          TAY
.C:e15e  A5 D9       LDA $D9
.C:e160  C9 DE       CMP #$DE
.C:e162  D0 02       BNE $E166
.C:e164  A9 FF       LDA #$FF
.C:e166  60          RTS
.C:e167  C9 22       CMP #$22
.C:e169  D0 08       BNE $E173
.C:e16b  A5 CD       LDA $CD
.C:e16d  49 01       EOR #$01
.C:e16f  85 CD       STA $CD
.C:e171  A9 22       LDA #$22
.C:e173  60          RTS
.C:e174  09 40       ORA #$40
.C:e176  A6 9F       LDX $9F
.C:e178  F0 02       BEQ $E17C
.C:e17a  09 80       ORA #$80
.C:e17c  A6 DC       LDX $DC
.C:e17e  F0 02       BEQ $E182
.C:e180  C6 DC       DEC $DC
.C:e182  20 06 E6    JSR $E606
.C:e185  E6 C6       INC $C6
.C:e187  A4 D5       LDY $D5
.C:e189  C4 C6       CPY $C6
.C:e18b  B0 19       BCS $E1A6
.C:e18d  A6 D8       LDX $D8
.C:e18f  C0 4F       CPY #$4F
.C:e191  D0 0C       BNE $E19F
.C:e193  20 B3 E1    JSR $E1B3
.C:e196  20 43 E3    JSR $E343
.C:e199  A9 00       LDA #$00
.C:e19b  85 C6       STA $C6
.C:e19d  F0 07       BEQ $E1A6
.C:e19f  E0 18       CPX #$18
.C:e1a1  D0 1B       BNE $E1BE
.C:e1a3  20 C4 E1    JSR $E1C4
.C:e1a6  68          PLA
.C:e1a7  A8          TAY
.C:e1a8  A5 DC       LDA $DC
.C:e1aa  F0 02       BEQ $E1AE
.C:e1ac  46 CD       LSR $CD
.C:e1ae  68          PLA
.C:e1af  AA          TAX
.C:e1b0  68          PLA
.C:e1b1  58          CLI
.C:e1b2  60          RTS
.C:e1b3  E0 17       CPX #$17
.C:e1b5  B0 06       BCS $E1BD
.C:e1b7  B5 E2       LDA $E2,X
.C:e1b9  09 80       ORA #$80
.C:e1bb  95 E2       STA $E2,X
.C:e1bd  60          RTS
.C:e1be  20 CD E1    JSR $E1CD
.C:e1c1  4C A6 E1    JMP $E1A6
.C:e1c4  20 69 E3    JSR $E369
.C:e1c7  C6 A3       DEC $A3
.C:e1c9  C6 D8       DEC $D8
.C:e1cb  A6 D8       LDX $D8
.C:e1cd  16 E1       ASL $E1,X
.C:e1cf  56 E1       LSR $E1,X
.C:e1d1  20 B3 E1    JSR $E1B3
.C:e1d4  A5 C6       LDA $C6
.C:e1d6  48          PHA
.C:e1d7  20 7F E0    JSR $E07F
.C:e1da  68          PLA
.C:e1db  85 C6       STA $C6
.C:e1dd  60          RTS
.C:e1de  A0 27       LDY #$27
(C:$e1e0) 

;--------------------------------------------------------------
;
;       $INDEX   ( addr char -- index|0 )
;
; returns the position of char within the counted string at addr
; otherwise returns 0
dolindexlfa
    .byt $de,$ad
    .byt (dolindex-*-1)|bit7
    .asc "$INDE","X"|bit7
dolindex
    brk
    .byt sub | ACC
    .byt st | N2
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt ldi | TOS
    .byt st | N1
dolindex01
    .byt inr | N2
    .byt ldi | TOS
    .byt sub | N0
    .byt bz, <(dolindex02-*-2)	; winner
    .byt dcr | N1
    .byt bnz, <(dolindex01-*-2)
    .byt ld | N1
    .byt st | N2
dolindex02
    .byt ld | N2
    .byt st | TOS
    .byt nxt
    
;--------------------------------------------------------------
;
;       $INDEX   ( addr char -- index|0 )
;
; returns the position of char within the counted string at addr
; otherwise returns 0
dolindexlfa
    .byt $de,$ad
    .byt (dolindex-*-1)|bit7
    .asc "$INDE","X"|bit7
dolindex
    brk
    .byt ld | TOS
    .byt st | N0                ; char
    .byt pull
    .byt ld | TOS               ; addr
    .byt st | N1                ; make a copy
    .byt ldi | N1
    .byt st | N2                ; count
dolindex01
    .byt ldi | N1
    .byt cpr | N0
    .byt bz, <(dolindex02-*-2)	; winner
    .byt dcr | N2
    .byt bnz, <(dolindex01-*-2)
    .byt ld | TOS
    .byt st | N1
dolindex02
    .byt ld | N1
    .byt sub | TOS
    .byt st | TOS
    .byt nxt
    
;--------------------------------------------------------------
;
;       $INDEX   ( addr char -- index|0 )
;
; returns the position of char within the counted string at addr
; otherwise returns 0
dolindexlfa
    .byt $de,$ad
    .byt (dolindex-*-1)|bit7
    .asc "$INDE","X"|bit7
dolindex
    ldy #1
    jsr setup
    sty n+2
    lda (n),y
    tay
dolindex01
    lda (n),y
    eor tos
    beq dolindex02
    dey
    bne dolindex01
dolindex02
    sty tos
    jmp next
    
    .byt ld | TOS
    .byt st | N0                ; char
    .byt pull
    .byt ld | TOS               ; addr
    .byt st | N1                ; make a copy
    .byt ldi | N1
    .byt st | N2                ; count
dolindex01
    .byt ldi | N1
    .byt cpr | N0
    .byt bz, <(dolindex02-*-2)	; winner
    .byt dcr | N2
    .byt bnz, <(dolindex01-*-2)
    .byt ld | TOS
    .byt st | N1
dolindex02
    .byt ld | N1
    .byt sub | TOS
    .byt st | TOS
    .byt nxt
    
>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 02   ................
>C:00f0  82 02 82 82  83 83 83 83  83 00 00 3d  29 ff ff 30   ...........=)..0

scrolled 40 off the top
>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 02 82   ................
>C:00f0  02 82 82 82  83 83 83 83  83 00 00 3d  29 ff ff 30   ...........=)..0

scrolled 40 off the top again
>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  81 02 82 02   ................
>C:00f0  82 82 82 82  83 83 83 83  83 00 00 3d  29 ff ff 30   ...........=)..0

scrolled 40 off the top again
>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  01 82 02 82   ................
>C:00f0  82 82 82 82  83 83 83 83  83 00 00 3d  29 ff ff 30   ...........=)..0

changed top to 80
>C:00e0  80 00 80 80  80 80 80 81  81 81 81 81  01 82 02 82   ................
>C:00f0  82 82 82 82  83 83 83 83  83 00 00 3d  29 ff ff 30   ...........=)..0

scrolled 80 off the top

: pastebuf
    pad                     ( pad )
    begin
        dup c@              ( addr len )
        qdup                ( addr 0 | addr len len )
    while
                            ( addr len )
        1+                  ( addr len+1 )
        +                   ( newaddr )
    repeat
                            ( addr )

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word _pastebuf
#include "page.i65"
    .word to6502
    lda $d5
    sta n
    ldy #0
editcopyline01
    sta (tos),y
    tax
    lda ($c4),y
    sta (tos),y
    iny
    dec n
    bpl editcopyline01
    jmp pops                ; [25]

editcopyline
#include "enter.i65"
    .word _pastebuf
#include "page.i65"
    .word to6502
    brk
    .byt set | N0           ; pointer to length
    .word $d5
    .byt set | N1           ; pointer to start of line
    .word $c4
    .byt ldi | N0           ; ACC = length
    .byt sti | TOS          ; put it in the buffer
    .byt st | N2            ; make a copy for countdown
editcopyline01
    .byt ldi | N1           ; get each screencode
    .byt sti | TOS
    .byt dcr | N2
    .byt bnm1 , <(editcopyline01-*-2)
    .byt pull
    .byt nxt                ; [18]

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word _pastebuf
#include "page.i65"
    .word clit
    .byt $d5
#include "page.i65"
    .word clit
    .byt $c4
#include "page.i65"
    .word to6502
    brk

: editcurrline   ( -- addr 40|80 )
    c4 @  d5 c@ 1+ ;

: editcopyline
    editcurrline pastebuf 2dup c!
    1+ swap cmove ;

c4 @  d5 c@  pastebuf 1+ 2dup 1- c! swap cmove

pastebuf 1+
d5 c@ 1+ over 1- c!

d5 c@ 1+ dup pastebuf c!

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word _pastebuf
#include "page.i65"
    .word clit
    .byt $d5
#include "page.i65"
    .word clit
    .byt $c4
#include "page.i65"
    .word to6502
    brk

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word _pastebuf
#include "page.i65"
    .word clit
    .byt $d5
#include "page.i65"
    .word clit
    .byt $c4
#include "page.i65"
    .word to6502
    brk

;--------------------------------------------------------------
;
;       EDITCURRLINE   ( -- addr 40|80 )
;
; return the starting address of the line at the cursor, and its length
;
;" : editcurrline   ( -- addr 40|80 )
;    c4 @  d5 c@ 1+ ;
;editcurrlinelfa
;    .byt $de,$ad
;    .byt (editcurrline-*-1)|bit7
;    .asc "EDITCURRLIN","E"|bit7
editcurrline
    ldy #1
    lda ($c4),y
    sta tos+1
    dey
    lda ($c4),y
    sta tos
    lda $d5
    jmp pushya                  ; [16]

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _editcurrline
#include "page.i65"
    .word pastebuf
    brk
    .byt set | N0           ; pointer to length
    .word $d5
    .byt set | N1           ; pointer to start of line
    .word $c4
    .byt ldi | N0           ; ACC = length
    .byt sti | TOS          ; put it in the buffer
    .byt st | N2            ; make a copy for countdown
editcopyline01
    .byt ldi | N1           ; get each screencode
    .byt sti | TOS
    .byt dcr | N2
    .byt bnm1 , <(editcopyline01-*-2)
    .byt pull
    .byt nxt                ; [18]

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;": editcopyline
;    editcurrline pastebuf 2dup c!
;    1+ swap cmove ;
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _editcurrline    ; ( addr size )
#include "page.i65"
    .word _pastebuf        ; ( addr size buf )
#include "page.i65"
    .word twodup           ; ( addr size buf size buf )
#include "page.i65"
    .word cstore           ; ( addr size buf )
#include "page.i65"
    .word oneplus          ; ( addr size buf+1 )
#include "page.i65"
    .word swap             ; ( addr buf+1 size )
#include "page.i65"
    .word cmove            ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; append a copy of the current line to the paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _editcurrline
#include "page.i65"
    .word pastebuf
    brk
    .byt set | N0           ; pointer to length
    .word $d5
    .byt set | N1           ; pointer to start of line
    .word $c4
    .byt ldi | N0           ; ACC = length
    .byt sti | TOS          ; put it in the buffer
    .byt st | N2            ; make a copy for countdown
editcopyline01
    .byt ldi | N1           ; get each screencode
    .byt sti | TOS
    .byt dcr | N2
    .byt bnm1 , <(editcopyline01-*-2)
    .byt pull
    .byt nxt                ; [18]
    
;--------------------------------------------------------------
;
;       RLEPACK   ( from to howmany -- )
;
;
rlepacklfa
    .byt $de,$ad
    .byt (rlepack-*-1)|bit7
    .asc "RLEPAC","K"
rlepack
    brk
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt ld | TOS
    .byt st | N1
    .byt pull
    

rlepack

	.export _rle_pack, rle_pack


	.import rle_store, rle_read
	.importzp src, dest
	.import lastbyte
	.import destlen

	.import popax


	.bss

srclen:		.res 2		; length of source data


	.code


; cc65 interface to rle_pack
; unsigned int __fastcall__ rle_pack(unsigned char *dest, unsigned char *src, unsigned int length);
_rle_pack:
	sta srclen		; save length arg
	stx srclen + 1
	jsr popax		; get src arg
	sta src
	stx src + 1
	jsr popax		; get dest arg
	sta dest
	stx dest + 1
	jsr rle_pack		; execute
	lda destlen		; return length
	ldx destlen + 1
	rts


; run length encode a stream
rle_pack:
	ldy #0
	sty destlen		; reset the byte counter
	sty destlen + 1
	jsr rle_read		; read the first byte
	sta lastbyte		; save for reference
	jsr rle_store		; store it
	jsr @decsrclen		; decrease source count
	beq @end		; if you're trying to pack a single byte, this the end
@pack:
	jsr rle_read		; grab a byte
	cmp lastbyte		; same as last byte?
	beq @rle		; then count bytes and store run length
	sta lastbyte		; save for reference
	jsr rle_store		; store byte
	jsr @decsrclen		; decrease source count
	bne @pack		; next
@end:
	lda lastbyte		; store last byte...
	jsr rle_store
	lda #0			; ...with a 0 count as the terminator
	jsr rle_store
	rts			; done
@rle:
	ldx #1			; start with a count of 1
	jsr @decsrclen
	beq @rleend
@rlenext:
	jsr rle_read		; grab a byte
	cmp lastbyte		; make sure it's the same
	bne @newbyte		; no, then terminate
	inx 			; inc counter
	beq @stop		; overflow?
	jsr @decsrclen		; check for end of data
	bne @rlenext
@rleend:			; end of data
	lda lastbyte		; store double byte
	jsr rle_store
	txa			; and counter
	jsr rle_store
	jmp @end
@stop:	    			; overflow
	lda lastbyte		; store the double byte
	jsr rle_store
	lda #$ff		; $ff as the byte count
	jsr rle_store
	inx			; start over with a counter of 1
	jsr @decsrclen
	beq @rleend
	bne @rlenext
@newbyte:			; new byte detected
	pha			; save
	lda lastbyte		; store double byte
	jsr rle_store
	txa			; and counter
	jsr rle_store
	pla			; restore new byte
	sta lastbyte		; save for reference
	jsr rle_store		; store it
	jsr @decsrclen		; data left?
	bne @pack		; yep, pack
	beq @end		; nope, end
; decrease number of bytes left, return 0 when done
@decsrclen:
	lda srclen
	bne :+
	dec srclen + 1
:	sec
	sbc #1
	sta srclen
	ora srclen + 1
	rts
    
    
    
	.export _rle_unpack, rle_unpack


	.import rle_store, rle_read
	.importzp src, dest
	.import lastbyte
	.import destlen

	.import popax


	.code


; cc65 interface to rle_unpack
; unsigned int __fastcall__ rle_unpack(unsigned char *dest, unsigned char *src);
_rle_unpack:
	sta src			; save src arg
	stx src + 1
	jsr popax		; get dest arg
	sta dest
	stx dest + 1
	jsr rle_unpack		; execute
	lda destlen		; return length
	ldx destlen + 1
	rts


; unpack a run length encoded stream
rle_unpack:
	ldy #0
	sty destlen		; reset byte counter
	sty destlen + 1
	jsr rle_read		; read the first byte
	sta lastbyte		; save as last byte
	jsr rle_store		; store
@unpack:
	jsr rle_read		; read next byte
	cmp lastbyte		; same as last one?
	beq @rle		; yes, unpack
	sta lastbyte		; save as last byte
	jsr rle_store		; store
	jmp @unpack		; next
@rle:
	jsr rle_read		; read byte count
	tax
	beq @end		; 0 = end of stream
	lda lastbyte
@read:
	jsr rle_store		; store X bytes
	dex
	bne @read
	beq @unpack		; next
@end:
	rts
    
jiffyfetch
    sei
    brk
    .byt set | N0
    .word TIME
    .byt ldd | N0
    .byt push
    .byt st | TOS
    .byt ldi | N0
    .byt push
    .byt st | TOS
    .byt rtn
    cli
    jmp next        ; [16]

jiffyfetch
    sei
    jsr slip
    lda TIME
    sta tos
    lda TIME+1
    sta tos+1
    ldy #0
    lda TIME+2
    cli
    jmp pushya      ; [20]

;--------------------------------------------------------------
;
;       D+   ( d1 d2 -- d1+d2 )
;
; * 83 nucleus
;
dpluslfa
    .byt $de,$ad
    .byt (dplus-*-1)|bit7
    .asc "D","+"|bit7
dplus           ; ~wut? should be possible to tighten this, inx inx not poptwo
    clc
    lda stackl,x
    adc stackl+2,x
    sta stackl+2,x
    lda stackh,x
    adc stackh+2,x
    sta stackh+2,x
    lda tos
    adc stackl+1,x
    sta stackl+1,x
    lda tos+1
    adc stackh+1,x
    sta stackh+1,x
    jmp poptwo          ; [28]
    
    clc
    lda stackl,x
    adc stackl+2,x
    sta stackl+2,x
    lda stackh,x
    adc stackh+2,x
    sta stackh+2,x
    lda tos
    adc stackl+1,x
    sta tos
    lda tos+1
    adc stackh+1,x
    sta tos+1
    inx
    inx
    jmp next            ; [30]
    
    clc
    lda stackl,x
    adc stackl+2,x
    sta stackl+2,x
    lda stackh,x
    adc stackh+2,x
    sta stackh+2,x
    lda tos
    adc stackl+1,x
    pha
    lda tos+1
    adc stackh+1,x
    tay
    pla
    inx
    inx
    jmp put            ; [29]

;--------------------------------------------------------------
;
;       EDITWRAP!   ( d startline -- )
;
; Updates a portion of the linewrap table at $E0 to reflect the bits
; stored in d, beginning at startline to end of the screen
; e.g. -1 -1 18 editwrap! would set lines 18-24 as 40-column
; line 1 is *always* $80, never a continuation line, so only 24 bits
; are used, not 25.  Put another way, 2 <= startline <= 25
;
editwrapstore
    ldy #2
    jsr setup
    stx storex
    ldx #24
editwrapstore01
    asl $e0,x
    lsr n+2
    ror n+1
    ror n
    ror $e0,x
    dex
    cpx tos
    bne editwrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       EDITWRAP@   ( d startline -- d )
;
; Reads (a portion of) the linewrap table in $E0, nondestructively
; shift the high bits into a double, beginning at startline.
; e.g. 9 editwrap@ would return 
;
editwrapfetch
    ldy #2
    jsr setup
    stx storex
    ldx tos
editwrapfetch01
    asl $e0,x
    rol n
    rol n+1
    rol n+2
    lsr $e0,x
    inx
    cpx #24
    bne editwrapfetch01
    lda n
    sta tos
    lda n+1
    sta tos+1
    lda n+2
    ldy n+3
    ldx storex
    jmp pushya

    
;--------------------------------------------------------------
;
;       EDITWRAPTOP@   ( -- d )
;
; Reads (a portion of) the linewrap table above the current physical
; line (stored at $D8) up to but not including the current line.  
; Returns a right-aligned double with those high bits
;
; $D8 = Current Cursor Physical Line Number
;
editwraptopfetch
    jsr slip
    stx storex
    ldx #1
editwraptopfetch01
    cpx $d8
    beq editwraptopfetch02  ; done
    asl $e0,x
    rol tos
    rol tos+1
    rol n
    lsr $e0,x
    inx
    bne editwraptopfetch01  ; bra
editwraptopfetch02
    ldx storex
    lda n
    jmp pushya

;--------------------------------------------------------------
;
;       EDITCURRLINE   ( -- addr 40|80 )
;
; return the starting address of the line at the cursor, and its length
;
;" : editcurrline   ( -- addr 40|80 )
;    c4 @  d5 c@ 1+ ;
;
;editcurrlinelfa
;    .byt $de,$ad
;    .byt (editcurrline-*-1)|bit7
;    .asc "EDITCURRLIN","E"|bit7
_editcurrline
#include "enter.i65"
    .word clit
    .byt $c4
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d5
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITCURRLINE   ( -- addr 40|80 )
;
; return the starting address of the line at the cursor, and its length
;
;" : editcurrline   ( -- addr 40|80 )
;    c4 @  d5 c@ 1+ ;
;
;editcurrlinelfa
;    .byt $de,$ad
;    .byt (editcurrline-*-1)|bit7
;    .asc "EDITCURRLIN","E"|bit7
_editcurrline
    jsr slip
    lda $c4
    sta tos
    lda $c5
    sta tos+1
    ldy $d5
    iny
    tya
    ldy #0
    jmp pushya      ; [20]

#include "enter.i65"
    .word clit
    .byt $c4
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d5
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit      ; [17]


;--------------------------------------------------------------
;
;       EDITPASTE   ( -- )
;
; insert the paste buffer before the current line
;
editpastelfa
    .byt $de,$ad
    .byt (_editpaste-*-1)|bit7
    .asc "EDITPAST","E"|bit7
_editpaste
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

1. remember the position of the paste buffer tail
2. append every line from currline to the bottom of screen to the paste buffer
3. copy lines from the start of the paste buffer from here to the end of the screen
4. get the wrap table above this line
5. roll in each bit or bit pair from the paste buffer
6. restore the paste buffer tail to its original position

pastebuf >r
26 nextphysline
do
    editdel
loop

currline


wrapabove
wrappaste
currphysline
wrapbelow

1. get the size of the paste buffer
2. move everything from the current line down
3. paste in the buffer
4. 
move everything down

: editpaste   ( -- )
    pastebuf            ( buftail )
    >r                  ( ) ( R; buftail ; held here until the end )
    25                  ( 25 )
    nextphysline        ( 25 line )
    do                  ( )
        editdel         ( )
    loop                ( cut all lines from current to end of screen ) 
    wrapabove           ( d )
    currline            ( d to size )
    drop                ( d to ; current line length is irrelevant )
    pad                 ( d to pad )
    >r                  ( d to ) ( R; buftail pad )
    >r                  ( d ) ( R; buftail pad to )
    begin
        r>              ( d to ) ( R; buftail pbuf )
        r@              ( d to pbuf ) ( R; buftail pbuf )
        c@              ( d to len ) ( R; buftail pbuf )
        r>              ( d to len pbuf ) ( R; buftail )
        1+              ( d to len from ) ( R; buftail )
        2dup            ( d to len from len addr+1 )
        +               ( d to len from nextpbuf )
        >r              ( d to len from ) ( R; buftail nextpbuf )
        lrot            ( d from to len ) 
        2dup            ( d from to len to len )
        +               ( d from to len nextline )
        dup             ( d from to len nextline nextline )
        >r              ( d from to len nextline ) ( R; buftail nextpbuf nextline )
        $8000+1000      ( d from to len nextline $83e8 )
        >               ( d from to len flag )
        if              ( d from to len )
            40          ( d from to len 40 )
            -           ( d from to len )
        then            ( d from to len )
        dup             ( d from to len len )
        >r              ( d from to len ) ( R; buftail nextpbuf nextline len )
        cmove           ( d )
        
        
        
                        ( from to howmany )
        cmove
    
    
    
    
        wrapfill        ( d flag )
    until

editpastelfa
    .byt $de,$ad
    .byt (_editpaste-*-1)|bit7
    .asc "EDITPAST","E"|bit7
_editpaste
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _pastebuf             ; ( addr )
#include "page.i65"
    .word tor                   ; ( )
#include "page.i65"
    .word clit
    .byt 25                     ; ( 25 )
#include "pad.i65"
    .word nextphysline          ; ( 25 line )
#include "page.i65"
    .word pdo                   ; ( )
#include "page.i65"
editpaste01
    .word _editdel              ; ( )
#include "page.i65"
    .word ploop
    .byt <(editpaste01-*+1)
#include "pad.i65"
    .word wrapabove             ; ( d )
#include "page.i65"
editpaste02                     ; BEGIN
    .word _pad                  ; ( d pad )
#include "page.i65"
    .word dup                   ; ( d pad pad )
#include "page.i65"
    .word oneplus               ; ( d pad from )
#include "page.i65"
    .word swap                  ; ( d from pad )
#include "page.i65"
    .word cfetch                ; ( d from length )
#include "page.i65"
    .word twodup                ; ( d from length from length )

    .word rfrom                 ; ( addr )
#include "page.i65"
    .word off                   ; ( )
#include "page.i65"
    .word exit

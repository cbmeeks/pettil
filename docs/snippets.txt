;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend uncompressed? )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
; and a flag indication if the data was compressed or not.
;
; If the length of the target exceeds {srclen}-1, RLENCODE will
; return a flag value of $4000 and simply store the data,
; otherwise it returns {uncompressed?} = 0.
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R11   ; output counter - when this hits zero, we're in negative compression
    .byt st | R10   ; input counter - when this hits zero, we're done

    .byt push       ; original size in case we go in the red
    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R11   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R10   ; are we in the red?
    .byt bz , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R11
    .byt sti | N1   ; write output stream
    .byt dcr | R10
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R11
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | R11
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R11              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R10
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt pull
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrapabove
;                                 ( blkbuf d )
;     rot dup >r
;                                 ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r
;                                 ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!
;                                 ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing
;                                 ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
;     r> swap
;                                 ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
;     rlencode
;                                 ( targend uncompressed? ) ( R; blkbuf )
;     over r> - >r
;                                 ( targend uncompressed? ) ( R; size )
;     over 2+ or vidram or swap !
;                                 ( ) ( R; size )
;     r> ;
;                                 ( size )
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore


;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt

;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( packet blkbuf packet blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( packet blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move move 0
;     then
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit


mkpkt

copy the linewrap table to blkbuf..blkbuf+2
scrsize = find the size of the screen (last non-blank character)
rlencode or store the current screen to blkbuf+3..+scrsize
newsize = get total size of new packet (3(wrap) + min(scrsize,rlencoded size) + 2(header))
or uncompressed? flag
or editable flag (true because we're storing it)
store the packet header at blkbuf+newsize-2

move vmbuf up or down to create a hole newsize bytes
targdata = calculate target address (packet - newsize + 2)
copy blkbuf into the hole   blkbuf



scr
packet address of old copy
compressed size of current screen

vmbuf
size of old copy




linewrap blkbuf
3c!

from to howmany
rlencode

packetheader targend
!


vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2
move

blkbuf packet-newsize+2 newsize
move


>C:0000  00 40 2a 07  02 20 03 30  ef 7b 58 12  80 7c 00 01   .@*.. .0.{X..|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

>C:7b80  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7b90  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7ba0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bb0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff  05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................

>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
>C:7c20  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
>C:7c30  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20

after 4 locals
>C:0000  00 40 2a 07  02 20 03 30  ef 7b f4 7b  00 7c 0e 00   .@*.. .0.{.{.|..
>C:0010  05 80 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

after (scr!)
>C:0000  02 80 2a 07  02 20 03 30  02 80 f6 7b  00 7c 0e 00   ..*.. .0...{.|..
>C:0010  05 80 ef 7b  02 00 ff ff  00 01 01 00  00 f5 f9 2c   ...{...........,
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e e6 ef  0e e8 00 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c fb 7b  00 7b 7c 40   ........||.{.{|@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt

7bef 7be4 7 move
7c00 7be6 10 move
(scr!)
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull
    .byt add | R10
    .byt st | TOS               ; end of new packet
    .byt popd | TOS             ; new packetheader
    .byt ext
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length

: scr!   ( scr -- )
    editable? @
                                ( scr flag )
    if
                                ( scr )
        dup pkt@ blkbuf tuck
                                ( scr blkbuf packet blkbuf )
        vmbuf @ -rot
                                ( scr blkbuf vmbuf packet blkbuf )
        dup mkpkt
                                ( scr blkbuf vmbuf packet blkbuf newlen )
        (scr!)
                                ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        move
                                ( scr blkbuf packet-newsize+2 newsize )
        move
                                ( scr )
    then
                                ( scr )
    drop ;

7bef 7be4 7 move
7c00 7be6 10 move

>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff ^05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................
>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  be be be be  be be be be  be be be be  be be be be   ................
>C:7c20  be be be be  be be be be  be be be be  be be be be   ................
>C:7c30  be be be be  be be be be  be be be be  be be be be   ................
>C:7c40  be be be be  be be be be  be be be be  be be be be   ................

(C:$2d0b) m 0
>C:0000  00 40 2a 07  02 20 03 30  0e 00 a2 12  80 7c 00 01   .@*.. .0.....|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 00 0e  10 10 00 f4  ef 00 02 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 7c 7c  40 c0 7c 7b  7b 7c 00 40   ......||@.|{{|.@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1d  2d 00 07 fe   ..........l.-...
(C:$0090) r
  ADDR AC XR YR SP 00 01 NV-BDIZC LIN CYC  STOPWATCH
.;2ce0 2d 2a 00 f0 00 40 00110000 011 036   31170532

0e      newlen
7c00    blkbuf
7bf4    packet






pscrstore
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull                   ; blkbuf
    .byt add | R10              ; newpacket
    .byt st | TOS               ; end of new packet
    .byt ldd | TOS              ; new packetheader
    .byt ext
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
    .byt ld | R11
    .byt st | R9                ; newsize
    .byt pull
    .byt st | N0                ; packet
    .byt ldd | TOS              ; old packetheader
    .byt ext
    .word pktheader16
    .pull                       ; vmbuf
    .byt st | N3
    .byt ld | N0
    .byt sub | R9
    .byt st | TOS
    .byt ld | R9
    .byt push
    .byt ld | N3
    .byt push
    .byt add | R11
    .byt sub | R9
    .byt push
    .byt ld | N0
    .byt sub | R11
    .byt sub | N3
    .byt push
    .byt nxt


;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
#ifdef HEADERS
bashtrailinglfa .byt $de,$ad
    .byt (_bashtrailing-*-1)|bit7
    .asc "+TRAILIN","G"|bit7
#endif
_bashtrailing
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
bashtrailing01
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word ne
#include "page.i65"
    .word pqleave
    .byt <(bashtrailing02-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word ploop
    .byt <(bashtrailing01-*+1)
#include "pad.i65"
bashtrailing02
    .word exit



dashtrailing
    brk
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt ext
    .word dashtrailing16
    .byt ld | N0
    .byt push
    .byt nxt

sum = addr + size

83e8

bcs exit

size =  3
        e8

    ldy sum_low
    lda #0
    sta sum_low
tight
    dey
    bne a

    bcc nextpage
    bcs zero
    dec sum_high
    dec count_high
    bne a
    sec


a   lda (sum),y
    cmp #' '
    beq tight
foundnonblank
    sty sum_low
    rts


two reasons you can exit
found nonblank
ran out of string


8050
 100

8150
;
;
;inputs
;   TOS (R4) = addr
;   N0 (R5) = addr+size
;   N1 (R6) = count
;returns
;   TOS = addr (unchanged)
;   N0 = addr of last non-blank character (= addr if all are blank)
    ;clc
dashtrailing16
    ldy n                       ; address low byte
    bne dashtrailing16b
dashtrailing16a                 ; another page
    bcs dashtrailing16c
    dec n+1                     ; address high byte
    dec n+3                     ; counter high byte
    bne dashtrailing16b
    sec                         ; flag last page
dashtrailing16b
    dey
    beq dashtrailing16a
    lda (n+2),y
    eor #$20
    beq dashtrailing16b
dashtrailing16c
    sty n
    rts

voctag 1+ c@ max tag so far
voctag c@ 0= core vocabulary
voctag c@ nametag c@ = this word is in current vocab
vocabular definition
jsr dovocab
.byt voctag
.word parent

rehash
target=SYMTAB
            +8 bloom filter
            +32 threads
            +2 newstuff
there is a pile of symbol table sitting at PAD
for each thread 0..f
    for each possible length 1..31
        is the CFA<HERE? if >+ we'll skip this one
            copy it to target
            target = target + symbol size
                 vocabularies have 2 extra bytes at the end



;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; tdict
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?         (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya


;--------------------------------------------------------------
;
;        SYMSIZ   ( -- n )
;
; returns the size of the symbol table
;
#ifdef HEADERS
symsizlfa
    .byt $de,$ad
    .byt (_symsiz-*-1)|bit7
    .asc "SYMSI","Z"|bit7
#endif
_symsiz
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
symsiz01
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "page.i65"
    .word andx
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(symsiz02-*-2)
#include "pad.i65"
    .word plus
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word branch
    .byt <(symsiz01-*-2)
#include "pad.i65"
symsiz02
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit      ; [38]

code symsiz   ( symbols -- )
    brk
    .byt inr | TOS
    .byt inr | TOS
    .byt rtn
symsiz01
    lda (tos),y

nfatocfa
    sec
    lda tos
    sbc #2
    sta tos
    bcs nfatocfa01
    dec tos+1
nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[24]

nfatocfa
    sec
    lda tos
    sbc #2
    sta n
    lda tos+1
    sbc #0
    sta n+1
    ldy #0
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    jmp next ;[28]


;--------------------------------------------------------------
;
;       BLOOMHASH   ( nfa -- bloomhash )
;
; Calculate the bloom filter hash.  For words containing any
; digits at all, this will be a total of each digit+1, or a
; nonzero value 1..63.  For words which have no digits, return
; bloomhash will be zero.  This is expected to sparsely populate
; the 64 bloom filter bits, allowing FIND to bypass the symbol
; table search if the bit is turned off.
;
#ifdef HEADERS
bloomhashlfa
    .byt $de,$ad
    .byt (bloomhash-*-1)|bit7
    .asc "BLOOMHAS","H"|bit7
#endif
bloomhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f
    sty n
    tay
bloomhash01
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash02             ;[3] carry is set only for digits
    adc n                       ;[3] anything with digits is nonzero
    and #(8*(bloomx-bloom))-1   ;[2] keep it within the filter bits
    sta n                       ;[3]
    bne bloomhash02
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash02
    dey
    bne bloomhash01
bloomhash03
    ;lda n
    ;ldy #0
    ldx storex
    jmp put

;": eligible?   ( hash searchlen nfa -- pearsonhash bloomhash flag )
;     dup c@ $1f and
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         dup indict?
;
;         2drop true ( more processing later )
;     else
;         2drop false
;     then ;
#ifdef HEADERS
eligibleqlfa
    .byt $de,$ad
    .byt (eligibleq-*-1)|bit7
    .asc "ELIGIBLE","?"|bit7
#endif
eligibleq
    ldy #2
    jsr locals
    ;ldy #0
    lda (tos),y
    and #$1f
    eor n                       ; same length?
    bne eligibleq05
    brk
    .byt set | R11
    .word uarea+userdp-userarea
    .byt set | R10
    .word uarea+usertdict-userarea
    .byt popd | TOS             ; CFA
    .byt st | N2
    .byt ldd | R11              ; DP
    .byt cpr | N2
    .byt bm , <(eligibleq02-*-2)    ; not in core dictionary? bail
    .byt cpr | R10              ; TDICT
    .byt bp , <(eligibleq02-*-2)    ; not in temp dictionary either? bail
    .byt rtn
    jsr dhash6502

eligibleq02
    .byt rtn


;": indict?   ( nfa -- flag )
;       nfa>cfa tdict @ over u< swap here u< or ;
#include "enter.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "pad.i65"
    .word andx
#include "page.i65"
    .word rot
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(eligibleq04-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word true
#include "page.i65"
    .word branch
    .byt <(eligibleq05-*+1)
#include "pad.i65"
eligibleq04
    .word twodrop
#include "page.i65"
    .word false
#include "page.i65"
eligibleq05
    .word exit

nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[13]

;--------------------------------------------------------------
;
;       SYMBYSIZE   ( searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
;
;": symbysize   ( searchlen nfa -- flag )
;     dup nfalen rot =
;     ( nfa samelength? )
;      dup
;      if
;          ( nfa samelength? )
;          drop indict?
;      then ;  ( flag )
;
;--------------------------------------------------------------
;
;       SYMBYHASH   ( hash nfa -- flag )
;
; returns true iff
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": symbyhash   ( hash nfa -- flag )
;     pearsonhash = ;
;
;--------------------------------------------------------------
;
;       ELIGIBLE?   ( hash searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": eligible?   ( hash searchlen nfa -- flag )
;     dup nfalen
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         ( hash nfa )
;         dup indict?
;         ( hash nfa indict? )
;         if
;             ( hash nfa )
;             pearsonhash =
;             ( flag )
;         else                  ( code smell alert -- )
;             2drop false       ( both elses are sort of cheesily combined )
;         then
;     else
;         2drop false
;     then ;
;
;--------------------------------------------------------------
;
;       SYMSORT   ( 'compare searchfor src dest -- src+ dest+ )
;
; Make a pass through the symbol table at PAD, copying eligible
; symbols to target
;": symsort   ( 'compare searchfor src dest )
;     >r 2+
;     ( 'compare searchfor nfa ) ( R; target )
;     begin
;         \ not done yet?
;         dup nfalen
;         ( 'compare searchfor nfa currlen ) ( R; target )
;     while
;         ( 'compare searchfor nfa ) ( R; target )
;         3dup rot execute
;         ( 'compare searchfor nfa flag ) ( R; target )
;         if
;             \ copy it up to the new symbol table
;             ( 'compare searchfor nfa ) ( R; target )
;             r@ over
;             ( 'compare searchfor nfa target nfa ) ( R; target )
;             sym+
;             ( 'compare searchfor nfa ) ( R; target )
;             \ advance target pointer
;             r> 2+ nfa+ 2- >r
;             ( 'compare searchfor nfa ) ( R; target+ )
;         then
;         \ advance source pointer
;         nfa+
;         ( 'compare searchfor nfa+ ) ( R; target+ )
;     repeat
;     ( 'compare searchlen nfa+ ) ( R; target+ )
;     r> 2swap 2drop ;   ( target+ )
;
: (rehash)   ( src targ 'compare -- )
    do rot drop i -rot symsort loop 2drop ;
: rehash  ( -- )
    pad >syms 2dup swap
    32 1 ['] symbysize (rehash)
    symtab @ 32 erase
    [ bloom ] literal 8 erase
    16 0 ['] symbyhash (rehash)

.C:0d23   .twominus:
.C:0d23  38          SEC
.C:0d24  A5 08       LDA $08
.C:0d26  E9 02       SBC #$02
.C:0d28  85 08       STA $08
.C:0d2a  B0 02       BCS .twominus01
.C:0d2c  C6 09       DEC $09
.C:0d2e   .twominus01:
.C:0d2e  4C 86 00    JMP .next
.C:0d31   .twoslash:

ldy tos
cpy #2
dey
dey
tya
ldy tos+1
bcs +
dey
jmp put

lda tos
sec
sbc #2
ldy tos+1
bcs +
dey
jmp put

;--------------------------------------------------------------
;
;       2+
;
twoplus
    ldy tos+1
    lda #2
twoplusminus
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    ldy tos+1
    dey
    lda #$fe
    bne twoplusminus            ; bra

;--------------------------------------------------------------
;
;       2+
;
twoplus
    lda #2
twoplusminus
    ldy tos+1
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    dec tos+1
    lda #$fe
    bne twoplusminus            ; bra

twominus
    dec tos+1
    lda #$fe
    .byt $2c ; 'bit absolute'
twoplus
    lda #2
    clc
    adc tos
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next

;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    pha
    ora #$7f
    bmi neg
    lda #0
neg
    dey
    beq done

    lda (n),y       ; high byte if CONST, low byte if CCONST
done
    sta tos+1
    jmp next     ;[30]


;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    pha
    ora #$7f
    bmi neg
    lda #0
neg
    dey
    beq done

    lda (n),y       ; high byte if CONST, low byte if CCONST
done
    sta tos+1
    jmp next     ;[30]


;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1         ; [11]
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    sta n+2
    dey
    bne twobytes
    asl n+2
    bcc +
    dey
+   jmp pushya
twobytes
    lda (n),y
    ldy n+2
out
    jmp pushya  ;[33]


doconst01
    jsr slip
-   lda (n),y       ; high byte if CONST, low byte if CCONST
    sta tos-1,y
    dey
    bne -           ;[11]

Y was 2, we're out


;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    clc
    .byt $24
;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    sec
    pla
    sta n
    pla
    sta n+1
    ldy #1
    lda (n),y
    pha
    bcs doconst02
    bpl doconst01
    dey
doconst01
    dey
    bcc doconst03
doconst02
    iny
    lda (n),y
    tay
doconst03
    pla
    jmp pushya      ; [30]


    bcs a
    dey
c   clc
    iny
a   lda (n),y
    pha
    dey
    bcs c

    pla
    bcs b

b   tay
    pla
    jmp pushya

    sty n+2
    iny
    iny
    sta n+2
+
    dey
    lda (n),y
    pha

    ldy #1
    lda (n),y
    bcc lowonly

    pha                 ; LSB of constant
    bcs get2nd
    ora #$7f
    bmi out2
    dey
    beq out3



get2nd
    iny
    lda (n),y           ; MSB of constant
out2
    tay
out3
    pla
    jmp pushya      ; [30]



;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    pla
    sta n
    pla
    sta n+1
    ldy #2
    lda (n),y
    sta n+2         ; high byte
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya  ;[20]



-   lda (n),y
    sta n+1,y
    dey
    bne -           ; [22]

    pla
    sta n
    pla
    sta n+1         ; [9]
    jsr slip
    ldy #2
    bcs +
    dey
+
    dey
    bne +
    bcs out
    sty tos+1
    asl
    bcc out
    dec tos+1
out
    jmp next


    bcc +
    asl

    dey
    bne +

    pla
    sta n






    lda (n),y       ; high byte if CONST, low byte if CCONST
    sta tos+2
    dey
    beq out
    bne twobytes
    asl n+2
    bcc +
    dey
+   jmp pushya
twobytes
    lda (n),y
    ldy n+2
out
    jmp pushya  ;[33]




twobytes
    lda (n),y       ; high byte if CONST, low byte if CCONST
onebyte
    sta tos+1
    jmp next     ;[30]


        ; calculates upper byte of sign-extension of A
        ora #$7F
        bmi neg
        lda #0
neg:

    sta n+2
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya


;--------------------------------------------------------------
;
;       (FIND)   ( name nfa fflag -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the list
; fflag is the type of search we are doing
;   0 = corelist - names are in ascending order by size
;   1 = newlist - names are random sizes, with a 0-length name to terminate
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------
;--------------------------------------------------------------
;
;       (FIND)   ( name nfa fflag -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the list
; fflag is the type of search we are doing
;   0 = corelist - names are in ascending order by size
;   1 = newlist - names are random sizes, with a 0-length name to terminate
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt ld | TOS
    .byt st | N2            ; findflag 0=sorted; 1=unsorted
    .byt pull
    .byt st | N0            ; nfa of search list
    .byt pull
    .byt ldi | TOS          ; name to search for
    .byt dcr | TOS
    .byt st | N1            ; length
pfind01



    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;       (FIND)   ( name nfa fflag -- name false | cfa flag )
pfind
    brk
    .byt ld | TOS
    .byt st | N2                ; N2 = findflag
    .byt pull
    .byt st | N1                ; N1 = symbols
    .byt pull
    .byt st | N0                ; N0 = name
    .byt ext
    .word wordlen16             ; get length of NFA (TOS)
    .byt ld | R11
    .byt st | N3                ; length we are searching for
    .byt ld | N1
    .byt st | TOS
    .byt rtn

    jsr nfalen01
    sta n+5
    brk
    .byt ld | N1
    .byt st | TOS
    .byt rtn

    brk
    .byt ld | TOS
    .byt st | N2            ; findflag 0=sorted; 1=unsorted
    .byt pull
    .byt st | N0            ; nfa of search list
    .byt pull
    .byt ldi | TOS          ; name to search for
    .byt dcr | TOS
    .byt st | N1            ; length
pfind01

------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
; for vocabularies
; if context is nonzero, append the vocabulary id to the end of the
; word and extend its length by 1
; first search symnew, then core
; if not found, chain up to its parent vocabulary and repeat
; if parent vocabulary = core, strip off the vocabulary id
; and repeat
: find   ( addr1 -- addr2 flag )
    >r
    ( )
    0 0
    ( 0 0 )
    r@ pearsonhash 2* symtab @ + @ 2+ 0
    ( 0 0  corethread 0 )
    symnew @ 2+ 1
    ( 0 0  corethread 0  newthread 1 )
    false
    ( 0 0  corethread 0  newthread 1  found? )
    begin
        ( 0 0  corethread 0  newthread 1  found? )
        r@ over 0= 2over or and
        ( 0 0  corethread 0  newthread 1  found? name !found?&more?  )
    while
        ( 0 0  corethread 0  newthread 1  found? name )
        nip -rot (find)
        ( 0 0  corethread 0  name newthread 1  )
    repeat ;

#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"        ; ( name )
    .word tor
#include "page.i65"
    .word zero
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word false
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word one
#include "page.i65"
    .word false
#include "page.i65"
find01
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word zeq
#include "page.i65"
    .word twoover
#include "page.i65"
    .word orx
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word _dashrot
#include "page.i65"
    .word pfind
#include "page.i65"
    .word branch
    .byt <(find01-*+1)
#include "page.i65"
find02
    .word xyzzy
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit

;--------------------------------------------------------------
;
;       SCAN   ( addr count char -- addr count )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt rtn
    lda n
    ldy n+1
    jmp pushya

;       SKIP   ( addr1 size1 char -- addr2 count2 )
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
    stx storex
    ldy #2
    jsr locals                  ; TOS=char; N0=addr1; N1=size1
                                ; sw16, N1=char; N0=size1; TOS=addr1
skip01
    ldy #0
    lda (n),y
    pha
    lda n+2
    bne skip02
    dec n+3                     ; DCR size1
    bmi leave
skip02
    dec n+2
    pla
    eor tos
    beq skip01

    dec $0,x
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit

PLACE( str len addr -- )  => "FORTH"

    Place the string _str len_ at _addr_, formatting it as a counted string.

      : PLACE  2DUP 2>R  1+ SWAP  MOVE  2R> C! ;
      : PLACE  2DUP C!   1+ SWAP CMOVE ;

$!

;inputs
;   X = Sweet16 register address e.g. TOS = 8
;returns
;   decrements that 16-bit register once or twice (X)=(X)-2
decx2
    jsr DCR
decx
    jmp DCR

;inputs
;   X = Sweet16 register address e.g. TOS = 8
;returns
;   increments that 16-bit register once or twice (X)=(X)-2
incx2
    jsr INR
incx
    jmp INR

   ( c addr size -- addr size )
scan
    lda #$ff
    .byt $2c
skip
    lda #$0
    sta n+2                     ; mask
    ldy #1
    jsr locals                  ; N0 = addr; stackl,x = char
    jsr invert                  ; instead of counting down, count up
skipscan01
    jsr inctos                  ; must pre-increment after eor FFFF
    beq skipscan03
    lda (n),y
    eor stackl,x
    php
    pla
    eor n+2
    lsr
    lsr
    inc n
    bne skipscan02
    inc n+1
skipscan02
    bcc loop
skipscan03
    jsr donegate
    lda n                       ; addr
    ldy n+1
    jsr slip2
    jmp next



QUERY EXPECT BLK B/BUF HERE
LATEST 'STREAM TIB #TIB >IN SPAN WORD SKIP SCAN

 : 'stream   ( -- addr size )
      blk @ ?dup
      if      block b/buf
      else    tib #tib @
      then
  ( addr size )
      >in @ over
  ( addr size >in size )
      min >r
  ( addr size ) ( R; size' )
      swap r@ +
  ( size addr+size' ) ( R; size' )
      swap r> - ;
  ( addr+size' size-size' )


          SPAN         -- addr                       U,83
               The address of a variable containing the count of characters
               actually received and stored by the last execution of
               EXPECT .  See:  EXPECT

  |Now is the time for all |good men to come to the aid of their country|
  ^                        ^                                            ^
TIB                        |                                            |
                           |                                          SPAN
                          >IN

          Interpreter layer

                #  #>  #S  #TIB  '  (  -TRAILING  .  .(  <#  >BODY  >IN
ABORT  BASE  BLK  CONVERT  DECIMAL  DEFINITIONS  FIND
FORGET  FORTH  FORTH-83  HERE  HOLD  LOAD  PAD  QUIT  SIGN
SPAN  TIB  U.  WORD
          SPAN         -- addr                       U,83
               The address of a variable containing the count of characters
               actually received and stored by the last execution of
               EXPECT .  See:  EXPECT

;       #TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}

;" : word   ( c -- nfa )
;      >r                              ; ( -- ) ( R; c )
;  ( ) ( R; c )
;      'stream
;  ( addr size ) ( R; c )
;      under
;  ( addr addr size ) ( R; c )
;      r@ skip
;  ( addr addr2 count2 ) ( R; c )
;      under
;  ( addr addr2 addr2 count2 ) ( R; c )
;      r> scan
;  ( addr addr2 addr3 count )
;      drop 2dup swap -
;  ( addr addr2 addr3 size )
;      >r
;  ( addr addr2 addr3 ) ( R; size )
;      rot - 1+
;  ( addr2 addr3 size2 ) ( R; size )
;      >in +!
;  ( addr2 addr3 ) ( R; size )
;      r> here
;  ( addr2 addr3 size here )
;      2dup c!
;  ( addr2 addr3 size here )
;      1+ swap cmove
;  ( addr2 )
;      here bl over
;  ( addr2 here bl here )
;      count + c! ;
;  ( addr2 here )
: word   ( c -- nfa )
    dup>r
  ( c )
    'stream
  ( c addr size )

  ( c addr size )
    skip
  ( c addr size )
    scan
  ( addr2 size )

  bl word  ( -- nfa )

;--------------------------------------------------------------
;
;       CMOVE>   ( from to howmany -- )
;
; * 83 nucleus
;
; Move the u bytes beginning at address addr1 to
; addr2.  The move begins by moving the byte at
; (addr1 plus u minus 1) to (addr2 plus u minus 1)
; and proceeds to successively lower addresses
; for u bytes.  If u is zero nothing is moved.
; Useful for sliding a string towards higher addresses.
;
;": cmove>   ( from to howmany -- )
;     dup>r 1- tuck
;  ( from howmany-1 to howmany-1 )
;     + -rot + r@
;  ( to+howmany-1 from+howmany-1 howmany )
;     >6502
;     ldy #2
;     jsr locals                ; N0 = to; N1 = from
#ifdef HEADERS
cmovegtlfa
    .byt $de,$ad
    .byt (_cmovegt-*-1)|bit7
    .asc "CMOVE",">"|bit7
#endif
_cmovegt
#include "enter.i65"
    .word duptor
    brk
    .byt ld | TOS
    .byt st | N2                ; howmany
    .byt dcr | N2
    .byt pull
    .byt add | N2
    .byt st | N1                ; to
    .byt pull
    .byt add | N2
    .byt st | N0                ; from
    .byt ld | N2
    .byt bp, <(cmovegt06-*-2)
    .byt pull
    .byt nxt
cmovegt06
    .byt inr | N2
    .byt rtn
    clc
    ldy #0                     ; done by Sweet16
    stx storex
    ldx #0
cmovegt01
    dec n+5
    bpl cmovegt03
cmovegt02       ; last page
    ldx n+4
    beq cmovegt05
    sec
cmovegt03
    lda (n),y
    sta (n+2),y
    tya
    bne cmovegt04
    dec n+1
    dec n+3
cmovegt04
    dey
    dex
    bne cmovegt03
    bcc cmovegt01
cmovegt05
    ldx storex
    jmp pops

: (vocablist)   ( -- 0 id id ... )
    0 >r  context
    begin
        @ dup 2+ c@  dup>r  0=
    until
    drop r>
    begin
        r> ?dup  0=
    until ;

: (find)   ( vocid name  -- name 0 | cfa -1|1 )

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
;": find   ( addr1 -- addr2 flag )
;     >r
;     ( )
;     (vocablist)
;     ( 0 [ vocid ... ] )


;     r@ pearsonhash 2* symtab @ + @ 2+ 0
;     ( 0 0  corethread 0 )
;     symnew @ 2+ 1
;     ( 0 0  corethread 0  newthread 1 )
;     r@ false
;     ( 0 0  corethread 0  newthread 1  name found? )
;     begin
;         ( 0 0  corethread 0  newthread 1  name found? )
;         2over or over 0= and
;         \ flag is set if word not found yet and more places to look
;         ( 0 0  corethread 0  newthread 1  name found? !found?&more?  )
;     while
;         ( 0 0  corethread 0  newthread 1  name found? )
;         drop -rot (find)
;     repeat
;         ( 0 0 ... name found? )
; \ save the results
;     >r >r
;     begin
;         or 0=
;     until
;     r> r> ;
; \ then get rid of the stack down to the two zeroes
; \ return the results
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"        ; ( name )
    .word tor
#include "page.i65"
    .word zero
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word false
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word one
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word false
#include "page.i65"
find01
    .word twoover
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _dashrot
#include "page.i65"
    .word pfind
#include "page.i65"
    .word branch
    .byt <(find01-*+1)
#include "pad.i65"
find02
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
find03
    .word orx
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit


: find   ( addr1 -- addr2 flag )
    >r
  ( ) ( R; name )
    (vocablist)
  ( 0 [ vocid ... ] ) ( R; name )
    true r@ false
    begin
        over or
  ( vocid vocid ) ( R; name )
        while
            dup (vocfind)
        then
  ( vocid )
         r@ (find)
    until

find
    txa

;--------------------------------------------------------------
;
;       (FIND)   ( name -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the hash list
;
; vocid identifies which vocabulary to search.  Vocabularies may be
; nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
; NFAs (with the vocid appended to the name before hashing) on the stack.
; The final vocabulary searched will be core, and (FIND) will exit afterward.
;   0 = corelist
;   1 = editor
;   2 = assembler
;   3+ = additional user vocabularies
;
; (FIND) first searches the unsorted names beginning at SYMTAIL, and keeps
; going without regard to name length.  If it fails to find the word there,
; it tries the hash list, which is expected to be sorted in ascending size
; order.  Vocabularies are searched first, beginning with CONTEXT and chaining
; up until core (0) is reached.  The vocid is appended to the word when
; searching that vocabulary.  Only one symbol within a vocabulary may be
; active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
; may exist within more than one vocabulary.
;
;" For example, at cold start the user types in,
;" VOCABULARY LATIN          \ creates a new user vocabulary with vocid = 3
;" LATIN DEFINITIONS         \ sets CURRENT to LATIN, definitions added there
;" : EPLURIBUSUNUM ;         \ adds a new word to the LATIN vocabulary
;" VOCABULARY PIGLATIN       \ creates a new user vocabulary with vocid = 4
;"                           \ PIGLATIN is a member of the LATIN vocabulary
;" PIGLATIN DEFINITIONS      \ sets CURRENT to PIGLATIN, new definitions there
;" : IXNAY ;                 \ adds a new word to the PIGLATIN vocabulary
;" FORTH                     \ set CONTEXT to core
;" IXNAY  not found          \ IXNAY is a member of PIGLATIN, out of context
;" PIGLATIN  not found       \ PIGLATIN is a member of LATIN vocabulary
;" LATIN PIGLATIN            \ set context to LATIN; set context to PIGLATIN
;" IXNAY  ok                 \ search for "IXNAY" + $04, found in PIGLATIN(4)
;" EPLURIBUSUNUM  ok         \ search for "EPLURIBUSUNUM" + $04, not found.
;"                           \ search for "EPLURIBUSUNUM" + $03, in LATIN(3)
;" DEPTH .  0 ok             \ search for "DEPTH" + $04, not found in PIGLATIN(4)
;"                           \ search for "DEPTH" + $03, not found in LATIN(3)
;                            \ search for "DEPTH", found in core(0)
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
#ifdef SWEET16
    brk
    .byt sub | R0
    .byt st | R9                ; result flag
    .byt st | N2                ; assume core mode
    .byt ld | TOS
    .byt bz , <(pfind01-*-2)
    .byt dcr | N2               ; N2 = findflag, testable by BIT instr
pfind01
    .byt pull
    .byt st | N1                ; N1 = start of symbol table list
    .byt pull
    .byt st | N0                ; N0 = name
    .byt ext
    .word wordlen16             ; get length of name (TOS)
    .byt ld | R11
    .byt st | N3                ; length we are searching for
    .byt ld | N1
    .byt st | TOS               ; set TOS = first on search list
    .byt rtn
pfind02
    jsr nfalen01
    beq pfind07                 ; end of list? return ( NAME 0 )
    bcs pfind03                 ; smudged? not findable. next!
    cmp n+6                     ; compare lengths
    beq pfind04                 ; same length, compare strings too
    bcc pfind03                 ; shorter length?  next!
    bit n+4                     ; check unsorted mode vs. core mode
    bmi pfind03                 ; look at all names on this list
    bpl pfind07                 ; core mode, and we've gone past it
pfind03
    jsr nfaplus01
    bne pfind02                 ; bra
pfind04
    jsr strcomp
    bcc pfind03                 ; non-match? next!

    ; winner!
    inc n+10                    ; assume immediate (returns +1)
    ;ldy #0                     ; thank you, strcomp
    lda (tos),y                 ; length and flags
    bmi pfind06                 ; immediate?
    dey
    sty r9
    sty r9+1                    ; set R9 = -1
pfind06
    brk
    .byt popd | TOS             ; get the CFA
    .byt br , <(pfind08-*-2)
pfind07
    ; loser...
    brk
    .byt ld | N0
pfind08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | R9                ; status flag
    .byt push
    .byt nxt
#endif

: (find)   ( name -- cfa flag | nfa 0 )
    1 symnew @ ((find))
    ?dup 0=
    if
        0 over pearsonhash 2* symtab @ + @ ((find))
    then ;


: voc@   ( -- vocid )
    context @ 2+ c@ ;

: (vocablist)   ( -- 0 id id ... )
      vocabs$  context
  ( vocabs$ context )
      begin
  ( vocabs$ context )
          @ dup 2+ c@
  ( vocabs$ vocab id )
          rot 2dup
  ( vocab id vocabs$ id vocabs$ )
          c! 1+ -rot
  ( vocabs$+ vocab id )
          0=
      until
      2drop ;



: smudge   ( -- )
    latest @ $20 cbit^ ;        \ toggle $20 bit on last word defined



: create   ( -- )
    exists?
    if
  ( cfa )
        [ RVSON ] cliteral emit
        here count type
        [ RVSOFF ] cliteral emit
        ."  EXISTS"
\ navigate to the NFA
\ smudge the previously existing word
\ leave the address of the name
  ( here )
    then
  ( here )
\ here is the name
    current @ 2+ c@ ?dup
    if
\ concatenate the vocabulary id
        under voc+
    then
  ( here )
    symtail @                   \ add the symbol to the symbol table
  ( symtail )
    r@ 2dup 2 +under
  ( symtail here symtail+2 here )
    over latest !               \ set LATEST variable to new word's NFA
  ( symtail here symtail+2 here )
    nfalen 1+ 3dup cmove smudge \ move symbol to symtail+2, smudge it
  ( symtail here symtail+2 len+1 )
    +
  ( symtail here symtail+2+len+1 )
    dup 3 erase                 \ mark the new symtail 00 00 00
  ( symtail here symtail+2+len+1 )
    symtail !                   \ update symtail
  ( symtail here )
    swap !                      \ set the CFA of the new symbol to HERE
  ( )
    [ docreate ] literal ,cfa ; \ enclose "JSR DOCREATE" in the dictionary


;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa )
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )

: isdup?   ( name -- flag )

: id.   ( nfa -- )
    dup nfalen  over c@
  ( nfa len len|flags )
    $40 and             \ check vocab bit
  ( nfa len isvoc? )
    if
        1-
    then
    1 +under type ;

\ if current vocabulary isn't root, append the vocid
: ?vocab   ( name -- name )
    current @ 2+ c@ ?dup
    if
        over voc+
    then ;

: create   ( -- )
\ parse input stream to here, and search context and its parents for name
    exists?
  ( xfa flag )
    here ?vocab swap
  ( xfa here flag )
    if
  ( xfa here )
\ is potential duplicate word in the current (not a parent) vocabulary?
\ otherwise it's not a redefinition, treat it as a new word
        nip (find)
  ( nfa xfa flag )
        if
  ( nfa cfa )
            [ RVSON ] cliteral emit
            over id.
            [ RVSOFF ] cliteral emit
            ."  EXISTS"
            drop smudge         \ smudge the previously existing word
            here
  ( here )
        then
  ( here )
    then
  ( here )
    symtail @                   \ add the symbol to the symbol table
  ( here symtail )
    over 2dup 2 +under
  ( here symtail here symtail+2 here )
    over latest !             \ set LATEST variable to new word's NFA
  ( here symtail here symtail+2 here )
    nfalen 1+ 3dup cmove smudge \ move symbol to symtail+2, smudge it
  ( here symtail here symtail+2 len+1 )
    +
  ( here symtail here symtail+2+len+1 )
    dup 3 erase                 \ mark the new symtail 00 00 00
  ( here symtail here symtail+2+len+1 )
    symtail !                   \ update symtail
  ( here symtail here )
    swap !                      \ set the CFA of the new symbol to HERE
  ( )
    [ docreate ] literal ,cfa ; \ enclose "JSR DOCREATE" in the dictionary
;--------------------------------------------------------------
;
;       (VOCABLIST)   ( -- )
;
; Sets the VOCABS$ string to the list of vocabularies, chaining up
; from CONTEXT to core
;
;": (vocablist)   ( -- )
;       vocabs$  context
;  ( vocabs$ context )
;     begin
;  ( vocabs$ context )
;         dup @ swap vocid
;  ( vocabs$ vocab id )
;         rot 2dup
;  ( vocab id vocabs$ id vocabs$ )
;         c! 1+ -rot
;  ( vocabs$+ vocab id )
;         0=
;     until
;     2drop ;

: :   ( -- )
    [ enter ] literal
    !csp  current @ context !  (create)
    latest @ dup smudge ] ;

#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word latest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
    jmp enter



;--------------------------------------------------------------
;
;       CFA!   ( addr nfa -- )
;
; puts a JSR addr at cfa, taking page alignment into account
;
#ifdef HEADERS
cfastorelfa
    .byt $de,$ad
    .byt (cfastore-*-1)|bit7
    .asc "CFA","!"|bit7
#endif
_cfastore
#include "enter.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt #$ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word clit
    .byt #$fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(cfastore01-*+1)
#include "pad.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
cfastore01
    .word clit
    .byt $20
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; set the code field of a new definition, taking page alignment
; into account.
;
; compiler tdict
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;
;       (VOCABLIST)   ( -- )
;
; Sets the VOCABS$ string to the list of vocabularies, chaining up
; from CONTEXT to core
;
: (vocablist)   ( -- )
       vocabs$  context
  ( vocabs$ context )
     begin
  ( vocabs$ context )
         dup @
  ( vocabs$ context parent )
         -rot
  ( parent vocabs$ context )
         vocid
  ( parent vocabs$ vocid )
         tuck
  ( parent vocid vocabs$ vocid )
         c!+
  ( parent id vocabs$+ )
         -rot
  ( vocabs$+ vocab id )
         0=
     until
     2drop ;
;

;--------------------------------------------------------------
;
;       ANCESTOR?   ( -- )
;
; description
;
#ifdef HEADERS
ancestorqlfa
    .byt $de,$ad
    .byt (_ancestorq-*-1)|bit7
    .asc "ANCESTOR","?"|bit7
#endif
_ancestorq

: ?candidate   ( descendant candidate -- )
  ( descendant candidate )
    \ candidate is inactive?
    dup c@ $20 and  		
  ( descendant candidate flag )
    if
  ( descendant candidate )
		\ candidate remains in dictionary? 
		\ and is more recent than prior candidates?
        dup name>  ancestor @  newdp @  between?
  ( descendant candidate flag )
        if
  ( descendant candidate )
            2dup sameasme?
  ( descendant candidate flag )
            if 
                dup name> ancestor !
            then
        then 
    then           
    2drop ;

;--------------------------------------------------------------
;
;       ?ANCESTOR   ( descendant nfa -- )
;
; Searches for a qualifying ancestor and activates it
;
: ?ancestor   ( descendant startnfa -- )
  ( descendant startnfa )
    ancestor off
  ( descendant startnfa )
    begin
  ( descendant nfa )
        dup nfalen
  ( descendant nfa length )
    while
  ( descendant nfa )
        2dup ?candidate
        nfa+
    repeat

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler tdict
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

ccomma
	lda #<(uarea+userdp-userarea)
	sta n
	lda #>(uarea+userdp-userarea)
	sta n+1
	ldy #1
	lda (n),y
	sta n+3
	dey
	lda (n),y
	sta n+2
	lda tos
	sta (n+2),y
	clc
	lda (n),y
	adc #1
	sta (n),y
	bcc ccomma01
	iny
	lda (n),y
	adc #0
	sta (n),y
	jmp pops

: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over 0>
    while
        dup @ $7ff and -
        -1 +under
    repeat
    nip ;

: >pkt   ( n -- packet )
    blkbuf 2- 
 ( n addr )
    begin
 ( n junk )
        swap 1-
 ( n junk )
        dup @
        - swap 1- swap
    repeat
    swap drop ;


;         #vmpkt @ - 0
; ( howmany junk )
;         begin
; ( howmany junk )
;             drop 1-
; ( howmany )
;             editmode @ pkt+
; ( howmany packet )
;             over 0<
;         until
; ( howmany packet )
;         nip
; ( howmany packet )

;--------------------------------------------------------------
;
;		PKTHEAD   ( packet -- uncompressed? len )
;
; Given the address of a packet, set the EDITBLK uservariable to
; true if the packet is editable, false otherwise.
;
#ifdef HEADERS
pktheadlfa
	.byt $de,$ad
	.byt (pkthead-*-1)|bit7
	.asc "PKTHEA","D"|bit7
#endif
pkthead



;--------------------------------------------------------------
;
;       UNPKT ( packet -- blkbuf )
;
; Given the address of a packet (its size/flags word, at the top)
; this will unpack the packet to the block buffer and return
; the address of the unpacked block. Distinguishes among
; compressed/uncompressed and editable/uneditable packets
; * set the EDITBLK flag true if packet is editable, false if readonly
; * leave the linewrap in BLKBUF first 3 bytes if editor
; 
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk ! 
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap b/buf blank	
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf editable? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R;  )
 ( packet size data blkbuf uncompressed? )
    if
	    cmove
	else
	    rldecode
	then
	rfrom ;

    dup @ dup 0< editblk !
 ( packet header ) ( R; blkbuf )
    tuck $7ff and
 ( header packet size ) ( R; blkbuf )
    dup>r - 2+ r> r>
 ( header data size blkbuf )
    2swap editblk @
 ( size blkbuf header data editable? )
    if
 ( header data size ) ( R; blkbuf )
        dup 3c@ r@ 3c!
        3+ r> 3+ >r -3 +under
	then
 ( data blkbuf size uncompressed? )
    if
        cmove
    else
		rldecode
	then
 ( packet header size packet data ) ( R; blkbuf )
    editblk @
 ( packet header size packet data editable? ) ( R; blkbuf )
    if
 ( packet header size packet data ) ( R; blkbuf )
        dup 3c@ r@ 3c! 
        r> 3+ >r
        3+ -3 +under
    then
 ( packet header packet size' data' ) ( R; blkbuf )

 ( packet blkbuf )
    over @ $7ff and
 ( packet blkbuf len )

;#ifdef HEADERS
;unpktlfa
;    .byt $de,$ad
;    .byt (_unpkt-*-1)|bit7|bit5
;    .asc "UNPK","T"|bit7
;    .byt 1
;#endif
_unpkt
#ifdef SWEET16
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank                ; blank the block buffer
#include "page.i65"
    .word to6502
    brk                         ; ( packet blkbuf )
    .byt ld | TOS
    .byt st | R9                ; blkbuf
    .byt st | R10               ; "to"
    .byt pull
    .byt st | N0                ; packet address
    .byt ldd | TOS              ; get packet header
    .byt ext
    .word pktheader16           ; get R11=packet length, N2=editable? N3=uncompressed?
    .byt ld | N0
    .byt sub | R11              ; address of packet data
    .byt st | R13               ; "from" (don't use R12, it turns the packet into the Sweet16 return stack!)
    .byt ld | N2
    .byt bz , <(unpkt01-*-2)    ; data packet?
    .byt ldi | R13              ; copy 3 bytes of linewrap from packet
    .byt sti | R10
    .byt dcr | R11              ; subtract 3 from length
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
unpkt01                         ; start stacking it back up
    .byt ld | R9
    .byt st | TOS               ; blkbuf
    .byt ld | R13
    .byt push                   ; from
    .byt ld | R10
    .byt push                   ; to
    .byt ld | R11
    .byt push                   ; howmany
    .byt ld | N3
    .byt push                   ; uncompressed?
    .byt ld | N2
    .byt push                   ; editable?
    .byt rtn
#include "toforth.i65"
    .word editblk
#include "page.i65"
    .word store
#include "page.i65"
    .word qbranch               ; IF
    .byt <(unpkt03-*+1)
#include "page.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt04-*+1)
#include "page.i65"
unpkt03                         ; ELSE
    .word rldecode
#include "page.i65"
unpkt04                         ; THEN
    .word exit
                                ; ( blkbuf )
#endif

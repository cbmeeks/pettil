; xor of two vectors, to switch between Sweet16 and TIM
brktoggle       .word TIMBRK^SW16
    
;--------------------------------------------------------------
;
;       MON    ( -- )
;
monlfa
    .byt $de,$ad
    .byt (mon-*-1)|bit7
    .asc "MO","N"|bit7
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
;~wut? this only works the first time
mon
    jsr swapzp      ; restore BASIC zpage
sw16
    ldy #2
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne sw16+2
    brk
    .byt rtn
plover          ; if we get here, it's unimplemented
xyzzy
    jmp next        ; used as a breakpoint in secondaries




;--------------------------------------------------------------
;
;       SETIRQ   ( newirq -- oldirq )
;
; Safely changes the IRQ vector at $90-$91 to the new value,
; leaving the previous value on the stack
setirqlfa
    .byt $de,$ad
    .byt (setirq-*-1)|bit7
    .asc "SETIR","Q"|bit7
setirq
    sei
    ldy 1+CINV
    lda CINV                ; old IRQ --> ya
    pha
    lda tos+1
    sta 1+CINV
    lda tos
    sta CINV                ; tos --> IRQ
    pla
    cli
    jmp put



;--------------------------------------------------------------
;
;       FOO ( -- )
;
; hooks/unhooks the IRQ
;
;
foolfa   
    .byt $de,$ad
    .byt (foo-*-1)|bit7
    .asc "FO","O"|bit7
foo
#include "enter.i65"
    .word plit
    .word foostash          ; ( new )
#include "pad.i65"
    .word dup               ; ( new new )
#include "page.i65"
    .word fetch             ; ( new newirq )
#include "page.i65"
    .word clit
    .byt $90                ; ( new newirq live )
#include "pad.i65"
    .word fetch             ; ( new newirq liveirq )
#include "page.i65"
    .word rot               ; ( newirq liveirq new )
#include "page.i65"
    .word store             ; ( newirq )
#include "pad.i65"
    .word setirq
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit
foostash  
    .word fooirq
fooirq    
    ldy #2
fooirq01  
    lda TIME,y
    sta VIDRAM+37,y
    dey
    bpl fooirq01
    jmp (foostash)


;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    brk
    .byt ld | TOS
    .byt st | N0        ; make a copy of the vector address
    .byt ldd | TOS      ; fetch the current target
    .byt pull           ; get the delta
    .byt ext
    .word xor16
    .byt std | N0
    .byt rtn
    cli
    jmp pops            ; [15]


;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
    sei
    jsr toforth
    .word dup
    .word tor
    .word fetch
    .word xor
    .word rfrom
    .word store
    .word to6502
    cli
    jmp next            ; [22]




;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    ldy #0
    lda (tos),y
    eor stackl,x
    sta (tos),y
    iny
    lda (tos),y
    eor stackh,x
    sta (tos),y
    cli
    jmp poptwo          ; [20]

;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    ldy #1
    jsr setup       ; eorvalue to N0
    sei
    iny             ; Y=1
toggleirq01
    lda (tos),y
    eor n,y
    sta (tos),y
    dey
    bpl toggleirq01
    cli
    jmp pops          ; [21]

;--------------------------------------------------------------
;
;       TOGGLEIRQ   ( eorvalue $90|$92 -- )
;
toggleirq
    sei
    brk
    .byt ld | TOS
    .byt st | N0
    .byt ldd | TOS
    .byt pull
    .byt rtn
    ldy #1
toggleirq01
    lda r0,y
    eor tos,y
    sta (n),y
    dey
    bpl toggleirq01
    cli
    jmp pops            ; [24]



;--------------------------------------------------------------
;
;       SETIRQ   ( newvalue -- )
;
    sei
    lda tos
    sta $90
    lda tos+1
    sta $91
    cli
    jmp nxt             ; [13]

;--------------------------------------------------------------
;
;       SETIRQ   ( newvalue -- )
;
    sei
    brk
    .byt set | N0
    .word $90
    .byt ld | tos
    .byt std | N0
    .byt rtn
    cli
    jmp next            ; [12]




;--------------------------------------------------------------
;
;       EDITQ   ( -- )
;
; editor quit
;
;editqlfa
;    .byt $de,$ad
;    .byt (editq-*-1)|bit7
;    .asc "EDIT","?"|bit7
editq
    ldx storex      ; restore data stack pointer
    lda #$55
    sta $90
    lda #$e4
    sta $91         ; restore factory IRQ
    dex
    lda #8
    sta stackl,x
    ldy #0
    sty stackh,x

    lda #<fail
    sta tos
    lda #>fail
    sta tos+1
    cli
    jmp execute     ; drop out to Forth



memory move routine (west p. 355)
.C:b357  38          SEC
.C:b358  A5 57       LDA $57
.C:b35a  E5 5C       SBC $5C
.C:b35c  85 1F       STA $1F
.C:b35e  A8          TAY
.C:b35f  A5 58       LDA $58
.C:b361  E5 5D       SBC $5D
.C:b363  AA          TAX
.C:b364  E8          INX
.C:b365  98          TYA
.C:b366  F0 23       BEQ $B38B
.C:b368  A5 57       LDA $57
.C:b36a  38          SEC
.C:b36b  E5 1F       SBC $1F
.C:b36d  85 57       STA $57
.C:b36f  B0 03       BCS $B374
.C:b371  C6 58       DEC $58
.C:b373  38          SEC
.C:b374  A5 55       LDA $55
.C:b376  E5 1F       SBC $1F
.C:b378  85 55       STA $55
.C:b37a  B0 08       BCS $B384
.C:b37c  C6 56       DEC $56
.C:b37e  90 04       BCC $B384
.C:b380  B1 57       LDA ($57),Y
.C:b382  91 55       STA ($55),Y
.C:b384  88          DEY
.C:b385  D0 F9       BNE $B380
.C:b387  B1 57       LDA ($57),Y
.C:b389  91 55       STA ($55),Y
.C:b38b  C6 58       DEC $58
.C:b38d  C6 56       DEC $56
.C:b38f  CA          DEX
.C:b390  D0 F2       BNE $B384
.C:b392  60          RTS


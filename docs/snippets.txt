;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend uncompressed? )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
; and a flag indication if the data was compressed or not.
;
; If the length of the target exceeds {srclen}-1, RLENCODE will 
; return a flag value of $4000 and simply store the data, 
; otherwise it returns {uncompressed?} = 0.  
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R11   ; output counter - when this hits zero, we're in negative compression
    .byt st | R10   ; input counter - when this hits zero, we're done

    .byt push       ; original size in case we go in the red
    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R11   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R10   ; are we in the red?
    .byt bz , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R11
    .byt sti | N1   ; write output stream
    .byt dcr | R10
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R11
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | R11
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R11              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R10
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt pull
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrapabove
;                                 ( blkbuf d )
;     rot dup >r
;                                 ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r
;                                 ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!
;                                 ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing
;                                 ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
;     r> swap
;                                 ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
;     rlencode
;                                 ( targend uncompressed? ) ( R; blkbuf )
;     over r> - >r
;                                 ( targend uncompressed? ) ( R; size )
;     over 2+ or vidram or swap !
;                                 ( ) ( R; size )
;     r> ;
;                                 ( size )
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore


;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the 
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs 
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( packet blkbuf packet blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( packet blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move move 0
;     then 
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit


mkpkt

copy the linewrap table to blkbuf..blkbuf+2
scrsize = find the size of the screen (last non-blank character)
rlencode or store the current screen to blkbuf+3..+scrsize
newsize = get total size of new packet (3(wrap) + min(scrsize,rlencoded size) + 2(header))
or uncompressed? flag
or editable flag (true because we're storing it)
store the packet header at blkbuf+newsize-2

move vmbuf up or down to create a hole newsize bytes
targdata = calculate target address (packet - newsize + 2)
copy blkbuf into the hole   blkbuf 



scr
packet address of old copy
compressed size of current screen

vmbuf
size of old copy




linewrap blkbuf
3c!

from to howmany
rlencode

packetheader targend 
!


vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2
move

blkbuf packet-newsize+2 newsize
move


>C:0000  00 40 2a 07  02 20 03 30  ef 7b 58 12  80 7c 00 01   .@*.. .0.{X..|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

>C:7b80  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7b90  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7ba0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bb0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff  05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................

>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   
>C:7c20  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   
>C:7c30  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   

after 4 locals
>C:0000  00 40 2a 07  02 20 03 30  ef 7b f4 7b  00 7c 0e 00   .@*.. .0.{.{.|..
>C:0010  05 80 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

after (scr!)
>C:0000  02 80 2a 07  02 20 03 30  02 80 f6 7b  00 7c 0e 00   ..*.. .0...{.|..
>C:0010  05 80 ef 7b  02 00 ff ff  00 01 01 00  00 f5 f9 2c   ...{...........,
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e e6 ef  0e e8 00 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c fb 7b  00 7b 7c 40   ........||.{.{|@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
7bef 7be4 7 move
7c00 7be6 10 move

: scr!   ( scr -- )
    editable? @
    if
        pkt@ blkbuf 2dup
                              ( packet blkbuf packet blkbuf )
        mkpkt swap @ vmbuf @
                              ( packet blkbuf newsize oldsize vmbuf )
        (scr!)
                              ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        move move 0
    then 
    drop ;

;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend uncompressed? )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
; and a flag indication if the data was compressed or not.
;
; If the length of the target exceeds {srclen}-1, RLENCODE will 
; return a flag value of $4000 and simply store the data, 
; otherwise it returns {uncompressed?} = 0.  
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R11   ; output counter - when this hits zero, we're in negative compression
    .byt st | R10   ; input counter - when this hits zero, we're done

    .byt push       ; original size in case we go in the red
    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R11   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R10   ; are we in the red?
    .byt bz , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R11
    .byt sti | N1   ; write output stream
    .byt dcr | R10
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R11
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | R11
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R11              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R10
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt pull
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
: mkpkt   ( blkbuf -- size )
    25 wrapabove
                                ( blkbuf d )
    rot dup >r
                                ( d blkbuf ) ( R; blkbuf )
    dup 3 + >r
                                ( d blkbuf ) ( R; blkbuf blkbuf+3 )
    3c!
                                ( ) ( R; blkbuf blkbuf+3 )
    vidram b/scr -trailing
                                ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
    r> swap
                                ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
    rlencode
                                ( targend flag ) ( R; blkbuf )
    over r> - >r
                                ( targend+2|flag targend blkbuf ) ( R; blkbuf )
     over swap - dup rot ! ;
                                ( size )

;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the 
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs 
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( packet blkbuf packet blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( packet blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move move 0
;     then 
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit


mkpkt

copy the linewrap table to blkbuf..blkbuf+2
scrsize = find the size of the screen (last non-blank character)
rlencode or store the current screen to blkbuf+3..+scrsize
newsize = get total size of new packet (3(wrap) + min(scrsize,rlencoded size) + 2(header))
or uncompressed? flag
or editable flag (true because we're storing it)
store the packet header at blkbuf+newsize-2

move vmbuf up or down to create a hole newsize bytes
targdata = calculate target address (packet - newsize + 2)
copy blkbuf into the hole   blkbuf 



scr
packet address of old copy
compressed size of current screen

vmbuf
size of old copy




linewrap blkbuf
3c!

from to howmany
rlencode

packetheader targend 
!


vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2
move

blkbuf packet-newsize+2 newsize
move

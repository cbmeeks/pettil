;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend uncompressed? )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
; and a flag indication if the data was compressed or not.
;
; If the length of the target exceeds {srclen}-1, RLENCODE will 
; return a flag value of $4000 and simply store the data, 
; otherwise it returns {uncompressed?} = 0.  
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R11   ; output counter - when this hits zero, we're in negative compression
    .byt st | R10   ; input counter - when this hits zero, we're done

    .byt push       ; original size in case we go in the red
    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R11   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R10   ; are we in the red?
    .byt bz , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R11
    .byt sti | N1   ; write output stream
    .byt dcr | R10
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R11
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | R11
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R11              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R10
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt pull
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrapabove
;                                 ( blkbuf d )
;     rot dup >r
;                                 ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r
;                                 ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!
;                                 ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing
;                                 ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
;     r> swap
;                                 ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
;     rlencode
;                                 ( targend uncompressed? ) ( R; blkbuf )
;     over r> - >r
;                                 ( targend uncompressed? ) ( R; size )
;     over 2+ or vidram or swap !
;                                 ( ) ( R; size )
;     r> ;
;                                 ( size )
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore


;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the 
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs 
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( packet blkbuf packet blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( packet blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move move 0
;     then 
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit


mkpkt

copy the linewrap table to blkbuf..blkbuf+2
scrsize = find the size of the screen (last non-blank character)
rlencode or store the current screen to blkbuf+3..+scrsize
newsize = get total size of new packet (3(wrap) + min(scrsize,rlencoded size) + 2(header))
or uncompressed? flag
or editable flag (true because we're storing it)
store the packet header at blkbuf+newsize-2

move vmbuf up or down to create a hole newsize bytes
targdata = calculate target address (packet - newsize + 2)
copy blkbuf into the hole   blkbuf 



scr
packet address of old copy
compressed size of current screen

vmbuf
size of old copy




linewrap blkbuf
3c!

from to howmany
rlencode

packetheader targend 
!


vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2
move

blkbuf packet-newsize+2 newsize
move


>C:0000  00 40 2a 07  02 20 03 30  ef 7b 58 12  80 7c 00 01   .@*.. .0.{X..|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

>C:7b80  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7b90  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7ba0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bb0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff  05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................

>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   
>C:7c20  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   
>C:7c30  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20                   

after 4 locals
>C:0000  00 40 2a 07  02 20 03 30  ef 7b f4 7b  00 7c 0e 00   .@*.. .0.{.{.|..
>C:0010  05 80 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

after (scr!)
>C:0000  02 80 2a 07  02 20 03 30  02 80 f6 7b  00 7c 0e 00   ..*.. .0...{.|..
>C:0010  05 80 ef 7b  02 00 ff ff  00 01 01 00  00 f5 f9 2c   ...{...........,
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e e6 ef  0e e8 00 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c fb 7b  00 7b 7c 40   ........||.{.{|@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
7bef 7be4 7 move
7c00 7be6 10 move
(scr!)
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull
    .byt add | R10
    .byt st | TOS               ; end of new packet
    .byt popd | TOS             ; new packetheader
    .byt ext 
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
    
: scr!   ( scr -- )
    editable? @
                                ( scr flag )
    if
                                ( scr )
        dup pkt@ blkbuf tuck
                                ( scr blkbuf packet blkbuf )
        vmbuf @ -rot
                                ( scr blkbuf vmbuf packet blkbuf )
        dup mkpkt
                                ( scr blkbuf vmbuf packet blkbuf newlen )
        (scr!)
                                ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        move
                                ( scr blkbuf packet-newsize+2 newsize )
        move
                                ( scr )
    then 
                                ( scr )
    drop ;

7bef 7be4 7 move
7c00 7be6 10 move

>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff ^05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................
>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  be be be be  be be be be  be be be be  be be be be   ................
>C:7c20  be be be be  be be be be  be be be be  be be be be   ................
>C:7c30  be be be be  be be be be  be be be be  be be be be   ................
>C:7c40  be be be be  be be be be  be be be be  be be be be   ................

(C:$2d0b) m 0
>C:0000  00 40 2a 07  02 20 03 30  0e 00 a2 12  80 7c 00 01   .@*.. .0.....|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 00 0e  10 10 00 f4  ef 00 02 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 7c 7c  40 c0 7c 7b  7b 7c 00 40   ......||@.|{{|.@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1d  2d 00 07 fe   ..........l.-...
(C:$0090) r
  ADDR AC XR YR SP 00 01 NV-BDIZC LIN CYC  STOPWATCH
.;2ce0 2d 2a 00 f0 00 40 00110000 011 036   31170532

0e      newlen
7c00    blkbuf
7bf4    packet






pscrstore
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull                   ; blkbuf
    .byt add | R10              ; newpacket
    .byt st | TOS               ; end of new packet
    .byt ldd | TOS              ; new packetheader
    .byt ext 
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
    .byt ld | R11
    .byt st | R9                ; newsize
    .byt pull
    .byt st | N0                ; packet
    .byt ldd | TOS              ; old packetheader
    .byt ext
    .word pktheader16
    .pull                       ; vmbuf
    .byt st | N3
    .byt ld | N0
    .byt sub | R9
    .byt st | TOS
    .byt ld | R9
    .byt push
    .byt ld | N3
    .byt push
    .byt add | R11
    .byt sub | R9
    .byt push
    .byt ld | N0
    .byt sub | R11
    .byt sub | N3
    .byt push
    .byt nxt
    
    
;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
#ifdef HEADERS
bashtrailinglfa .byt $de,$ad
    .byt (_bashtrailing-*-1)|bit7
    .asc "+TRAILIN","G"|bit7
#endif
_bashtrailing
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
bashtrailing01
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word ne
#include "page.i65"
    .word pqleave
    .byt <(bashtrailing02-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word ploop
    .byt <(bashtrailing01-*+1)
#include "pad.i65"
bashtrailing02
    .word exit



dashtrailing
    brk
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt ext
    .word dashtrailing16
    .byt ld | N0
    .byt push
    .byt nxt

sum = addr + size

83e8

bcs exit

size =  3
        e8

    ldy sum_low
    lda #0
    sta sum_low
tight
    dey
    bne a

    bcc nextpage
    bcs zero
    dec sum_high
    dec count_high
    bne a
    sec

    
a   lda (sum),y
    cmp #' '
    beq tight
foundnonblank
    sty sum_low
    rts


two reasons you can exit
found nonblank
ran out of string


8050
 100

8150
;
;
;inputs
;   TOS (R4) = addr
;   N0 (R5) = addr+size
;   N1 (R6) = count 
;returns
;   TOS = addr (unchanged)
;   N0 = addr of last non-blank character (= addr if all are blank)
    ;clc
dashtrailing16
    ldy n                       ; address low byte
    bne dashtrailing16b
dashtrailing16a                 ; another page
    bcs dashtrailing16c
    dec n+1                     ; address high byte
    dec n+3                     ; counter high byte
    bne dashtrailing16b
    sec                         ; flag last page
dashtrailing16b
    dey
    beq dashtrailing16a
    lda (n+2),y
    eor #$20
    beq dashtrailing16b
dashtrailing16c
    sty n
    rts

voctag 1+ c@ max tag so far 
voctag c@ 0= core vocabulary
voctag c@ nametag c@ = this word is in current vocab
vocabular definition
jsr dovocab
.byt voctag
.word parent

rehash
target=SYMTAB
            +8 bloom filter
            +32 threads
            +2 newstuff
there is a pile of symbol table sitting at PAD
for each thread 0..f
    for each possible length 1..31
        is the CFA<HERE? if >+ we'll skip this one
            copy it to target
            target = target + symbol size
                 vocabularies have 2 extra bytes at the end



;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; tdict
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table 
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?         (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya


;--------------------------------------------------------------
;
;        SYMSIZ   ( -- n )
;
; returns the size of the symbol table
;
#ifdef HEADERS
symsizlfa
    .byt $de,$ad
    .byt (_symsiz-*-1)|bit7
    .asc "SYMSI","Z"|bit7
#endif
_symsiz
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
symsiz01
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "page.i65"
    .word andx
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(symsiz02-*-2)
#include "pad.i65"
    .word plus
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word branch
    .byt <(symsiz01-*-2)
#include "pad.i65"
symsiz02
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit      ; [38]

code symsiz   ( symbols -- )
    brk
    .byt inr | TOS
    .byt inr | TOS
    .byt rtn
symsiz01
    lda (tos),y
    
nfatocfa
    sec
    lda tos
    sbc #2
    sta tos
    bcs nfatocfa01
    dec tos+1
nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[24]

nfatocfa
    sec
    lda tos
    sbc #2
    sta n
    lda tos+1
    sbc #0
    sta n+1
    ldy #0
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    jmp next ;[28]


;--------------------------------------------------------------
;
;       BLOOMHASH   ( nfa -- bloomhash )
;
; Calculate the bloom filter hash.  For words containing any
; digits at all, this will be a total of each digit+1, or a 
; nonzero value 1..63.  For words which have no digits, return 
; bloomhash will be zero.  This is expected to sparsely populate 
; the 64 bloom filter bits, allowing FIND to bypass the symbol 
; table search if the bit is turned off.
;
#ifdef HEADERS
bloomhashlfa
    .byt $de,$ad
    .byt (bloomhash-*-1)|bit7
    .asc "BLOOMHAS","H"|bit7
#endif
bloomhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f
    sty n
    tay
bloomhash01
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash02             ;[3] carry is set only for digits 
    adc n                       ;[3] anything with digits is nonzero
    and #(8*(bloomx-bloom))-1   ;[2] keep it within the filter bits
    sta n                       ;[3]
    bne bloomhash02
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash02
    dey
    bne bloomhash01
bloomhash03
    ;lda n
    ;ldy #0
    ldx storex
    jmp put

;": eligible?   ( hash searchlen nfa -- pearsonhash bloomhash flag )
;     dup c@ $1f and
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         dup indict?
;
;         2drop true ( more processing later )
;     else
;         2drop false
;     then ;
#ifdef HEADERS
eligibleqlfa
    .byt $de,$ad
    .byt (eligibleq-*-1)|bit7
    .asc "ELIGIBLE","?"|bit7
#endif
eligibleq
    ldy #2
    jsr locals
    ;ldy #0
    lda (tos),y
    and #$1f
    eor n                       ; same length?
    bne eligibleq05
    brk
    .byt set | R11
    .word uarea+userdp-userarea
    .byt set | R10
    .word uarea+usertdict-userarea
    .byt popd | TOS             ; CFA
    .byt st | N2
    .byt ldd | R11              ; DP
    .byt cpr | N2
    .byt bm , <(eligibleq02-*-2)    ; not in core dictionary? bail
    .byt cpr | R10              ; TDICT
    .byt bp , <(eligibleq02-*-2)    ; not in temp dictionary either? bail
    .byt rtn
    jsr dhash6502

eligibleq02
    .byt rtn
    
    
;": indict?   ( nfa -- flag )
;       nfa>cfa tdict @ over u< swap here u< or ;
#include "enter.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "pad.i65"
    .word andx
#include "page.i65"
    .word rot
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(eligibleq04-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word true
#include "page.i65"
    .word branch
    .byt <(eligibleq05-*+1)
#include "pad.i65"
eligibleq04
    .word twodrop
#include "page.i65"
    .word false
#include "page.i65"
eligibleq05
    .word exit

nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[13]

;--------------------------------------------------------------
;
;       SYMBYSIZE   ( searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
;
;": symbysize   ( searchlen nfa -- flag )
;     dup nfalen rot =
;     ( nfa samelength? ) 
;      dup
;      if
;          ( nfa samelength? )
;          drop indict? 
;      then ;  ( flag )
;
;--------------------------------------------------------------
;
;       SYMBYHASH   ( hash nfa -- flag )
;
; returns true iff
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": symbyhash   ( hash nfa -- flag )
;     pearsonhash = ;
;
;--------------------------------------------------------------
;
;       ELIGIBLE?   ( hash searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": eligible?   ( hash searchlen nfa -- flag )
;     dup nfalen
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         ( hash nfa )
;         dup indict?
;         ( hash nfa indict? )
;         if
;             ( hash nfa )
;             pearsonhash =
;             ( flag )
;         else                  ( code smell alert -- )
;             2drop false       ( both elses are sort of cheesily combined )
;         then
;     else
;         2drop false
;     then ;
;
;--------------------------------------------------------------
;
;       SYMSORT   ( 'compare searchfor src dest -- src+ dest+ )
;
; Make a pass through the symbol table at PAD, copying eligible
; symbols to target
;": symsort   ( 'compare searchfor src dest )
;     >r 2+
;     ( 'compare searchfor nfa ) ( R; target )
;     begin
;         \ not done yet?
;         dup nfalen
;         ( 'compare searchfor nfa currlen ) ( R; target )
;     while
;         ( 'compare searchfor nfa ) ( R; target )
;         3dup rot execute
;         ( 'compare searchfor nfa flag ) ( R; target )
;         if
;             \ copy it up to the new symbol table
;             ( 'compare searchfor nfa ) ( R; target )
;             r@ over
;             ( 'compare searchfor nfa target nfa ) ( R; target )
;             sym+
;             ( 'compare searchfor nfa ) ( R; target )
;             \ advance target pointer
;             r> 2+ nfa+ 2- >r
;             ( 'compare searchfor nfa ) ( R; target+ )
;         then
;         \ advance source pointer
;         nfa+
;         ( 'compare searchfor nfa+ ) ( R; target+ )
;     repeat
;     ( 'compare searchlen nfa+ ) ( R; target+ )
;     r> 2swap 2drop ;   ( target+ )
;
: (rehash)   ( src targ 'compare -- )
    do rot drop i -rot symsort loop 2drop ;
: rehash  ( -- )
    pad >syms 2dup swap
    32 1 ['] symbysize (rehash)
    symtab @ 32 erase
    [ bloom ] literal 8 erase
    16 0 ['] symbyhash (rehash)

.C:0d23   .twominus:
.C:0d23  38          SEC
.C:0d24  A5 08       LDA $08
.C:0d26  E9 02       SBC #$02
.C:0d28  85 08       STA $08
.C:0d2a  B0 02       BCS .twominus01
.C:0d2c  C6 09       DEC $09
.C:0d2e   .twominus01:
.C:0d2e  4C 86 00    JMP .next
.C:0d31   .twoslash:

ldy tos
cpy #2
dey
dey
tya
ldy tos+1
bcs +
dey
jmp put

lda tos
sec
sbc #2
ldy tos+1
bcs +
dey
jmp put

;--------------------------------------------------------------
;
;       2+
;
twoplus
    ldy tos+1
    lda #2
twoplusminus
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    ldy tos+1
    dey
    lda #$fe
    bne twoplusminus            ; bra

;--------------------------------------------------------------
;
;       2+
;
twoplus
    lda #2
twoplusminus
    ldy tos+1
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    dec tos+1
    lda #$fe
    bne twoplusminus            ; bra

twominus
    dec tos+1
    lda #$fe
    .byt $2c ; 'bit absolute'
twoplus
    lda #2
    clc
    adc tos
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next

;--------------------------------------------------------------
;
;       DOCONST
;
doconst
	ldy #2
	.byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
	ldy #1
	jsr slip
    pla
    sta n
    pla
    sta n+1
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    sta tos-1,y
	ora #$7f
	bmi neg
	lda #0
neg
	dey
	beq done
    lda (n),y       ; high byte if CONST, low byte if CCONST
done
	sta tos+1
	jmp next

	dey
	bne	doconst02
	ora #0			; one-byte constant, sign-extend A into Y
	bpl doconst03
	dey
doconst02
	lda (n),y
	
doconst03
	jmp pushya

        ; calculates upper byte of sign-extension of A
        ora #$7F
        bmi neg
        lda #0
neg:

    sta n+2
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya


;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    pla
    sta n
    pla
    sta n+1
    ldy #2
    lda (n),y
    sta n+2         ; high byte
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya


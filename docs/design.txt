EDITOR

Forth blocks and the PET full screen editor are a natural symbiosis.
To accomplish this, all I had to do was hook the IRQ vector to escape 
the STOP key.  The screen flashes, and the following keystroke is an
editor command.  Entire screens, including the linewrap table, are 
compressed and then moved, where they build downward from  the top of
memory.  This region is preserved on mass storage in sequential files.  
There are also editor commands to import/export screens in an unpacked,
CR-delimited format for non-native editing.

screens to/from CR-delimited only? 
	no line wrap tables
	simplifies UI design to just STOP-S / STOP-L
	probably easier for INTERPRET loop
	uses CHRIN kernel routine to copy screen
what about reverse-field, just a screen full of graphics?  Should there
be an option to store screens as RLE-compressed screen codes and a copy
of the line-wrap table?  What about 1K blocks of binary data?

edit - invoke the editor on the most recent screen or whatever is displayed

Editor commands begin with STOP, which flashes the screen

general
STOP SPACE - cancel editor command
STOP Q - save current screen, exit the editor
STOP CLR - reset linewrap table to all 40-char lines

screen navigations
STOP HOME - first screen
STOP UP - previous screen
STOP DOWN - next screen
STOP INS - insert a blank screen before the current screen
STOP DEL - delete the current screen.  go to next then prev then blank
STOP I - index, displays top 40 characters of active buffers

mass storage
STOP S - save screens to file
STOP L - load a file of screens

line copy/paste buffer
STOP Z - zilch the paste buffer.  There is no undo, only do.
STOP X - cut the current line, append to paste buffer
STOP C - copy the current line, append to paste buffer
STOP V - paste the buffer (whole lines only) here


Screens are compressed/decompressed on the fly with some combination
of RLE/LZ/Rad50

7C00 - 7FFF   1024 byte work buffer (1000 chars + line wrap table)
7BFE - 7BFF   link address of "current" buffer
7BFC - 7BFD   1st buffer link (0 if no buffers)
7x   - 7BFB   compressed buffer 1 (home)
7x-2          address of next buffer link (chain ends with 0)
PAD           copy/paste buffer


Events / Multitasking

Have some sort of event queue, where high level words are triggered
by the jiffy clock IRQ.  See Garth's design

The IRQ counts down a timer, with events triggered at their expiration

oneshot   ( jiffies cfa -- ; add a one-time event to the queue )
repeat   ( jiffies cfa -- ; add a repeating event to the queue )

use the event queue to flash the screen in the editor for 5 jiffies


DICTIONARY
inner interpreter primitives
nucleus layer
device layer
interpreter layer
compiler layer


setirq pla
 sta n
 pla
 sta n+1
 sei           ; disable interrupts
 brk
 .byt inr | N0 ; bump the RTS address
 .byt ldd | N0 ; retrieve the word
 .byt set | N0 ; IRQ vector
 .word $0090
 .byt std | N0 ; set the new IRQ vector
 .byt rtn      ; done
 cli           ; enable interrupts
 rts
 
 jsr hookirq
irqhandler

hookirq
 sei
 pla
 tay
 pla
 sta $91
 iny
 sty $90
 bne +
 inc $91
+ cli
 jmp next

CREATE
need to align the code field to avoid jmp ($xxFF) bug

38 characters is the maximum idea size
because there are spaces before, after
ideas appear here when space is struck


EDIT ( -- ; invokes the full screen editor )

general
    STOP STOP
    - nothing happens. The editor continues to wait for the second keypress
    STOP any key (cancel)
    - cancel editor command, return to edit mode
    STOP Q       (quit)
    - buffer current screen, drop out of the editor to the Forth command line
    STOP CLR     (unwrap)
    - reset linewrap table to all 40-char lines

screen navigation
    STOP HOME    (pagetop)
    - buffer current screen, display first screen
    STOP UP      (pageup)
    - buffer current screen, display previous (or new) screen
    STOP DOWN    (pagedown)
    - buffer current screen, display next (or new) screen
    STOP INS     (insertscreen)      
    - buffer current screen, display a new blank screen inserted before it
    STOP DEL     (deletescreen)
    - delete the current screen, display next, then previous, then blank screen
    STOP I       (index)
    - display an index screen of just the top lines (first 40 characters) of 
      all active buffers (max 25). Moving the cursor to any index line and
      hitting return will display that screen.

mass storage
    STOP S       (save)
    - prompt for a filename and device, save all buffered screens on mass storage as PRG file
    STOP L       (load) 
    - prompt for a filename and device, load a PRG file containing buffered screens, display first
    STOP V       (verify) 
    - prompt for a filename and device, verify memory buffer vs. saved PRG file

line copy/paste buffer
    STOP Z       (zilch)
    - zilch the paste buffer at PAD. Do or do not. There is no undo.
    STOP R       (restore) 
    - restore the current screen from the last time it was buffered e.g. by STOP UP or STOP Q
    STOP D       (deleteline)
    - delete the current logical line (40 or 80 characters), append to paste buffer. (like "dd" in vi)
    STOP C       (copy)
    - copy the current logical line, append to paste buffer
    STOP P       (paste)
    - insert the entire paste buffer (whole lines only) at the current cursor line (like "P" in vi) 

copy only needs to know whether the current line is 80 or 40

for cut and paste, everything depends on knowing that PLUS the size of each line below the current logical line

the $e0 table can be checked


for cut, cmove one line at a time up either 80 or 40, then fill the bottom of the screen with 80 or 40

for paste, append everything from the current line to the end of the screen to the paste buffer
you can stop appending when paste buffer size > 1024 bytes
then, copy everything from the paste buffer up to line 25 back to the screen, setting line lengths as we go

Q: what happens if someone attempts a STOP-Restore when no block exists?
A: the editor always has a block

distinguish screens from blocks
first 3 bytes are linewrap high bits for lines 1..24 ($e1-f8) 
there can't be two consecutive 0 bits in that 3 bytes

packet address = the address of the packet header
last 2 bytes are the packet header
packet header = editor flag ($8000) and uncompressed flag ($4000), packet size
packet size = (packet header & $7ff) the total length of the packet including header
packet length = (packet header & $7ff) - 2, the length of the packet data
packet data is from (packet address - packet length) to (packet address - 1)
screen packet - first three bytes are linewrap

new data packet
packet data     00 00 00    four null*256 RLE packets
                00 00 00
                00 00 00
                00 00 00
packet address  0e 00       packet header

new screen packet
packet data     FF FF FF    three bytes of linewrap for lines 1..24
packet address  05 80       packet header with editable ($8000) bit set

REHASH
move everything down to pad in sorted threaded order
block move the whole thing back

search order

context @
begin
    
while
    (findvocab)
    chain to parent vocabulary
repeat
(findcore)


(findcore)
search new words
dhash
search core by hash


create

context @
current !
find


defining words in a vocabulary 
    add 2 to the length
    suffix with the vocabulary link




forget




words
context @
collect all the CFAs at pad, with addresses of their symbols





core definition symbol
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $1467                 | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
[0]             | immediate bit   +2 name field length/flags byte
| [0]           | smudge bit
|   [0]_________| vocabulary bit
|     [    5    ] name length 0..31
+-+-+-+-+-+-+-+-+
|      A        |                 +3 name field first letter
+-+-+-+-+-+-+-+-+
|      L        |
+-+-+-+-+-+-+-+-+
|      L        |
+-+-+-+-+-+-+-+-+
|      O        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter
+-+-+-+-+-+-+-+-+

vocabulary definition symbol
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $22F3                 | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
[0]             | immediate bit   +2 name field length/flags byte
| [0]           | smudge bit
|   [1]_________| vocabulary bit
|     [    4    ] name length (0..31)
+-+-+-+-+-+-+-+-+
|      E        |                 +3 name field first letter
+-+-+-+-+-+-+-+-+
|      D        |
+-+-+-+-+-+-+-+-+
|      I        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $7536                 | +n+1 vocabulary link (0 for last)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

vocabulary entry
+-+-+-+-+-+-+-+-+
|    jsr        |                 +0 code
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    dovocab                    | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    first word in vocabulary   | +3 first word
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    parent vocab (0 = core)    | +5 parent vocabulary
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



+---------------+
| video         | $8000-$83ff video memory
+===============+
| heads         | $7400-$7fff symbol table
+---------------+
|temp dictionary| $6800-$73ff interpreter/compiler
+---------------+
| block buffer  | $6400-$67ff 1K block buffer
+---------------+
| ramdisk       | $63ff
| packets       |
|   |           |
|   |           |
|   v           |
|               |
   ...           
|               |
|   ^           | PAD
|   |           | HERE
|   |           |
| dictionary    |
| bodies        | $0400
+---------------+
| tape buffers  |
| and stuff     | $0200-$03ff
+---------------+
| stack page    | $0100-$01ff
+---------------+
| zero page     | $0000-$00ff
+---------------+
+-+-+-+-+-+-+-+-+
|      D        |
+-+-+-+-+-+-+-+-+
|      I        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter


-----symtab---
32 bytes corehash
===

 8 bytes pearson table
 8 bytes bloom filter
move pearson/bloom to the end of the core dictionary, so they can be
directly accessed.  Let FORGET-called-by-COLD add 16 to DP to enclose
this data. 


REHASH - high level
called by COLD to move the symbol table up from PAD to the top of memory
erase bloom filter
erase corehash table (formerly lfalist)
cmove the whole symbol table to pad

target = symtab+8+32+2		; start returning things here
if called by COLD
	scan forward for a 0 length.  This delimits the temp dictionary
	the next word is a himem load address where the temporary dictionary
	would load
	copy everything from that point to $7FFF
else
	target
	pad
	over newstuff @ swap - 		; newstuff-target
	cmove
endif

corehash[0] = target
for ihash = 0 to 15
	corehash[ihash] = target
	for ilength = 1 to 31
		for each symbol
			set the bloom filter bit.  It does not matter if we do this multiple times.
			if (ilength = symbol.length) and (ihash = symbol.hash)
				copy symbol back to symtab
				target += symbol.length+2
				if symbol.isvocab
					target += 2 
				endif
			endif
		next
	next
next
startup ['] abort  over !  @ execute

LOCALS
alwwys on zero page
implied fetch
separate word for store

4 locals
n4!
0  dup local r0acc  local! r0acc!
2  dup local r1up   local! r1up!
4  dup local r2i    local! r2i!
6  dup local r3lim  local! r3lim!
8  dup local r4tos  local! r4tos!
10 dup local n0     local! n0!
12 dup local n1     local! n1!
14 dup local n2     local! n2!
16 dup local n3     local! n3!
18 dup local n4     local! n4!
20 dup local n5     local! n5!
22 dup local r11ext local! r11ext!
24 dup local r12sp  local! r12sp!
26 dup local r13cpr local! r13cpr!
28 dup local r14st  local! r14st!
30 dup local r15pc  local! r15pc!

: local 
   create c, 
   ;code
   jsr slip
   ldy #0
   lda (tos),y
   sty tos+1
   sta tos
   lda (tos),y
   sta tos
   jmp next

: local!
   create c,
   ;code
   ldy #0
   lda (tos),y
   tay
   lda stackl,x
   sta 0,y
   lda stackh,y
   sta 1,y
   jmp poptwo

code nfa+
    ldy #0
    lda (tos),y
    and #$1f
    clc
    adc #3
    adc tos
    sta tos
    bcc +
    inc tos
+   jmp next

[20]
: nfa+
	dup c@ $1f and 3 + + ;

code nfa+		( nfa -- nfa+ )
	brk
	

: foo 4002 4000 ! 4002 jiffy@ third 2000 0 do >cfa loop drop jiffy@ 2swap d- du. ;
: >cfa   ( nfa -- cfa )
    2- @ ;
code >cfa   ( nfa -- cfa )
    brk
    .byt   popd | TOS
    .byt   st | TOS
    .byt   nxt




FAIL is vectored like EMIT and KEY
In the core-only, it just says "ERROR#" and the number, then MON (via WARM?)
in pettil development environment, it prints a canned message, then ABORT

EDITOR

Forth blocks and the PET full screen editor are a natural symbiosis.
To accomplish this, all I had to do was hook the IRQ vector to escape 
the STOP key.  The screen flashes, and the following keystroke is an
editor command.  Entire screens, including the linewrap table, are 
compressed and then moved, where they build downward from  the top of
memory.  This region is preserved on mass storage in sequential files.  
There are also editor commands to import/export screens in an unpacked,
CR-delimited format for non-native editing.

screens to/from CR-delimited only? 
	no line wrap tables
	simplifies UI design to just STOP-S / STOP-L
	probably easier for INTERPRET loop
	uses CHRIN kernel routine to copy screen
what about reverse-field, just a screen full of graphics?  Should there
be an option to store screens as RLE-compressed screen codes and a copy
of the line-wrap table?  What about 1K blocks of binary data?

edit - invoke the editor on the most recent screen or whatever is displayed

Editor commands begin with STOP, which flashes the screen

general
STOP SPACE - cancel editor command
STOP Q - save current screen, exit the editor
STOP CLR - reset linewrap table to all 40-char lines

screen navigations
STOP HOME - first screen
STOP UP - previous screen
STOP DOWN - next screen
STOP INS - insert a blank screen before the current screen
STOP DEL - delete the current screen.  go to next then prev then blank
STOP I - index, displays top 40 characters of active buffers

mass storage
STOP S - save screens to file
STOP L - load a file of screens

line copy/paste buffer
STOP Z - zilch the paste buffer.  There is no undo, only do.
STOP X - cut the current line, append to paste buffer
STOP C - copy the current line, append to paste buffer
STOP V - paste the buffer (whole lines only) here


Screens are compressed/decompressed on the fly with some combination
of RLE/LZ/Rad50

7C00 - 7FFF   1024 byte work buffer (1000 chars + line wrap table)
7BFE - 7BFF   link address of "current" buffer
7BFC - 7BFD   1st buffer link (0 if no buffers)
7x   - 7BFB   compressed buffer 1 (home)
7x-2          address of next buffer link (chain ends with 0)
PAD           copy/paste buffer


Events / Multitasking

Have some sort of event queue, where high level words are triggered
by the jiffy clock IRQ.  See Garth's design

The IRQ counts down a timer, with events triggered at their expiration

oneshot   ( jiffies cfa -- ; add a one-time event to the queue )
repeat   ( jiffies cfa -- ; add a repeating event to the queue )

use the event queue to flash the screen in the editor for 5 jiffies


DICTIONARY
inner interpreter primitives
nucleus layer
device layer
interpreter layer
compiler layer


setirq pla
 sta n
 pla
 sta n+1
 sei           ; disable interrupts
 brk
 .byt inr | N0 ; bump the RTS address
 .byt ldd | N0 ; retrieve the word
 .byt set | N0 ; IRQ vector
 .word $0090
 .byt std | N0 ; set the new IRQ vector
 .byt rtn      ; done
 cli           ; enable interrupts
 rts
 
 jsr hookirq
irqhandler

hookirq
 sei
 pla
 tay
 pla
 sta $91
 iny
 sty $90
 bne +
 inc $91
+ cli
 jmp next

CREATE
need to align the code field to avoid jmp ($xxFF) bug

38 characters is the maximum idea size
because there are spaces before, after
ideas appear here when space is struck


EDIT ( -- ; invokes the full screen editor )

general
    STOP STOP
    - nothing happens. The editor continues to wait for the second keypress
    STOP any key (cancel)
    - cancel editor command, return to edit mode
    STOP Q       (quit)
    - buffer current screen, drop out of the editor to the Forth command line
    STOP CLR     (unwrap)
    - reset linewrap table to all 40-char lines

screen navigation
    STOP HOME    (pagetop)
    - buffer current screen, display first screen
    STOP UP      (pageup)
    - buffer current screen, display previous (or new) screen
    STOP DOWN    (pagedown)
    - buffer current screen, display next (or new) screen
    STOP INS     (insertscreen)      
    - buffer current screen, display a new blank screen inserted before it
    STOP DEL     (deletescreen)
    - delete the current screen, display next, then previous, then blank screen
    STOP I       (index)
    - display an index screen of just the top lines (first 40 characters) of 
      all active buffers (max 25). Moving the cursor to any index line and
      hitting return will display that screen.

mass storage
    STOP S       (save)
    - prompt for a filename and device, save all buffered screens on mass storage as PRG file
    STOP L       (load) 
    - prompt for a filename and device, load a PRG file containing buffered screens, display first
    STOP V       (verify) 
    - prompt for a filename and device, verify memory buffer vs. saved PRG file

line copy/paste buffer
    STOP Z       (zilch)
    - zilch the paste buffer at PAD. Do or do not. There is no undo.
    STOP R       (restore) 
    - restore the current screen from the last time it was buffered e.g. by STOP UP or STOP Q
    STOP D       (deleteline)
    - delete the current logical line (40 or 80 characters), append to paste buffer. (like "dd" in vi)
    STOP C       (copy)
    - copy the current logical line, append to paste buffer
    STOP P       (paste)
    - insert the entire paste buffer (whole lines only) at the current cursor line (like "P" in vi) 

copy only needs to know whether the current line is 80 or 40

for cut and paste, everything depends on knowing that PLUS the size of each line below the current logical line

the $e0 table can be checked


for cut, cmove one line at a time up either 80 or 40, then fill the bottom of the screen with 80 or 40

for paste, append everything from the current line to the end of the screen to the paste buffer
you can stop appending when paste buffer size > 1024 bytes
then, copy everything from the paste buffer up to line 25 back to the screen, setting line lengths as we go

Next steps
add some user variables
RAMTOP -- give this the same name as the basic zp variable.  Seed it with the zero page value at COLD

at cold, zero virtual memory
ramtop 1024 - 2- off
what happens if someone attempts a STOP-Restore when no block exists?

EDITOR

Forth blocks and the PET full screen editor are a natural symbiosis.
To accomplish this, all I had to do was hook the IRQ vector to escape
the STOP key.  The screen flashes, and the following keystroke is an
editor command.  Entire screens, including the linewrap table, are
compressed and then moved, where they build downward from  the top of
memory.  This region is preserved on mass storage in sequential files.
There are also editor commands to import/export screens in an unpacked,
CR-delimited format for non-native editing.

screens to/from CR-delimited only?
    no line wrap tables
    simplifies UI design to just STOP-S / STOP-L
    probably easier for INTERPRET loop
    uses CHRIN kernel routine to copy screen
what about reverse-field, just a screen full of graphics?  Should there
be an option to store screens as RLE-compressed screen codes and a copy
of the line-wrap table?  What about 1K blocks of binary data?

edit - invoke the editor on the most recent screen or whatever is displayed

Editor commands begin with STOP, which flashes the screen

general
STOP SPACE - cancel editor command
STOP Q - save current screen, exit the editor
STOP CLR - reset linewrap table to all 40-char lines

screen navigations
STOP HOME - first screen
STOP UP - previous screen
STOP DOWN - next screen
STOP INS - insert a blank screen before the current screen
STOP DEL - delete the current screen.  go to next then prev then blank
STOP I - index, displays top 40 characters of active buffers

mass storage
STOP S - save screens to file
STOP L - load a file of screens

line copy/paste buffer
STOP Z - zilch the paste buffer.  There is no undo, only do.
STOP X - cut the current line, append to paste buffer
STOP C - copy the current line, append to paste buffer
STOP V - paste the buffer (whole lines only) here


Screens are compressed/decompressed on the fly with some combination
of RLE/LZ/Rad50

7C00 - 7FFF   1024 byte work buffer (1000 chars + line wrap table)
7BFE - 7BFF   link address of "current" buffer
7BFC - 7BFD   1st buffer link (0 if no buffers)
7x   - 7BFB   compressed buffer 1 (home)
7x-2          address of next buffer link (chain ends with 0)
PAD           copy/paste buffer


Events / Multitasking

Have some sort of event queue, where high level words are triggered
by the jiffy clock IRQ.  See Garth's design

The IRQ counts down a timer, with events triggered at their expiration

oneshot   ( jiffies cfa -- ; add a one-time event to the queue )
repeat   ( jiffies cfa -- ; add a repeating event to the queue )

use the event queue to flash the screen in the editor for 5 jiffies


DICTIONARY
inner interpreter primitives
nucleus layer
device layer
interpreter layer
compiler layer


setirq pla
 sta n
 pla
 sta n+1
 sei           ; disable interrupts
 brk
 .byt inr | N0 ; bump the RTS address
 .byt ldd | N0 ; retrieve the word
 .byt set | N0 ; IRQ vector
 .word $0090
 .byt std | N0 ; set the new IRQ vector
 .byt rtn      ; done
 cli           ; enable interrupts
 rts

 jsr hookirq
irqhandler

hookirq
 sei
 pla
 tay
 pla
 sta $91
 iny
 sty $90
 bne +
 inc $91
+ cli
 jmp next

CREATE
need to align the code field to avoid jmp ($xxFF) bug

38 characters is the maximum idea size
because there are spaces before, after
ideas appear here when space is struck


EDIT ( -- ; invokes the full screen editor )

general
    STOP STOP
    - nothing happens. The editor continues to wait for the second keypress
    STOP any key (cancel)
    - cancel editor command, return to edit mode
    STOP Q       (quit)
    - buffer current screen, drop out of the editor to the Forth command line
    STOP CLR     (unwrap)
    - reset linewrap table to all 40-char lines

screen navigation
    STOP HOME    (pagetop)
    - buffer current screen, display first screen
    STOP UP      (pageup)
    - buffer current screen, display previous (or new) screen
    STOP DOWN    (pagedown)
    - buffer current screen, display next (or new) screen
    STOP INS     (insertscreen)
    - buffer current screen, display a new blank screen inserted before it
    STOP DEL     (deletescreen)
    - delete the current screen, display next, then previous, then blank screen
    STOP I       (index)
    - display an index screen of just the top lines (first 40 characters) of
      all active buffers (max 25). Moving the cursor to any index line and
      hitting return will display that screen.

mass storage
    STOP S       (save)
    - prompt for a filename and device, save all buffered screens on mass storage as PRG file
    STOP L       (load)
    - prompt for a filename and device, load a PRG file containing buffered screens, display first
    STOP V       (verify)
    - prompt for a filename and device, verify memory buffer vs. saved PRG file

line copy/paste buffer
    STOP Z       (zilch)
    - zilch the paste buffer at PAD. Do or do not. There is no undo.
    STOP R       (restore)
    - restore the current screen from the last time it was buffered e.g. by STOP UP or STOP Q
    STOP D       (deleteline)
    - delete the current logical line (40 or 80 characters), append to paste buffer. (like "dd" in vi)
    STOP C       (copy)
    - copy the current logical line, append to paste buffer
    STOP P       (paste)
    - insert the entire paste buffer (whole lines only) at the current cursor line (like "P" in vi)

copy only needs to know whether the current line is 80 or 40

for cut and paste, everything depends on knowing that PLUS the size of each line below the current logical line

the $e0 table can be checked


for cut, cmove one line at a time up either 80 or 40, then fill the bottom of the screen with 80 or 40

for paste, append everything from the current line to the end of the screen to the paste buffer
you can stop appending when paste buffer size > 1024 bytes
then, copy everything from the paste buffer up to line 25 back to the screen, setting line lengths as we go

Q: what happens if someone attempts a STOP-Restore when no block exists?
A: the editor always has a block

distinguish screens from blocks
first 3 bytes are linewrap high bits for lines 1..24 ($e1-f8)
there can't be two consecutive 0 bits in that 3 bytes

packet address = the address of the packet header
last 2 bytes are the packet header
packet header = editor flag ($8000) and uncompressed flag ($4000), packet size
packet size = (packet header & $7ff) the total length of the packet including header
packet length = (packet header & $7ff) - 2, the length of the packet data
packet data is from (packet address - packet length) to (packet address - 1)
screen packet - first three bytes are linewrap

new data packet
packet data     00 00 00    four null*256 RLE packets
                00 00 00
                00 00 00
                00 00 00
packet address  0e 00       packet header

new screen packet
packet data     FF FF FF    three bytes of linewrap for lines 1..24
packet address  05 80       packet header with editable ($8000) bit set

REHASH
move everything down to pad in sorted threaded order
block move the whole thing back

search order

context @
begin

while
    (findvocab)
    chain to parent vocabulary
repeat
(findcore)


(findcore)
search new words
dhash
search core by hash


create

context @
current !
find


defining words in a vocabulary
    add 2 to the length
    suffix with the vocabulary link




forget




words
context @
collect all the CFAs at pad, with addresses of their symbols





core definition symbol
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $1467                 | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
[0]             | immediate bit   +2 name field length/flags byte
| [0]           | smudge bit
|   [0]_________| vocabulary bit
|     [    5    ] name length 0..31
+-+-+-+-+-+-+-+-+
|      A        |                 +3 name field first letter
+-+-+-+-+-+-+-+-+
|      L        |
+-+-+-+-+-+-+-+-+
|      L        |
+-+-+-+-+-+-+-+-+
|      O        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter
+-+-+-+-+-+-+-+-+

vocabulary definition symbol
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $22F3                 | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
[0]             | immediate bit   +2 name field length/flags byte
| [0]           | smudge bit
|   [1]_________| vocabulary bit
|     [    4    ] name length (0..31)
+-+-+-+-+-+-+-+-+
|      E        |                 +3 name field first letter
+-+-+-+-+-+-+-+-+
|      D        |
+-+-+-+-+-+-+-+-+
|      I        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         $7536                 | +n+1 vocabulary link (0 for last)
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

vocabulary entry
+-+-+-+-+-+-+-+-+
|    jsr        |                 +0 code
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    dovocab                    | +0 code field
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    first word in vocabulary   | +3 first word
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    parent vocab (0 = core)    | +5 parent vocabulary
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



+---------------+
| video         | $8000-$83ff video memory
+===============+
| heads         | $7400-$7fff symbol table
+---------------+
|temp dictionary| $6800-$73ff interpreter/compiler
+---------------+
| block buffer  | $6400-$67ff 1K block buffer
+---------------+
| ramdisk       | $63ff
| packets       |
|   |           |
|   |           |
|   v           |
|               |
   ...
|               |
|   ^           | PAD
|   |           | HERE
|   |           |
| dictionary    |
| bodies        | $0400
+---------------+
| tape buffers  |
| and stuff     | $0200-$03ff
+---------------+
| stack page    | $0100-$01ff
+---------------+
| zero page     | $0000-$00ff
+---------------+
+-+-+-+-+-+-+-+-+
|      D        |
+-+-+-+-+-+-+-+-+
|      I        |
+-+-+-+-+-+-+-+-+
|      T        |                 +n name field last letter


-----symtab---
32 bytes corehash
===

 8 bytes pearson table
 8 bytes bloom filter
move pearson/bloom to the end of the core dictionary, so they can be
directly accessed.  Let FORGET-called-by-COLD add 16 to DP to enclose
this data.


REHASH - high level
called by COLD to move the symbol table up from PAD to the top of memory
erase bloom filter
erase corehash table (formerly lfalist)
cmove the whole symbol table to pad

target = symtab+8+32+2      ; start returning things here
if called by COLD
    scan forward for a 0 length.  This delimits the temp dictionary
    the next word is a himem load address where the temporary dictionary
    would load
    copy everything from that point to $7FFF
else
    target
    pad
    over newstuff @ swap -      ; newstuff-target
    cmove
endif

corehash[0] = target
for ihash = 0 to 15
    corehash[ihash] = target
    for ilength = 1 to 31
        for each symbol
            set the bloom filter bit.  It does not matter if we do this multiple times.
            if (ilength = symbol.length) and (ihash = symbol.hash)
                copy symbol back to symtab
                target += symbol.length+2
                if symbol.isvocab
                    target += 2
                endif
            endif
        next
    next
next
startup ['] abort  over !  @ execute

LOCALS
alwwys on zero page
implied fetch
separate word for store

4 locals
n4!
0  dup local r0acc  local! r0acc!
2  dup local r1up   local! r1up!
4  dup local r2i    local! r2i!
6  dup local r3lim  local! r3lim!
8  dup local r4tos  local! r4tos!
10 dup local n0     local! n0!
12 dup local n1     local! n1!
14 dup local n2     local! n2!
16 dup local n3     local! n3!
18 dup local n4     local! n4!
20 dup local n5     local! n5!
22 dup local r11ext local! r11ext!
24 dup local r12sp  local! r12sp!
26 dup local r13cpr local! r13cpr!
28 dup local r14st  local! r14st!
30 dup local r15pc  local! r15pc!

: local
   create c,
   ;code
   jsr slip
   ldy #0
   lda (tos),y
   sty tos+1
   sta tos
   lda (tos),y
   sta tos
   jmp next

: local!
   create c,
   ;code
   ldy #0
   lda (tos),y
   tay
   lda stackl,x
   sta 0,y
   lda stackh,y
   sta 1,y
   jmp poptwo

code nfa+
    ldy #0
    lda (tos),y
    and #$1f
    clc
    adc #3
    adc tos
    sta tos
    bcc +
    inc tos
+   jmp next

[20]
: nfa+
    dup c@ $1f and 3 + + ;

code nfa+       ( nfa -- nfa+ )
    brk


: foo 4002 4000 ! 4002 jiffy@ third 2000 0 do >cfa loop drop jiffy@ 2swap d- du. ;
: >cfa   ( nfa -- cfa )
    2- @ ;
code >cfa   ( nfa -- cfa )
    brk
    .byt   popd | TOS
    .byt   st | TOS
    .byt   nxt




FAIL is vectored like EMIT and KEY
In the core-only, it just says "ERROR#" and the number, then MON (via WARM?)
in pettil development environment, it prints a canned message, then ABORT


http://pfe.sourceforge.net/pfe-wordsets/forth_usual.html
VOCS( -- )  => "FORTH"

    list all vocabularies in the system

      simulate:
        : VOCS VOC-LINK @ BEGIN DUP WHILE
                                DUP ->WORDLIST.NAME @ ID.
                                ->WORDLIST.LINK @
                          REPEAT DROP ;

Also incorporate the dpans concept of wordsets (like vocabularies, but loaded from Forth?)

At the beginning of FORGET
find the next word in the input stream.  It's CFA will become the new DP
iterate the entire symbol table (outer loop)   BEGIN   0= UNTIL
    Is this word active?
    And its CFA is between new DP and old DP?
    It is being forgotten.  Does it have any ancestors?
    iterate the entire symbol table   BEGIN   0= UNTIL inner loop
        set ancestor CFA = 0
        Is this word inactive?
        And it's CFA is between ancestor CFA and new DP?
        it's a candidate for most-recent ancestor.  Update Ancestor CFA / Ancestor NFA
        ancestor CFA = 0?  There were no ancestors
        toggle smudge bit (activate) most recent ancestor
    next symbol in inner loop
next symbol in outer loop


: ?error   ( flag err# -- )
   ... ;

: +branch   ( n -- )
add "n" to the instruction pointer but do not continue execution there just yet

: ?:   ( == ) ( flag -- )
defining word that scans ahead in the input stream, finds two words, and
encloses their CFA into the dictionary.  At runtime, the first word is
executed if flag is true, otherwise the second word executes
<builds here 0 c, ['] , ['] , here over - swap c!   ( [offset] [trueword] [falseword] )
does> c@+ >r  0= 2* + @ r> +branch execute ;

LOAD

: isscr?   ( -- flag )
    blk @ writable? @ and ;

lin off                     \ counts from 0..24

: 40/80   ( -- 40/80 )
    40
    lin @  >bloom  blkbuf +
    cbit@ 0=
    if
        lin 1+!
        40 +
    then
    lin 1+! ;

 : 'stream
       blk @ ?dup
       if      block b/buf
       else    tib #tib @
       then
       >in @ over min >r swap r@ + swap r> - ;



: query   ( -- )
    tib 80 expect
    span @ #tib !
(    blk off )              \ move this out to the word that calls query
    >in off ;

    fakescreen query


okay, it's a screen
block
get it in the buffer


linestartaddr= blkbuf 3+
begin
    put a 40 on the stack
    Check the bit of linewrap on the next line
size=   0 = 80, 1 = 40, use 2*
    set up for fake screen expect
    do the expect and use TIB ?


do this twice for an 80
it's a 40

: "   ( text" == ) ( -- addr )
    [ ascii " ] literal  word >in 1+!
    pad dup>r over c@ 1+ cmove> r> ;

: $>pad
  pad dup>r over c@ 1+ cmove> r> ;

: $enclose
   dup c@ allot ;

: (")   ( -- addr )


: "   ( text" == ) ( -- addr )
    state @
    dup if compile (") then
    [ ascii " ] literal  word >in 1+!
    rot ?: $enclose $>pad ;

L0d40 .byt 8 | bit7
 .asc "?LOADIN","G"|bit7
 .word L0d28
QLOADING
 .word DOCOL
 .word BLK
 .word FETCH
 .word ZEQ
 .word CLIT
 .byt 22
 .word QERROR
 .word SEMIS

;~~~disk
L18be .byt 3 | bit7 | bit6
 .byt "--",">"|bit7
 .word L1885
DASHDASHGT
 .word DOCOL
 .word QLOADING
 .word ZERO
 .word IN
 .word STORE
 .word BSCR
 .word BLK
 .word FETCH
 .word OVER
 .word MOD
 .word NEGATE
 .word BLK
 .word PSTORE
 .word SEMIS
: -->
    ?loading
    >in off
    b/scr
    blk @
    over mod
    negate
    blk +! ;
; Initialized in RAM:
DOPRIM
   JMP (COLDD)          ; [5]


NEXT
   INY                  ; [2]
   BMI PGFIX            ; [2]*
NEXT1
   LDA (IP),Y           ; [5]
   BMI ENTER            ; [2]
   STA DOPRIM+1         ; [3]  assume DOPRIM is in z.p.?
   JMP DOPRIM           ; [3]
                        ; ---
                        ;[22]

ENTER
   STA W+1 ; lead with high byte of target      ; [3]
   INY                                          ; [2]
   LDA (IP),Y ; then low byte                   ; [5]
   STA W                ; [3]
   DEC RX               ; [5]
   LDX RX               ; [3]
   TYA                  ; [2]
   SEC                  ; [2]
   ADC IP               ; [3]
   STA RL,X             ; [5]
   LDA IP+1             ; [3]
   STA RH,X             ; [5]
   LDA W                ; [3]
   STA IP               ; [3]
   LDA W+1              ; [3]
   STA IP+1             ; [3]
   LDY #0               ; [2]
   BEQ NEXT1            ; [3]

EXIT
   LDX RX
   INC RX
   LDA RL,X
   STA IP
   LDA RH,X
   STA IP+1
   LDY #0
   BEQ NEXT1

PGFIX       ; add half page to IP & subtract from Y
   TYA      ; rare occurrence, but rather guard against
   AND #$80 ; it here than in compiler process
   TAY
   LDA IP
   BPL +
   AND #$80
   STA IP
   INC IP+1
   BNE NEXT1
   BRK
+  ORA #$80
   STA IP
   BPL NEXT1

input sources
console QUERY EXPECT
BLOCK
screen


: quit
    [ rp!
    begin
        cr
        usetib  blk off
        query interpret
        state @ 0=
        if
            ." OK"
        then
    again ;

: query   ( -- )
    tib 80 expect
    span @ #tib !
    blk off
    >in off ;




A.6.2.2125 REFILL

This word is a useful generalization of QUERY. Re-defining QUERY to meet this specification would have broken existing code. REFILL is designed to behave reasonably for all possible input sources. If the input source is coming from the user, as with QUERY, REFILL could still return a false value if, for instance, a communication channel closes so that the system knows that no more input will be available.


console
block
screen
seq file


refill
source    ( -- addr size )


11.8 Input Text
<name>

An arbitrary FORTH word accepted from the input stream.
This notation refers to text from the input stream, not to
values on the data stack.
See:  "10.2 General Error Conditions"

ccc

A sequence of arbitrary characters accepted from the input
stream until the first occurrence of the specified
delimiting character.  The delimiter is accepted from the
input stream, but is not one of the characters ccc and is
therefore not otherwise processed.  This notation refers to
text from the input stream, not to values on the data stack.
Unless noted otherwise, the number of characters accepted
may be from 0 to 255.

input stream
A sequence of characters available to the system, for
processing by the text interpreter.  The input stream
conventionally may be taken from the current input device
(via the text input buffer) and mass storage (via a block
buffer).  BLK , >IN , TIB and #TIB specify the input stream.
Words using or altering BLK , >IN , TIB and #TIB are
responsible for maintaining and restoring control of the
input stream.

The input stream extends from the offset value of >IN to the
size of the input stream.  If BLK is zero the input stream
is contained within the area addressed by TIB and is #TIB
bytes long.  If BLK is non-zero the input stream is
contained within the block buffer specified by BLK and is
1024 bytes long.   See:  "11.8 Input Text"

BLK

>IN

TIB

#TIB         -- addr                       U,83   "number-t-i-b"
The address of a variable containing the number of bytes in
the text input buffer.  #TIB is accessed by WORD when BLK is
zero.  {{0..capacity of TIB}}  See:  "input stream"

WORD   ( char -- addr )

console
Take QUERY out of QUIT and instead use REFILL within INTERPRET (lazy-loading console input)
This is the inexhaustible input source.  It arrives in 80-byte chunks found at TIB

TIB          -- addr                       83            "t-i-b"
The address of the text input buffer.  This buffer is used
to hold characters when the input stream is coming from the
current input device.  The minimum capacity of TIB is 80
characters.
TIB base of the input buffer ( $0200 constant tib )

>IN          -- addr                       U,79          "to-in"
The address of a variable which contains the present
character offset within the input stream {{0..the number of
characters in the input stream}}.  See:  WORD

#TIB         -- addr                       U,83   "number-t-i-b"
The address of a variable containing the number of bytes in
the text input buffer.  #TIB is accessed by WORD when BLK is
zero.  {{0..capacity of TIB}}  See:  "input stream"

SPAN         -- addr                       U,83
The address of a variable containing the count of characters
actually received and stored by the last execution of
EXPECT .  See:  EXPECT

block

What have we learned?
INTERPRET is confusing
Vectoring WORD, a bad idea
reimplementing WORD using REFILL and SOURCE, a better idea

Four input sources
console

pad cr 80 expect cr span ?

1  ok
pad c@ . 32  ok
pad 1 -trailing  ok
.s    7269       0  ok
pad cr 80 expect cra span ?
x
1  ok
pad 1 -trailing  ok
.s    7269       0     7269      1  ok
pad cr 80 expect cr span ?
now is the time for all good men to come to the aid of their country.  now is th
80  ok
pad 80 -trailing  ok
.s    7269       0    7269       1    7269      80  ok

;--------------------------------------------------------------
#if 0
name=WORD.SCR
stack=( char -- addr )
tags=interpreter,vm

#endif
_wordscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word tor
#include "page.i65"
    .word currlin
#include "page.i65"
    .word lin
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tobloom
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "pad.i65"
    .word to6502
plugh
    ldy #2
    jsr locals
    sty n+7
    lda #<PNT
    sta n+6
    lda #3
    sta DFLTN                   ; Screen = device 3
    lda #0
    sta PNTR                    ; PNTR cursor column on current line
    lda tos
    sta LNMX                    ; LNMX physical screen line length
    brk
    .byt ldd | N0
    .byt st | N2
    .byt std | N3               ; PNT pointer - current screen line address
    .byt rtn
    ldy #0


#include "page.i65"
    .word plit
    .word $0100
#include "pad.i65"
    .word eighty
#include "page.i65"
    .word expect
#include "page.i65"
    .word xyzzy
#include "page.i65"

    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word here
#include "page.i65"
    .word dup
#include "page.i65"
    .word bl
#include "page.i65"
    .word _blank
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word here
#include "page.i65"
    .word exit



#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
x    .word doneq
#include "page.i65"
    .word store

;--------------------------------------------------------------
#if 0
name=WORDm.BLK
stack=( char -- addr )
tags=interpreter,vm

#endif
_wordblk
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word under
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word here
#include "page.i65"
    .word dup
#include "page.i65"
    .word bl
#include "page.i65"
    .word _blank
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word here
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=USETIB
stack=( -- )
tags=interpreter
Reset ISDONE? and WORD to use PET keyboard
#endif
_usetib
#include "enter.i65"
    .word plit
    .word _wordtib
#include "pad.i65"
    .word wordvec
#include "page.i65"
    .word store
#include "page.i65"
    .word exit


: interpret   ( -- )
    begin
        ?stack
        bl word dup c@
    while
        find ?dup
        if
            state @ <>
            ?: execute ,xt
        else
            dup c@
            if
                number
                jumptable  dpl @ 0< 2* state @ + 2* -
                @ execute
            then
        then
    repeat drop ;

begin

info screen  maybe a bar graph between pad...vmbuf
symtab symnew symtail tdict memsiz  dp vmbuf #vmblks scr

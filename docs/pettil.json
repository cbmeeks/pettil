[
{ "title":"WARM","text":"!! WARM&nbsp;&nbsp;&nbsp;( -- )\n\nDropping out to BASIC can be accomplished on purpose with MON\n(to get to TIM), then .X to get to BASIC.  It also will happen\nby mistake if cassette i/o is interrupted by the STOP key or \nany tape error.  There may be other ways.  WARM should be able\nto bring the system back to a usable state.\n[heading]Tasks[/heading]\n[list]\n* aloha\n* - swap zero page with zpbuf\n* - switch Sweet16<-->TIM BRK vector\n* - switch PETTIL<-->BASIC IRQ vector\n* reset Forth return stack (machine stack)\n* reset Forth data stack\n* print start message CR,\"WELCOME TO PETTIL!\",CR\n* STARTUP @ EXECUTE\n[/list]","tags":["nosymbol"]},
{ "title":"COLD","text":"!! COLD&nbsp;&nbsp;&nbsp;( -- )\n\nOne-time only (then disappear) system bootstrap initialization.\nRuns once after \"pettil.obj\" loads, to prepare a development\nenvironment.  The size of COLD doesn't really matter.  As\nthe final word in the core dictionary, COLD will FORGET\nitself and its address becomes the value of FENCE.\nIt's a little hairy, I hope my comments will explain.\n[heading]the pieces at load time[/heading]\n[list]\n* 0400-040c   BASIC bootstrap (10 SYS 1037)\n* 040d-0410   pettillaunch (JMP COLD)\n* 0410-049c   zpbuf (partial zero page mirror $00-$8C)\n* 049d-04a4   power2 (01 02 04 08 10 20 40 80)\n* 04a5        unused byte\n* 04a6-065a   Sweet16\n* 065b-       slip, slide, Sweet16 extensions\n* brktoggle,  the EOR of TIM and Sweet16 entry points\n* userarea,   User variable storage\n* swapzp,     and other native 6502 code subroutines\n* core,       permanent dictionary (bodies only)\n\n* cold,       bootstrap initialization\n---------------tdict & symbol table concatenated to there-----\n* there,      target load address of temporary dictionary (2)\n* there+2,    size of temporary dictionary (2)\n* there+4,    temporary dictionary, bodies only\n* tdict       outer interpreter, compiler, editor, assembler\n* symbols,    symbol table data\n[/list]\n\n[heading]COLD tasks[/heading\n[list]\n* change the startup vector from COLD to WARM\n* set MEMSIZ from BASIC $34-35\n* set SYMTAB as an offset from MEMSIZ\n* set TDICT as the load address + 2 of part 2 (found at 'there')\n* display a banner\n* set STARTUP uservariable to LAUNCH\n* move temporary dictionary to TDICT\n* move symbol table to SYMTAB\n* set FENCE\n* call WARM to put us in Forth mode\n[/list]\nThere is no knowledge in the core dictionary (at the bottom of memory)\nof what is in the temporary dictionary or where it resides.  To kick\nthings off upstairs, WARM starts Forth, then executes the word LAUNCH\nin the upper dictionary, via the STARTUP uservariable.  The requirement\nis that the first thing in tdict must be the executable CFA of LAUNCH\nThat's where we will pick things up.\n\ntemporary dictionary and symbols are built separately\nas PETTIL-TDICT.OBJ and PETTIL.SYM, then they are both\nappended to the PETTIL.OBJ core binary\n\npettil-tdict.obj looks like this:\ntwo byte load address of pettil-tdict.obj e.g. $71fe\ntwo byte length of pettil-tdict.obj\n\nThe actual load address is off by -2.  There are two bytes in\nfront of the tdict.obj code storing the length of tdict.obj.\nThis length information is needed to figure out where the symbol\ntable starts, following tdict\n\nAll addresses in tdict in this example would be located as though\ntdict had been assembled and loaded at *=$7200, in spite of the\nmisleading load address.\n\npettil.sym looks like this:\nrepeated for each head\n[ two byte CFA\n  one byte length and flags\n  name\n  one byte vocabulary identifier, if present ]","tags":["transient","nosymbol"]},
{ "title":"HOT","text":"!! HOT&nbsp;&nbsp;&nbsp;( -- )\n\nCOLD does enough to kickstart Forth, then HOT is next.\n[list]\n* sets TDICT and SYMTAB user variables\n* copy the temporary dictionary to TDICT\n* copy the symbols to SYMTAB+32\n* execute LAUNCH (first word at the first address in TDICT)\n[/list]","tags":["transient","nosymbol"]},
{ "title":"USERVAR","text":"!! USERVAR&nbsp;&nbsp;&nbsp;( -- addr )\n\nRuntime action of all user variables.  Returns the address of the variable","tags":["uservariable","nosymbol"]},
{ "title":"SP0","text":"!! SP0&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable\nThe data stack initialization value ($30)","tags":["uservar","fig"]},
{ "title":"RP0","text":"!! RP0&nbsp;&nbsp;&nbsp;( -- addr )\n\n[heading]User variable[/heading]\nThe return stack initialization value ($01FE)","tags":["uservar","fig"]},
{ "title":"DP","text":"!! DP&nbsp;&nbsp;&nbsp;( -- addr )\n\nDictionary pointer","tags":["uservar","fig"]},
{ "title":"MEMSIZ","text":"!! MEMSIZ&nbsp;&nbsp;&nbsp;( -- addr )\n\n[heading]User variable[/heading]\nTop of RAM, initialized at COLD from BASIC zero page variable at $34\nThis variable may be adjusted, e.g. to allocate a contiguous block of\nmemory at the top of RAM","tags":["uservar","kernel"]},
{ "title":"SYMTAB","text":"!! SYMTAB&nbsp;&nbsp;&nbsp;( -- addr)\n\n[heading]User variable[/heading]\nSymbol table start address\n\nFirst 32 bytes are thread pointers for each possible Pearson\nhash value, followed by 16 threads of symbols, ordered by size.  ","tags":["uservar","pettil"]},
{ "title":"SYMTAIL","text":"!! SYMTAIL&nbsp;&nbsp;&nbsp;( -- addr )\n\n[heading]User variable[/heading]\nSymbol table end address\n\nWhere new symbols are appended","tags":["uservar","pettil"]},
{ "title":"STARTUP","text":"!! STARTUP&nbsp;&nbsp;&nbsp;( -- addr )\n\n[heading]User variable[/heading]\nStores the code field address of the word that runs after ABORT\noccurs\n","tags":["uservar"]},
{ "title":"VMBUF","text":"!! VMBUF&nbsp;&nbsp;&nbsp;( -- addr )\n\nPointer to the bottom of the virtual memory buffer.  Save and\nverify operate between this address and BLKBUF","tags":[]},
{ "title":"#VMPKT","text":"!! #VMPKT&nbsp;&nbsp;&nbsp;( -- addr )\n\nNumber of virtual memory packets","tags":[]},
{ "title":"EDITING?","text":"!! EDITING?&nbsp;&nbsp;&nbsp;( -- addr )\n\nBLOCK will generate new packets in the virtual memory packet \nbuffer if they don't already exist.  This user variable decides\nwhether those created packets are read-only (data) blocks or \nwritable (screens).","tags":[]},
{ "title":"WRITABLE?","text":"!! WRITABLE?&nbsp;&nbsp;&nbsp;( -- addr )\n\nPETTIL's editor distinguishes between \"data\" and \"screen\" blocks\nusing a bitflag (metadata) in the packet header.\n\nData blocks are 1024 bytes and can't be completely displayed on\nthe PET's 40x25 hardware.  The editor will show the first 1000 bytes\nand otherwise treats such blocks as read-only.\n\nScreens (typically source code) are read-write and the editor\nwill update the virtual memory packet buffer when leaving the screen,\ne.g. via the STOP-Q editor command.  Screens also contain 24 bits\nof linewrap information (the first three bytes of the block buffer), \nand are treated as a collection of 40-character or 80-character \nlines by the compiler.  In other words, line terminations are \nconsidered to be whitespace when loading screens, and source lines \ncan extend all the way to the left and right edges.\n\nThe STOP-CLR editor command converts a data block into a screen,\ndiscarding the last (unseen) 24 bytes and initializing the linewrap\nto all 40-character lines, or it will reset the linewrap on existing\nscreens.  Changes aren't saved to the packet buffer until the screen\nis exited.","tags":[]},
{ "title":"TDICT","text":"!! TDICT&nbsp;&nbsp;&nbsp;( -- addr )\n\nbase address of temporary dictionary","tags":[]},
{ "title":"BASE","text":"!! BASE&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser Variable containing the system number base","tags":[]},
{ "title":"DPL","text":"!! DPL&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable containing the number of digits following the \ndecimal in numeric input conversion","tags":[]},
{ "title":"HLD","text":"!! HLD&nbsp;&nbsp;&nbsp;( -- addr )\n","tags":[]},
{ "title":"BLK","text":"!! BLK&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe address of a variable containing the number of the mass\nstorage block being interpreted as the input stream.  If the\nvalue of BLK is zero the input stream is taken from the text\ninput buffer.  {{0..the number of blocks available -1}}\n-1 = cassette tape 1 ~wut?\n-2 = cassette tape 2 ~wut?","tags":[]},
{ "title":">IN","text":"!! >IN&nbsp;&nbsp;&nbsp;( -- )\n\nLeaves the address of the user variable >IN which contains the\nnumber of bytes from the beginning of the input stream at any\nparticular moment during interpretation.\nThe address of a user variable which contains the present\ncharacter offset within the input stream.  ","tags":[]},
{ "title":"SPAN","text":"!! SPAN&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe address of a variable containing the count of characters\nactually received and stored by the last execution of EXPECT","tags":[]},
{ "title":"#TIB","text":"!! #TIB&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe address of a variable containing the number of bytes in\nthe text input buffer.  #TIB is accessed by WORD when BLK is\nzero.  {{0..capacity of TIB}}  ","tags":[]},
{ "title":"#OUT","text":"!! #OUT&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable \nCounts number of characters that have been emitted","tags":[]},
{ "title":"#LINE","text":"!! #LINE&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable\nCounts the number of lines output","tags":[]},
{ "title":"ERRMESS","text":"!! ERRMESS&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable\nAddress of the error messages table.  If zero, only a numeric\nerror is output","tags":[]},
{ "title":"EXECUTE","text":"!! EXECUTE&nbsp;&nbsp;&nbsp;( cfa -- )\n\nExecutes the word whose code field address is on the stack.","tags":[]},
{ "title":">6502","text":"!! >6502&nbsp;&nbsp;&nbsp;( -- )\n\nDrop down from high-level Forth to inline 6502","tags":[]},
{ "title":"(ABORT\")","text":"!! (ABORT\")&nbsp;&nbsp;&nbsp;( flag -- )\n\nif the flag is nonzero, types the inline counted string from the\ndictionary and executes the word in STARTUP.  Otherwise adjusts IP\nto after the string, paging if necessary ~wut?","tags":["nosymbol"]},
{ "title":"(LIT)","text":"!! (LIT)&nbsp;&nbsp;&nbsp;( -- n )\n\nRuntime behavior of LITERAL, puts a number \"n\" on the stack","tags":["nosymbol"]},
{ "title":"CLIT","text":"!! CLIT&nbsp;&nbsp;&nbsp;( -- n )\n\nRuntime behavior of CLITERAL, puts the next byte \"n\" in the \ndictionary to the stack","tags":["nosymbol"]},
{ "title":"HEX","text":"!! HEX&nbsp;&nbsp;&nbsp;( -- )\n\nSets the system number base to hexadecimal","tags":[]},
{ "title":"DECIMAL","text":"!! DECIMAL&nbsp;&nbsp;&nbsp;( -- )\n\nSets the system number base to decimal","tags":[]},
{ "title":"(DOES)","text":"!! (DOES)&nbsp;&nbsp;&nbsp;( -- )\n\nRuntime behavior of a word built with <BUILDS ... DOES>","tags":["nosymbol"]},
{ "title":"?BRANCH","text":"!! ?BRANCH&nbsp;&nbsp;&nbsp;( flag -- )\n\nIf the flag is zero, takes the branch","tags":["nosymbol","control"]},
{ "title":"(?DO)","text":"!! (?DO)&nbsp;&nbsp;&nbsp;( end begin -- )\n\nPerforms a do-loop if end<>begin","tags":["nosymbol"]},
{ "title":"BRANCH","text":"!! BRANCH&nbsp;&nbsp;&nbsp;( -- )\n\nCompiles an unconditional branch operation.\nWhen used in the form: COMPILE BRANCH\nan unconditional branch operation is compiled.\nA one-byte branch offset must immediately follow\nthis compilation address.  The branch address\nis typically generated by following BRANCH\nwith <RESOLVE or >MARK .\n\nIP = address of 'branch' (you are here)\nIP+2 = relative address of the target, same as for 6502 branches","tags":["nosymbol"]},
{ "title":"(+LOOP)","text":"!! (+LOOP)&nbsp;&nbsp;&nbsp;( n -- )\n\nAdd \"n\" to inner loop index.  If loop index exceeds loop limit,\nthen iterate to the (do), otherwise skip past the branch and\nproceed","tags":["nosymbol"]},
{ "title":"(LOOP)","text":"!! (LOOP)&nbsp;&nbsp;&nbsp;( -- )\n","tags":["nosymbol","control"]},
{ "title":"(DO)","text":"!! (DO)&nbsp;&nbsp;&nbsp;( end begin -- )\n\nLoops from \"begin\" to \"end\"","tags":["nosymbol"]},
{ "title":"2DROP","text":"!! 2DROP&nbsp;&nbsp;&nbsp;( d -- )\n\nDiscard the top two items on the stack","tags":[]},
{ "title":"DROP","text":"!! DROP&nbsp;&nbsp;&nbsp;( n -- )\n\nDiscard the top of stack","tags":[]},
{ "title":"4DROP","text":"!! 4DROP&nbsp;&nbsp;&nbsp;( a b c d -- )\n\nDiscard the top four stack items","tags":[]},
{ "title":"3DROP","text":"!! 3DROP&nbsp;&nbsp;&nbsp;( a b c -- )\n\nDiscard the top three stack items","tags":[]},
{ "title":"I","text":"!! I&nbsp;&nbsp;&nbsp;( -- index )\n\nPush the inner loop index of a DO LOOP to the stack","tags":[]},
{ "title":"J","text":"!! J&nbsp;&nbsp;&nbsp;( -- index )\n\nPush the outer loop index of a DO LOOP to the stack","tags":[]},
{ "title":"(LEAVE)","text":"!! (LEAVE)&nbsp;&nbsp;&nbsp;( -- )\n\nExit a do loop early","tags":["inner","control","nosymbol"]},
{ "title":"(?LEAVE)","text":"!! (?LEAVE)&nbsp;&nbsp;&nbsp;( flag -- )\n\nIf flag is nonzero, exit the do loop early","tags":["inner","control","nosymbol"]},
{ "title":"SP@","text":"!! SP@&nbsp;&nbsp;&nbsp;( -- sp )\n\nFetches the current data stack pointer","tags":[]},
{ "title":"SP!","text":"!! SP!&nbsp;&nbsp;&nbsp;( -- )\n\nInitializes the data stack pointer to the value in user \nvariable SP0","tags":[]},
{ "title":"RP!","text":"!! RP!&nbsp;&nbsp;&nbsp;( -- )\n\nOrdinarily the 6502 machine stack (aka PETTIL return stack) is\ninitialized to $01ff by BASIC, but the value stored at RP0 defaults\nto $01fe instead.  This is because the PET ROM stores a line of\ninput at $0200 (where TIB points) and INTERPRET will be storing a\ncount of the first word on the line at $01ff","tags":[]},
{ "title":"EXIT","text":"!! EXIT&nbsp;&nbsp;&nbsp;( -- )\n\nThe runtime behavior of ; \nExits a colon definition, unnesting to the next higher level of\nthe return stack","tags":["nosymbol"]},
{ "title":"DOCREATE","text":"!! DOCREATE&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe business end of words created by CREATE","tags":["nosymbol"]},
{ "title":"ENTER","text":"!! ENTER&nbsp;&nbsp;&nbsp;( -- )\n\nThe business end of colon definition words, pushes the current\nIP on the return stack and execues the word following it","tags":["nosymbol"]},
{ "title":"DOCCONST","text":"!! DOCCONST&nbsp;&nbsp;&nbsp;( -- c )\n\nRuntime behavior of a word defined by CCONSTANT","tags":["nosymbol"]},
{ "title":"DOCONST","text":"!! DOCONST&nbsp;&nbsp;&nbsp;( -- n )\n\nRuntime behavior of a word defined by CONSTANT","tags":["nosymbol"]},
{ "title":"DO2CONST","text":"!! DO2CONST&nbsp;&nbsp;&nbsp;( -- d )\n\nRuntime behavior of words defined by 2CONSTANT","tags":["nosymbol"]},
{ "title":"!IRQ","text":"!! !IRQ&nbsp;&nbsp;&nbsp;( -- )\n\nInvert the 6502 interrupt flag","tags":[]},
{ "title":"?STACK","text":"!! ?STACK&nbsp;&nbsp;&nbsp;( -- )\n\nCheck the  data stack pointer for sanity, abort if trouble","tags":[]},
{ "title":"SYSERR","text":"!! SYSERR&nbsp;&nbsp;&nbsp;( -- )\n\nGeneral-purpose error handler, callable from primitives, used\nto print a system error message and abort\npass in the error # in Y\n      1 stack empty\n      2 stack full","tags":["nosymbol"]},
{ "title":">FORTH","text":"!! >FORTH&nbsp;&nbsp;&nbsp;( -- )\n\nJump up to high-level Forth from inline 6502","tags":[]},
{ "title":"DOPAGE","text":"!! DOPAGE&nbsp;&nbsp;&nbsp;( -- )\n\nPage boundary crossing is handled by the compiler inserting 'page'\nwhen the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed\nto occur, and indicates an error in the compiler.\n\npad is also used by LITERAL, string, and other words which\ncontain inline arguments to offset IP at runtime","tags":["nosymbol"]},
{ "title":"FAIL","text":"!! FAIL&nbsp;&nbsp;&nbsp;( error -- )\n\nPrint an error message and abort","tags":[]},
{ "title":"IRQ^","text":"!! IRQ^&nbsp;&nbsp;&nbsp;( eormask -- )\n\nCalled by the editor (and anything else) to flip the IRQ vector\non and off between two different values","tags":[]},
{ "title":"SPACE","text":"!! SPACE&nbsp;&nbsp;&nbsp;( -- )\n\nEmits a space character","tags":[]},
{ "title":"SPACES","text":"!! SPACES&nbsp;&nbsp;&nbsp;( n -- )\n\nEmits \"n\" spaces","tags":[]},
{ "title":"COUNT","text":"!! COUNT&nbsp;&nbsp;&nbsp;( addr1 -- addr2 n1 )\n\nLeaves the address, addr2 and the character count +n of text \nbeginning at addr1.  addr2 is addr1+1 and n1 is the length of \nthe counted string at addr1.  The byte at addr1 contains the \nbyte count +n.  Range of +n is {0...255}.","tags":["forth-83"]},
{ "title":"TYPE","text":"!! TYPE&nbsp;&nbsp;&nbsp;( addr count -- )\n","tags":["forth-83"]},
{ "title":"(.\")","text":"","tags":["nosymbol"]},
{ "title":".S","text":"\nOutput the data stack","tags":[]},
{ "title":"EMIT","text":"!! EMIT&nbsp;&nbsp;&nbsp;( c -- )\n","tags":["forth-83","i/o"]},
{ "title":"KEY","text":"!! KEY&nbsp;&nbsp;&nbsp;( -- c )\n\nWait for a keypress by the user","tags":["forth-83","i/o"]},
{ "title":"?TERMINAL","text":"!! ?TERMINAL&nbsp;&nbsp;&nbsp;( -- flag )\n\nReturns true if the stop key was pressed","tags":["forth-83","i/o"]},
{ "title":"CR","text":"!! CR&nbsp;&nbsp;&nbsp;( -- )\n\nOutput a carriage return","tags":["forth-83","i/o"]},
{ "title":"VIDRAM","text":"!! VIDRAM&nbsp;&nbsp;&nbsp;( -- $8000 )\n\nConstant, address of PET video memory $8000","tags":["i/o","const"]},
{ "title":"MON","text":"!! MON&nbsp;&nbsp;&nbsp;( -- )\n\nRestores BASIC zero page and exits to the TIM monitor","tags":[]},
{ "title":"JIFFY@","text":"!! JIFFY@&nbsp;&nbsp;&nbsp;( -- d )\n\nThe number of jiffies since powerup or midnight as a double","tags":[]},
{ "title":"CMDOFF","text":"!! CMDOFF&nbsp;&nbsp;&nbsp;( -- )\n\nRestore default I/O channels","tags":["i/o","kernel"]},
{ "title":"EXPECT","text":"!! EXPECT&nbsp;&nbsp;&nbsp;( addr +n -- )\n\nStores up to +n characters into memory beginning at addr.\nReceive characters and store each into memory.\nThe transfer begins at addr proceeding towards\nhigher addresses one byte per character until\neither \"return\" is received or until +n characters have been transfered.  No more than +n\ncharacters will be stored.  The \"return\" is not\nstored into memory.  No characters are received\nor transfered if +n is zero.  All characters\nactually received and stored into memory will\nbe displayed, with the \"return\" displaying as a\nspace.","tags":["forth-83","i/o"]},
{ "title":"FILENAME","text":"!! FILENAME&nbsp;&nbsp;&nbsp;( addr n -- )\n\nSet the filename for file operations.  Must be used before\nOPEN or CSAVE.","tags":["i/o","kernel"]},
{ "title":"OPEN","text":"!! OPEN&nbsp;&nbsp;&nbsp;( n1 n2 n3 -- f )\n\nOpen the logical file number n1 on device n2 with secondary\naddress n3.  Filename must have been set with NAME.  Returns\nan error flag f (0=none, 24=error).\nftp://www.zimmers.net/pub/cbm/vic20/programming/VIC-Forth/Manual.txt","tags":["i/o","kernel"]},
{ "title":"HPIN","text":"!! HPIN&nbsp;&nbsp;&nbsp;( n -- f )\n\nSend the current input stream to logical file number n.\nReturns and error flag f (0=none, 24=error).  See OPEN.\nPronounced \"h-p-in\".","tags":["i/o","kernel"]},
{ "title":"HPOFF","text":"!! HPOFF&nbsp;&nbsp;&nbsp;( -- )\n\nRestore the current input and output stream to the\nkeyboard and screen respectively.  Pronounced \"h-p-off\".","tags":["i/o","kernel"]},
{ "title":"HPOUT","text":"!! HPOUT&nbsp;&nbsp;&nbsp;( n -- f )\n\n consider CMDIN CMDOUT CMDOFF\n Send the current output stream to logical file number n.\n Returns an error flag f (0=none, 24=error).  See OPEN.\n Pronounced \"h-p-out\".","tags":["i/o","kernel"]},
{ "title":"CSAVE","text":"!! CSAVE&nbsp;&nbsp;&nbsp;( -- f )\n\n Save the wordlist and USER-variables to cassette.  The\n wordlist may be given a name (see NAME).  Returns an error\n flag (0=none, 24=error).  See CLOAD.","tags":["i/o","kernel"]},
{ "title":"CLOAD","text":"!! CLOAD&nbsp;&nbsp;&nbsp;( -- f )\n\n Load the saved wordlist from cassette.  Returns an error\n flag f (0=none, 24=error).  See CSAVE.","tags":["i/o","kernel"]},
{ "title":"?DISC","text":"!! ?DISC&nbsp;&nbsp;&nbsp;( -- )\n\n          Read the disk error channel storing the message at address\n          $8C0 (C64-FORTH) or $1295 (VIC-FORTH) and the length byte\n          at $8BF (C64-FORTH) or $1294 (VIC-FORTH).  See COUNT and\n          TYPE.  Pronounced \"question-disc\".","tags":["i/o","kernel"]},
{ "title":"D+","text":"!! D+&nbsp;&nbsp;&nbsp;( d1 d2 -- d1+d2 )\n\nAdd two double precision numbers","tags":["forth-83","double"]},
{ "title":"D<","text":"!! D<&nbsp;&nbsp;&nbsp;( d1 d2 -- flag )\n\nCompare two doubles.  True if d1 < d2","tags":["forth-83","double"]},
{ "title":"DNEGATE","text":"!! DNEGATE&nbsp;&nbsp;&nbsp;( d -- -d )\n\nNegate the double on the stack","tags":["forth-83","double"]},
{ "title":"DABS","text":"!! DABS&nbsp;&nbsp;&nbsp;( d -- |d| )\n\nReturns the absolute value of double \"d\"","tags":[]},
{ "title":"2DUP","text":"!! 2DUP&nbsp;&nbsp;&nbsp;( n1 n2 -- n1 n2 n1 n2 )\n\nMake a copy of the double on top of stack","tags":[]},
{ "title":"2OVER","text":"!! 2OVER&nbsp;&nbsp;&nbsp;( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )\n\nCopy the double underneath the double on top of stack to become the new top of stack","tags":["primitive","double","stack","forth-83"]},
{ "title":"2ROT","text":"!! 2ROT&nbsp;&nbsp;&nbsp;( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )\n\nRotate the three doubles on the stack","tags":[]},
{ "title":"2SWAP","text":"!! 2SWAP&nbsp;&nbsp;&nbsp;( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )\n\nSwap the two doubles on the stack","tags":[]},
{ "title":"2!","text":"!! 2!&nbsp;&nbsp;&nbsp;( hi lo addr -- )\n\nStore the double \"hi\" \"lo\" to \"addr\"\ntags=forth-83,memory,double","tags":["forth-83","memory","double"]},
{ "title":"2@","text":"!! 2@&nbsp;&nbsp;&nbsp;( addr -- hi lo )\n\nRetrieve the double stored at \"addr\" to the stack","tags":["forth-83","memory","double"]},
{ "title":"D-","text":"!! D-&nbsp;&nbsp;&nbsp;( d1 d2 -- d1-d2 )\n\nSubtract \"d2\" from \"d1\" leaving the result on the stack","tags":["double","math","forth-83"]},
{ "title":"D0=","text":"!! D0=&nbsp;&nbsp;&nbsp;( d -- flag )\n\nLeave true if the double \"d\" is zero","tags":[]},
{ "title":"D=","text":"!! D=&nbsp;&nbsp;&nbsp;( hi2 lo2 hi1 lo1 -- flag )\n\nLeaves true if the two doubles are equal","tags":[]},
{ "title":"DU<","text":"!! DU<&nbsp;&nbsp;&nbsp;( d1 d2 -- flag )\n\nPerforms an unsigned compare of two doubles and leaves true if \"d1\" < \"d2\"","tags":["forth-83","double"]},
{ "title":"D2/","text":"!! D2/&nbsp;&nbsp;&nbsp;( d -- d/2 )\n\nDivides double \"d\" by 2, unsigned","tags":[]},
{ "title":"D2*","text":"!! D2*&nbsp;&nbsp;&nbsp;( d -- d*2 )\n\nMultiply the double \"d\" by 2","tags":["double"]},
{ "title":"D>","text":"!! D>&nbsp;&nbsp;&nbsp;( d1 d2 -- flag )\n","tags":["double"]},
{ "title":"DMIN","text":"!! DMIN&nbsp;&nbsp;&nbsp;( d1 d2 -- d3 )\n\nReturns d1 or d2, whichever is smaller (signed)","tags":[]},
{ "title":"DMAX","text":"!! DMAX&nbsp;&nbsp;&nbsp;( d1 d2 -- d3 )\n\nReturns the larger of two doubles, signed","tags":[]},
{ "title":"$INDEX","text":"!! $INDEX&nbsp;&nbsp;&nbsp;( addr char -- index|0 )\n\nreturns the position of char within the counted string at addr\notherwise returns 0","tags":[]},
{ "title":"B/BUF","text":"!! B/BUF&nbsp;&nbsp;&nbsp;( -- 1024 )\n\nConstant, bytes per buffer = 1024","tags":["const"]},
{ "title":"B/SCR","text":"!! B/SCR&nbsp;&nbsp;&nbsp;( -- 1000 )\n\nConstant, Bytes per screen.  Not what it usually means in other Forths,\n(not blocks per screen = 1)","tags":[]},
{ "title":"BLKBUF","text":"!! BLKBUF&nbsp;&nbsp;&nbsp;( -- addr )\n\nReturn the address of the 1K block buffer -- this might move \nafter REHASH (FORGET) reallocates memory to accommodate more or\nfewer symbols.","tags":[]},
{ "title":"RLENCODE","text":"!! RLENCODE&nbsp;&nbsp;&nbsp;( srcaddr targaddr srclen -- targend )\n\nencode length {srclen} bytes from source address {srcaddr} to\ntarget address {targaddr}.  Return target end address {targend}","tags":["vm","sweet16"]},
{ "title":"RLDECODE","text":"!! RLDECODE&nbsp;&nbsp;&nbsp;( srcaddr targaddr srclen -- )\n\ndecode length {srclen} bytes beginning at source address\n{srcaddr} to the target address (targaddr).","tags":["vm","sweet16"]},
{ "title":">PKT","text":"!! >PKT&nbsp;&nbsp;&nbsp;( n -- packet )\n\nReturn the packet address of block N\n\n```\n: >pkt   ( n -- packet )\n    blkbuf 2-\n    begin\n        over 0>\n    while\n        dup @\n        - swap 1- swap\n    repeat\n    swap drop ;\n\n```","tags":[]},
{ "title":"PKT+","text":"!! PKT+&nbsp;&nbsp;&nbsp;( writable? -- packet )\n\nAppend a new packet to the bottom of vmbuf, return its address\nflag = false for data packet, true for editor packet\n\n```\n: pkt+   ( editable? -- packet )\n                                ( editable? )\n    >r vmbuf @ 14 r@ 9 and -      \\ packet length editor=5 data=14\n ( vmtail size )\n    2dup - dup third erase        \\ clear packet and new tail\n    dup 2+ 3 r@ fill              \\ first 3 bytes of packet = flag\n    vmbuf !                       \\ update vmbuf to new tail\n    VIDRAM r> and or over !       \\ set packet length\n    #vmpkt 1+! ;                  \\ increment packet counter )\n    ( vmbuf )                     \\ packet address\n\n```","tags":[]},
{ "title":"UNPKT","text":"!! UNPKT&nbsp;&nbsp;&nbsp;( packet -- blkbuf )\n\nGiven the address of a packet (its size/flags word, at the top)\nthis will unpack the packet to the block buffer and return\nthe address of the unpacked block. Distinguishes among\ncompressed/uncompressed and editable/uneditable packets\n\n```\n: unpkt   ( packet -- blkbuf )\n    dup @ dup 0< editblk !\n ( packet header )\n    dup 2* 0< >r\n ( packet header ) ( R; uncompressed? )\n    $7ff and 2dup - 2+\n ( packet size data ) ( R; uncompressed? )\n    blkbuf dup>r rswap dup b/buf blank\n ( packet size data blkbuf ) ( R; blkbuf uncompressed? )\n    editblk @\n ( packet size data blkbuf editable? ) ( R; blkbuf uncompressed? )\n    if\n ( packet size data blkbuf ) ( R; blkbuf uncompressed? )\n        over 3c@ third 3c!\n        3+ rot 3- rot 3+ rot\n    then\n    rot 2- r>\n ( packet data blkbuf size uncompressed? ) ( R; blkbuf )\n    if\n        cmove\n    else\n        rldecode\n    then\n   rfrom nip ;\n\n```","tags":[]},
{ "title":"(BLOCK)","text":"!! (BLOCK)&nbsp;&nbsp;&nbsp;( blk -- blkbuf new? )\n\nRetrieves or creates the VM block \"blk\" and returns the block\nbuffer address.  If the block was created, \"new?\" is true\nflag is true if the block is new, false if it already exists\nNew packets are created as data blocks (1024 zeroes) or as editor\nscreens (3 bytes linewrap + 1000 spaces) if EDITMODE is set\n\n```\n: (block)   ( blk -- blkbuf )\n    dup 1+ #vmpkt @  >  dup>r\n ( blk new? )\n    if\n ( blk )\n        #vmpkt @ - 0\n ( howmany junk )\n        begin\n ( howmany junk )\n            drop 1-\n ( howmany )\n            editmode @ pkt+\n ( howmany packet )\n            over 0<\n        until\n ( howmany packet )\n        nip\n ( howmany packet )\n    else\n ( blk )\n        >pkt\n ( packet )\n    then\n ( packet )\n    unpkt  r> ;\n ( blkbuf new? )\n\n```","tags":[]},
{ "title":"BLOCK","text":"!! BLOCK&nbsp;&nbsp;&nbsp;( n -- addr )\n\nIn PETTIL, returns the address of the only block buffer in the system","tags":[]},
{ "title":"DISC","text":"!! DISC&nbsp;&nbsp;&nbsp;( -- )\n\nTo start a disk session, insert a blank formatted disk and type","tags":["vm","unimplemented"]},
{ "title":"SAVE-BUFFERS","text":"!! SAVE-BUFFERS&nbsp;&nbsp;&nbsp;( -- )\n\nWrites the virtual memory area, from VMBUF to BLKBUF, out to a PRG file on cassette or disk\n\nThis is the equivalent of STOP-S in the editor","tags":["vm","forth-83","unimplemented"]},
{ "title":"UPDATE","text":"!! UPDATE&nbsp;&nbsp;&nbsp;( -- )\n\nCopies the block buffer to the packet buffer at BLK where it will be\nsaved to tape at the next SAVE-BUFFERS","tags":["forth-83","vm","unimplemented"]},
{ "title":"EMPTY-BUFFERS","text":"!! EMPTY-BUFFERS&nbsp;&nbsp;&nbsp;( -- )\n\nUnassign all virtual memory.  UPDATEed blocks are not written\nto mass storage.\n\n```\n: empty-buffers   ( -- )\n    #vmpkt off blkbuf 2- dup off vmbuf ! ;\n\n```","tags":["i/o","forth-83"]},
{ "title":"USER","text":"!! USER&nbsp;&nbsp;&nbsp;( n -- )\n\nDefining word to create a new uservariable","tags":[]},
{ "title":"+ORIGIN","text":"!! +ORIGIN&nbsp;&nbsp;&nbsp;( n1 -- n2 )\n\nReturns the address \"n2\" in the user variable area offset by \n\"n1\" bytes from the start","tags":[]},
{ "title":"CONTEXT","text":"!! CONTEXT&nbsp;&nbsp;&nbsp;( -- addr )\n\nReturns the address of the current search vocabulary.  If a word\nis not found in the context vocabulary, its parent vocabulary is\nsearched next, chaining up to the core vocabulary\n\nsearch vocabulary\n  0 = core\n  1 = assembler","tags":[]},
{ "title":"CURRENT","text":"!! CURRENT&nbsp;&nbsp;&nbsp;( -- addr )\n\nReturns the address of the vocabulary where new definitions are\nadded.","tags":[]},
{ "title":"FENCE","text":"!! FENCE&nbsp;&nbsp;&nbsp;( -- addr )\n\nReturns the address of the user variable FENCE which defines \nthe lower limit of FORGET","tags":[]},
{ "title":"SYMNEW","text":"!! SYMNEW&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable points to the start of new (unhashed) symbols\nThese are searched first, regardless of length","tags":["uservar"]},
{ "title":"#VOC","text":"!! #VOC&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable containing the total number of vocabularies \ndefined on the system.  Defining a new vocabulary increases\nthis by 1","tags":[]},
{ "title":"NEWEST","text":"!! NEWEST&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable containing the address (NFA) of the most recently\ncreated symbol.  Used by LATEST","tags":[]},
{ "title":"STATE","text":"!! STATE&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe address of the user variable containing the compilation  \nstate.    A non-zero content indicates compilation is occuring,  \nbut the value itself is system dependent.  A Standard Program\nmay not modify this variable.","tags":["forth-83","uservar"]},
{ "title":"CSP","text":"!! CSP&nbsp;&nbsp;&nbsp;( -- addr )\n\nUser variable used to store the current stack pointer, used by\nthe compiler to check for balance.","tags":[]},
{ "title":"NEWDP","text":"!! NEWDP&nbsp;&nbsp;&nbsp;( -- addr )\n\nUsed by REHASH to store the CFA (if invoked by FORGET)\nor HERE (if REHASH is invoked standalone).  Determines\nwhich ancestors to reawaken.  Used to set DP after REHASH","tags":[]},
{ "title":"SCR","text":"!! SCR&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe address of a user variable containing the\nnumber of the screen most recently LISTed or EDITed","tags":[]},
{ "title":"FORTH","text":"!! FORTH&nbsp;&nbsp;&nbsp;( -- )\n\nSet the core vocabulary as context","tags":[]},
{ "title":"BLOOM","text":"!! BLOOM&nbsp;&nbsp;&nbsp;( -- addr )\n\nThe 8-byte Bloom filter used by the core dictionary.  The hash\nis designed to tend to filter out tokens containing numbers","tags":["nosymbol"]},
{ "title":"ASSEMBLER","text":"!! ASSEMBLER&nbsp;&nbsp;&nbsp;( -- )\n\nSet the CONTEXT vocabulary to ASSEMBLER.  ASSEMBLER is\nIMMEDIATE so it executes even when compiling.","tags":[]},
{ "title":"DEFINITIONS","text":"!! DEFINITIONS&nbsp;&nbsp;&nbsp;( -- )\n\nMakes the context vocabulary current","tags":["forth-83"]},
{ "title":"(","text":"!! (&nbsp;&nbsp;&nbsp;( -- )\n\nBegins a Forth comment, terminated by the next ')' character in\nthe input stream","tags":["forth-83"]},
{ "title":"QUERY","text":"!! QUERY&nbsp;&nbsp;&nbsp;( -- )\n","tags":[]},
{ "title":"PEARSON#","text":"!! PEARSON#&nbsp;&nbsp;&nbsp;( nfa -- pearsonhash )\n\ninput is NFA or address of a counted string\npearsonhash is the thread index (0..f)\n\nthe pearson hash should return an evenly distributed\nvalue between $00-$0f based on the wordset in the\ncore dictionary.  In other words, all 16 threads\nare initially balanced with the same number of words,\nto reduce searches to (on average) 1/16th of the\ndictionary.\n\nsymbol table\n\n+---------------+\n|    CFA[low]   |  +0      Code field address\n|    CFA[high]  |\n+-+-+-+-+-+-+-+-+\n|     [   len   ]  +2      Length field\n[I]             |          Immediate bit\n| [V]           |          Vocabulary bit\n|   [S]         |          Smudge bit\n+-+-+-+-+-+-+-+-+\n|   name[1]     |  +3      Name field\n|           ... |\n|   name[len]   |\n+~~~~~~~~~~~~~~~+\n?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)\n+~~~~~~~~~~~~~~~+","tags":["nosymbol"]},
{ "title":"BLOOM#","text":"!! BLOOM#&nbsp;&nbsp;&nbsp;( nfa -- mask addr )\n\nThe dictionary Bloom filter tries to answer the question,\n'is this word a number or does it contain numbers?'\nreturning zero (no digits present) or the sum (mod64)\nof each digits in this word plus how many digits.  If\nany digit is present, BLOOMHASH will not return zero.\n\nThis is expected to sparsely populate the 64-bit wide\nbloom filter field, allowing FIND to bypass the symbol\ntable search if the bit is turned off.\n\nCalculate the bloom filter hash between 0..63.  Returns\na mask and address (starting at bloom) suitable for CBIT!\nor CBIT@.","tags":["nosymbol"]},
{ "title":"NFALEN","text":"!! NFALEN&nbsp;&nbsp;&nbsp;( nfa -- length )\n\nReturn the length of the name","tags":["nosymbol"]},
{ "title":"VOCAB$","text":"!! VOCAB$&nbsp;&nbsp;&nbsp;( -- addr )\n\nString variable holds up to 9 vocabularies to search, not \nincluding core.","tags":[]},
{ "title":"VOCABS>","text":"!! VOCABS>&nbsp;&nbsp;&nbsp;( -- vocabid )\n\nPresents the next one-byte vocabulary id from VOCABS$, slides\nthe rest of the vocab string buffer to the left by one","tags":["nosymbol"]},
{ "title":"VOCID","text":"!! VOCID&nbsp;&nbsp;&nbsp;( vocabulary -- vocabid )\n\nRetrieves the vocabulary identifier from the given vocabulary","tags":["nosymbol"]},
{ "title":"(VOCABLIST)","text":"!! (VOCABLIST)&nbsp;&nbsp;&nbsp;( -- )\n\nSets the VOCABS$ string to the chain of vocabularies between\ncontext and core","tags":["nosymbol"]},
{ "title":"VOC+","text":"!! VOC+&nbsp;&nbsp;&nbsp;( vocabid nfa -- )\n\nAppend the vocabulary id to the string at NFA, and set the \nvocabulary member bit on the name field","tags":["nosymbol"]},
{ "title":"VOC-","text":"!! VOC-&nbsp;&nbsp;&nbsp;( nfa -- )\n\nStrip the vocabulary byte from the string and clear the vocabulary\nmember bit","tags":["nosymbol"]},
{ "title":"((FIND))","text":"!! ((FIND))&nbsp;&nbsp;&nbsp;( name fflag startnfa -- nfa xfa flag )\n","tags":["interpreter","nosymbol"]},
{ "title":"(FIND)","text":"!! (FIND)&nbsp;&nbsp;&nbsp;( name -- nfa xfa flag )\n","tags":["nosymbol"]},
{ "title":"(VOCFIND)","text":"!! (VOCFIND)&nbsp;&nbsp;&nbsp;( vocid name -- nfa xfa flag )\n","tags":["nosymbol"]},
{ "title":"FIND","text":"!! FIND&nbsp;&nbsp;&nbsp;( addr1 -- addr2 flag )\n\naddr1 is the address of a counted string, which is the word to look\nup in the dictionary.\n\nif not found, addr2 is the original addr1, and flag = 0\nif found, addr2 is the code field address of the word,\nand flag = -1 for normal words, +1 for immediate words\n\n! outer interpreter\n\nname is the address of a counted string we are searching for.\nfflag is the find mode.  False means NFAs are sorted, True means check them all\nnfa is the first nfa in the hash list\n\nvocid identifies which vocabulary to search.  Vocabularies may be\nnested.  FIND walks up the CONTEXT tree and leaves a set of hashed\nNFAs (with the vocid appended to the name before hashing) on the stack.\nThe final vocabulary searched will be core, and (FIND) will exit afterward.\n\n  0 = corelist\n\n  1 = assembler\n\n  2+ = vocabularies added by the user\n\n(FIND) first searches the unsorted names beginning at SYMTAIL, and keeps\ngoing without regard to name length.  If it fails to find the word there,\nit tries the hash list, which is expected to be sorted in ascending size\norder.  Vocabularies are searched first, beginning with CONTEXT and chaining\nup until core (0) is reached.  The vocid is appended to the word when\nsearching that vocabulary.  Only one symbol within a vocabulary may be\nactive (unsmudged) at a time.  Smudged words are ignored.  The same symbol\nmay exist within more than one vocabulary.\n\nFor example, at cold start the user types in,\n\n```\nVOCABULARY LATIN          \\ creates a new user vocabulary with vocid = 3\nLATIN DEFINITIONS         \\ sets CURRENT to LATIN, definitions added there\n: EPLURIBUSUNUM ;         \\ adds a new word to the LATIN vocabulary\nVOCABULARY PIGLATIN       \\ creates a new user vocabulary with vocid = 4\n                          \\ PIGLATIN is a member of the LATIN vocabulary\nPIGLATIN DEFINITIONS      \\ sets CURRENT to PIGLATIN, new definitions there\n: IXNAY ;                 \\ adds a new word to the PIGLATIN vocabulary\nFORTH                     \\ set CONTEXT to core\nIXNAY  not found          \\ IXNAY is a member of PIGLATIN, out of context\nPIGLATIN  not found       \\ PIGLATIN is a member of LATIN vocabulary\nLATIN PIGLATIN            \\ set context to LATIN; set context to PIGLATIN\nIXNAY  ok                 \\ search for \"IXNAY\" + $04, found in PIGLATIN(4)\nEPLURIBUSUNUM  ok         \\ search for \"EPLURIBUSUNUM\" + $04, not found.\n                          \\ search for \"EPLURIBUSUNUM\" + $03, in LATIN(3)\nDEPTH .  0 ok             \\ search for \"DEPTH\" + $04, not found in PIGLATIN(4)\n                          \\ search for \"DEPTH\" + $03, not found in LATIN(3)\n                          \\ search for \"DEPTH\", found in core(0)\n\n returns\n       ( cfa -1 ) if found normal word\n       ( cfa 1 ) if found immediate word\n       ( name 0 ) if not in dictionary\n\n```","tags":[]},
{ "title":"EXISTS?","text":"!! EXISTS?&nbsp;&nbsp;&nbsp;( -- addr flag )\n\nparses the next token in the input stream.  Returns either the\naddress of the (unfound) token at HERE and a 0, or the code \nfield address of the word and -1 for normal, +1 for immediate\nwords\nand returns either","tags":[]},
{ "title":"?FIND","text":"!! ?FIND&nbsp;&nbsp;&nbsp;( flag -- )\n\nAborts with the error message \"NOT FOUND\" if flag is true","tags":["nosymbol"]},
{ "title":"'","text":"!! '&nbsp;&nbsp;&nbsp;( -- cfa )\n\nParse the next token in the inputer stream and search for it,\nreturning the CFA if successful.  Otherwise aborts with the\nmessage \"NOT FOUND\"","tags":["forth-83"]},
{ "title":"INTERPRET","text":"!! INTERPRET&nbsp;&nbsp;&nbsp;( -- )\n\nThe Forth interpreter loop","tags":[]},
{ "title":"QUIT","text":"!! QUIT&nbsp;&nbsp;&nbsp;( -- )\n\nThis is the infinite outer interpreter loop:\n      - resets the return stack (RP!)\n      - outputs a carriage return (CR)\n      - waits for a line of input (QUERY)\n      - interprets that line","tags":["forth-83"]},
{ "title":"ABORT","text":"!! ABORT&nbsp;&nbsp;&nbsp;( -- )\n","tags":[]},
{ "title":"INCORE?","text":"!! INCORE?&nbsp;&nbsp;&nbsp;( cfa -- flag )\n\nReturns true if the CFA is in the core dictionary","tags":["nosymbol"]},
{ "title":"INTDICT?","text":"!! INTDICT?&nbsp;&nbsp;&nbsp;( cfa -- flag )\n\nReturns true if the CFA is in the temporary dictionary","tags":["nosymbol"]},
{ "title":"INDICT?","text":"!! INDICT?&nbsp;&nbsp;&nbsp;( nfa -- flag )\n\nreturn true if the code field is in either the core or pettil \ndictionary","tags":["nosymbol"]},
{ "title":">SYMS","text":"!! >SYMS&nbsp;&nbsp;&nbsp;( -- addr )\n\nreturns the address of the symbol portion of the symbol table","tags":[]},
{ "title":"SYM+","text":"!! SYM+&nbsp;&nbsp;&nbsp;( nfa target -- target+ )\n\nadd a symbol to the symbol table, and turn on its bloomfilter bit\nleave the address following the symbol on the stack\n\n```\n: sym+\n    ( nfa target )\n    over bloomhash cbit!\n    ( nfa target )\n    over nfalen 1+\n    ( nfa target len+1 )\n    2dup + >r\n    ( nfa target len+1 ) ( R; target+ )\n    cmove r> ;\n    ( target+ )\n\n```","tags":[]},
{ "title":"NFA+","text":"!! NFA+&nbsp;&nbsp;&nbsp;( nfa -- nfa+ )\n\nChain to the next NFA on the list","tags":[]},
{ "title":"SYMBYSIZE","text":"!! SYMBYSIZE&nbsp;&nbsp;&nbsp;( searchlen nfa -- flag )\n\nreturns true iff\n\nsearchleng matches the current length? (I)\n\nand (CFA < DP or CFA > TDICT?)\n\n```\n: symbysize   ( searchlen nfa -- flag )\n    nfalen = ;\n\n```","tags":[]},
{ "title":"SYMBYHASH","text":"!! SYMBYHASH&nbsp;&nbsp;&nbsp;( hash nfa -- flag )\n\nreturns true iff\n\ncalculate its pearson hash\n\nand that matches the current hash?\n\n```\n: symbyhash   ( hash nfa -- flag )\n    dup pearsonhash rot = dup\n    if\n        swap name>\n        dup b/buf newdp @ between?\n        swap tdict @ memsiz @ between?  or\n    then nip ;\n\n```","tags":[]},
{ "title":"SYMSORT","text":"!! SYMSORT&nbsp;&nbsp;&nbsp;( 'compare searchfor src target -- target+ )\n\nMake a pass through the symbol table at PAD, copying eligible\nsymbols to target\n\n```\n: symsort   ( 'compare searchfor src target )\n    >r 2+\n    ( 'compare searchfor nfa ) ( R; target )\n    begin\n        \\ not done yet?\n        dup nfalen\n        ( 'compare searchfor nfa currlen ) ( R; target )\n    while\n        ( 'compare searchfor nfa ) ( R; target )\n        3dup rot execute\n        ( 'compare searchfor nfa flag ) ( R; target )\n        if\n            \\ copy the CFA\n            ( 'compare searchfor nfa ) ( R; target )\n            r> over name> !+\n            \\ copy the symbol\n            ( 'compare searchfor nfa target+2 )\n            under sym+ >r\n            ( 'compare searchfor nfa ) ( R; target+ )\n        then\n        \\ advance source pointer\n        nfa+\n        ( 'compare searchfor nfa+ ) ( R; target+ )\n    repeat\n    ( 'compare searchfor nfa+ ) ( R; target+ )\n    3drop r> ;   ( target+ )\n\n```","tags":[]},
{ "title":"PASSBITS","text":"!! PASSBITS&nbsp;&nbsp;&nbsp;( -- addr )\n\n32-bit wide Bloom filter for skipping REHASH passes if there\nare no words of a particular length","tags":["nosymbol"]},
{ "title":">BLOOM","text":"!! >BLOOM&nbsp;&nbsp;&nbsp;( n -- mask offset )\n\ntransform an integer into a bitmask and offset, suitable for\naddressing a bloom filter\n\nmask = 2^(n%8)\n\noffset = n/8\n\n```\n: >bloom   ( n -- mask offset )\n        dup 7 and power2 + c@\n        swap 2/ 2/ 2/ ;\n\ntobloom\n    dex\n    lda tos\n    and #7\n    tay\n    lda power2,y\n    sta stackl,x\n    lda #0\n    sta stackh,x\n    lsr tos+1\n    ror tos\n    lsr tos+1\n    ror tos\n    lsr tos+1\n    ror tos             ; /8\n    lda tos+1\n    jmp next\n\n\n```","tags":[]},
{ "title":"AUTOMEM","text":"!! AUTOMEM&nbsp;&nbsp;&nbsp;( lastpad -- )\n\nAutomatically move symbol table and vmbuf to someplace that leaves\n~512 bytes for symbol table growth\n\nThe \"lastpad\" address points to the null byte at the end of the\nsorted-by-size symbol table copy at pad\n\n```\n: automem   ( addr -- )\n    pad - tdict @ swap - $ff00 and $200 -\n( newsymtab -- )\n    dup symtab @ -  swap symtab !\n( delta -- )\n    #vmpkt @\n    if\n        vmbuf @\n        symtab @\n        third\n        +move\n        vmbuf over +!\n    else\n        drop blkbuf\n        2- dup off vmbuf !\n    then ;\n\n```","tags":["nosymbol"]},
{ "title":"ANCESTOR","text":"!! ANCESTOR&nbsp;&nbsp;&nbsp;( -- addr )\n\nvariable that holds the youngest ancestor for REHASH","tags":["nosymbol"]},
{ "title":"SAMEASME?","text":"!! SAMEASME?&nbsp;&nbsp;&nbsp;( descendant candidate -- flag )\n","tags":["nosymbol"]},
{ "title":"?CANDIDATE","text":"!! ?CANDIDATE&nbsp;&nbsp;&nbsp;( descendant candidate -- )\n\n\n```\n: ?candidate   ( descendant candidate -- )\n  ( descendant candidate )\n    \\ candidate is inactive?\n    dup c@ $20 and\n  ( descendant candidate flag )\n    if\n  ( descendant candidate )\n      \\ candidate remains in dictionary?\n      \\ and is more recent than prior candidates?\n        dup name>  ancestor @  dup\n        if\n            nip name>\n        then\n        newdp @  between?\n  ( descendant candidate flag )\n        if\n  ( descendant candidate )\n            2dup sameasme?\n  ( descendant candidate flag )\n            if\n                dup ancestor !\n                32 third cbit!\n            then\n        then\n    then\n    2drop ;\n\n```","tags":["nosymbol"]},
{ "title":"?ANCESTOR","text":"!! ?ANCESTOR&nbsp;&nbsp;&nbsp;( descendant nfa -- )\n\nSearches for a qualifying ancestor and exchanges the smudge bit\n\n```\n: ?ancestor   ( descendant startnfa -- )\n  ( descendant startnfa )\n    ancestor off\n  ( descendant startnfa )\n    begin\n  ( descendant nfa )\n        dup nfalen\n  ( descendant nfa length )\n    while\n  ( descendant nfa )\n        2dup ?candidate\n        nfa+\n    repeat\n    ancestor @ ?dup\n    if\n        smudge\n    then\n    2drop ;\n\n```","tags":[]},
{ "title":"REAWAKEN","text":"!! REAWAKEN&nbsp;&nbsp;&nbsp;( nfa -- )\n\nfor each active symbol being forgotten.\n\n- search for its youngest living ancestor.\n\n- if found, deactivate the descendant, activate the ancestor\n\nscan through the NFA list at PAD, awakening ancestors\n\n* list is terminated by 0-length\n\n* iterate each word from nfa until end (outer loop)\n\n* newdp < nfa < dp and nfa is active\n\n* - ancestor = 0\n\n* - iterate each word from nfa until end (inner loop)\n\n* - - is inactive\n\n* - - and is same name\n\n* - - and ancestor < cfa < newdp\n\n* - - - replace ancestor\n\n* ancestor = 0?\n\n* - iterate each word from nfa until end (inner loop)\n\n* - - is inactive\n\n* - - and is same name\n\n* - - and tdict < cfa < memsiz\n\n* - - - replace ancestor\n\n* ancestor <> 0?\n\n* - deactivate active symbol\n\n* - activate ancestor\n\n```\n ( start )\n 2+ dup>r\n ( startnfa ) ( R; startnfa )\n begin\n     dup\n     nfalen\n while\n ( nfa )\n     dup c@ $20 and 0=\n     over name>  newdp @ dp @ between? and\n     if\n         dup r@ ?ancestor\n     then\n     nfa+\n    repeat\n    r> 2drop ;\n\n```","tags":["nosymbol"]},
{ "title":"PASSFILTER","text":"!! PASSFILTER&nbsp;&nbsp;&nbsp;( symbols -- )\n\nDuring the first half of rehash, it is unnecessary to make a\npass through the entire symbol table searching for words of a\ngiven length, if none of that length exist.  This is a\nbloom filter to eliminate those symbol table passes.\n\n```\n: passfilter   ( symbols -- )\n    passbits 4 erase\n    2+\n    ( nfa )\n    begin\n        dup nfalen ?dup\n    while\n        >bloom passbits + cbit!\n        nfa+\n    repeat drop ;\n\n```","tags":["nosymbol"]},
{ "title":"(REHASH1)","text":"!! (REHASH1)&nbsp;&nbsp;&nbsp;( -- lastsym )\n\nPhase 1 of REHASH\n\n* Make a pass through SYMTAB + SYMNEW, create Bloom filter of sizes\n\n* For each size 1..31\n\n* - If it has members, merge SYMTAB + SYMNEW to PAD, ordered by length\n\n* - tack on three zeroes at the end\n\n* - Make a pass through PAD at that size\n\n* - - If active and between CFA..HERE\n\n* - - - Make a pass through PAD at current size\n\n* - - - Reawaken youngest ancestor less than CFA (or in TDICT)\n\n* set DP = cfa\n\n* Return the last symbol at PAD for automatic memory allocation\n\n```\n: (rehash1)   ( -- )\n( )\n    >syms pad   over passfilter\n( symbols pad )\n    32 1 do\n( src targ )\n        i >bloom\n( src targ mask offset )\n        passbits + cbit@\n( src targ flag )\n        if\n            dup >r\n( src targ ) ( R; src )\n            [ 'symbysize ] literal i\n( src targ 'compare i ) ( R; src )\n            2over symsort nip\n( src targ+ ) ( R; src )\n            over 3 erase r> reawaken\n        then\n( src targ+ )\n    loop  nip ;\n\n```","tags":[]},
{ "title":"(REHASH2)","text":"!! (REHASH2)&nbsp;&nbsp;&nbsp;( -- )\n\nPhase 2 of REHASH\n\n* symtab 32 erase\n\n* bloom 8 erase\n\n* target = symtab+32\n\n* For each hashcode 0..15\n\n* - set symtab+i*2 = target\n\n* - run all the symbols\n\n* - - if hashcode matches, and it's alive, append it to target\n\n* set symnew = symtail = target\n\n* symnew 3 erase\n\n```\n: (rehash2)   ( -- )\n    symtab @ 32 erase\n    bloom 8 erase\n    pad >syms\n    16 0 do\n        dup i 2* symtab @ + !\n        [ 'symbyhash ] literal i\n        2over symsort nip\n    loop\n( target )\n    dup symnew ! dup symtail !\n    3 erase ;\n\n```","tags":["nosymbol"]},
{ "title":"(REHASH)","text":"!! (REHASH)&nbsp;&nbsp;&nbsp;( cfa -- )\n\nrebuild the symbol table at SYMTAB, moving VMBUF and SYMTAB\nat halftime, if necessary.  The CFA is used in phase 1 to\nrewaken sleeping ancestors.  Passing HERE will not wake up\nanything.\n\n```\n: (rehash)   ( cfa -- )\n    newdp !\n    (rehash1)\n    automem\n    (rehash2)\n    newdp @ dp ! ;\n\n```","tags":["nosymbol"]},
{ "title":"REHASH","text":"!! REHASH&nbsp;&nbsp;&nbsp;( -- )\n\nrebuilds the symbol table in high memory.\n\n```\n: rehash  ( -- )\n    here (rehash) ;   \\ effectively a FORGET nil\n\n```","tags":[]},
{ "title":"FORGET","text":"!! FORGET&nbsp;&nbsp;&nbsp;( -- )\n\nchecks FENCE, moves DP, sorts symbol table\n\n```\n: forget   ( -- )\n    '\n ( cfa )\n    dup fence @ u<\n ( cfa flag )\n    if\n        7 fail\n    then\n ( cfa )\n    (rehash) ;\n\n```","tags":[]},
{ "title":"Glossary","text":"[[WARM]] [[COLD]] [[HOT]] [[USERVAR]] [[SP0]] [[RP0]] [[DP]] [[MEMSIZ]] [[SYMTAB]] [[SYMTAIL]] [[STARTUP]] [[VMBUF]] [[#VMPKT]] [[EDITING?]] [[WRITABLE?]] [[TDICT]] [[BASE]] [[DPL]] [[HLD]] [[BLK]] [[>IN]] [[SPAN]] [[#TIB]] [[#OUT]] [[#LINE]] [[ERRMESS]] [[EXECUTE]] [[>6502]] [[(ABORT\")]] [[(LIT)]] [[CLIT]] [[HEX]] [[DECIMAL]] [[(DOES)]] [[?BRANCH]] [[(?DO)]] [[BRANCH]] [[(+LOOP)]] [[(LOOP)]] [[(DO)]] [[2DROP]] [[DROP]] [[4DROP]] [[3DROP]] [[I]] [[J]] [[(LEAVE)]] [[(?LEAVE)]] [[SP@]] [[SP!]] [[RP!]] [[EXIT]] [[DOCREATE]] [[ENTER]] [[DOCCONST]] [[DOCONST]] [[DO2CONST]] [[!IRQ]] [[?STACK]] [[SYSERR]] [[>FORTH]] [[DOPAGE]] [[FAIL]] [[IRQ^]] [[SPACE]] [[SPACES]] [[COUNT]] [[TYPE]] [[(.\")]] [[.S]] [[EMIT]] [[KEY]] [[?TERMINAL]] [[CR]] [[VIDRAM]] [[MON]] [[JIFFY@]] [[CMDOFF]] [[EXPECT]] [[FILENAME]] [[OPEN]] [[HPIN]] [[HPOFF]] [[HPOUT]] [[CSAVE]] [[CLOAD]] [[?DISC]] [[D+]] [[D<]] [[DNEGATE]] [[DABS]] [[2DUP]] [[2OVER]] [[2ROT]] [[2SWAP]] [[2!]] [[2@]] [[D-]] [[D0=]] [[D=]] [[DU<]] [[D2/]] [[D2*]] [[D>]] [[DMIN]] [[DMAX]] [[$INDEX]] [[B/BUF]] [[B/SCR]] [[BLKBUF]] [[RLENCODE]] [[RLDECODE]] [[>PKT]] [[PKT+]] [[UNPKT]] [[(BLOCK)]] [[BLOCK]] [[DISC]] [[SAVE-BUFFERS]] [[UPDATE]] [[EMPTY-BUFFERS]] [[USER]] [[+ORIGIN]] [[CONTEXT]] [[CURRENT]] [[FENCE]] [[SYMNEW]] [[#VOC]] [[NEWEST]] [[STATE]] [[CSP]] [[NEWDP]] [[SCR]] [[FORTH]] [[BLOOM]] [[ASSEMBLER]] [[DEFINITIONS]] [[(]] [[QUERY]] [[PEARSON#]] [[BLOOM#]] [[NFALEN]] [[VOCAB$]] [[VOCABS>]] [[VOCID]] [[(VOCABLIST)]] [[VOC+]] [[VOC-]] [[((FIND))]] [[(FIND)]] [[(VOCFIND)]] [[FIND]] [[EXISTS?]] [[?FIND]] [[']] [[INTERPRET]] [[QUIT]] [[ABORT]] [[INCORE?]] [[INTDICT?]] [[INDICT?]] [[>SYMS]] [[SYM+]] [[NFA+]] [[SYMBYSIZE]] [[SYMBYHASH]] [[SYMSORT]] [[PASSBITS]] [[>BLOOM]] [[AUTOMEM]] [[ANCESTOR]] [[SAMEASME?]] [[?CANDIDATE]] [[?ANCESTOR]] [[REAWAKEN]] [[PASSFILTER]] [[(REHASH1)]] [[(REHASH2)]] [[(REHASH)]] [[REHASH]] [[FORGET]] "}]
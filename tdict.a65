; tdict.a65
;
; PETTIL temporary dictionary
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
						; load address of temporary dictionary
						; (usually $8000 - size of tdict)
#undefine HEADERS
#define tdict $7c92
    .word tdict                   ; this will be the load address
* = tdict

; all symbols from main dictionary. generated from pettil source by symtab.rb

#define RVSON       $12
#define RVSOFF      $92
#include syms_tdict.tmp

;--------------------------------------------------------------
;
;       ALLOT
;
; * 83 compiler
;
#ifdef HEADERS
allotlfa
    .byt $de,$ad
    .byt (_allot-*-1)|bit7
    .asc "ALLO","T"|bit7
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,   ( w -- )
;
; * 83 compiler
;
#ifdef HEADERS
commalfa
    .byt $de,$ad
    .byt (_comma-*-1)|bit7
    .asc ","|bit7
#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,$   ( ?? -- ?? )
;
; compiler
;
#ifdef HEADERS
commadollarlfa
    .byt $de,$ad
    .byt (_commadollar-*-1)|bit7
    .asc ",","$"|bit7
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       HERELSB   ( -- c )
;
; Returns the least significant byte of DP
;
;#ifdef HEADERS
;herelsblfa
;    .byt $de,$ad
;    .byt (_herelsb-*-1)|bit7
;    .asc "HERELS","B"|bit7
;#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; create the code field of a new definition, taking page alignment
; into account.
;
; compiler
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,XT   ( xt -- )
;
; encloses the execution token into the dictionary, paying heed
; to PETTIL's requirement that XTs must be page-aligned and that
; secondaries are responsible for invoking 'page' to cross a page
; boundary
;
; compiler
;
;": ,xt   ( xt -- )
;     herelsb $fc >
;     if
;         ['] page ,
;         herelsb
;         if
;             dp 1+!
;         then
;     then
;     , ;
;
;#ifdef HEADERS
;commaxtlfa
;    .byt $de,$ad
;    .byt (_commaxt-*-1)|bit7
;    .asc ",X","T"|bit7
;#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word exit

;--------------------------------------------------------------
;
;       CREATE
;
; * 83 compiler
;
; A defining word executed in the form
;     CREATE <name>                 
;     Creates a dictionary entry for <name>.  After <name> is
;     created, the next available dictionary location is the first
;     byte of <name>'s parameter field.  When <name> is
;     subsequently executed, the address of the first byte of
;     <name>'s parameter field is left on the stack.  CREATE does
;     not allocate space in <name>'s parameter field.
;
;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa ) 
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )                               
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )
#ifdef HEADERS
createlfa
    .byt $de,$ad
    .byt (_create-*-1)|bit7
    .asc "CREAT","E"|bit7
#endif
_create
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word bl                    ; ( bl )
#include "page.i65"
    .word _word                 ; ( nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa nfa )
#include "page.i65"
    .word _find                 ; ( nfa nfa addr2 flag )
#include "page.i65"
    .word swap                  ; ( nfa nfa flag addr2 )
#include "page.i65"
    .word drop                  ; ( nfa nfa flag )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(create03-*+1)
#include "pad.i65"
    .word clit                  ; ( nfa cfa $12 )
    .byt RVSON
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word over                  ; ( nfa cfa nfa )
#include "page.i65"
    .word count                 ; ( nfa cfa addr+1 len )
#include "page.i65"
    .word type                  ; ( nfa cfa )
#include "page.i65"
    .word clit
    .byt RVSOFF                 ; ( nfa cfa $92 )
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word _pdq
    .byt create02-*-1
    .asc    " EXISTS"           ; ( nfa cfa )
create02
#include "pad.i65"              ; ( nfa addr )
create03                        ; THEN
    .word drop                  ; ( nfa )
#include "page.i65"
    .word tor                   ; ( ) ( R; nfa )
#include "page.i65"
    .word clit                  ; ( $80 )
    .byt $80
#include "page.i65"
    .word rfetch                ; ( $80 nfa ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word _twodup               ; ( $80 len $80 len ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( $80 len len|bit7 ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len len|bit7 nfa ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len nfa ) ( R; nfa )
#include "page.i65"
    .word plus                  ; ( $80 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word dup                   ; ( $80 cfa-1 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 cfa-1 last ) ( R; nfa )
#include "page.i65"
    .word rot                   ; ( cfa-1 last $80 ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( cfa-1 last|bit7 ) ( R; nfa )
#include "page.i65"
    .word over                  ; ( cfa-1 last|bit7 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( cfa-1 ) ( R; nfa )
#include "page.i65"
    .word oneplus               ; ( cfa ) ( R; nfa )
#include "page.i65"
    .word dp                    ; ( cfa dp ) ( R; nfa )
#include "page.i65"
    .word store                 ; ( )  ( R; nfa )
#include "page.i65"
    .word plit
    .word docreate              ; ( 'docreate ) ( R; nfa )
#include "pad.i65"
    .word _commacfa             ; ( ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( nfa ) ( R; nfa )
#include "page.i65"
    .word dhash                 ; ( hash1 hash2 ) ( R; nfa )
#include "page.i65"
    .word bloomstore            ; ( hash1 ) ( R; nfa )
#include "page.i65"
    .word rfrom                 ; ( hash1 nfa ) ( R; nfa )
#include "page.i65"
    .word twominus              ; ( hash1 lfa )
#include "page.i65"
    .word swap                  ; ( lfa hash1 )
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word dhashstore            ; ( )
#include "page.i65"
    .word exit                  ; ( )
;docreate
;    pla
;    clc
;    adc #1
;    sta n
;    pla
;    tay
;    bcc docreate01
;    iny
;docreate01
;    lda n
;    jmp pushya

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;
; * 83 compiler
;
; "colon"
;" A defining word executed in the form:
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi

; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
; wrapper to build PETTIL core dictionary
; disposable run-once COLD start code

; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
;" http://pettil.tumblr.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

#define DEBUG
#define SWEET16
#define PET_ROM4                ; target machine
#undefine HEADERS                 ; put headers in code?
                                ; PET target memory size
#define PETRAM 32

#include modules/cbm.def
#include modules/pettil.def

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================
#define basic $0400
    .word basic+1               ; this will be the load address
* = basic+1
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold

;==============================================================
;==== zeropage buffer and user area                        ====
;==============================================================
;
; this is an image of PETTIL zeropage at cold start.  Swapping it
; with the BASIC zeropage makes hopping back and forth possible
;
zpbuf
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,$2002,$3003
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack

;--------------------------------------------------------------
;
;       NEXT
;
; * inner interpreter headerless
;
;               +IP
;               [IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ;
    nop                     ; see "RANDU" for how it works
    nop                     ;
;$86
zpnext
    inc ip                  ; 5
    inc ip                  ; 5
;ip = *+1
    jmp ($cafe)             ; 5

                            ;15 cycles total
;$8D TIME

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================
#ifdef SWEET16
    nop                         ; fine tune position of Sweet16

#if (* <> $04a6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04a6 (1190).  This is a problem. 
#endif
#echo .       program counter just before Sweet16 should be 1190, is:
#print *

#include modules/sweet16.a65

#endif
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;==============================================================
; uarea initialization data
userarea
userup          .word uarea                             ; WARM
usersp0         .word bos+1                             ;
userrp0         .word $01fe                             ;
usercontext     .word 0                                 ;
usercurrent     .word 0                                 ;
userwarm
; everything before userwarm is initialized at WARM start

userfence       .word cold                              ; COLD
userdp          .word cold                              ;
usermemsiz      .word 0     ; set by COLD from BASIC (copy of $34)
usersymtab      .word 0
userstartup     .word hot   ; CFA of bootstrap code to run after warm
usercold
; everything before usercold is initialized at COLD start

; everything below this is set to 0 by COLD and untouched by WARM
uservmbuf       = usercold                              ; SOFT
uservmsiz       = usercold+2                            ; (COLD = 0)
usersymnew      = usercold+4                            ; set by REHASH
usersymtail     = usercold+6                            ; set by CREATE
usertdict       = usercold+8                            ; 
userbase        = usercold+10                           ; (WARM = unchanged)
userdpl         = usercold+12                           ;
userhld         = usercold+14                           ;
userblk         = usercold+16                           ;
usertoin        = usercold+18                           ;
userspan        = usercold+20                           ;
usertib         = usercold+22                           ;
usernumout      = usercold+24                           ;
usernumline     = usercold+26                           ;
usererrmess     = usercold+28                           ;
userscr         = usercold+30                           ;
userstate       = usercold+32                           ;
usercsp         = usercold+34                           ;
usernumvoc      = usercold+36                           ;

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+48,0

;==============================================================
;==== PETTIL dictionary                                    ====
;==============================================================
#include modules/core-subroutines.a65
#include modules/core-user.a65
#include modules/core-inner.a65
#include modules/core-nucleus.a65
#include modules/core-device.a65
#include modules/core-pet.a65
#include modules/core-numword.a65
#include modules/core-double.a65
#include modules/core-string.a65
#include modules/core-vm.a65

;--------------------------------------------------------------
;
;       WARM
;
; Dropping out to BASIC can be accomplished on purpose with
; MON (to get to TIM), then .X to get to BASIC.  It also will
; happen by mistake if cassette i/o is interrupted by the STOP
; key or any tape error.  There may be other ways.  WARM should
; be able to bring the system back to a usable state.
;
; Tasks
; * aloha
; * - swap zero page with zpbuf
; * - switch Sweet16<-->TIM BRK vector
; * - switch PETTIL<-->BASIC IRQ vector
; * reset Forth return stack (machine stack)
; * reset Forth data stack
; * print start message CR,"WELCOME TO PETTIL!",CR
; * STARTUP @ EXECUTE
;
;#ifdef HEADERS
;warmlfa
;    .byt $de,$ad
;    .byt (warm-*-1)|bit7
;    .asc "WAR","M"|bit7
;#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
#include "toforth.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable
;==============================================================

;--------------------------------------------------------------
;
;        COLD   ( -- )
;
; One-time only (then disappear) system bootstrap initialization.
; Runs once after "pettil.obj" loads, to prepare a development
; environment.  The size of COLD doesn't really matter.  As
; the final word in the core dictionary, COLD will FORGET
; itself and its address becomes the value of FENCE.
; It's a little hairy, I hope my comments will explain.
;
; the pieces at load time
; * 0400-040c   BASIC bootstrap (10 SYS 1037)
; * 040d-0410   pettillaunch (JMP COLD)
; * 0410-049c   zpbuf (partial zero page mirror $00-$8C)
; * 049d-04a4   power2 (01 02 04 08 10 20 40 80)
; * 04a5        unused byte
; * 04a6-065a   Sweet16
; * 065b-       slip, slide, Sweet16 extensions
; * brktoggle,  the EOR of TIM and Sweet16 entry points
; * userarea,   User variable storage
; * swapzp,     and other native 6502 code subroutines
; * core,       permanent dictionary (bodies only)
;
;
; * cold,       bootstrap initialization
;---------------tdict & symbol table concatenated to there-----
; * there,      target load address of temporary dictionary (2)
; * there+2,    size of temporary dictionary (2)
; * there+4,    temporary dictionary, bodies only
; * tdict       outer interpreter, compiler, editor, assembler
; * symbols,    symbol table data
;
; COLD tasks
; * change the startup vector from COLD to WARM
; * set MEMSIZ from BASIC $34-35
; * set SYMTAB as an offset from MEMSIZ
; * set TDICT as the load address + 2 of part 2 (found at 'there')
; * display a banner
; * set STARTUP uservariable to LAUNCH
; * move temporary dictionary to TDICT
; * move symbol table to SYMTAB
; * set FENCE
; * call WARM to put us in Forth mode
;
; There is no knowledge in the core dictionary (at the bottom of memory)
; of what is in the temporary dictionary or where it resides.  To kick
; things off upstairs, WARM starts Forth, then executes the word LAUNCH
; in the upper dictionary, via the STARTUP uservariable.  The requirement
; is that the first thing in tdict must be the executable CFA of LAUNCH
; That's where we will pick things up.
;
; temporary dictionary and symbols are built separately
; and concatenated to the PETTIL.OBJ core binary
;
;#ifdef HEADERS
;coldlfa
;    .byt $de,$ad
;    .byt (cold-*-1)|bit7
;    .asc "COL","D"|bit7
;#endif
cold
    lda #<bannermsg             ; display a banner
    sta TEMPF1
    lda #>bannermsg
    sta TEMPF1+1
    ldy #0
cold01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg-1
    bne cold01

    lda #<warm                  ; close the door on ourselves
    sta pettillaunch+1          ; runs cold once, warm to reenter
    lda #>warm
    sta pettillaunch+2

    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz              ; and symbol table pointers
    sta usersymtab
    lda MEMSIZ+1
    sta usermemsiz+1            ; $6400 = SYMTAB
    sec                         ; $7100 = temp dictionary
    sbc #$1c                    ; $8000 = MEMSIZ
    sta usersymtab+1

    jmp cold2warm

;--------------------------------------------------------------
;
;        HOT   ( -- )
;
; The tail end of the one-time only (then disappear) system
; bootstrap initialization.  HOT runs as the STARTUP word after
; COLD invokes WARM to kick things off. Hence the name.
;
; HOT tasks
; * set user variable ERRMESS
; * find FIND
; * ' ABORT DUP STARTUP !
; * FORGET HOT
; * ( abort ) EXECUTE
;
;#ifdef HEADERS
;hotlfa
;    .byt $de,$ad
;    .byt (hot-*-1)|bit7
;    .asc "HO","T"|bit7
;#endif
hot
#include "enter.i65"
    .word plit
    .word there                 ; ( there )
#include "pad.i65"
    .word dup                   ; ( there there ) 
#include "page.i65"
    .word fetch                 ; ( there tdict-2 )
#include "page.i65"
    .word twoplus               ; ( there tdict )
#include "page.i65"
    .word dup                   ; ( tdict there )
#include "page.i65"
    .word tdict                 ; ( tdict there )
#include "page.i65"
    .word store                 ; ( tdict there )
#include "page.i65"
    .word swap                  ; ( tdict there )
#include "page.i65"
    .word twoplus               ; ( tdict there+2 )
#include "page.i65"
    .word dup                   ; ( tdict there+2 there+2 )
#include "page.i65"
    .word fetch                 ; ( tdict there+2 tdictsiz )
#include "page.i65"
    .word swap                  ; ( tdict tdictsiz there+2 )
#include "page.i65"
    .word twoplus               ; ( tdict tdictsiz there+4 )
#include "page.i65"
    .word twodup               ; ( tdict tdictsiz there+4 tdictsiz there+4 )
#include "page.i65"
    .word plus                  ; ( tdict tdictsiz there+4 tdictsiz+there+4 )
#include "page.i65"
    .word plit
    .word usersymtab            ; ( tdict tdictsiz there+4 tdictsiz+there+4 usersymtab )
#include "pad.i65"
    .word fetch                 ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab )
#include "page.i65"
    .word clit
    .byt 32                     ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab 32 )
#include "pad.i65"
    .word twodup               ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab 32 symtab 32 )
#include "page.i65"
    .word _erase                ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab 32 )
#include "page.i65"
    .word plus                  ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab+32 )
#include "page.i65"
    .word clit
    .byt EAL                    ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab+32 $c9 )
#include "page.i65"
    .word fetch                 ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab+32 loadend )
#include "page.i65"
    .word third                 ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab+32 loadend tdictsiz+there+4 )
#include "page.i65"
    .word minus                 ; ( tdict tdictsiz there+4 tdictsiz+there+4 symtab+32 symtabsiz )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _dashrot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute               ; launch

;--------------------------------------------------------------
    .byt (there-*-1)
bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-06-10",CR
    .asc    "1977 APPLE ][ GOES ON SALE",CR
            ;123456789.123456789.123456789.123456789.
there
; temporary dictionary and symbols are built separately
; as PETTIL-TDICT.OBJ and PETTIL.SYM, then they are both
; appended to the PETTIL.OBJ core binary
;
;"pettil-tdict.obj looks like this:
; two byte load address of pettil-tdict.obj e.g. $71fe
; two byte length of pettil-tdict.obj
;
; The actual load address is off by -2.  There are two bytes in 
; front of the tdict.obj code storing the length of tdict.obj.
; This length information is needed to figure out where the symbol
; table starts, following tdict
;
; All addresses in tdict in this example would be located as though
; tdict had been assembled and loaded at *=$7200, in spite of the 
; misleading load address.
;
;"pettil.sym looks like this:
; repeated for each head
; [ two byte CFA
;   one byte length and flags
;   name
;   one byte vocabulary identifier, if present ]

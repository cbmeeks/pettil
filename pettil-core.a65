; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
; wrapper to build PETTIL core dictionary
; disposable run-once COLD start code

; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
;" http://pettil.tumblr.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

; include debugging logic
#define DEBUG

; build with Sweet-16
#define SWEET16

; target machine
#define PET_ROM4

; PET target memory size
#define PETRAM 32

#include modules/cbm.def
#include modules/pettil.def

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================

#define basic $0400
;--------------------------------------------------------------
#if 0
name=BASIC bootstrap
[desc]
PETTIL loads as a BASIC program consisting of one line,
`10 SYS1037` to kick off the cold start routine
[/desc]
#endif
    .word basic+1               ; this will be the load address
* = basic+1
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold
;--------------------------------------------------------------
#if 0
name=zpbuf and zero page NEXT routine
[desc]
This buffer holds an image at load time of zero page between
$00..$8D. PETTIL cold start calls the `zpswap` routine to
exchange it with the BASIC zero page on entry or exit.

At $86 is PETTIL's 15-clock inner interpreter consisting of 
just three instructions.  Whoa.  It's fast.
[/desc]
#endif
;==============================================================
;==== zeropage buffer and user area                        ====
;==============================================================
;
;
zpbuf
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,$2002,$3003
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack
;
;       NEXT
;               +IP
;               [IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ;
    nop                     ; see "RANDU" for how it works
    nop                     ;
;$86
zpnext
    inc ip                  ; [5]
    inc ip                  ; [5]
;ip = *+1
    jmp ($cafe)             ; [5]

                            ;[15] cycles total
;$8D TIME					; end of zero page buffer, Jiffy clock is here

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================
#ifdef SWEET16
    nop                         ; fine tune position of Sweet16

#if (* <> $04a6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04a6 (1190).  This is a problem.
#endif
#echo .       program counter just before Sweet16 should be 1190, is:
#print *

#include modules/sweet16.a65

#endif
;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;==============================================================
; uarea initialization data
userarea

; WARM
userup          .word uarea     ;
usersp0         .word bos+1     ;
userrp0         .word $01fe     ;
usercontext     .word 0         ; LAUNCH sets to FORTH
usercurrent     .word 0         ; LAUNCH sets to FORTH
userwarm

; COLD
userfence       .word cold      ;
userdp          .word cold      ;
userstartup     .word hot       ; bootstrap COLD->HOT->LAUNCH
usermemsiz      .word 0         ; set by COLD (BASIC $34)
usercold

; SOFT
; everything below initializes to 0 at COLD and is untouched by WARM
;
; memory pointers, in descending order
usertdict       = usercold+0    ; set by COLD
usersymtail     = usercold+2    ; set by REHASH
usersymnew      = usercold+4    ; set by REHASH
usersymtab      = usercold+6    ; set by COLD
uservmbuf       = usercold+8    ;
;
usernumvmpkt    = usercold+10   ;
userscr         = usercold+12   ;
usereditingq    = usercold+14   ;
userwritableq   = usercold+16   ;
usernumvoc      = usercold+18   ;
usernewest      = usercold+20   ;
usernewdp       = usercold+22   ;
usererrmess     = usercold+24   ;
;
userbase        = usercold+26   ;
userdpl         = usercold+28   ;
userhld         = usercold+30   ;
userblk         = usercold+32   ;
usertoin        = usercold+34   ;
userspan        = usercold+36   ;
usertib         = usercold+38   ;
usernumout      = usercold+40   ;
usernumline     = usercold+42   ;
userstate       = usercold+44   ;
usercsp         = usercold+46   ;

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+56,0

;==============================================================
;==== PETTIL dictionary                                    ====
;==============================================================
#include modules/core-subroutines.a65
#include modules/core-user.a65
#include modules/core-inner.a65
#include modules/core-nucleus.a65
#include modules/core-device.a65
#include modules/core-pet.a65
#include modules/core-numword.a65
#include modules/core-double.a65
#include modules/core-string.a65
#include modules/core-vm.a65

;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=nosymbol
[desc]
Dropping out to BASIC can be accomplished on purpose with MON
(to get to TIM), then .X to get to BASIC.  It also will happen
by mistake if cassette i/o is interrupted by the STOP key or 
any tape error.  There may be other ways.  WARM should be able
to bring the system back to a usable state.
[heading]Tasks[/heading]
[list]
* aloha
* - swap zero page with zpbuf
* - switch Sweet16<-->TIM BRK vector
* - switch PETTIL<-->BASIC IRQ vector
* reset Forth return stack (machine stack)
* reset Forth data stack
* print start message CR,"WELCOME TO PETTIL!",CR
* STARTUP @ EXECUTE
[/list]
[/desc]
#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
#include "toforth.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable
;==============================================================

;--------------------------------------------------------------
#if 0
name=COLD
stack=( -- )
tags=transient,nosymbol
[desc]
One-time only (then disappear) system bootstrap initialization.
Runs once after "pettil.obj" loads, to prepare a development
environment.  The size of COLD doesn't really matter.  As
the final word in the core dictionary, COLD will FORGET
itself and its address becomes the value of FENCE.
It's a little hairy, I hope my comments will explain.
[heading]the pieces at load time[/heading]
[list]
* 0400-040c   BASIC bootstrap (10 SYS 1037)
* 040d-0410   pettillaunch (JMP COLD)
* 0410-049c   zpbuf (partial zero page mirror $00-$8C)
* 049d-04a4   power2 (01 02 04 08 10 20 40 80)
* 04a5        unused byte
* 04a6-065a   Sweet16
* 065b-       slip, slide, Sweet16 extensions
* brktoggle,  the EOR of TIM and Sweet16 entry points
* userarea,   User variable storage
* swapzp,     and other native 6502 code subroutines
* core,       permanent dictionary (bodies only)

* cold,       bootstrap initialization
---------------tdict & symbol table concatenated to there-----
* there,      target load address of temporary dictionary (2)
* there+2,    size of temporary dictionary (2)
* there+4,    temporary dictionary, bodies only
* tdict       outer interpreter, compiler, editor, assembler
* symbols,    symbol table data
[/list]

[heading]COLD tasks[/heading
[list]
* change the startup vector from COLD to WARM
* set MEMSIZ from BASIC $34-35
* set SYMTAB as an offset from MEMSIZ
* set TDICT as the load address + 2 of part 2 (found at 'there')
* display a banner
* set STARTUP uservariable to LAUNCH
* move temporary dictionary to TDICT
* move symbol table to SYMTAB
* set FENCE
* call WARM to put us in Forth mode
[/list]
There is no knowledge in the core dictionary (at the bottom of memory)
of what is in the temporary dictionary or where it resides.  To kick
things off upstairs, WARM starts Forth, then executes the word LAUNCH
in the upper dictionary, via the STARTUP uservariable.  The requirement
is that the first thing in tdict must be the executable CFA of LAUNCH
That's where we will pick things up.

temporary dictionary and symbols are built separately
as PETTIL-TDICT.OBJ and PETTIL.SYM, then they are both
appended to the PETTIL.OBJ core binary

pettil-tdict.obj looks like this:
two byte load address of pettil-tdict.obj e.g. $71fe
two byte length of pettil-tdict.obj

The actual load address is off by -2.  There are two bytes in
front of the tdict.obj code storing the length of tdict.obj.
This length information is needed to figure out where the symbol
table starts, following tdict

All addresses in tdict in this example would be located as though
tdict had been assembled and loaded at *=$7200, in spite of the
misleading load address.

pettil.sym looks like this:
repeated for each head
[ two byte CFA
  one byte length and flags
  name
  one byte vocabulary identifier, if present ]
[/desc]
#endif
cold
	nop							; make it easy to find here
	nop
	nop
	nop
    lda #<bannermsg             ; display a banner
    sta TEMPF1
    lda #>bannermsg
    sta TEMPF1+1
    ldy #0
cold01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg-1
    bne cold01

    lda #<warm                  ; Overwrite the BASIC hook
    sta pettillaunch+1          ; change +1037 JMP COLD to +1037 JMP WARM
    lda #>warm                  ; for reentry
    sta pettillaunch+2

    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz
    lda MEMSIZ+1
    sta usermemsiz+1

    jmp cold2warm               ; start Forth, run HOT next

;--------------------------------------------------------------
#if 0
name=HOT
stack=( -- )
tags=transient,nosymbol
[desc]
COLD does enough to kickstart Forth, then HOT is next.
[list]
* sets TDICT and SYMTAB user variables
* copy the temporary dictionary to TDICT
* copy the symbols to SYMTAB+32
* execute LAUNCH (first word at the first address in TDICT)
[/list]
[/desc]
#endif
hot
#include "enter.i65"
    .word plit
    .word there
#include "pad.i65"
    .word dup
#include "page.i65"
    .word four
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
    .word tdict
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 4096
#include "pad.i65"
    .word minus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word over
#include "page.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word plus
#include "page.i65"
    .word clit
    .byt EAL
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word cmove
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute               ; launch

;--------------------------------------------------------------
    .byt (there-*-1)
bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-06-19",CR
    .asc    "1623 PASCAL'S BIRTHDAY",CR
            ;123456789.123456789.123456789.123456789.
there

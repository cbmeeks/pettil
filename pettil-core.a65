; pettil-core.a65
#echo .       pettil-core.a65
#echo .       PETTIL - Personal Electronics Transactor Threaded Interpretive Language
#echo .
; wrapper to build PETTIL core dictionary
; disposable run-once COLD start code

; PETTIL
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001N)
;
;" ven-er-a-ble (adj.)
;" 3a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>" -- Merriam Webster Dictionary
;
; chitselb 2010-2014
;" http://chitselb.com
;" http://github.com/chitselb/pettil
;" http://pettil.tumblr.com
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years.
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read

; things between ;==== bars == use caution if relocating
; things between ;---- bars -- may be moved freely

#define DEBUG
#define PET_ROM4                ; target machine
#undefine HEADERS                 ; put headers in code?
                                ; PET target memory size
#define PETRAM 32

#include modules/cbm.def
#include modules/pettil.def

;==============================================================
;==== BASIC bootstrap                                      ====
;==============================================================
#define basic $0400
    .word basic+1               ; this will be the load address
* = basic+1
    .word basend
    .word 10
    .byt $9e                    ; SYS token
    .asc "1037",0
basend
    .word 0
pettillaunch
    jmp cold

;==============================================================
;==== zeropage buffer and user area                        ====
;==============================================================
;
; this is an image of PETTIL zeropage at cold start.  Swapping it
; with the BASIC zeropage makes hopping back and forth possible
;
zpbuf
;$00
;
; R2 is the PETTIL User Pointer.  Changing it without cause will
; trick PETTIL into looking in the wrong place for important system
; variables.
; R12 is the BS/RS stack pointer, it grows upward.  Initialized here
; to $0100.  Changing R12 will overwrite those areas of memory
; at unexpected times.  Caveat scriptor!
;
    .word $0000,$1001,$2002,$3003
    .word $4004,$5005,$6006,$7007   ; PETTIL registers
    .word $8008,$9009,$a00a,$b00b   ; and
    .word $0100,$d00d,$e00e,$f00f   ; Sweet16 registers
;$20
    .dsb bos,$aa                    ; low stack
;$50
    .dsb bos,$bb                    ; high stack

;--------------------------------------------------------------
;
;       NEXT
;
; * inner interpreter headerless
;
;               +IP
;               [IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
;$80
    nop                     ; six bytes of memory used by the
    nop                     ; 8-bit random number generator RANDU
    nop                     ; from the First Book of KIM
    nop                     ;
    nop                     ; see "RANDU" for how it works
    nop                     ;
;$86
zpnext
    inc ip                  ; 5
    inc ip                  ; 5
;ip = *+1
    jmp ($cafe)             ; 5

                            ;15 cycles total
;$8D TIME

;==============================================================
; powers of 2 in a lookup table
power2
    .byt $01,$02,$04,$08,$10,$20,$40,$80

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

    nop                         ; fine tune position of Sweet16

#if (* <> $04a6)
#echo PETTIL Build Error - Program counter is not at $04a6!
#echo You moved something, didn't you?  Sweet16 is expected
#echo to start at $04a6 (1190).  This is a problem. 
#endif
#echo .       program counter just before Sweet16 should be 1190, is:
#print *

#include modules/sweet16.a65

;==============================================================
;==== ALL SWEET16 OPERATION HANDLERS MUST BE ON SAME PAGE! ====
;==============================================================

; xor of two vectors, to switch BRK vector between Sweet16 and TIM
brktoggle       .word SW16^TIMBRK
; xor of two vectors, to switch IRQ vector between PETTIL and BASIC
irqtoggle       .word 0

;==============================================================
; uarea initialization data
userarea
userup          .word uarea                             ; WARM
usersp0         .word bos+1                             ;
userrp0         .word $01fe                             ;
usercontext     .word 0                                 ;
usercurrent     .word 0                                 ;
userwarm
; everything before userwarm is initialized at WARM start

userfence       .word launch                            ; COLD
userdp          .word cold                              ;
usermemsiz      .word 0     ; set by COLD from BASIC (copy of $34)
usersymtab      .word 0
userstartup     .word hot   ; CFA of bootstrap code to run after warm
usercold
; everything before usercold is initialized at COLD start

; everything below this is set to 0 by COLD and untouched by WARM
uservmbuf       = usercold                              ; SOFT
uservmsiz       = usercold+2                            ; (COLD = 0)
usersymnew		= usercold+4							; set by REHASH
usersymtail     = usercold+6                            ; set by CREATE
usertdict       = usercold+8                            ; 
userbase        = usercold+10                           ; (WARM = unchanged)
userdpl         = usercold+12                           ;
userhld         = usercold+14                           ;
userblk         = usercold+16                           ;
usertoin        = usercold+18                           ;
userspan        = usercold+20                           ;
usertib         = usercold+22                           ;
usernumout      = usercold+24                           ;
usernumline     = usercold+26                           ;
usererrmess     = usercold+28                           ;
userscr         = usercold+30                           ;
userstate       = usercold+32                           ;
usercsp         = usercold+34                           ;
usernumvoc      = usercold+36                           ;

; User Pointer (UP) at $0002 points here
uarea           .dsb usercold-userarea+48,0

;==============================================================
;==== PETTIL dictionary                                    ====
;==============================================================
#include modules/core-subroutines.a65
#include modules/core-user.a65
#include modules/core-inner.a65
#include modules/core-nucleus.a65
#include modules/core-device.a65
#include modules/core-pet.a65
#include modules/core-numword.a65
#include modules/core-double.a65
#include modules/core-string.a65
#include modules/core-vm.a65

;--------------------------------------------------------------
;
;       WARM
;
; Dropping out to BASIC can be accomplished on purpose with
; MON (to get to TIM), then .X to get to BASIC.  It also will
; happen by mistake if cassette i/o is interrupted by the STOP
; key or any tape error.  There may be other ways.  WARM should
; be able to bring the system back to a usable state.
;
; Tasks
; * aloha
; * - swap zero page with zpbuf
; * - switch Sweet16<-->TIM BRK vector
; * - switch PETTIL<-->BASIC IRQ vector
; * reset Forth return stack (machine stack)
; * reset Forth data stack
; * print start message CR,"WELCOME TO PETTIL!",CR
; * STARTUP @ EXECUTE
;
;#ifdef HEADERS
;warmlfa
;    .byt $de,$ad
;    .byt (warm-*-1)|bit7
;    .asc "WAR","M"|bit7
;#endif
warm
    ldy #userwarm-userarea-1    ; init only warm uservariables
    bne warm01
cold2warm
    ldy #usercold-userarea-1    ; init both cold and warm uservariables
warm01
    tya                         ; Y is # of bytes of userarea to move
    pha
    jsr aloha                   ; swap zero page, enable Sweet16, set IRQ
    pla
    tay
    lda userup                  ; initialize user variables
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
#include "toforth.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word _decimal
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit

;==============================================================
; FENCE  all that comes before this is unforgettable
;==============================================================

;--------------------------------------------------------------
;
;        LAUNCH   ( abortcfa 'launch forgetcfa -- )
;
launch
#include "enter.i65"
launch01
    .word execute
#include "page.i65"
    .word execute

;--------------------------------------------------------------
;
;        COLD   ( -- )
;
; One-time only (then disappear) system bootstrap initialization.
; Runs once after "pettil.obj" loads, to prepare a development
; environment.  The size of COLD doesn't really matter.  As
; the final word in the core dictionary, COLD will FORGET
; itself and its address becomes the value of FENCE.
; It's a little hairy, I hope my comments will explain.
;
; the pieces at load time
; * 0400-040c   BASIC bootstrap (10 SYS 1037)
; * 040d-0410   pettillaunch (JMP COLD)
; * 0410-049c   zpbuf (partial zero page mirror $00-$8C)
; * 049d-04a4   power2 (01 02 04 08 10 20 40 80)
; * 04a5        unused byte
; * 04a6-065a   Sweet16
; * 065b-       slip, slide, Sweet16 extensions
; * brktoggle,  the EOR of TIM and Sweet16 entry points
; * userarea,   User variable storage
; * swapzp,     and other native 6502 code subroutines
; * core,       permanent dictionary (bodies only)
;
;
; * cold,       bootstrap initialization
;---------------tdict & symbol table concatenated to there-----
; * there,      target load address of temporary dictionary (2)
; * there+2,    size of temporary dictionary (2)
; * there+4,    temporary dictionary, bodies only
; * tdict       outer interpreter, compiler, editor, assembler
; * symbols,    symbol table data
;
; COLD tasks
; * set MEMSIZ from BASIC $34-35
; * set SYMTAB as an offset from MEMSIZ
; * display a banner
; * set STARTUP uservariable to HOT
;
; * call WARM to put us in Forth mode
;
; There is no knowledge in the core dictionary (at the bottom of memory)
; of what is in the temporary dictionary or where it resides.  To kick
; things off upstairs, WARM starts Forth, then executes the word HOT
; via the STARTUP uservariable.  That's where we will pick things up.
;
; 'there' has a few pointers and the temporary dictionary (pettil-tdict)
; ($C9) End address for tape LOAD marks the end of the symbol table
;
; HOT tasks
; * copy tdict region to high memory
; * copy symbol table to high memory at SYMTAB+8+32+2
; * find FIND in the symbol table, use it to...
; * find ABORT in the symbol table
; * set STARTUP to ABORT
; * find FORGET in the symbol table
; * FORGET COLD
;
; what FORGET does
; * when FORGET is invoked by COLD, it uses the CFA on the data stack
;   instead of scanning ahead in the input stream
;       R@ test?
;       COLD calls FORGET somewhere in the middle?
; * find the word and get its CFA
; * trying to forget a CFA < FENCE ?   ABORT" CAN'T FORGET BELOW FENCE"
; * set DP equal to the CFA of the word being forgotten
; * when FORGET is invoked by COLD, it uses the address on the data
;   stack instead of PAD, and it doesn't copy the symbol table from
;   SYMTAB
; * move the symbols to PAD
; * and MOVE the symbols one by one back to SYMTAB
;
; when FORGET exits, the return stack sends us to @W1 which runs
; the word in STARTUP (typically ABORT)
;
; before warm can do its thing, we need to populate STARTUP with the
; CFA of ABORT.  The temporary dictionary was compiled separately and
; we have no idea what that CFA is without searching the symbol table.
; First, let's move the symbol table to where it belongs, which is
; at SYMTAB + bloomfilter(8) + hashthreads(32) + new (SYMTAB+8
;
; COLD expects to find the tdict size, followed by the load
; address, then the code bodies for the PETTIL development
; environment.  This follows immediately after ICE
; itself in RAM.  This block (there) is copied to upper
; memory.  This binary object must know where it resides,
; as no relocation is done.  In other words, a 16K PET
; requires a different build of "there" than a 32K PET.
;
; Next COLD invokes REHASH to populate the symbol table at
; user variable SYMTAB.  Symbols never require relocation,
; but FIND expects to find them in a specific order, as
; dictated by REHASH.
;
; COLD replaces the vector to itself at pettillaunch with
; a JMP WARM instruction.
;
; COLD replaces the vector (pettillaunch) to ICE with a
; JMP WARM instruction.
;
; COLD does FENCE @ DP !
;
; temporary dictionary and symbols are built separately
; and concatenated to the PETTIL.OBJ core binary
;
;#ifdef HEADERS
;coldlfa
;    .byt $de,$ad
;    .byt (cold-*-1)|bit7
;    .asc "COL","D"|bit7
;#endif
cold
    lda #<bannermsg             ; display a banner
    sta TEMPF1
    lda #>bannermsg
    sta TEMPF1+1
    ldy #0
cold01
    lda (TEMPF1),y
    jsr CHROUT
    iny
    cpy bannermsg-1
    bne cold01

    lda #<warm                  ; close the door on ourselves
    sta pettillaunch+1          ; runs cold once, warm to reenter
    lda #>warm
    sta pettillaunch+2

    lda MEMSIZ                  ; set top of memory address
    sta usermemsiz              ; and symbol table pointers
    sta usersymtab
    lda MEMSIZ+1
    sta usermemsiz+1            ; $6400 = SYMTAB
    sec                         ; $7100 = temp dictionary
    sbc #$1c                    ; $8000 = MEMSIZ
    sta usersymtab+1

    jmp cold2warm

; HOT must scan through the symbol table until it finds FORGET and
; ABORT
;--------------------------------------------------------------
;
;        HOT   ( -- )
;
; The tail end of the one-time only (then disappear) system
; bootstrap initialization.  HOT runs as the STARTUP word after
; COLD invokes WARM to kick things off. Hence the name.
;
; HOT tasks
; * set user variable ERRMESS
; * find FIND
; * ' ABORT DUP STARTUP !
; * FORGET HOT
; * ( abort ) EXECUTE
;
;#ifdef HEADERS
;hotlfa
;    .byt $de,$ad
;    .byt (hot-*-1)|bit7
;    .asc "HO","T"|bit7
;#endif
hot
    brk
    .byt set | R10
    .word EAL
    .byt set | R9
    .word usersymtab
    .byt set | ACC
    .word there                 ; points to load address (tdict targ)
    .byt push
    .byt ldd | R9               ; "R9 is now okay for me to poop on" -- Triumph
    .byt st | R9
    .byt set | ACC
    .word 32                    ; skip over thread pointers (32 bytes)
    .byt add | R9
    .byt st | R9                ; symbol target address e.g. $642A
    .byt ldd | R10
    .byt st | R10               ; load end address
    .byt ldd | TOS              ; pettil-tdict.obj file load address
    .byt st | N0                ; tdict target
    .byt inr | N0               ; add 2 to take care of the offset for the file length
    .byt inr | N0               ; that was added at the beginning of pettil-tdict.obj
    .byt ldd | TOS              ; TOS now points to the tdict blob (from1)
    .byt st | N1                ; tdict size
    .byt add | TOS
    .byt st | N2                ; symbol source address
    .byt ld | N0
    .byt push                   ; (to1)
    .byt ld | N1
    .byt push                   ; (howmany1)
    .byt ld | N2
    .byt push                   ; (from2)
    .byt ld | R9
    .byt push                   ; (to2)
    .byt ld | R10
    .byt sub | N2
    .byt push                   ; (howmany2)
    .byt rtn                    ; ( from1 tdict howmany1 from2 symtab+32 howmany2 )
#include "toforth.i65"
    .word over                  ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+32 )
#include "page.i65"
    .word clit
    .byt 32                     ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+42 32 )
#include "pad.i65"
    .word _twodup               ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+42 32 symtab+42 32 )
#include "page.i65"
    .word minus                 ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+42 32 symtab )
#include "page.i65"
    .word swap                  ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+42 symtab 32 )
#include "page.i65"
    .word _erase                ; ( from1 tdict howmany1 from2 symtab+32 howmany2 symtab+32 )
#include "page.i65"
    .word tor                   ; ( from1 tdict howmany1 from2 symtab+32 howmany2 )  ( R; symtab+32 ) 
#include "page.i65"
    .word cmove                 ; ( from1 tdict howmany1 ) ( R; symtab+32 ) 
#include "page.i65"
    .word over                 ; ( from1 tdict howmany1 tdict ) ( R; symtab+32 ) 
#include "page.i65"
    .word tdict                 ; ( from1 tdict howmany1 tdict addr ) ( R; symtab+32 ) 
#include "page.i65"
    .word store                 ; ( from1 tdict howmany1 ) ( R; symtab+32 ) 
#include "page.i65"
    .word cmove                 ; ( ) ( R; symtab+32 ) 
#include "page.i65"
    .word plit
    .word findabort             ; address of 5,"ABORT"
#include "pad.i65"
    .word rfrom                 ; ( findabort symbols )
#include "page.i65"
    .word plit
    .word findforget            ; address of 6,"FORGET"
#include "pad.i65"
    .word over                  ; ( findabort symbols findforget symbols )
#include "page.i65"
    .word to6502
    brk
    .byt bs , <(xfind-*-2)      ; ( findabort symbols ) ACC = forgetcfa )
    .byt st | R10               ; cfa of FORGET
    .byt bs , <(xfind-*-2)      ; ( ) cfa of ABORT  
    .byt push                   ; ( abortcfa )  
    .byt ld | R10
    .byt push                   ; ( abortcfa forgetcfa )
    .byt rtn
#include "toforth.i65"          ( abort forget )
    .word plit
    .word launch
#include "pad.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word store
#include "page.i65"
    .word plit
    .word launch
#include "pad.i65"
    .word launch

xfind
    .byt ld | TOS
    .byt st | N0                ; N0 = first nfa
    .byt pull                   ; TOS = name
    .byt ldi | TOS              ; get the length of "{searchword}"
    .byt dcr | TOS
    .byt st | N1                ; set length of what we're searching for
xfind01
    .byt ldd | N0               ; get the CFA of the next word
    .byt ext
    .word wordlen16             ; length in R11, smudged? in C
    .byt ld | R11
    .byt bc , <(xfind02-*-2)    ; always skip smudged words
    .byt cpr | N1
    .byt bnz , <(xfind02-*-2)   ; next if different lengths
    ; TOS and N0 both point to the first byte of the strings
    ; both strings are the same length
    .byt ext
    .word strcomp16
    .byt bc , <(xfind03-*-2)   ; winner!
    .byt ld | N1
xfind02
    .byt add | N0
    .byt st | N0
    .byt inr | N0
    .byt br , <(xfind01-*-2)
xfind03
    ; N0 points to the nfa of "(FIND)"
    .byt pull                   ; discard name argument
    .byt popd | N0              ; got the CFA of (FIND)
    .byt rs

;--------------------------------------------------------------
findabort
    .byt 5, "ABORT"
findforget
    .byt 6, "FORGET"

    .byt (there-*-1)
bannermsg
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-06-02",CR
            ;123456789.123456789.123456789.123456789.
    .asc    "455 SACK OF ROME: VANDALS ENTER ROME,",CR
    .asc    "    AND PLUNDER THE CITY FOR TWO WEEKS",CR
there
; temporary dictionary and symbols are built separately
; as PETTIL-TDICT.OBJ and PETTIL.SYM, then they are both
; appended to the PETTIL.OBJ core binary
;
;"pettil-tdict.obj looks like this:
; two byte actual load address of pettil-tdict.obj e.g. $71fe
; two byte length of pettil-tdict.obj
;
; The actual load address is off by -2.  The two bytes for code
; length are needed by the COLD start routine to figure out where
; the symbol table is, but the length was "invisibly prepended" to 
; the file by a Ruby script, not by Commodore's SAVE routine.  All
; addresses in tdict in this example would be located as though
; tdict had been assembled and loaded at *=$7200, in spite of the 
; misleading load address.
;
;"pettil.sym looks like this:
; repeated for each head
; [ two byte CFA
;   one byte length and flags
;   name
;   one byte vocabulary identifier, if present ]

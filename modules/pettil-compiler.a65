; pettil-compiler.a65
#echo .       pettil-compiler.a65       Compiler

;--------------------------------------------------------------
;
;       HERELSB   ( -- c )
;
; Returns the least significant byte of DP
;
; tdict
;
;#ifdef HEADERS
;herelsblfa
;    .byt $de,$ad
;    .byt (_herelsb-*-1)|bit7
;    .asc "HERELS","B"|bit7
;#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ALLOT
;
; * 83 compiler tdict
;
#ifdef HEADERS
allotlfa
    .byt $de,$ad
    .byt (_allot-*-1)|bit7
    .asc "ALLO","T"|bit7
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,   ( w -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
commalfa
    .byt $de,$ad
    .byt (_comma-*-1)|bit7
    .asc ","|bit7
#endif
_comma
#include "enter.i65"
    .word _here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler tdict
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word _here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,$   ( ?? -- ?? )
;
; compiler tdict
;
#ifdef HEADERS
commadollarlfa
    .byt $de,$ad
    .byt (_commadollar-*-1)|bit7
    .asc ",","$"|bit7
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word _here
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; create the code field of a new definition, taking page alignment
; into account.
;
; compiler tdict
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,XT   ( xt -- )
;
; encloses the execution token into the dictionary, paying heed
; to PETTIL's requirement that XTs must be page-aligned and that
; secondaries are responsible for invoking 'page' to cross a page
; boundary
;
; compiler tdict
;
;": ,xt   ( xt -- )
;     herelsb $fc >
;     if
;         ['] page ,
;         herelsb
;         if
;             dp 1+!
;         then
;     then
;     , ;
;
;#ifdef HEADERS
;commaxtlfa
;    .byt $de,$ad
;    .byt (_commaxt-*-1)|bit7
;    .asc ",X","T"|bit7
;#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word exit

;--------------------------------------------------------------
;
;       CREATE
;
; * 83 compiler tdict ~wut? rewrite
;
; A defining word executed in the form
;     CREATE <name>                 
;     Creates a dictionary entry for <name>.  After <name> is
;     created, the next available dictionary location is the first
;     byte of <name>'s parameter field.  When <name> is
;     subsequently executed, the address of the first byte of
;     <name>'s parameter field is left on the stack.  CREATE does
;     not allocate space in <name>'s parameter field.
;
;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa ) 
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )                               
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )
#ifdef HEADERS
createlfa
    .byt $de,$ad
    .byt (_create-*-1)|bit7
    .asc "CREAT","E"|bit7
#endif
_create
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word bl                    ; ( bl )
#include "page.i65"
    .word _word                 ; ( nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa nfa )
#include "page.i65"
    .word _find                 ; ( nfa nfa addr2 flag )
#include "page.i65"
    .word swap                  ; ( nfa nfa flag addr2 )
#include "page.i65"
    .word drop                  ; ( nfa nfa flag )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(create03-*+1)
#include "pad.i65"
    .word clit                  ; ( nfa cfa $12 )
    .byt RVSON
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word over                  ; ( nfa cfa nfa )
#include "page.i65"
    .word count                 ; ( nfa cfa addr+1 len )
#include "page.i65"
    .word type                  ; ( nfa cfa )
#include "page.i65"
    .word clit
    .byt RVSOFF                 ; ( nfa cfa $92 )
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word _pdq
    .byt create02-*-1
    .asc    " EXISTS"           ; ( nfa cfa )
create02
#include "pad.i65"              ; ( nfa addr )
create03                        ; THEN
    .word drop                  ; ( nfa )
#include "page.i65"
    .word tor                   ; ( ) ( R; nfa )
#include "page.i65"
    .word clit                  ; ( $80 )
    .byt $80
#include "page.i65"
    .word rfetch                ; ( $80 nfa ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word twodup               ; ( $80 len $80 len ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( $80 len len|bit7 ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len len|bit7 nfa ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len nfa ) ( R; nfa )
#include "page.i65"
    .word plus                  ; ( $80 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word dup                   ; ( $80 cfa-1 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 cfa-1 last ) ( R; nfa )
#include "page.i65"
    .word rot                   ; ( cfa-1 last $80 ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( cfa-1 last|bit7 ) ( R; nfa )
#include "page.i65"
    .word over                  ; ( cfa-1 last|bit7 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( cfa-1 ) ( R; nfa )
#include "page.i65"
    .word oneplus               ; ( cfa ) ( R; nfa )
#include "page.i65"
    .word dp                    ; ( cfa dp ) ( R; nfa )
#include "page.i65"
    .word store                 ; ( )  ( R; nfa )
#include "page.i65"
    .word plit
    .word docreate              ; ( 'docreate ) ( R; nfa )
#include "pad.i65"
    .word _commacfa             ; ( ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( nfa ) ( R; nfa )
#include "page.i65"
;    .word dhash                 ; ( hash1 hash2 ) ( R; nfa )
#include "page.i65"
;    .word bloomstore            ; ( hash1 ) ( R; nfa )
#include "page.i65"
    .word rfrom                 ; ( hash1 nfa ) ( R; nfa )
#include "page.i65"
    .word twominus              ; ( hash1 lfa )
#include "page.i65"
    .word swap                  ; ( lfa hash1 )
#include "page.i65"
    .word xyzzy
#include "page.i65"
;    .word dhashstore            ; ( )
#include "page.i65"
    .word exit                  ; ( )

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;
; * 83 compiler tdict
;
; "colon"
;" A defining word executed in the form:
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
    jmp enter

;--------------------------------------------------------------
;
;       ;   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
semilfa
    .byt $de,$ad
    .byt (semi-*-1)|bit7|bit6
    .asc ";"|bit7
#endif
semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       CONSTANT   ( n -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
constantlfa
    .byt $de,$ad
    .byt (_constant-*-1)|bit7
    .asc "CONSTAN","T"|bit7
#endif
_constant
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jmp doconst
    
;--------------------------------------------------------------
;
;       CCONSTANT   ( n -- )
;
; create an 8-bit constant
;
#ifdef HEADERS
cconstantlfa
    .byt $de,$ad
    .byt (_cconstant-*-1)|bit7
    .asc "CCONSTAN","T"|bit7
#endif
_cconstant
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _psemi
    jmp docconst
    
;--------------------------------------------------------------
;
;       VARIABLE   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
variablelfa
    .byt $de,$ad
    .byt (_variable-*-1)|bit7
    .asc "VARIABL","E"|bit7
#endif
_variable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LATEST   ( -- nfa )
;
; tdict
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
#ifdef HEADERS
latestlfa
    .byt $de,$ad
    .byt (_latest-*-1)|bit7
    .asc "LATES","T"|bit7
#endif
_latest
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >NAME   ( cfa -- nfa )
;
; tdict
;
; returns the NFA of a given word
;
#ifdef HEADERS
tonamelfa
    .byt $de,$ad
    .byt (_toname-*-1)|bit7
    .asc ">NAM","E"|bit7
#endif
_toname
#include "enter.i65"
;    .word oneminus
;#include "page.i65"
;    .word minusone
;#include "page.i65"
;    .word _traverse
;#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NAME>   ( nfa -- cfa )
;
#ifdef HEADERS
namefromlfa
    .byt $de,$ad
    .byt (_namefrom-*-1)|bit7
    .asc "NAME",">"|bit7
#endif
_namefrom
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       !CSP
;
; tdict
;
#ifdef HEADERS
storecsplfa
    .byt $de,$ad
    .byt (_storecsp-*-1)|bit7
    .asc "!CS","P"|bit7
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT"   ( flag -- ) ( -- ; compiling )
;
; * 83 compiler immediate tdict
;
; ~ handle page boundary crossings
#ifdef HEADERS
abortqlfa
    .byt $de,$ad
    .byt (_abortq-*-1)|bit7|bit6
    .asc "ABORT",'"'|bit7
#endif
_abortq
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word _pabortq
#include "page.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?COMP
;
; tdict
;
;#ifdef HEADERS
;qcomplfa
;    .byt $de,$ad
;    .byt (_qcomp-*-1)|bit7
;    .asc "?COM","P"|bit7
;#endif
_qcomp
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(qcomp01-*+1)
#include "pad.i65"
    .word clit
    .byt 5
#include "page.i65"
    .word fail
#include "page.i65"
qcomp01
    .word exit

;--------------------------------------------------------------
;
;       ?PAIRS
;
;#ifdef HEADERS
;qpairslfa
;    .byt $de,$ad
;    .byt (_qpairs-*-1)|bit7
;    .asc "?PAIR","S"|bit7
;#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
;
;       ?CSP
;
; tdict
;
#ifdef HEADERS
qcsplfa
    .byt $de,$ad
    .byt (_qcsp-*-1)|bit7
    .asc "?CS","P"|bit7
#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
;
;       ?CHAR   ( -- )
;
; tdict
;
#ifdef HEADERS
qcharlfa
    .byt $de,$ad
    .byt (_qchar-*-1)|bit7
    .asc "?CHA","R"|bit7
#endif
_qchar
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word over
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(qchar02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word cr
#include "page.i65"
    .word emit
#include "page.i65"
    .word _pdq
    .byt qchar01-*-1
    .asc    " MISSING "
    ;123456789
qchar01
#include "pad.i65"
    .word _abort
#include "page.i65"
qchar02         .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       COMPILE
;
; tdict
;
; * 83 compiler
;
#ifdef HEADERS
compilelfa
    .byt $de,$ad
    .byt (_compile-*-1)|bit7
    .asc "COMPIL","E"|bit7
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [
;
; * 83 compiler tdict
;
#ifdef HEADERS
lbracketlfa
    .byt $de,$ad
    .byt (_lbracket-*-1)|bit7
    .asc "["|bit7
#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ]
;
; * 83 compiler tdict
;~wut? rewrite
;
#ifdef HEADERS
rbracketlfa
    .byt $de,$ad
    .byt (_rbracket-*-1)|bit7
    .asc "]"|bit7
#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
rbracket01
    .word qstack
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02
    .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04
    .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05
    .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       SMUDGE
;
; tdict
;
#ifdef HEADERS
smudgelfa
    .byt $de,$ad
    .byt (_smudge-*-1)|bit7
    .asc "SMUDG","E"|bit7
#endif
_smudge
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt bit5       ; $20
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (;CODE)
;
; tdict
;
;#ifdef HEADERS
;psemilfa
;    .byt $de,$ad
;    .byt (_psemi-*-1)|bit7
;    .asc "(;CODE",")"|bit7
;#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DOES>
;
; * 83 compiler tdict
;
#ifdef HEADERS
doeslfa
    .byt $de,$ad
    .byt (_does-*-1)|bit7
    .asc "DOES",">"|bit7
#endif
_does
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word _psemi
#include "pad.i65"
    .word clit
    .byt $20        ; jsr instruction
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _compile  ; ~ fix paging here
    .word dodoes
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       ."   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
dotqlfa
    .byt $de,$ad
    .byt (_dotq-*-1)|bit7
    .asc ".",'"'|bit7
#endif
_dotq
#include "enter.i65"
    .word _compile
    .word _pdq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .(
;
; * 83 interpreter tdict
;
#ifdef HEADERS
dotplfa
    .byt $de,$ad
    .byt (_dotp-*-1)|bit7
    .asc ".","("|bit7
#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUIT?   ( flag -- flag )
;
; tdict
;
#ifdef HEADERS
quitqlfa
    .byt $de,$ad
    .byt (_quitq-*-1)|bit7
    .asc "QUIT","?"|bit7
#endif
_quitq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (PUNCT?)
;
; tdict
;
;#ifdef HEADERS
;ppunctqlfa
;    .byt $de,$ad
;    .byt (_ppunctq-*-1)|bit7
;    .asc "(PUNCT?",")"|bit7
;#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PUNCT?
;
;#ifdef HEADERS
;punctqlfa
;    .byt $de,$ad
;    .byt (_punctq-*-1)|bit7
;    .asc "PUNCT","?"|bit7
;#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?>MARK
;
; tdict
;
;#ifdef HEADERS
;qtomarklfa
;    .byt $de,$ad
;    .byt (_qtomark-*-1)|bit7
;    .asc "?>MAR","K"|bit7
;#endif
_qtomark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?<MARK
;
; tdict
;
;#ifdef HEADERS
;qfrommarklfa
;   .byt $de,$ad
;    .byt (_qfrommark-*-1)|bit7
;    .asc "?<MAR","K"|bit7
;#endif
_qfrommark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?>RESOLVE
;
; tdict
;
;#ifdef HEADERS
;qtoresolvelfa
;  .byt $de,$ad
;    .byt (_qtoresolve-*-1)|bit7
;    .asc "?>RESOLV","E"|bit7
;#endif
_qtoresolve
#include "enter.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _here
#include "page.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
;
;       ?<RESOLVE
;
; tdict
;
;#ifdef HEADERS
;qltresolvelfa
;  .byt $de,$ad
;    .byt (_qltresolve-*-1)|bit7
;    .asc "?<RESOLV","E"|bit7
;#endif
_qltresolve
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       ADD>MARK
;
; tdict
;
;#ifdef HEADERS
;addtomarklfa
;    .byt $de,$ad
;    .byt (_addtomark-*-1)|bit7
;    .asc "ADD>MAR","K"|bit7
;#endif
_addtomark
#include "enter.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01     .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02     .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [']
;
; * 83 compiler tdict
;
#ifdef HEADERS
brticklfa
    .byt $de,$ad
    .byt (_brtick-*-1)|bit7
    .asc "['","]"|bit7
#endif
_brtick
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       IMMEDIATE
;
; tdict
;
; * 83 compiler
;
#ifdef HEADERS
immediatelfa
    .byt $de,$ad
    .byt (_immediate-*-1)|bit7
    .asc "IMMEDIAT","E"|bit7
#endif
_immediate
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       VOCABULARY
;
; * 83 compiler tdict
;
; see FD-V05N3 p. 5
#ifdef HEADERS
vocabularylfa
    .byt $de,$ad
    .byt (_vocabulary-*-1)|bit7
    .asc "VOCABULAR","Y"|bit7
#endif
_vocabulary
#include "enter.i65"
    .word _create
#include "page.i65"
    .word exit
;#include "page.i65"
;               .word current
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word twoplus
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word _here
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word store
;#include "page.i65"
;               .word _psemi
vocabdoes
    jsr dodoes
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BEGIN
;
; * 83 compiler tdict
;
#ifdef HEADERS
beginlfa
    .byt $de,$ad
    .byt (_begin-*-1)|bit7
    .asc "BEGI","N"|bit7
#endif
_begin
#include "enter.i65"
    .word _qfrommark
#include "page.i65"
    .word one
    .word exit

;--------------------------------------------------------------
;
;       THEN
;
; * 83 compiler tdict
;
#ifdef HEADERS
thenlfa
    .byt $de,$ad
    .byt (_then-*-1)|bit7
    .asc "THE","N"|bit7
#endif
_then
#include "enter.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       DO
;
; * 83 compiler tdict
;
#ifdef HEADERS
dolfa
    .byt $de,$ad
    .byt (_do-*-1)|bit7
    .asc "D","O"|bit7
#endif
_do
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word pdo
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?DO
;
; tdict
;
#ifdef HEADERS
qdolfa
    .byt $de,$ad
    .byt (_qdo-*-1)|bit7
    .asc "?D","O"|bit7
#endif
_qdo
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LOOP
;
; * 83 compiler tdict
;
#ifdef HEADERS
looplfa
    .byt $de,$ad
    .byt (_loop-*-1)|bit7
    .asc "LOO","P"|bit7
#endif
_loop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       +LOOP
;
; * 83 compiler tdict
;
#ifdef HEADERS
pluslooplfa
    .byt $de,$ad
    .byt (_plusloop-*-1)|bit7
    .asc "+LOO","P"|bit7
#endif
_plusloop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LEAVE
;
; * 83 compiler tdict
;
#ifdef HEADERS
leavelfa
    .byt $de,$ad
    .byt (_leave-*-1)|bit7
    .asc "LEAV","E"|bit7
#endif
_leave
#include "enter.i65"
    .word _compile
    .word pleave
#include "pad.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       ?LEAVE
;
; tdict
;
#ifdef HEADERS
qleavelfa
    .byt $de,$ad
    .byt (_qleave-*-1)|bit7
    .asc "?LEAV","E"|bit7
#endif
_qleave
#include "enter.i65"
    .word _compile
    .word pqleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       UNTIL
;
; * 83 compiler tdict
;
#ifdef HEADERS
untillfa
    .byt $de,$ad
    .byt (_until-*-1)|bit7
    .asc "UNTI","L"|bit7
#endif
_until
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
    .word exit

;--------------------------------------------------------------
;
;       AGAIN
;
; tdict
;
#ifdef HEADERS
againlfa
    .byt $de,$ad
    .byt (_again-*-1)|bit7
    .asc "AGAI","N"|bit7
#endif
_again
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       REPEAT
;
; * 83 compiler tdict
;
#ifdef HEADERS
repeatlfa
    .byt $de,$ad
    .byt (_repeat-*-1)|bit7
    .asc "REPEA","T"|bit7
#endif
_repeat
#include "enter.i65"
    .word _again
    .word exit

;--------------------------------------------------------------
;
;       IF
;
; * 83 compiler tdict
;
#ifdef HEADERS
iflfa
    .byt $de,$ad
    .byt (_if-*-1)|bit7
    .asc "I","F"|bit7
#endif
_if
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ELSE
;
; * 83 compiler tdict
;
#ifdef HEADERS
elselfa
    .byt $de,$ad
    .byt (_else-*-1)|bit7
    .asc "ELS","E"|bit7
#endif
_else
#include "enter.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       WHILE
;
; * 83 compiler tdict
;
#ifdef HEADERS
whilelfa
    .byt $de,$ad
    .byt (_while-*-1)|bit7
    .asc "WHIL","E"|bit7
#endif
_while
#include "enter.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2CONSTANT
;
; tdict
;
#ifdef HEADERS
twoconstlfa
    .byt $de,$ad
    .byt (_twoconst-*-1)|bit7
    .asc "2CONSTAN","T"|bit7
#endif
_twoconst
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jsr dodoes
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2VARIABLE
;
; tdict
;
#ifdef HEADERS
twovariablelfa
  .byt $de,$ad
    .byt (_twovariable-*-1)|bit7
    .asc "2VARIABL","E"|bit7
#endif
_twovariable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ID.
;
; tdict
;
#ifdef HEADERS
iddotlfa
    .byt $de,$ad
    .byt (_iddot-*-1)|bit7
    .asc "ID","."|bit7
#endif
_iddot
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word clit
    .asc '*'
#include "pad.i65"
    .word fill
#include "page.i65"
    .word dup
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word count
#include "page.i65"
    .word clit
    .byt $1f                ; ~ shouldn't this use WIDTH?
#include "pad.i65"
    .word andx
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [COMPILE]
;
; * 83 compiler tdict
;
#ifdef HEADERS
bcompilelfa
    .byt $de,$ad
    .byt (_bcompile-*-1)|bit7
    .asc "[COMPILE","]"|bit7
#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LITERAL
;
; * 83 compiler tdict
;
#ifdef HEADERS
literallfa
    .byt $de,$ad
    .byt (_literal-*-1)|bit7
    .asc "LITERA","L"|bit7
#endif
_literal
#include "enter.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01       .word _compile
    .word plit
#include "page.i65"
    .word _comma
#include "page.i65"
literal02       .word exit

;--------------------------------------------------------------
;
;       DLITERAL
;
; tdict
;
#ifdef HEADERS
dliterallfa
    .byt $de,$ad
    .byt (_dliteral-*-1)|bit7
    .asc "DLITERA","L"|bit7
#endif
_dliteral
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit




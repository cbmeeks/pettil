; pettil-compiler.a65
#echo pettil-compiler.a65       Compiler

;--------------------------------------------------------------
;
;       ALLOT
;
; * 83 compiler tdict
;
#ifdef HEADERS
allotlfa
    .byt $de,$ad
    .byt (_allot-*-1)|bit7
    .asc "ALLO","T"|bit7
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,   ( w -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
commalfa
    .byt $de,$ad
    .byt (_comma-*-1)|bit7
    .asc ","|bit7
#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler tdict
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,$   ( ?? -- ?? )
;
; compiler tdict
;
#ifdef HEADERS
commadollarlfa
    .byt $de,$ad
    .byt (_commadollar-*-1)|bit7
    .asc ",","$"|bit7
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       HERELSB   ( -- c )
;
; Returns the least significant byte of DP
;
; tdict
;
;#ifdef HEADERS
;herelsblfa
;    .byt $de,$ad
;    .byt (_herelsb-*-1)|bit7
;    .asc "HERELS","B"|bit7
;#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; create the code field of a new definition, taking page alignment
; into account.
;
; compiler tdict
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,XT   ( xt -- )
;
; encloses the execution token into the dictionary, paying heed
; to PETTIL's requirement that XTs must be page-aligned and that
; secondaries are responsible for invoking 'page' to cross a page
; boundary
;
; compiler tdict
;
;": ,xt   ( xt -- )
;     herelsb $fc >
;     if
;         ['] page ,
;         herelsb
;         if
;             dp 1+!
;         then
;     then
;     , ;
;
;#ifdef HEADERS
;commaxtlfa
;    .byt $de,$ad
;    .byt (_commaxt-*-1)|bit7
;    .asc ",X","T"|bit7
;#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word exit

;--------------------------------------------------------------
;
;       CREATE
;
; * 83 compiler tdict
;
; A defining word executed in the form
;     CREATE <name>                 
;     Creates a dictionary entry for <name>.  After <name> is
;     created, the next available dictionary location is the first
;     byte of <name>'s parameter field.  When <name> is
;     subsequently executed, the address of the first byte of
;     <name>'s parameter field is left on the stack.  CREATE does
;     not allocate space in <name>'s parameter field.
;
;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa ) 
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )                               
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )
#ifdef HEADERS
createlfa
    .byt $de,$ad
    .byt (_create-*-1)|bit7
    .asc "CREAT","E"|bit7
#endif
_create
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word bl                    ; ( bl )
#include "page.i65"
    .word _word                 ; ( nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa nfa )
#include "page.i65"
    .word _find                 ; ( nfa nfa addr2 flag )
#include "page.i65"
    .word swap                  ; ( nfa nfa flag addr2 )
#include "page.i65"
    .word drop                  ; ( nfa nfa flag )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(create03-*+1)
#include "pad.i65"
    .word clit                  ; ( nfa cfa $12 )
    .byt RVSON
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word over                  ; ( nfa cfa nfa )
#include "page.i65"
    .word count                 ; ( nfa cfa addr+1 len )
#include "page.i65"
    .word type                  ; ( nfa cfa )
#include "page.i65"
    .word clit
    .byt RVSOFF                 ; ( nfa cfa $92 )
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word _pdq
    .byt create02-*-1
    .asc    " EXISTS"           ; ( nfa cfa )
create02
#include "pad.i65"              ; ( nfa addr )
create03                        ; THEN
    .word drop                  ; ( nfa )
#include "page.i65"
    .word tor                   ; ( ) ( R; nfa )
#include "page.i65"
    .word clit                  ; ( $80 )
    .byt $80
#include "page.i65"
    .word rfetch                ; ( $80 nfa ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word _twodup               ; ( $80 len $80 len ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( $80 len len|bit7 ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len len|bit7 nfa ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len nfa ) ( R; nfa )
#include "page.i65"
    .word plus                  ; ( $80 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word dup                   ; ( $80 cfa-1 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 cfa-1 last ) ( R; nfa )
#include "page.i65"
    .word rot                   ; ( cfa-1 last $80 ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( cfa-1 last|bit7 ) ( R; nfa )
#include "page.i65"
    .word over                  ; ( cfa-1 last|bit7 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( cfa-1 ) ( R; nfa )
#include "page.i65"
    .word oneplus               ; ( cfa ) ( R; nfa )
#include "page.i65"
    .word dp                    ; ( cfa dp ) ( R; nfa )
#include "page.i65"
    .word store                 ; ( )  ( R; nfa )
#include "page.i65"
    .word plit
    .word docreate              ; ( 'docreate ) ( R; nfa )
#include "pad.i65"
    .word _commacfa             ; ( ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( nfa ) ( R; nfa )
#include "page.i65"
    .word dhash                 ; ( hash1 hash2 ) ( R; nfa )
#include "page.i65"
    .word bloomstore            ; ( hash1 ) ( R; nfa )
#include "page.i65"
    .word rfrom                 ; ( hash1 nfa ) ( R; nfa )
#include "page.i65"
    .word twominus              ; ( hash1 lfa )
#include "page.i65"
    .word swap                  ; ( lfa hash1 )
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word dhashstore            ; ( )
#include "page.i65"
    .word exit                  ; ( )

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;
; * 83 compiler tdict
;
; "colon"
;" A defining word executed in the form:
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
    jmp enter

;--------------------------------------------------------------
;
;       ;   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
semilfa
    .byt $de,$ad
    .byt (semi-*-1)|bit7|bit6
    .asc ";"|bit7
#endif
semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       CONSTANT   ( n -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
constantlfa
    .byt $de,$ad
    .byt (_constant-*-1)|bit7
    .asc "CONSTAN","T"|bit7
#endif
_constant
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jmp doconst
    
;--------------------------------------------------------------
;
;       VARIABLE   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
variablelfa
    .byt $de,$ad
    .byt (_variable-*-1)|bit7
    .asc "VARIABL","E"|bit7
#endif
_variable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       USER   ( n -- )
;
; compiler tdict
;
#ifdef HEADERS
userlfa
    .byt $de,$ad
    .byt (user-*-1)|bit7
    .asc "USE","R"|bit7
#endif
user
#include "enter.i65"
    .word _constant
#include "page.i65"
    .word _psemi
    jmp uservar
    
;--------------------------------------------------------------
;
;       +ORIGIN
;
; compiler tdict
;
#ifdef HEADERS
plusoriginlfa
    .byt $de,$ad
    .byt (_plusorigin-*-1)|bit7
    .asc "+ORIGI","N"|bit7
#endif
_plusorigin
#include "enter.i65"
    .word plit
    .word userarea
#include "pad.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FENCE
;
; tdict
;
#ifdef HEADERS
fencelfa
    .byt $de,$ad
    .byt (fence-*-1)|bit7
    .asc "FENC","E"|bit7
#endif
fence
    jsr uservar
    .byt userfence-userarea

;--------------------------------------------------------------
;
;       DP
;
; tdict
;
#ifdef HEADERS
dplfa
    .byt $de,$ad
    .byt (dp-*-1)|bit7
    .asc "D","P"|bit7
#endif
dp
    jsr uservar
    .byt userdp-userarea

;--------------------------------------------------------------
;
;		CONTEXT   ( -- addr )
;
; search vocabulary
;	0 = core
;	1 = editor
;	2 = assembler
;
#ifdef HEADERS
contextlfa
	.byt $de,$ad
	.byt (context-*-1)|bit7
	.asc "CONTEX","T"|bit7
#endif
context
    jsr uservar
    .byt usercontext-userarea

;--------------------------------------------------------------
;
;       CURRENT   ( -- addr )
;
; tdict
;
#ifdef HEADERS
currentlfa
    .byt $de,$ad
    .byt (current-*-1)|bit7
    .asc "CURREN","T"|bit7
#endif
current
    jsr uservar
    .byt usercurrent-userarea

;--------------------------------------------------------------
;
;       STATE   ( -- addr )
;
; * 83 compiler tdict
;
; The address of the user variable containing the
; compilation  state.    A non-zero content indi-
; cates compilation is occuring,  but  the  value
; itself is system dependent.  A Standard Program
; may not modify this variable.
;
#ifdef HEADERS
statelfa
    .byt $de,$ad
    .byt (state-*-1)|bit7
    .asc "STAT","E"|bit7
#endif
state
    jsr uservar
    .byt userstate-userarea

;--------------------------------------------------------------
;
;       CSP   ( -- addr )
;
; tdict
;
#ifdef HEADERS
csplfa
    .byt $de,$ad
    .byt (csp-*-1)|bit7
    .asc "CS","P"|bit7
#endif
csp
    jsr uservar
    .byt usercsp-userarea

;--------------------------------------------------------------
;
;       SYMTAB   ( -- addr )
;
;   tdict
;
; user variable containing the beginning of the symbol table
;
#ifdef HEADERS
symtablfa
    .byt $de,$ad
    .byt (symtab-*-1)|bit7
    .asc "SYMTA","B"|bit7
#endif
symtab
    jsr uservar
    .byt usersymtab-userarea

;--------------------------------------------------------------
;
;       TRAVERSE   ( addr n -- addr )
;
; * dictionary tdict
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"      SWAP
;"      BEGIN
;"              OVER +  127  OVER C@  <
;"      UNTIL
;"      SWAP DROP ;
#ifdef HEADERS
traverselfa
    .byt $de,$ad
    .byt (_traverse-*-1)|bit7
    .asc "TRAVERS","E"|bit7
#endif
_traverse
#include "enter.i65"
    .word swap
#include "page.i65"
traverse01      .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word clit
    .byt $7f
#include "pad.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(traverse01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LATEST   ( -- NFA )
;
; tdict
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
#ifdef HEADERS
latestlfa
    .byt $de,$ad
    .byt (_latest-*-1)|bit7
    .asc "LATES","T"|bit7
#endif
_latest
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >BODY   ( cfa -- pfa )
;
; * 83 interpreter tdict
;
; convert the compilation address (CFA) to the address of the parameter field.
#ifdef HEADERS
tobodylfa
    .byt $de,$ad
    .byt (_tobody-*-1)|bit7
    .asc ">BOD","Y"|bit7
#endif
_tobody
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >NAME   ( CFA -- NFA )
;
; tdict
;
; returns the NFA of a given word
;
#ifdef HEADERS
tonamelfa
    .byt $de,$ad
    .byt (_toname-*-1)|bit7
    .asc ">NAM","E"|bit7
#endif
_toname
#include "enter.i65"
    .word oneminus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >LINK   ( CFA -- LFA )
;
; tdict
;
; returns the LFA of a given word
;
#ifdef HEADERS
tolinklfa
    .byt $de,$ad
    .byt (_tolink-*-1)|bit7
    .asc ">LIN","K"|bit7
#endif
_tolink
#include "enter.i65"
    .word _toname
#include "page.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BODY>   ( PFA -- CFA )
;
; tdict
;
#ifdef HEADERS
bodyfromlfa
    .byt $de,$ad
    .byt (_bodyfrom-*-1)|bit7
    .asc "BODY",">"|bit7
#endif
_bodyfrom
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NAME>   ( nfa -- cfa )
;
; tdict
;
#ifdef HEADERS
namefromlfa
    .byt $de,$ad
    .byt (_namefrom-*-1)|bit7
    .asc "NAME",">"|bit7
#endif
_namefrom
#include "enter.i65"
    .word one
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LINK>   ( lfa -- cfa )
;
; tdict
;
#ifdef HEADERS
linkfromlfa
    .byt $de,$ad
    .byt (_linkfrom-*-1)|bit7
    .asc "LINK",">"|bit7
#endif
_linkfrom
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       N>LINK   ( nfa -- lfa )
;
; tdict
;
#ifdef HEADERS
ntolinklfa
    .byt $de,$ad
    .byt (_ntolink-*-1)|bit7
    .asc "N>LIN","K"|bit7
#endif
_ntolink
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       L>NAME   ( lfa -- nfa )
;
; tdict
;
#ifdef HEADERS
linktonamelfa
    .byt $de,$ad
    .byt (_linktoname-*-1)|bit7
    .asc "L>NAM","E"|bit7
#endif
_linktoname
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       !CSP
;
; tdict
;
#ifdef HEADERS
storecsplfa
    .byt $de,$ad
    .byt (_storecsp-*-1)|bit7
    .asc "!CS","P"|bit7
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT"   ( flag -- ) ( -- ; compiling )
;
; * 83 compiler immediate tdict
;
; ~ handle page boundary crossings
#ifdef HEADERS
abortqlfa
    .byt $de,$ad
    .byt (_abortq-*-1)|bit7|bit6
    .asc "ABORT",'"'|bit7
#endif
_abortq
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word _pabortq
#include "page.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?COMP
;
; tdict
;
;#ifdef HEADERS
;qcomplfa
;    .byt $de,$ad
;    .byt (_qcomp-*-1)|bit7
;    .asc "?COM","P"|bit7
;#endif
_qcomp
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(qcomp01-*+1)
#include "pad.i65"
    .word clit
    .byt 5
#include "page.i65"
    .word fail
#include "page.i65"
qcomp01
    .word exit

;--------------------------------------------------------------
;
;       ?FIND
;
; tdict
;
;#ifdef HEADERS
;qfindlfa
;    .byt $de,$ad
;    .byt (_qfind-*-1)|bit7
;    .asc "?FIN","D"|bit7
;#endif
_qfind
#include "enter.i65"
    .word qbranch
    .byt <(qfind01-*+1)
#include "pad.i65"
    .word three
#include "page.i65"
    .word fail
#include "page.i65"
qfind01
    .word exit

;--------------------------------------------------------------
;
;       ?PAIRS
;
; tdict
;
;#ifdef HEADERS
;qpairslfa
;    .byt $de,$ad
;    .byt (_qpairs-*-1)|bit7
;    .asc "?PAIR","S"|bit7
;#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
;
;       ?CSP
;
; tdict
;
#ifdef HEADERS
qcsplfa
    .byt $de,$ad
    .byt (_qcsp-*-1)|bit7
    .asc "?CS","P"|bit7
#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
;
;       ?CHAR   ( -- )
;
; tdict
;
#ifdef HEADERS
qcharlfa
    .byt $de,$ad
    .byt (_qchar-*-1)|bit7
    .asc "?CHA","R"|bit7
#endif
_qchar
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word over
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(qchar02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word cr
#include "page.i65"
    .word emit
#include "page.i65"
    .word _pdq
    .byt qchar01-*-1
    .asc    " MISSING "
    ;123456789
qchar01
#include "pad.i65"
    .word _abort
#include "page.i65"
qchar02         .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       COMPILE
;
; tdict
;
; * 83 compiler
;
#ifdef HEADERS
compilelfa
    .byt $de,$ad
    .byt (_compile-*-1)|bit7
    .asc "COMPIL","E"|bit7
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [
;
; * 83 compiler tdict
;
#ifdef HEADERS
lbracketlfa
    .byt $de,$ad
    .byt (_lbracket-*-1)|bit7
    .asc "["|bit7
#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ]
;
; * 83 compiler tdict
;~wut? rewrite
;
#ifdef HEADERS
rbracketlfa
    .byt $de,$ad
    .byt (_rbracket-*-1)|bit7
    .asc "]"|bit7
#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
rbracket01
    .word qstack
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02
    .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04
    .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05
    .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       SMUDGE
;
; tdict
;
#ifdef HEADERS
smudgelfa
    .byt $de,$ad
    .byt (_smudge-*-1)|bit7
    .asc "SMUDG","E"|bit7
#endif
_smudge
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt bit5       ; $20
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (;CODE)
;
; tdict
;
;#ifdef HEADERS
;psemilfa
;    .byt $de,$ad
;    .byt (_psemi-*-1)|bit7
;    .asc "(;CODE",")"|bit7
;#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DOES>
;
; * 83 compiler tdict
;
#ifdef HEADERS
doeslfa
    .byt $de,$ad
    .byt (_does-*-1)|bit7
    .asc "DOES",">"|bit7
#endif
_does
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word _psemi
#include "pad.i65"
    .word clit
    .byt $20        ; jsr instruction
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _compile  ; ~ fix paging here
    .word dodoes
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       ."   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
dotqlfa
    .byt $de,$ad
    .byt (_dotq-*-1)|bit7
    .asc ".",'"'|bit7
#endif
_dotq
#include "enter.i65"
    .word _compile
    .word _pdq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .(
;
; * 83 interpreter tdict
;
#ifdef HEADERS
dotplfa
    .byt $de,$ad
    .byt (_dotp-*-1)|bit7
    .asc ".","("|bit7
#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUERY
;
; tdict
;
#ifdef HEADERS
querylfa
    .byt $de,$ad
    .byt (_query-*-1)|bit7
    .asc "QUER","Y"|bit7
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUIT?   ( flag -- flag )
;
; tdict
;
#ifdef HEADERS
quitqlfa
    .byt $de,$ad
    .byt (_quitq-*-1)|bit7
    .asc "QUIT","?"|bit7
#endif
_quitq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (PUNCT?)
;
; tdict
;
;#ifdef HEADERS
;ppunctqlfa
;    .byt $de,$ad
;    .byt (_ppunctq-*-1)|bit7
;    .asc "(PUNCT?",")"|bit7
;#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PUNCT?
;
;#ifdef HEADERS
;punctqlfa
;    .byt $de,$ad
;    .byt (_punctq-*-1)|bit7
;    .asc "PUNCT","?"|bit7
;#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (FIND)   ( name-2 LFA -- name-2 0 | CFA flag )
;
; * outer interpreter headerless
;
; name-2 is the address-2 of a counted string we are searching for.
; LFA is the LFA at the head of a chain of LFAs
; returns
;       ( CFA -1 ) if found normal word
;       ( CFA 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"                    ; ( name )
    .word context           ; ( name context )
#include "page.i65"
    .word fetch             ; ( name vocabulary )
#include "page.i65"
    .word fetch             ; ( name LFA|0 )
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"                      ; ( name LFA )
    .word clit
    .byt 7
#include "pad.i65"
    .word fail              ; vocabularies unimplemented
#include "page.i65"
find01                                  ; ( name )
    .word dup               ; ( name name )
#include "page.i65"
    .word dhash             ; ( name hash1 hash2 )
#include "page.i65"
    .word bloomfetch        ; ( name hash1 flag )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(find02-*+1)
#include "pad.i65"
    .word dhashfetch        ; ( name LFA )
#include "page.i65"
    .word swap              ; ( LFA name )
#include "page.i65"
    .word twominus          ; ( LFA name-2 )
#include "page.i65"
    .word swap              ; ( name-2 LFA )
#include "page.i65"
    .word pfind             ; ( addr flag )
#include "page.i65"
    .word qdup              ; ( addr flag flag | addr 0 )
#include "page.i65"
    .word zeq               ; ( addr flag 0 | name-2 true )
#include "page.i65"
    .word qbranch           ; found? exit
    .byt <(find03-*+1)
#include "pad.i65"
    ; bloom filter false positive
    .word twoplus           ; ( name )
#include "page.i65"
    .word false             ; ( name false )
#include "page.i65"
    .word branch
    .byt <(find03-*+1)
#include "pad.i65"
find02                                  ; ELSE
    ; bloom filter negative
    ; ( name hash1 )
    .word drop              ; ( name )
#include "page.i65"
    .word false             ; ( here false )
#include "page.i65"
find03                                  ; THEN
    .word exit              ; ( addr flag )

;--------------------------------------------------------------
;
;       EXISTS?   ( -- addr flag )
;
; tdict
;
; scans ahead in the input stream for the next blank-delimited word,
; and returns either
#ifdef HEADERS
existsqlfa
    .byt $de,$ad
    .byt (_existsq-*-1)|bit7
    .asc "EXISTS","?"|bit7
#endif
_existsq
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find             ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ID.
;
; tdict
;
#ifdef HEADERS
iddotlfa
    .byt $de,$ad
    .byt (_iddot-*-1)|bit7
    .asc "ID","."|bit7
#endif
_iddot
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word clit
    .asc '*'
#include "pad.i65"
    .word fill
#include "page.i65"
    .word dup
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word count
#include "page.i65"
    .word clit
    .byt $1f                ; ~ shouldn't this use WIDTH?
#include "pad.i65"
    .word andx
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [COMPILE]
;
; * 83 compiler tdict
;
#ifdef HEADERS
bcompilelfa
    .byt $de,$ad
    .byt (_bcompile-*-1)|bit7
    .asc "[COMPILE","]"|bit7
#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LITERAL
;
; * 83 compiler tdict
;
#ifdef HEADERS
literallfa
    .byt $de,$ad
    .byt (_literal-*-1)|bit7
    .asc "LITERA","L"|bit7
#endif
_literal
#include "enter.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01       .word _compile
    .word plit
#include "page.i65"
    .word _comma
#include "page.i65"
literal02       .word exit

;--------------------------------------------------------------
;
;       DLITERAL
;
; tdict
;
#ifdef HEADERS
dliterallfa
    .byt $de,$ad
    .byt (_dliteral-*-1)|bit7
    .asc "DLITERA","L"|bit7
#endif
_dliteral
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit




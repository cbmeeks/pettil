; pettil-compiler.a65
#echo .       pettil-compiler.a65       Compiler

;--------------------------------------------------------------
#if 0
name=HERELSB
stack=( -- c )
tags=compiler
[desc]
 Returns the least significant byte of DP
[/desc]
#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ALLOT
stack=( n -- )
tags=compiler
[desc]

[/desc]
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,
stack=( w -- )
tags=compiler
[desc]

[/desc]
#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C,
stack=( b -- )
tags=compiler
[desc]

[/desc]
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,$
stack=( ?? -- ?? )
tags=compiler
[desc]

[/desc]
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,CFA
stack=( addr -- )
tags=compiler
[desc]

 Set the code field of a new definition, taking page alignment
 into account.  The address is the creator word's CFA, e.g. : or 
 VARIABLE

```
: ,cfa   ( xt -- )
    herelsb $fc =
    if
        $ea c,
    then
    $20 c,
    , ;

```
[/desc]
#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,XT
stack=( xt -- )
tags=compiler
[desc]

 Encloses the execution token into the dictionary, paying heed
 to page alignment and inserting the 'page' token into the 
 dictionary stream at page boundaries


```
: ,xt   ( xt -- )
     herelsb $fc >
     if
         ['] page ,
         herelsb
         if
             dp 1+!
         then
     then
     , ;

```
[/desc]
#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler
[desc]

 Toggle the smudge bit so it won't be found by FIND.  In PETTIL,
 the smudge bit does double duty, also marking as inactive any
 words that have been redefined.  

[/desc]
#endif
smudge
    ldy #0
    lda (tos),y
    eor #$20
    sta (tos),y
    jmp pops

;--------------------------------------------------------------
#if 0
name=ID.
stack=( nfa -- )
tags=compiler
[desc]
Displays the name of a word

```
: id.   ( nfa -- )
     dup nfalen  over c@
  ( nfa len len|flags )
     $40 and 0<> +             \ vocab bit? drop final char
     1 +under type ;

```
[/desc]
#endif
_iddot
#include "enter.i65"
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word andx
#include "page.i65"
    .word zne
#include "page.i65"
    .word plus
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?VOCAB
stack=( name -- name )
tags=compiler,nosymbol
[desc]

```
\ if current vocabulary isn't root, append the vocid to name and set V bit
: ?vocab   ( name -- name )
    current vocid ?dup
    if
        over voc+
    then ;

```
[/desc]
#endif
_qvocab
#include "enter.i65"
    .word current
#include "page.i65"
    .word _vocid
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qvocab01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word vocplus
#include "page.i65"
qvocab01
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( addr -- )
tags=compiler,nosymbol
[desc]

 Creates a new symbol table entry with a CFA linking back to HERE,
 where (CREATE) will compile "jsr addr", with consideration for page
 alignment


```
: (create)   ( addr -- )
\ parse input stream to here, and search context and its parents for name
     exists? nip
  ( addr flag )
     here ?vocab swap          \ append vocabid if current != core
  ( addr here flag )
     if
  ( addr here )
\ is potential duplicate word in the current (not a parent) vocabulary?
\ otherwise it's not a redefinition, treat it as a new word
         (find) nip
  ( addr nfa flag )
         if
  ( addr nfa )
             [ RVSON ] cliteral emit
             dup id. smudge    \ smudge the previously existing word
             [ RVSOFF ] cliteral emit
             ."  EXISTS"
             here              \ leave the address of the name
        then
  ( addr here )
    then
   ( addr here )
     symtail @                 \ add the symbol to the symbol table
   ( addr here symtail )
     2dup !                    \ new CFA
   ( addr here symtail )
     2+ dup newest !           \ set NEWEST
   ( addr here symtail+2 )
     over nfalen 1+ 2dup +     \
   ( addr here symtail+2 len+1 symtail+len+3 )
     dup symtail ! 3 erase     \ mark new symtail
   ( addr here symtail+2 len+1 )
     third bloomhash cbit!     \ add symbol to the bloom filter
   ( addr here symtail+2 len+1 )
     cmove
   ( addr )
     ,cfa ; \ enclose "JSR DOCREATE" in the dictionary

```
[/desc]
#endif
_pcreate
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word nip
#include "page.i65"
    .word here
#include "page.i65"
    .word _qvocab
#include "page.i65"
    .word swap
#include "page.i65"
    .word qbranch
    .byt <(create02-*+1)
#include "pad.i65"
    .word _pfind
#include "page.i65"
    .word nip
#include "page.i65"
    .word qbranch
    .byt <(create02-*+1)
#include "pad.i65"
    .word clit
    .byt RVSON
#include "pad.i65"
    .word emit
#include "page.i65"
    .word dup
#include "page.i65"
    .word _iddot
#include "page.i65"
    .word smudge
#include "page.i65"
    .word clit
    .byt RVSOFF
#include "pad.i65"
    .word emit
#include "page.i65"
    .word _pdq
    .byt (pcreate01-*-1)
    .asc    " EXISTS "
pcreate01
#include "pad.i65"
    .word here
#include "page.i65"
create02
    .word symtail
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twodup
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup
#include "page.i65"
   .word newest
#include "page.i65"
   .word store
#include "page.i65"
   .word over
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word third
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _commacfa
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CREATE
stack=( -- ; parses the next token in the input stream )
tags=compiler,defining
[desc]

 A defining word executed in the form
     `CREATE <name>`
     Creates a dictionary entry for <name>.  After <name> is
     created, the next available dictionary location is the first
     byte of <name>'s parameter field.  When <name> is
     subsequently executed, the address of the first byte of
     <name>'s parameter field is left on the stack.  CREATE does
     not allocate space in <name>'s parameter field.

[/desc]
#endif
_create
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:
stack=( -- sys )
tags=compiler,defining
[desc]

 "colon"
 A defining word executed in the form:
 : <name> ... ;
 Create a word definition for <name> in the compilation
 vocabulary and set compilation state.  The search order is
 changed so that the first vocabulary in the search order is
 replaced by the compilation vocabulary.  The compilation
 vocabulary is unchanged.  The text from the input stream is
 subsequently compiled.  <name> is called a "colon
 definition".  The newly created word definition for <name>
 cannot be found in the dictionary until the corresponding ;
 or ;CODE is successfully processed.

 An error condition exists if a word is not found and cannot
 be converted to a number or if, during compilation from mass
 storage, the input stream is exhausted before encountering ;
 or ;CODE .  sys is balanced with its corresponding ; .

```
: :   ( -- )
      current @ context !
      [ 'enter ]  (create)
      !csp   latest smudge  ] ;

```
#endif
_colon
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word plit
    .word enter
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _storecsp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;
stack=( -- )
tags=compiler
flags=immediate
[desc]
Pronounced: "semi"

```
: ;   ( -- )
     ?csp
     [ 'exit ] ,xt  latest smudge [ ; immediate

```
[/desc]
#endif
_semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CONSTANT
stack=( n -- )
tags=compiler

: constant   ( n -- )

[/desc]
#endif
_constant
#include "enter.i65"
    .word plit
    .word doconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CCONSTANT
stack=( n -- )
tags=compiler
[desc]

 create an 8-bit constant

[/desc]
#endif
_cconstant
#include "enter.i65"
    .word plit
    .word docconst
#include "pad.i65"
    .word _pcreate
#include "enter.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VARIABLE
stack=( -- )
tags=compiler,forth-79
[desc]
               A defining word executed in the form: 
                       `VARIABLE <name>`            
               A dictionary entry for <name> is created and two bytes are
               ALLOTted in its parameter field.  This parameter field is to
               be used for contents of the variable.  The application is
               responsible for initializing the contents of the variable
               which it creates.  When <name> is later executed, the
               address of its parameter field is placed on the stack.
[/desc]
#endif
_variable
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LATEST
stack=( -- nfa )
tags=compiler
[desc]

 Leaves the name field address of the top-most word in the
 symbol table.

[/desc]
#endif
_latest
#include "enter.i65"
    .word newest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
[desc]

 returns the NFA of a given word, or 0 if this CFA isn't found
 in the symbol table.

```
: >name   ( cfa -- nfa )
     >syms 2+
 ( cfa nfa )
     begin
 ( cfa nfa )
         dup>r
 ( cfa nfa ) ( R; nfa )
         name>  over <>
         r@ nfalen and
 ( cfa flag ) ( R; nfa )
     while
         r> nfa+
     until
     r> nip dup nfalen 0<> and ;

```
[/desc]
#endif
_toname
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word twoplus
#include "page.i65"
toname01
    .word duptor
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word ne
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(toname02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(toname01-*+1)
#include "pad.i65"
toname02
    .word drop
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word zne
#include "page.i65"
    .word andx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
[desc]

[/desc]
#endif
namefrom
    sec
    lda tos
    sbc #2
    sta tos
    bcs namefrom01
    dec tos+1
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=!CSP
[desc]

[/desc]
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=."
stack=( -- )
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_dotq
#include "enter.i65"
    .word _compile
    .word _pdq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT"
stack=( flag -- ) ( -- ; compiling )
tags=compiler
flags=immediate
[desc]

~ handle page boundary crossings
[/desc]
#endif
_abortq
#include "enter.i65"
    .word _compile
    .word _dotq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word _compile
    .word _abort
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?COMP
stack=
tags=compiler
[desc]

 Check the STATE variable to see if we are compiling, issue an
 error if STATE is off (INTERPRET mode)

[/desc]
#endif
_qcomp
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(qcomp01-*+1)
#include "pad.i65"
    .word clit
    .byt 5
#include "pad.i65"
    .word fail                  ; "COMPILATION ONLY"
#include "page.i65"
qcomp01
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAIRS
stack=
tags=compiler
[desc]

[/desc]
#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
#if 0
name=?CSP
stack=
tags=compiler
[desc]

[/desc]
#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
#if 0
name=?CHAR
stack=( c -- )
tags=compiler
[desc]

[/desc]
#endif
_qchar
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word over
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(qchar02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word cr
#include "page.i65"
    .word emit
#include "page.i65"
    .word clit
    .byt 10
#include "pad.i65"
    .word fail
#include "page.i65"
qchar02
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILE
stack=( -- )
tags=compiler
[desc]

[/desc]
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word dup           ; ~wut? check for xxFF here, on this copy?
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[
stack=( -- )
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=]
stack=( -- )
tags=compiler
[desc]

[/desc]
#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
rbracket01
    .word qstack
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _commaxt
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02
    .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04
    .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05
    .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(;CODE)
stack=( -- )
tags=compiler
[desc]

[/desc]
#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOES>
stack=( -- )
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_does
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word _psemi
#include "pad.i65"
    .word clit
    .byt $20        ; jsr instruction
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _compile
    .word dodoes
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.(
stack=( -- )
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT?
stack=( flag -- flag )
tags=compiler
[desc]

[/desc]
#endif
_quitq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(PUNCT?)
stack=
tags=compiler
[desc]

[/desc]
#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PUNCT?
stack=
tags=compiler
[desc]

[/desc]
#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>MARK
stack=
tags=compiler
[desc]

[/desc]
#endif
_qtomark
#include "enter.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?<MARK
stack=
tags=compiler
[desc]

[/desc]
#endif
_qfrommark
#include "enter.i65"
;    .word _qcomp
;#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>RESOLVE
stack=
tags=compiler
[desc]

[/desc]
#endif
_qtoresolve
#include "enter.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word here
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cstore
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
;
;       ?<RESOLVE
;
; This one is working with BEGIN AGAIN UNTIL
;
;--------------------------------------------------------------
#if 0
name=?<RESOLVE
stack=
tags=compiler
flags=immediate
[desc]


[/desc]
#endif
_qltresolve
#include "enter.i65"
    .word swap
#include "page.i65"
    .word here
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
#if 0
name=ADD>MARK
stack=
tags=compiler
[desc]

[/desc]
#endif
_addtomark
#include "enter.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01
    .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[']
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_brtick
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IMMEDIATE
stack=
tags=compiler
[desc]

[/desc]
#endif
_immediate
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VOCABULARY
stack=
tags=compiler
[desc]

 see FD-V05N3 p. 5
[/desc]
#endif
_vocabulary
#include "enter.i65"
    .word _create
#include "page.i65"
    .word exit
;#include "page.i65":
;               .word current
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word twoplus
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word here
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word store
;#include "page.i65"
;               .word _psemi
vocabdoes
    jsr dodoes
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BEGIN
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_begin
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word one
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=THEN
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_then
#include "enter.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DO
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_do
#include "enter.i65"
    .word _compile
    .word pdo
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?DO
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_qdo
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOOP
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_loop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "page.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=+LOOP
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_plusloop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "page.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LEAVE
stack=
tags=compiler
flags=immediate

#endif
_leave
#include "enter.i65"
    .word _compile
    .word pleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=?LEAVE
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_qleave
#include "enter.i65"
    .word _compile
    .word pqleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
#if 0
name=UNTIL
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_until
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AGAIN
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_again
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REPEAT
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_repeat
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _again
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IF
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_if
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ELSE
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_else
#include "enter.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WHILE
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_while
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2CONSTANT
stack=
tags=compiler
[desc]

[/desc]
#endif
_twoconst
#include "enter.i65"
    .word plit
    .word do2const
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2VARIABLE
stack=
tags=compiler
[desc]

[/desc]
#endif
_twovariable
#include "enter.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[COMPILE]
stack=
tags=compiler
flags=immediate
[desc]

[/desc]
#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _commaxt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LITERAL
stack=
tags=compiler
[desc]

[/desc]
#endif
_literal
#include "enter.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01
    .word _compile
    .word plit
#include "pad.i65"
    .word _comma
#include "page.i65"
literal02
    .word exit

;--------------------------------------------------------------
#if 0
name=DLITERAL
stack=
tags=compiler
[desc]

[/desc]
#endif
_dliteral
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( scr -- )
tags=compiler
[desc]

 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  >IN  BLK  BLOCK

[/desc]
#endif
_load

;--------------------------------------------------------------
#if 0
name=SAVE-FORTH
stack=( -- )
tags=compiler,unimplemented
[desc]

 Writes a binary file to mass storage of the core dictionary
 ($0401 to HERE)

[/desc]
#endif
_saveforth

; core-pet.a65
#echo .       core-pet.a65              PET-specific features

;--------------------------------------------------------------
;
;       EMIT
;
; * 83 device
;
#ifdef HEADERS
emitlfa
    .byt $de,$ad
    .byt (emit-*-1)|bit7
    .asc "EMI","T"|bit7
#endif
emit
    jmp emitvector
emitvector
    ldy numout+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bne emit01
    iny
    clc
    lda (up),y
    adc #1
    sta (up),y
emit01
    lda tos
    jsr CHROUT
    jmp pops

;--------------------------------------------------------------
;
;       KEY
;
; * 83 device
;
#ifdef HEADERS
keylfa
    .byt $de,$ad
    .byt (key-*-1)|bit7
    .asc "KE","Y"|bit7
#endif
key
    stx storex
key01
    jsr GETIN
    beq key01
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       ?TERMINAL   ( -- flag )
;
; true if stop key pressed
;
#ifdef HEADERS
qterminallfa
    .byt $de,$ad
    .byt (qterminal-*-1)|bit7
    .asc "?TERMINA","L"|bit7
#endif
qterminal
    ldy #0
    lda $9b
    cmp #$ef            ; check STOP key
    bne qterminal01
    dey
qterminal01
    tya
    jmp pushya

;--------------------------------------------------------------
;
;       CR
;
; * 83 device
;
#ifdef HEADERS
crlfa
    .byt $de,$ad
    .byt (cr-*-1)|bit7
    .asc "C","R"|bit7
#endif
cr
    jmp crvector
crvector
    lda #$0d
    jsr CHROUT
    lda #0
    ldy numout+3
    sta (up),y
    iny
    sta (up),y
    ldy numline+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bcc cr01
    iny
    lda (up),y
    adc #0
    sta (up),y
cr01
    jmp next

;--------------------------------------------------------------
;
;       VIDRAM   ( -- addr )
;
; address of PET video memory $8000
;
#ifdef HEADERS
vidramlfa
    .byt $de,$ad
    .byt (vidram-*-1)|bit7
    .asc "VIDRA","M"|bit7
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
;
;       MON    ( char base -- digit true | false )
;
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
;~wut? this only works the first time
;
#ifdef HEADERS
monlfa
    .byt $de,$ad
    .byt (mon-*-1)|bit7
    .asc "MO","N"|bit7
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage
plover              ; if we get here, it's unimplemented
xyzzy
    jmp next        ; used as a breakpoint in secondaries

;--------------------------------------------------------------
;
;       JIFFY@   ( --  djiffyclock )
;
; returns number of jiffies since powerup or midnight as a double
;
;jiffyfetch
;    sei
;    jsr slip
;    lda TIME+2
;    sta tos
;    lda TIME+1
;    sta tos+1
;    ldy #0
;    lda TIME
;    cli
;    jmp pushya ; [20]
;
#ifdef HEADERS
jiffyfetchlfa
    .byt $de,$ad
    .byt (_jiffyfetch-*-1)|bit7
    .asc "JIFFY","@"|bit7
#endif
_jiffyfetch
#include "enter.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
;
;       CMDOFF
;
#ifdef HEADERS
cmdofflfa
    .byt $de,$ad
    .byt (cmdoff-*-1)|bit7
    .asc "CMDOF","F"|bit7
#endif
cmdoff
    stx storex
    jsr CLRCHN
    ldx storex
    jmp next

;--------------------------------------------------------------
;
;       EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.
#ifdef HEADERS
expectlfa
    .byt $de,$ad
    .byt (expect-*-1)|bit7
    .asc "EXPEC","T"|bit7
#endif
expect
    jmp expectvector
expectvector
    ldy #1
    jsr locals
    stx storex
    dey
expect01
    iny
    cpy tos
    bcs expect02
    jsr CHRIN
    cmp #$0d
    beq expect02
    sta (n),y
    bne expect01
expect02
    tya
    ldy span+3
    sta (up),y
    iny
    lda #0
    sta (up),y
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       FILENAME   ( addr n -- )
;
; FILENAME
;    Set the filename for file operations.  Must be used before
;    OPEN or CSAVE.
;
#ifdef HEADERS
filenamelfa
    .byt $de,$ad
    .byt (_filename-*-1)|bit7
    .asc "FILENAM","E"|bit7
#endif
_filename

;--------------------------------------------------------------
;
;		OPEN   ( n1 n2 n3 -- f )
;
; Open the logical file number n1 on device n2 with secondary
; address n3.  Filename must have been set with NAME.  Returns
; an error flag f (0=none, 24=error).
;"ftp://www.zimmers.net/pub/cbm/vic20/programming/VIC-Forth/Manual.txt
;
#ifdef HEADERS
openlfa
	.byt $de,$ad
	.byt (_open-*-1)|bit7
	.asc "OPE","N"|bit7
#endif
_open

;--------------------------------------------------------------
;
;		HPIN   ( n -- f )
;
; Send the current input stream to logical file number n.
; Returns and error flag f (0=none, 24=error).  See OPEN.
; Pronounced "h-p-in".
;
#ifdef HEADERS
hpinlfa
	.byt $de,$ad
	.byt (_hpin-*-1)|bit7
	.asc "HPI","N"|bit7
#endif
_hpin

;--------------------------------------------------------------
;
;		HPOFF   ( -- )
;
; Restore the current input and output stream to the
; keyboard and screen respectively.  Pronounced "h-p-off".
;
#ifdef HEADERS
hpofflfa
	.byt $de,$ad
	.byt (_hpoff-*-1)|bit7
	.asc "HPOF","F"|bit7
#endif
_hpoff

;--------------------------------------------------------------
;
;		HPOUT   ( n -- f )
;
; consider CMDIN CMDOUT CMDOFF
; Send the current output stream to logical file number n.
; Returns an error flag f (0=none, 24=error).  See OPEN.
; Pronounced "h-p-out".
;
#ifdef HEADERS
hpoutlfa
	.byt $de,$ad
	.byt (_hpout-*-1)|bit7
	.asc "HPOU","T"|bit7
#endif
_hpout

;--------------------------------------------------------------
;
;		CSAVE   ( -- f )
;
; Save the wordlist and USER-variables to cassette.  The
; wordlist may be given a name (see NAME).  Returns an error
; flag (0=none, 24=error).  See CLOAD.
;
#ifdef HEADERS
csavelfa
	.byt $de,$ad
	.byt (_csave-*-1)|bit7
	.asc "CSAV","E"|bit7
#endif
_csave

;--------------------------------------------------------------
;
;		CLOAD   ( -- f )
;
; Load the saved wordlist from cassette.  Returns an error
; flag f (0=none, 24=error).  See CSAVE.
;
#ifdef HEADERS
cloadlfa
	.byt $de,$ad
	.byt (_cload-*-1)|bit7
	.asc "CLOA","D"|bit7
#endif
_cload

;--------------------------------------------------------------
;
;		?DISC   ( -- )
;
;          Read the disk error channel storing the message at address
;          $8C0 (C64-FORTH) or $1295 (VIC-FORTH) and the length byte
;          at $8BF (C64-FORTH) or $1294 (VIC-FORTH).  See COUNT and
;          TYPE.  Pronounced "question-disc".
;
#ifdef HEADERS
qdisclfa
	.byt $de,$ad
	.byt (_qdisc-*-1)|bit7
	.asc "?DIS",""|bit7
#endif
_qdisc

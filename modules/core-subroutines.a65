; core-subroutines.a65
#echo .       core-subroutines.a65      Native 6502 support routines

;--------------------------------------------------------------
; using ROM tape I/O drops to BASIC if there's a problem.
; we'd like the user to be able to type RUN and pick up
; more or less at the dropping off point if this happens.
; this subroutine performs that BASIC/PETTIL zp switch
; between $00-$8C inclusive.
;
swapzp
    stx storex      ; preserve Forth data stack pointer
    ldx #TIME       ; everything below the jiffy clock
swapzp01
    lda $ff,x
    ldy zpbuf-1,x
    sty $ff,x
    sta zpbuf-1,x
    dex
    bne swapzp01
    ldx storex      ; restore Forth data stack pointer
	rts

;--------------------------------------------------------------
; Do some housekeeping when flipping back and forth between 
; BASIC and PETTIL modes.
; performs swapzp, toggleirq and togglesw16
;
aloha
    cld							; clear decimal mode
    jsr CLRCHN					; restore default I/O channels
    jsr CLALL					; close all open files
	jsr swapzp					; swap bottom of zero page with zpbuf
	jsr toggleirq				; set the IRQ vector
; fall through					; set the BRK vector
;--------------------------------------------------------------
; Toggle the BRK vector between Sweet16 <--> TIM
;
togglesw16
    ldy #2
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne togglesw16+2
    rts

;--------------------------------------------------------------
; Toggle the IRQ vector between PETTIL <--> BASIC
;
toggleirq
	php
	sei
    ldy #2
    lda irqtoggle-1,y
    eor CINV-1,y
    sta CINV-1,y
    dey
    bne toggleirq+4
	plp
	rts

;--------------------------------------------------------------
; Pops cells from the split stack to N area, working backwards.
; Used for setting up primitives that consume multiple arguments
;
; input
; Y = how many words to pop
;
; returns
; Y = 0
; C = clear
; TOS unchanged
;
; Y     1         2         3         4
; 2OS-->N0
; 2OS-->N1; 3OS-->N0
; 2OS-->N2; 3OS-->N1; 4OS-->N0
; 2OS-->N3; 3OS-->N2; 4OS-->N1; 5OS-->N0
;
; inverts the order in the N area from what was on the stack
;
locals
    tya
    asl     ; doubled, now Y is a countdown index, also clc
    tay
locals01
    lda stackh,x
    dey
    sta n,y
    lda stackl,x
    inx
    dey
    sta n,y
    bne locals01
    rts

;--------------------------------------------------------------
    ; negate the double at n0..n3
dnegaten
    ldy #0
    sec
    tya
    sbc n+2
    sta n+2         ; low order byte
    tya
    sbc n+3
    sta n+3
    tya
    sbc n
    sta n
    tya
    sbc n+1
    sta n+1         ; high order byte
    rts

;--------------------------------------------------------------
; return the length of a name field, ignoring flag bits
; sets C flag if smudged
nfalen01
    ldy #0
    lda (tos),y
    pha
    asl
    asl
    pla
    and #$1f
    rts

; strcomp compares two strings that are already known to be the same length.
; C flag set if the strings match, otherwise clear
;
;inputs
;    TOS (R4) = current NFA in the symbol table (initially the first NFA)
;    N0 (R5) = addr of a string we are searching for
;    N1 (R6) = length of both strings
;
;returns
;    C = true iff the strings match
;
strcomp
    clc             ; assume fail
    ldy n+6         ; the length
strcomp01
    lda (n),y
    eor (tos),y
    bne strcomp02  ; different? outtie fail
    dey
    bne strcomp01  ; C flag is set on successful strcmp
    sec             ; success!
strcomp02
    rts

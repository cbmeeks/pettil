; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter

bloom
    .dsb 8,0      ; 64 bits, used by hash2 (bloom filter)
bloomx
pearson
    .byt 27, 120, 229, 241, 111, 44, 47, 141
pearsonx

;==============================================================
;==== Error messages                                       ====
;==============================================================
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08,msg09

msg01
    .byt msg02-*-1
    .asc "STACK EMPTY"
msg02
    .byt msg03-*-1
    .asc "STACK FULL"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc "UNIMPLEMENTED"
msg10

;--------------------------------------------------------------
;
;       FORTH
;
; the core vocabulary
; 
#ifdef HEADERS
forthlfa
    .byt $de,$ad
    .byt (forth-*-1)|bit7
    .asc "FORT","H"|bit7
#endif
forth
    jsr vocabdoes
    .word 0                 ; no parent
    .byt 0					; root vocabulary

;--------------------------------------------------------------
;
;       EDITOR   ( -- )
;
; description
;
#ifdef HEADERS
editorlfa
    .byt $de,$ad
    .byt (editor-*-1)|bit7
    .asc "EDITO","R"|bit7
#endif
editor
    jsr vocabdoes
    .word forth+3           ; parent vocabulary
    .byt 1                  ; vocabulary identifier

;--------------------------------------------------------------
;
;       DEFINITIONS
;
; * 83 interpreter tdict
;
#ifdef HEADERS
definitionslfa
  .byt $de,$ad
    .byt (_definitions-*-1)|bit7
    .asc "DEFINITION","S"|bit7
#endif
_definitions
#include "enter.i65"
    .word context
#include "page.i65"
    .word fetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (
;
; * 83 interpreter tdict
;
#ifdef HEADERS
lparenlfa
    .byt $de,$ad
    .byt (_lparen-*-1)|bit7
    .asc "("|bit7
#endif
_lparen
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUERY
;
; tdict
;
#ifdef HEADERS
querylfa
    .byt $de,$ad
    .byt (_query-*-1)|bit7
    .asc "QUER","Y"|bit7
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PEARSONHASH   ( nfa -- pearsonhash )
;
; tdict
;
; input is NFA or address of a counted string
; pearsonhash is the thread index (0..f)
;
; the pearson hash should return an evenly distributed
; value between $00-$0f based on the wordset in the
; core dictionary.  In other words, all 16 threads
; are initially balanced with the same number of words,
; to reduce searches to (on average) 1/16th of the
; diction  ary.
;
;symbol table
;
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?  vocab ident  ?  +len+3  Vocabulary token (if V bit set)
;+~~~~~~~~~~~~~~~+
;
;#ifdef HEADERS
;pearsonhashlfa
;    .byt $de,$ad
;    .byt (pearsonhash-*-1)|bit7
;    .asc "PEARSONHAS","H"|bit7
;#endif
pearsonhash
    stx storex
    jsr nfalen01            ; A=length; Y=0
    sta n                   ; seed hash1 with length
    tay                     ; count backwards 
pearsonhash01
    lda (tos),y                     ;[5]
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    dey
    bne pearsonhash01
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    ldx storex
    jmp put

;--------------------------------------------------------------
;
;       BLOOMHASH   ( nfa -- mask addr )
;
; The PETTIL Bloom filter tries to answer the question,
; 'is this word a number or does it contain numbers?'
; returning zero (no digits present) or the sum (mod64)
; of each digits in this word plus how many digits.  If
; any digit is present, BLOOMHASH will not return zero.
;
; This is expected to sparsely populate the 64-bit wide
; bloom filter field, allowing FIND to bypass the symbol 
; table search if the bit is turned off.
;
; Calculate the bloom filter hash between 0..63.  Returns
; a mask and address (starting at bloom) suitable for CBIT! 
; or CBIT@.
;
;#ifdef HEADERS
;bloomhashlfa
;    .byt $de,$ad
;    .byt (bloomhash-*-1)|bit7
;    .asc "BLOOMHAS","H"|bit7
;#endif
bloomhash
    stx storex
    jsr nfalen01                ; A=length; Y=0
    sty n
    tay
bloomhash01
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash02             ;[3] carry is set only for digits 
    adc n                       ;[3] anything with digits is nonzero
    and #(8*(bloomx-bloom))-1   ;[2] keep it within the filter bits
    sta n                       ;[3]
    bne bloomhash02             ; never return 0 if any digits present
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash02
    dey
    bne bloomhash01
    lda n
    sty tos+1
    pha
    and #7
    tax
    lda power2,x
    sta tos                     ; mask
    pla
    lsr
    lsr
    lsr
    clc
    adc #<bloom
    ldy #>bloom
    bcc bloomhash03
    iny
bloomhash03
    ldx storex
    jmp pushya

;--------------------------------------------------------------
;
;       (FIND)   ( name nfa vocid -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the hash list
;
; vocid identifies which vocabulary to search.  Vocabularies may be
; nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
; NFAs (with the vocid appended to the name before hashing) on the stack.  
; The final vocabulary searched will be core, and (FIND) will exit afterward.
;   0 = corelist
;   1 = editor
;   2 = assembler
;   3+ = additional user vocabularies
;
; (FIND) first searches the unsorted names beginning at SYMTAIL, and keeps
; going without regard to name length.  If it fails to find the word there,
; it tries the hash list, which is expected to be sorted in ascending size
; order.  Vocabularies are searched first, beginning with CONTEXT and chaining
; up until core (0) is reached.  The vocid is appended to the word when 
; searching that vocabulary.  Only one symbol within a vocabulary may be
; active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
; may exist within more than one vocabulary.
;
;" For example, at cold start the user types in,
;" VOCABULARY LATIN          \ creates a new user vocabulary with vocid = 3
;" LATIN DEFINITIONS         \ sets CURRENT to LATIN, definitions added there
;" : EPLURIBUSUNUM ;         \ adds a new word to the LATIN vocabulary
;" VOCABULARY PIGLATIN       \ creates a new user vocabulary with vocid = 4
;"                           \ PIGLATIN is a member of the LATIN vocabulary
;" PIGLATIN DEFINITIONS      \ sets CURRENT to PIGLATIN, new definitions there
;" : IXNAY ;                 \ adds a new word to the PIGLATIN vocabulary
;" FORTH                     \ set CONTEXT to core 
;" IXNAY  not found          \ IXNAY is a member of PIGLATIN, out of context 
;" PIGLATIN  not found       \ PIGLATIN is a member of LATIN vocabulary 
;" LATIN PIGLATIN            \ set context to LATIN; set context to PIGLATIN 
;" IXNAY  ok                 \ search for "IXNAY" + $04, found in PIGLATIN(4)
;" EPLURIBUSUNUM  ok         \ search for "EPLURIBUSUNUM" + $04, not found.  
;"                           \ search for "EPLURIBUSUNUM" + $03, in LATIN(3)
;" DEPTH .  0 ok             \ search for "DEPTH" + $04, not found in PIGLATIN(4)
;"                           \ search for "DEPTH" + $03, not found in LATIN(3)
;                            \ search for "DEPTH", found in core(0)
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
#ifdef SWEET16
    brk
    .byt sub | R0
    .byt st | R9                ; result flag
    .byt st | N2                ; assume core mode
    .byt ld | TOS
    .byt bz , <(pfind01-*-2)
    .byt dcr | N2               ; N2 = findflag, testable by BIT instr
pfind01
    .byt pull
    .byt st | N1                ; N1 = start of symbol table list
    .byt pull
    .byt st | N0                ; N0 = name
    .byt ext
    .word wordlen16             ; get length of name (TOS)
    .byt ld | R11
    .byt st | N3                ; length we are searching for
    .byt ld | N1
    .byt st | TOS               ; set TOS = first on search list
    .byt rtn
pfind02
    jsr nfalen01
    beq pfind07                 ; end of list? return ( NAME 0 )
    bcs pfind03                 ; smudged? not findable. next!
    cmp n+6                     ; compare lengths
    beq pfind04                 ; same length, compare strings too
    bcc pfind03                 ; shorter length?  next!
    bit n+4                     ; check unsorted mode vs. core mode 
    bmi pfind03                 ; look at all names on this list
    bpl pfind07                 ; core mode, and we've gone past it
pfind03
    jsr nfaplus01
    bne pfind02                 ; bra
pfind04
    jsr strcomp
    bcc pfind03                 ; non-match? next!

    ; winner!
    inc n+10                    ; assume immediate (returns +1)
    ;ldy #0                     ; thank you, strcomp
    lda (tos),y                 ; length and flags
    bmi pfind06                 ; immediate?
    dey
    sty r9
    sty r9+1                    ; set R9 = -1
pfind06
    brk
    .byt popd | TOS             ; get the CFA
    .byt br , <(pfind08-*-2)
pfind07
    ; loser... 
    brk
    .byt ld | N0
pfind08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | R9                ; status flag
    .byt push
    .byt nxt
#endif

;--------------------------------------------------------------
;
;		VOCABS$   ( -- )
;
; Variable to store up to 9 vocabularies to search, plus the core
;
#ifdef HEADERS
vocabsdlfa
	.byt $de,$ad
	.byt (vocabsd-*-1)|bit7
	.asc "VOCABS","$"|bit7
#endif
vocabsd
	jsr docreate
	.dsb 10,0

;--------------------------------------------------------------
;
;       (VOCABLIST)   ( --  0 [ vocid ... contextid ] )
;
; Adds a vocabulary identifier to the stack for each vocabulary, starting
; with CONTEXT vocabulary at TOS and chaining up to core (0).  Just zero is
; returned if the context is FORTH.
;
;": (vocablist)   ( -- 0 id id ... )
;	  vocabs$
;  ( vocabs$ )
;     context
;  ( vocabs$ context )
;     begin 
;  ( vocabs$ context )
;         @ dup 2+ c@
;  ( vocabs$ vocab id )
;         rot 2dup 
;  ( vocab id vocabs$ id vocabs$ )
;		  c! 1+ -rot
;  ( vocabs$+ vocab id )
;		  0=
;     until 
;	  2drop ;
;
#ifdef HEADERS
vocablistlfa
    .byt $de,$ad
    .byt (_pvocablist-*-1)|bit7
    .asc "(VOCABLIST",")"|bit7
#endif
_pvocablist
#include "enter.i65"
    .word vocabsd
#include "page.i65"
    .word context
#include "page.i65"
pvocablist01
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
	.word twoplus
#include "page.i65"
	.word cfetch
#include "page.i65"
	.word rot
#include "page.i65"
	.word twodup
#include "page.i65"
	.word cstore
#include "page.i65"
	.word oneplus
#include "page.i65"
	.word dashrot
#include "page.i65"
	.word zeq
#include "page.i65"
	.word qbranch
	.byt <(pvocablist01-*+1)
#include "pad.i65"
	.word twodrop
#include "page.i65"
	.word exit

;--------------------------------------------------------------
;
;		(VOCFIND)   ( vocid nfa -- )
;
;  ( vocid ) ( R; name )
;             r@ nfalen 1+  
;  ( vocid len+1 ) ( R; name )
;             dup $40 or r@ c!
;  ( vocid len+1 )
;             r@ + over c!
;
#ifdef HEADERS
pvocfindlfa
	.byt $de,$ad
	.byt (_pvocfind-*-1)|bit7
	.asc "(VOCFIND",")"|bit7
#endif
_pvocfind
#include "enter.i65"
	.word exit

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
;": find   ( addr1 -- addr2 flag )
;     >r 
;  ( ) ( R; name )
;     (vocablist) 
;  ( 0 [ vocid ... ] ) ( R; name )
;     begin
;         r@ over 
;  ( vocid name vocid ) ( R; name ) 
;         if
;             over (vocfind)
;         else
;             (find)
;         then 
;
;
;
;    until
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pvocablist
#include "page.i65"
find01
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
	.word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word _pvocfind
#include "page.i65"
	.word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
find02
    .word pfind
#include "page.i65"
find03
    .word rot
#include "page.i65"
    .word zeq
#include "page.i65"
	.word qbranch
    .byt <(find01-*+1)
#include "pad.i65"
	.word rfrom
#include "page.i65"
	.word exit

;--------------------------------------------------------------
;
;       EXISTS?   ( -- addr flag )
;
; tdict
;
; scans ahead in the input stream for the next blank-delimited word,
; and returns either
#ifdef HEADERS
existsqlfa
    .byt $de,$ad
    .byt (_existsq-*-1)|bit7
    .asc "EXISTS","?"|bit7
#endif
_existsq
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find             ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FIND2   ( -- )
;
; eventually to replace FIND
;
#ifdef HEADERS
find2lfa
    .byt $de,$ad
    .byt (_find2-*-1)|bit7
    .asc "FIN","2"|bit7
#endif
_find2
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?'   ( -- addr flag )
;
; harness for testing out the new FIND with vocabulary support
;
;~wut? remove this when FIND2 works
#ifdef HEADERS
queryticklfa
    .byt $de,$ad
    .byt (_querytick-*-1)|bit7
    .asc "?","'"|bit7
#endif
_querytick
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find2            ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       ?FIND   ( flag -- )
;
;#ifdef HEADERS
;qfindlfa
;    .byt $de,$ad
;    .byt (_qfind-*-1)|bit7
;    .asc "?FIN","D"|bit7
;#endif
_qfind
#include "enter.i65"
    .word qbranch
    .byt <(qfind01-*+1)
#include "pad.i65"
    .word three                 ; not found
#include "page.i65"
    .word fail
#include "page.i65"
qfind01
    .word exit

;--------------------------------------------------------------
;
;       '   ( -- cfa )
;
; * 83 interpreter tdict
;
; scans ahead in the input stream for the next word and finds
; it in the dictionary, else ABORT" NOT FOUND"
;
#ifdef HEADERS
ticklfa
    .byt $de,$ad
    .byt (_tick-*-1)|bit7
    .asc "'"|bit7
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qfind
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       INTERPRET
;
; tdict
;
;
;": interpret   ( )
;       begin   ?stack
;               exists?
;               if      link>
;                       execute
;               else    number dpl @ 1+ 0=
;                       if      drop
;                       then
;               then
;               false
;               quit?
;       again ;
;
#ifdef HEADERS
interpretlfa
    .byt $de,$ad
    .byt (_interpret-*-1)|bit7
    .asc "INTERPRE","T"|bit7
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack            ; ( )
#include "page.i65"
    .word _existsq          ; ( addr flag )
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word execute
#include "page.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(interpret03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
interpret03
    .word false
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUIT
;
; tdict
;
;"This is the infinite outer interpreter loop:
;       - resets the return stack (RP!)
;       - outputs a carriage return (CR)
;       - waits for a line of input (QUERY)
;       - interprets that line
; * 83 interpreter outer
;
#ifdef HEADERS
quitlfa
    .byt $de,$ad
    .byt (_quit-*-1)|bit7
    .asc "QUI","T"|bit7
#endif
_quit
#include "enter.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _lbracket         ; STATE OFF
#include "page.i65"
quit01                                  ; BEGIN
    .word rpstore
#include "page.i65"
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT
;
; * 83 interpreter tdict
;
#ifdef HEADERS
abortlfa
    .byt $de,$ad
    .byt (_abort-*-1)|bit7
    .asc "ABOR","T"|bit7
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _quit
#include "page.i65"
    .word exit      ; make the decompiler happy

;--------------------------------------------------------------
;
;       NFALEN   ( nfa -- length )
;
; return the length of this name
;
;#ifdef HEADERS
;nfalenlfa
;    .byt $de,$ad
;    .byt (nfalen-*-1)|bit7
;    .asc "NFALE","N"|bit7
;#endif
nfalen
    jsr nfalen01
    jmp put

;--------------------------------------------------------------
;
;       INDICT?   ( nfa -- flag )
;
; return true if the code field is in either dictionary
;
;": indict?   ( nfa -- flag )
;       nfa>cfa tdict @ over u< swap here u< or ;
;#ifdef HEADERS
;indictqlfa
;    .byt $de,$ad
;    .byt (_indictq-*-1)|bit7
;    .asc "INDICT","?"|bit7
;#endif
_indictq
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word ult
#include "page.i65"
    .word swap
#include "page.i65"
    .word _here
#include "page.i65"
    .word ult
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >SYMS   ( -- addr )
;
; returns the address of the symbol portion of the symbol table
;
;#ifdef HEADERS
;tosymslfa
;    .byt $de,$ad
;    .byt (_tosyms-*-1)|bit7
;    .asc ">SYM","S"|bit7
;#endif
_tosyms
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 32
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SYM+   ( target nfa -- )
;
; move a symbol up to pad and turn on its bloomfilter bit
;
;": sym+
;     ( target nfa )
;     dup>r
;     ( target nfa ) ( R; nfa )
;     nfalen 3 +
;     ( target len+3 ) ( R; nfa )
;     r@ 2- -rot
;     ( nfa-2 target len+3 ) ( R; nfa )
;     cmove
;     ( R; nfa )
;     r> bloomhash cbit! ;
;#ifdef HEADERS
;sympluslfa
;    .byt $de,$ad
;    .byt (_symplus-*-1)|bit7
;    .asc "SYM","+"|bit7
;#endif
_symplus
#include "enter.i65"
    .word duptor
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word cmove
#include "page.i65"
#ifdef ENTERTAINMENT
    .word rfetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word one
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
#endif
    .word rfrom
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NFA+   ( nfa -- nfa+ )
;
; description
;
;#ifdef HEADERS
;nfapluslfa
;    .byt $de,$ad
;    .byt (nfaplus-*-1)|bit7
;    .asc "NFA","+"|bit7
;#endif
nfaplus
    jsr nfaplus01
    jmp next
nfaplus01               ; this should *never* return Z=true
    jsr nfalen01
    clc
    adc #3
    adc tos
    sta tos
    bcc nfaplus02
    inc tos+1
nfaplus02
    rts

;--------------------------------------------------------------
;
;       SYMBYSIZE   ( searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
;
;": symbysize   ( searchlen nfa -- flag )
;     dup nfalen rot =
;     ( nfa samelength? ) 
;     dup
;     if
;         ( nfa samelength? )
;         drop indict? 
;     then nip ;  ( flag )
;
;#ifdef HEADERS
;symbysizelfa
;    .byt $de,$ad
;    .byt (_symbysize-*-1)|bit7
;    .asc "SYMBYSIZ","E"|bit7
;#endif
_symbysize
#include "enter.i65"
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word rot
#include "page.i65"
    .word eq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(symbysize01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _indictq
#include "page.i65"
symbysize01
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SYMBYHASH   ( hash nfa -- flag )
;
; returns true iff
; calculate its pearson hash
; and that matches the current hash?
;
;": symbyhash   ( hash nfa -- flag )
;     pearsonhash = ;
;
;#ifdef HEADERS
;symbyhashlfa
;    .byt $de,$ad
;    .byt (_symbyhash-*-1)|bit7
;    .asc "SYMBYHAS","H"|bit7
;#endif
_symbyhash
#include "enter.i65"
    .word pearsonhash
#include "page.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SYMSORT   ( 'compare searchfor src dest -- dest+ )
;
; Make a pass through the symbol table at PAD, copying eligible
; symbols to target
;
;": symsort   ( 'compare searchfor src dest )
;     >r 2+
;     ( 'compare searchfor nfa ) ( R; target )
;     begin
;         \ not done yet?
;         dup nfalen
;         ( 'compare searchfor nfa currlen ) ( R; target )
;     while
;         ( 'compare searchfor nfa ) ( R; target )
;         3dup rot execute
;         ( 'compare searchfor nfa flag ) ( R; target )
;         if
;             \ copy it up to the new symbol table
;             ( 'compare searchfor nfa ) ( R; target )
;             r@ over
;             ( 'compare searchfor nfa target nfa ) ( R; target )
;             sym+
;             ( 'compare searchfor nfa ) ( R; target )
;             \ advance target pointer
;             r> 2+ nfa+ 2- >r
;             ( 'compare searchfor nfa ) ( R; target+ )
;         then
;         \ advance source pointer
;         nfa+
;         ( 'compare searchfor nfa+ ) ( R; target+ )
;     repeat
;     ( 'compare searchfor nfa+ ) ( R; target+ )
;     3drop r> ;   ( dest+ )
;
;#ifdef HEADERS
;symsortlfa
;    .byt $de,$ad
;    .byt (_symsort-*-1)|bit7
;    .asc "SYMSOR","T"|bit7
;#endif
_symsort
#include "enter.i65"
    .word tor
#include "page.i65"
    .word twoplus
#include "page.i65"
symsort01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qbranch
    .byt <(symsort03-*+1)
#include "pad.i65"
    .word threedup
#include "page.i65"
    .word rot
#include "page.i65"
    .word execute
#include "page.i65"
    .word qbranch
    .byt <(symsort02-*+1)
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word _symplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word twominus
#include "page.i65"
    .word tor
#include "page.i65"
symsort02
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(symsort01-*+1)
#include "pad.i65"
symsort03
    .word threedrop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >BLOOM   ( n -- mask offset )
;
; transform an integer into a bitmask and offset, suitable for
; addressing a bloom filter
; mask = 2^(n%8)
; offset = n/8
;
;": >bloom   ( n -- mask offset )
;         dup 7 and [ power2 ] literal + c@
;         swap 2/ 2/ 2/ ;
;
;#ifdef HEADERS
;tobloomlfa
;    .byt $de,$ad
;    .byt (_tobloom-*-1)|bit7
;    .asc ">BLOO","M"|bit7
;#endif
_tobloom
#include "enter.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word andx
#include "page.i65"
    .word plit
    .word power2
#include "pad.i65"
    .word plus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word twoslash
#include "page.i65"
    .word twoslash
#include "page.i65"
    .word twoslash
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PASSFILTER   ( symbols -- )
;
; During the first half of rehash, it is unnecessary to make a
; pass through the entire symbol table searching for words of a
; given length, if none of that length exist.  This is a 
; bloom filter to eliminate those symbol table passes.
;
;": passfilter   ( symbols -- )
;     2+
;     ( nfa )
;     begin
;         dup nfalen ?dup
;     while
;         dup 7 and [ power2 ] literal + c@
;         swap 2/ 2/ 2/ [ passbits ] literal +
;     ( mask addr )
;         cbit!
;         nfa+
;     repeat drop ;
;
;#ifdef HEADERS
;passfilterlfa
;    .byt $de,$ad
;    .byt (_passfilter-*-1)|bit7
;    .asc "PASSFILTE","R"|bit7
;#endif
_passfilter
#include "enter.i65"
    .word plit
    .word passbits
#include "pad.i65"
    .word four
#include "page.i65"
    .word _erase
#include "page.i65"
    .word twoplus
#include "page.i65"
passfilter01
    .word dup
#include "page.i65"
    .word nfalen
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(passfilter02-*+1)
#include "pad.i65"
    .word _tobloom
#include "page.i65"
    .word plit
    .word passbits
#include "pad.i65"
    .word plus
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word nfaplus
#include "page.i65"
    .word branch
    .byt <(passfilter01-*+1)
#include "page.i65"
passfilter02
    .word drop
#include "page.i65"
    .word exit

passbits
    .word 0,0

;--------------------------------------------------------------
;
;       (REHASH)   ( 'compare flag src targ end start -- targ+ )
;
;": (rehash)   ( 'compare flag src targ end start -- targ+ )
;     do 
;         ( 'compare flag src targ )
;         i >bloom [ passbits ] literal + cbit@
;         ( 'compare flag src targ flag )
;         if
;             ( 'compare flag src targ )
;             >r 3dup r>
;             ( 'compare flag src 'compare flag src targ )
;             2swap 
;             ( 'compare flag src src targ 'compare flag )
;             if
;             ( 'compare flag src src targ 'compare )
;                   over i 2* symtab + !
;             ( 'compare flag src src targ 'compare )
;             then
;             ( 'compare flag src src targ 'compare )
;             i 2swap
;             ( 'compare flag src 'compare i src targ )
;             symsort
;             ( 'compare flag src targ+ )
;         then
;         ( 'compare flag src targ+ )
;     loop
;     ( 'compare flag src targ+ )
;     dup>r 3 erase 3drop r> ;
;     ( targ+ )
;
;#ifdef HEADERS
;prehashlfa
;    .byt $de,$ad
;    .byt (_prehash-*-1)|bit7
;    .asc "(REHASH",")"|bit7
;#endif
_prehash
#include "enter.i65"
    .word pdo
#include "page.i65"
prehash01
#include "page.i65"
    .word i
#include "page.i65"
    .word _tobloom
#include "page.i65"
    .word plit
    .word passbits
#include "pad.i65"
    .word plus
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word qbranch
    .byt <(prehash03-*+1)
#include "page.i65"
#ifdef ENTERTAINMENT
    .word cr
#include "page.i65"
    .word i
#include "page.i65"
    .word _dot
#include "page.i65"
    .word cr
#include "page.i65"
#endif
    .word tor
#include "page.i65"
    .word threedup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word qbranch
    .byt <(prehash02-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word i
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word store
#include "page.i65"
prehash02
    .word i
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word _symsort
#include "page.i65"
prehash03
    .word ploop
    .byt <(prehash01-*+1)
#include "pad.i65"
    .word duptor
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word threedrop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;        REHASH   ( -- )
;
; rebuilds the symbol table in high memory.
;
;": rehash  ( -- )
;     pad >syms
;     ( pad symbols )
;     ['] symbysize false
;     ( pad symbols 'compare flag )
;     2over swap
;     ( pad symbols 'compare flag symbols pad )
;     32 1  (rehash)
;     ( pad symbols targ+ )
;     symtab @ 32 erase
;     ( pad symbols  )
;     [ bloom ] literal 8 erase
;     ( pad symbols  )
;     [ passbits ] literal on
;     ['] symbyhash true 2swap 16 0  (rehash)
;     ( )
;
#ifdef HEADERS
rehashlfa
    .byt $de,$ad
    .byt (_rehash-*-1)|bit7
    .asc "REHAS","H"|bit7
#endif
_rehash
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word _tosyms
#include "page.i65"
    .word dup
#include "page.i65"
    .word _passfilter
#include "page.i65"
    .word plit
    .word _symbysize
#include "pad.i65"
    .word false
#include "page.i65"
    .word twoover
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word one
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word drop
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word plit
    .word bloom
#include "pad.i65"
    .word clit
    .byt 8
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word plit
    .word passbits
#include "pad.i65"
    .word on
#include "page.i65"
    .word plit
    .word _symbyhash
#include "pad.i65"
    .word true
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word _prehash
#include "page.i65"
    .word dup
#include "page.i65"
    .word symnew
#include "page.i65"
    .word store
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORGET   ( -- )
;
;   ( cfa -- ; special COLD mode - does not scan input )
;
; * 83 interpreter
;
; checks FENCE, moves DP, sorts symbol table
;
#ifdef HEADERS
forgetlfa
    .byt $de,$ad
    .byt (_forget-*-1)|bit7
    .asc "FORGE","T"|bit7
#endif
_forget
#include "enter.i65"
    .word rfetch                ; ( cfa caller )
#include "page.i65"
    .word plit
    .word launch01              ; ( cfa caller launch01 )
#include "pad.i65"
    .word ne                    ; ( cfa iscold? )
#include "page.i65"
    .word qbranch               ; ( cfa )
    .byt <(forget01-*+1)
#include "pad.i65"
    .word _tick
#include "page.i65"
forget01
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(forget03-*+1)
#include "pad.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word fail                  ; CAN'T FORGET BELOW FENCE
#include "page.i65"
forget03
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word _rehash
#include "page.i65"
    .word exit

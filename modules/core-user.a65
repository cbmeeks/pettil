; core-user.a65
#echo .       core-user.a65             Core User Variables

; user variables required for pettil-core

;--------------------------------------------------------------
#if 0
name=USERVAR
stack=( -- addr )
tags=uservariable,nosymbol
[desc]
Runtime action of all user variables.  Returns the address of the variable
[/desc]
#endif
uservar
    pla
    tay
    pla
    sta n+1
    iny
    bne uservar01
    inc n+1
uservar01
    sty n
    ldy #0
    clc
    lda up
    adc (n),y
    sta n
    lda up+1
    adc #0
    tay
    lda n
    jmp pushya

;--------------------------------------------------------------
#if 0
name=SP0
stack=( -- addr )
tags=uservar,fig
[desc]
User variable
The data stack initialization value ($30)
[/desc]
#endif
sp0
    jsr uservar
    .byt usersp0-userarea

;--------------------------------------------------------------
#if 0
name=RP0
stack=( -- addr )
tags=uservar,fig
[desc]
[heading]User variable[/heading]
The return stack initialization value ($01FE)
[/desc]
#endif
rp0
    jsr uservar
    .byt userrp0-userarea

;--------------------------------------------------------------
#if 0
name=DP
stack=( -- addr )
tags=uservar,fig
[desc]
Dictionary pointer
[/desc]
#endif
dp
    jsr uservar
    .byt userdp-userarea

;--------------------------------------------------------------
;       MEMSIZ
;
;
#if 0
name=MEMSIZ
stack=( -- addr )
tags=uservar,kernel
[desc]
[heading]User variable[/heading]
Top of RAM, initialized at COLD from BASIC zero page variable at $34
This variable may be adjusted, e.g. to allocate a contiguous block of
memory at the top of RAM
[/desc]
#endif
memsiz
    jsr uservar
    .byt usermemsiz-userarea

;--------------------------------------------------------------
#if 0
name=SYMTAB
stack=( -- addr)
tags=uservar,pettil
[desc]
[heading]User variable[/heading]
Symbol table start address

First 32 bytes are thread pointers for each possible Pearson
hash value, followed by 16 threads of symbols, ordered by size.  
[/desc]
~wut? Why is it necessary in core?
#endif
symtab
    jsr uservar
    .byt usersymtab-userarea

;--------------------------------------------------------------
#if 0
name=SYMTAIL
stack=( -- addr )
tags=uservar,pettil
[desc]
[heading]User variable[/heading]
Symbol table end address

Where new symbols are appended
[/desc]
#endif
symtail
    jsr uservar
    .byt usersymtail-userarea

;--------------------------------------------------------------
#if 0
name=STARTUP
stack=( -- addr )
tags=uservar
[desc]
[heading]User variable[/heading]
Stores the code field address of the word that runs after ABORT
occurs

#endif
startup
    jsr uservar
    .byt userstartup-userarea

;--------------------------------------------------------------
#if 0
name=VMBUF
stack=( -- addr )
[desc]
Pointer to the bottom of the virtual memory buffer.  Save and
verify operate between this address and BLKBUF
[/desc]
#endif
vmbuf
    jsr uservar
    .byt uservmbuf-userarea

;--------------------------------------------------------------
#if 0
name=#VMPKT
stack=( -- addr )
[desc]
Number of virtual memory packets
[/desc]
#endif
numvmpkt
    jsr uservar
    .byt usernumvmpkt-userarea

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- addr )
[desc]
BLOCK will generate new packets in the virtual memory packet 
buffer if they don't already exist.  This user variable decides
whether those created packets are read-only (data) blocks or 
writable (screens).
[/desc]
#endif
editingq
	jsr uservar
	.byt usereditingq-userarea

;--------------------------------------------------------------
#if 0
name=WRITABLE?
stack=( -- addr )
[desc]
PETTIL's editor distinguishes between "data" and "screen" blocks
using a bitflag (metadata) in the packet header.

Data blocks are 1024 bytes and can't be completely displayed on
the PET's 40x25 hardware.  The editor will show the first 1000 bytes
and otherwise treats such blocks as read-only.

Screens (typically source code) are read-write and the editor
will update the virtual memory packet buffer when leaving the screen,
e.g. via the STOP-Q editor command.  Screens also contain 24 bits
of linewrap information (the first three bytes of the block buffer), 
and are treated as a collection of 40-character or 80-character 
lines by the compiler.  In other words, line terminations are 
considered to be whitespace when loading screens, and source lines 
can extend all the way to the left and right edges.

The STOP-CLR editor command converts a data block into a screen,
discarding the last (unseen) 24 bytes and initializing the linewrap
to all 40-character lines, or it will reset the linewrap on existing
screens.  Changes aren't saved to the packet buffer until the screen
is exited.
[/desc]
#endif
writableq
	jsr uservar
	.byt userwritableq-userarea

;--------------------------------------------------------------
#if 0
name=TDICT
stack=( -- addr )
[desc]
base address of temporary dictionary
[/desc]
#endif
tdict
    jsr uservar
    .byt usertdict-userarea

;--------------------------------------------------------------
#if 0
name=BASE
stack=( -- addr )
[desc]
User Variable containing the system number base
[/desc]
#endif
base
    jsr uservar
    .byt userbase-userarea

;--------------------------------------------------------------
#if 0
name=DPL
stack=( -- addr )
[desc]
User variable containing the number of digits following the 
decimal in numeric input conversion
[/desc]
#endif
dpl
    jsr uservar
    .byt userdpl-userarea

;--------------------------------------------------------------
#if 0
name=HLD
stack=( -- addr )
[desc]
[/desc]
#endif
hld
    jsr uservar
    .byt userhld-userarea

;--------------------------------------------------------------
#if 0
name=BLK
stack=( -- addr )
[desc]
The address of a variable containing the number of the mass
storage block being interpreted as the input stream.  If the
value of BLK is zero the input stream is taken from the text
input buffer.  {{0..the number of blocks available -1}}
-1 = cassette tape 1 ~wut?
-2 = cassette tape 2 ~wut?
[/desc]
#endif
blk
    jsr uservar
    .byt userblk-userarea

;--------------------------------------------------------------
#if 0
name=>IN
stack=( -- )
[desc]
Leaves the address of the user variable >IN which contains the
number of bytes from the beginning of the input stream at any
particular moment during interpretation.
The address of a user variable which contains the present
character offset within the input stream.  
[/desc]
#endif
toin
    jsr uservar
    .byt usertoin-userarea

;--------------------------------------------------------------
#if 0
name=SPAN
stack=( -- addr )
[desc]
The address of a variable containing the count of characters
actually received and stored by the last execution of EXPECT
[/desc]
#endif
span
    jsr uservar
    .byt userspan-userarea

;--------------------------------------------------------------
#if 0
name=#TIB
stack=( -- addr )
[desc]
The address of a variable containing the number of bytes in
the text input buffer.  #TIB is accessed by WORD when BLK is
zero.  {{0..capacity of TIB}}  
[/desc]
#endif
numtib
    jsr uservar
    .byt usertib-userarea

;--------------------------------------------------------------
#if 0
name=#OUT
stack=( -- addr )
[desc]
User variable 
Counts number of characters that have been emitted
[/desc]
#endif
numout
    jsr uservar
    .byt usernumout-userarea

;--------------------------------------------------------------
#if 0
name=#LINE
stack=( -- addr )
[desc]
User variable
Counts the number of lines output
[/desc]
#endif
numline
    jsr uservar
    .byt usernumline-userarea

;--------------------------------------------------------------
#if 0
name=ERRMESS
stack=( -- addr )
[desc]
User variable
Address of the error messages table.  If zero, only a numeric
error is output
[/desc]
#endif
errmess
    jsr uservar
    .byt usererrmess-userarea

; sweet16.a65
#echo .       sweet16.a65               Woz's SWEET16 virtual machine, roughly emulates the Cosmac 1802

; based on "http://6502.org/source/interpreters/sweet16.htm
;
;* SWEET 16 INTERPRETER
;
;* APPLE-II PSEUDO MACHINE INTERPRETER
;* COPYRIGHT (C) 1977
;* APPLE COMPUTER, INC
;* ALL RIGHTS RESERVED
;* S. WOZNIAK
;

#define R0    $0
r0 = 2*R0           ; ACC
#define R1    $1
r1 = 2*R1           ; UP
#define R2    $2
r2 = 2*R2           ; I
#define R3    $3
r3 = 2*R3           ; ILIMIT
#define R4    $4
r4 = 2*R4           ; TOS
#define R5    $5
r5 = 2*R5           ; N0
#define R6    $6
r6 = 2*R6           ; N1
#define R7    $7
r7 = 2*R7           ; N2
#define R8    $8
r8 = 2*R8           ; N3
#define R9    $9
r9 = 2*R9
#define R10   $a
r10 = 2*R10
#define R11   $b
r11 = 2*R11
#define R12   $c
r12 = 2*R12         ; BS/RS stack pointer
#define R13   $d
r13 = 2*R13         ; CPR result
#define R14   $e
r14 = 2*R14         ; prior result register(l) and carry flag(h)
#define R15   $f
r15 = 2*R15         ; Sweet16 PC

#define ACC    $0
#define UP     $1
#define IREG   $2
#define ILIMIT $3
#define TOS    $4
#define N0     $5
#define N1     $6
#define N2     $7
#define N3     $8

#define R0L    $0
#define R0H    R0L+$1
#define R14L   R0L+$1c
#define R14H   R0L+$1d
#define R15L   R0L+$1e
#define R15H   R0L+$1f

; return                    leave Sweet16 (to 6502 mode)
#define rtn   $00

; branch if plus            R15 <-- R15 +/- offset if prior result is positive
#define bp    $01

; branch if minus           R15 <-- R15 +/- offset if prior result is negative
#define bm    $02

; branch if zero            R15 <-- R15 +/- offset if prior result is 0
#define bz    $03

; branch if not zero        R15 <-- R15 +/- offset if prior result is not 0
#define bnz   $04

; branch if -1              R15 <-- R15 +/- offset if prior result is -1
#define bm1   $05

; branch if not -1          R15 <-- R15 +/- offset if prior result is not -1
#define bnm1  $06

; next                      leave Sweet16 and jmp next
#define nxt   $07

; push to data stack        R0 --> TOS
#define push  $08

; pull from data stack      R0 <-- 2OS                   
#define pull  $09

; branch always             R15 <-- R15 +/- offset
#define br    $0a

; extension, address        runs native 6502 code, ended by RTS
#define ext   $0b

; branch to subroutine      (R12++) <-- R15; R12++ ; R15 <-- R15 +/- offset
#define bs    $0c

; return from subroutine    R15 <-- (R12--)
#define rs    $0d

; branch if carry           R15 <-- R15 +/- offset if R14H bit 1 is set
#define bc    $0e

; branch if no carry        R15 <-- R15 +/- offset if R14H bit 1 is clear
#define bnc   $0f

; set Rn, constant          Rn <-- constant
#define set $10

; load Rn                   R0 <-- Rn
#define ld $20

; store Rn                  Rn <-- R0
#define st $30

; load indirect Rn          R0L <-- (Rn++); R0H <-- 0
#define ldi $40

; store indirect Rn         (Rn++) <-- R0L
#define sti $50

; load double indirect Rn   R0L <-- (Rn++); R0H <-- (Rn++)
#define ldd $60

; store double indirect Rn  (Rn++) <-- R0L; (Rn++) <-- R0H
#define std $70

; pop indirect Rn           R0L <-- (--Rn); R0H <-- 0
#define pop $80

; store pop indirect Rn     (--Rn) <-- R0L
#define stpx $90

; add Rn                    R0 <-- R0 + Rn
#define add $A0

; sub Rn                    R0 <-- R0 - Rn
#define sub $B0

; pop double indirect Rn    R0H <-- (--Rn); R0L <-- (--Rn)
#define popd $C0

; compare Rn                R13 <-- R0 - Rn
#define cpr $D0

; increment Rn              Rn++
#define inr $E0

; decrement Rn              Rn--
#define dcr $F0

BRTBL
    .BYT <RTN-1   ;0
OPTBL
    .BYT <SET-1   ;1X
    .BYT <BP-1    ;1
    .BYT <LD-1    ;2X
    .BYT <BM-1    ;2
    .BYT <ST-1    ;3X
    .BYT <BZ-1    ;3
    .BYT <LDAT-1  ;4X
    .BYT <BNZ-1   ;4
    .BYT <STAT-1  ;5X
    .BYT <BM1-1   ;5
    .BYT <LDDAT-1 ;6X
    .BYT <BNM1-1  ;6
    .BYT <STDAT-1 ;7X
    .BYT <NXT-1   ;7
    .BYT <POP-1   ;8X
    .BYT <PUSH-1  ;8
    .BYT <STPAT-1 ;9X
    .BYT <PULL-1  ;9
    .BYT <ADD-1   ;AX
    .BYT <BR-1    ;A
    .BYT <SUB-1   ;BX
    .BYT <EXT-1   ;B    uses R11
    .BYT <POPD-1  ;CX
    .BYT <BS-1    ;C    uses R12
    .BYT <CPR-1   ;DX   uses R13
    .BYT <RS-1    ;D
    .BYT <INR-1   ;EX
    .BYT <BC-1    ;E
    .BYT <DCR-1   ;FX
    .BYT <BNC-1   ;F


SW16C
    INC R15L
    BNE SW16D
    INC R15H
SW16D
    LDA #>LD       ;COMMON HIGH BYTE FOR ALL ROUTINES
    PHA            ;PUSH ON STACK FOR RTS
    LDY #0
    LDA (R15L),Y   ;FETCH INSTR
    AND #$0F       ;MASK REG SPECIFICATION
    ASL            ;DOUBLE FOR TWO BYTE REGISTERS
    TAX            ;TO X REG FOR INDEXING
    LSR            ; always clears carry
    EOR (R15L),Y   ;NOW HAVE OPCODE
    BEQ TOBR       ;IF ZERO THEN NON-REG OP
    STX R14L       ;INDICATE "PRIOR RESULT REG"
    LSR
    LSR            ;OPCODE*2 TO LSB'S
    LSR
    TAY            ;TO Y REG FOR INDEXING
    LDA OPTBL-2,Y  ;LOW ORDER ADR BYTE
    PHA            ;ONTO STACK
disp1
    RTS            ;GOTO REG-OP ROUTINE

    ; A = 0
    ; X = opcode*2
    ; Y = 0
    ; N = 0
    ; Z = 1
    ; C = 0
TOBR
    LDA BRTBL,X    ;LOW ORDER ADR BYTE
    PHA            ;ONTO STACK FOR NON-REG OP

    ; nxt, push, pull, br, ext, rs, rtn
    ; A = addr[low]
    ; X = opcode*2
    ; N = top/bottom of addr[low]
    ; Z = 0
    ; C = 0 
    BMI TOBR4
    INC R15L
    BEQ TOBR5
TOBR2
    CPX #nxt*2
    BCS TOBR3
    LDX R14L
    LDA R0H,X

    ; bp, bm, bz, bnz, bm1, bnm1
    ; A = prior result[high]
    ; X = prior register*2
    ; Y = 0
    ; N = sign? prior result[high]
    ; Z = zero? prior result[high]
    ; C = 0
disp2
    RTS
TOBR3
    LDA R14H
    LSR
    
    ; bs, bc, bnc
    ; A = ?
    ; X = opcode*2
    ; Y = 0
    ; N = 0
    ; Z = ?
    ; C = from prior result
TOBR4
disp3
    RTS
TOBR5
    INC R15H
    BNE TOBR2
    

;* FOLLOWING CODE MUST BE
;* CONTAINED ON A SINGLE PAGE!

LD
    LDA R0L,X
    STA R0L
    LDA R0H,X       ;MOVE RX TO R0
    STA R0H
    RTS
STAT
    LDA R0L
STAT2
    STA (R0L,X)     ;STORE BYTE INDIRECT
    LDY #0
STAT3
    STY R14L        ;INDICATE R0 IS PRIOR RESULT REG
INR
    INC R0L,X
    BNE INR2        ;INCR RX
    INC R0H,X
INR2
    RTS
LDAT
    LDA (R0L,X)     ;LOAD INDIRECT (RX)
    STA R0L         ;TO R0
    LDY #0
    STY R0H         ;ZERO HIGH ORDER R0 BYTE
    BEQ STAT3       ;ALWAYS TAKEN
POP
    LDY #0          ;HIGH ORDER BYTE = 0
    BEQ POP2        ;ALWAYS TAKEN
POPD
    JSR DCR         ;DECR RX
    LDA (R0L,X)     ;POP HIGH ORDER BYTE @RX
    TAY             ;SAVE IN Y REG
POP2
    JSR DCR        ;DECR RX
    LDA (R0L,X)    ;LOW ORDER BYTE
    STA R0L        ;TO R0
    STY R0H
POP3
    LDY #0         ;INDICATE R0 AS LAST RESULT REG
    STY R14L
    RTS
BP
    BPL BR1        ;BRANCH IF SO
    RTS
BM
    BMI BR1
    RTS
BZ
    ORA R0L,X       ;(BOTH BYTES)
    BEQ BR1        ;BRANCH IF SO
    RTS
BNZ
    ORA R0L,X       ;(BOTH BYTES)
    BNE BR1        ;BRANCH IF SO
    RTS
BM1
    AND R0L,X       ;FOR $FF (MINUS 1)
    EOR #$FF
    BEQ BR1         ;BRANCH IF SO
    RTS
BNM1
    AND R0L,X       ;CHECK BOTH BYTES FOR NO $FF
    EOR #$FF
    BNE BR1         ;BRANCH IF NOT MINUS 1
    RTS
BS
    ;LDX #R12*2     ; already R12 because x=opcode*2
    LDA R15L        ;NOTE X REG IS 12*2!
    JSR STAT2       ;PUSH LOW PC BYTE VIA R12
    LDA R15H
    JSR STAT2       ;PUSH HIGH ORDER PC BYTE
    ;LDY #0
BR
    CLC             ;bra
BNC
    BCS BNC2        ;NO CARRY TEST
BR1
    ;LDY #0
    ;CLC
    LDA (R15L),Y    ;DISPLACEMENT BYTE
    BPL BR2
    DEY
BR2
    ADC R15L        ;ADD TO PC
    STA R15L
    TYA
    ADC R15H
    STA R15H
BNC2
    RTS
BC
    BCS BR
    RTS
ST
    LDA R0L
    STA R0L,X       ;MOVE R0 TO RX
    LDA R0H
    STA R0H,X
    RTS
;--------------- middle of page ---------------
LDDAT
    JSR LDAT        ;LOW ORDER BYTE TO R0, INCR RX
    LDA (R0L,X)     ;HIGH ORDER BYTE TO R0
    STA R0H
    JMP INR         ;INCR RX
STDAT
    JSR STAT        ;STORE INDIRECT LOW ORDER
    LDA R0H         ;BYTE AND INCR RX. THEN
    STA (R0L,X)     ;STORE HIGH ORDER BYTE.
    JMP INR         ;INCR RX AND RETURN
EXT
    ;LDX #R11*2
    STX R14L
    LDY #2          ; point to high byte of transfer address
    JSR SET
    ; A = R15L
    ; X = opcode*2
    ; Y = 1
    ; N = 0
    ; Z = 1
    ; C = ?
    JMP (r11)       ; implement your 6502 extension to Sweet16 here
                    ; reuse R11 as a return value
STPAT
    JSR DCR         ;DECR RX
    LDA R0L
    STA (R0L,X)     ;STORE R0 LOW BYTE @RX
    JMP POP3        ;INDICATE R0 AS LAST RESULT REG
DCR
    LDA R0L,X
    BNE DCR2        ;DECR RX
    DEC R0H,X
DCR2
    DEC R0L,X
    RTS
SUB
    LDY #0          ;RESULT TO R0
CPR
    ;LDY #R13*2
    SEC             ;NOTE Y REG = 13*2 FOR CPR
    LDA R0L
    SBC R0L,X
    STA R0L,Y       ;R0-RX TO RY
    LDA R0H
    SBC R0H,X
SUB2
    STA R0H,Y
    STY R14L        ;LAST RESULT REG*2
    ROL R14H        ;CARRY TO LSB
    RTS
NXT
    LDA #<(next-1)
    STA R15L
    LDA #>(next-1)
    STA R15H
RTN
    INC R15L
    BNE RTN2
    INC R15H
RTN2
    PLA
    PLA
    TSX
    LDA R15L
    STA $0105,X
    LDA R15H
    STA $0106,X
    JMP $E600
RS
    BMI RSZ         ;bra
PULL
    BMI PULLZ       ;bra
PUSH
    BMI PUSHZ       ;bra
ADD
    ;CLC            ;already clear
    LDA R0L
    ADC R0L,X
    STA R0L         ;R0+RX TO R0
    LDA R0H
    ADC R0H,X
    LDY #0          ;R0 FOR RESULT
    BEQ SUB2        ;FINISH ADD
SET
    ;LDY #2
    ;X = register * 2
    LDA (R15L),Y    ;HIGH ORDER BYTE OF CONSTANT
    STA R0H,X
    DEY
    LDA (R15L),Y    ;LOW ORDER BYTE OF CONSTANT
    STA R0L,X
    TYA
    SEC             ;ADD 2 to R15
    ADC R15L
    STA R15L
    BCS SET2        ;usually 2 clocks
    RTS
SET2
    INC R15H
    RTS
RSZ
    LDX #R12*2      ;STACK POINTER
    JSR DCR         ;DECR STACK POINTER
    LDA (R0L,X)     ;POP HIGH RETURN ADDRESS TO PC
    STA R15H
    JSR DCR    ;SAME FOR LOW ORDER BYTE
    LDA (R0L,X)
    STA R15L
    RTS
PULLZ
    TSX
    LDA $0104,X
    TAX             ; get PETTIL stack pointer
    JSR slide       ; remove item from Forth data stack (DROP in Forth)
    TXA
    TSX
    STA $0104,X
    LDX #2*TOS      ; LD TOS
    JMP LD
PUSHZ
    TSX
    LDA $0104,X
    TAX             ; get PETTIL stack pointer
    JSR slip        ; push TOS -> Forth data stack (DUP in Forth)
PUSH2
    TXA
    TSX
    STA $0104,X
    LDX #2*TOS      ; ST TOS
    JMP ST

SW16
    cli             ; Allow interrupt processing during Sweet16.
                    ; This will cause problems if Sweet16 is used
                    ; as part of an IRQ handler.  Not doing this
                    ; will stop the jiffy clock during Sweet16.
    LDY $0106,X     ;INIT SWEET16 PC
    LDA $0105,X     ;ADDRESS
    SEC
    SBC #2
    BCS SW16A
    DEY
SW16A
    STY R15H
    STA R15L
SW16B
    JSR SW16C      ;INTERPRET AND EXECUTE
    JMP SW16B      ;ONE SWEET16 INSTR.

; push TOS to the stack (DUP)
slip
    dex    ; slip something onto the stack
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    rts

; pop the stack
slide
    lda stackh,x    ; slide something off of the stack
    sta tos+1
    lda stackl,x
    sta tos
    inx
    rts

; returns the low 5 bits of a length byte (length only)
;
;inputs
;    N0 (R5) = LFA(-ish) address (two below a counted string)
;returns
;    R11 = low bits of length byte at (N0)
;    C is set if the word is smudged
wordlen16
    ;ldy #1         done by Sweet16
    dey             ;Y=0
    sty r11+1       ; clear high byte
    lda (n),y
    tay
    and #$1f
    sta r11         ; R11 = length
    tya
    asl             ; c = immediate bit
    asl             ; c = smudge bit
    rol R14H
    rts

; strcomp16 compares two strings that are already known to be the same length.
; sets the Sweet16 C flag if the strings match, otherwise clears it
;
;inputs
;    TOS (R4) = addr of a string
;    N0 (R5) = current NFA in the symbol table (initially the first NFA)
;    N1 (R6) = length of both strings
;
;returns
;    C = true iff the strings match
;
strcomp16    
    clc             ; assume fail
    ldy n+2         ; the length
strcomp16a
    lda (n),y
    eor (tos),y
    bne strcomp16b  ; different? outtie fail
    dey
    bne strcomp16a  ; C flag is set on successful strcmp
    sec             ; success!
strcomp16b
    rol R14H        ; tell Sweet16 about the C flag
    rts

;--------------------------------------------------------------
pearson
;    .byt 150,191,252,0,194,202,129,7
    .byt 80, 63, 253, 57, 173, 24, 93, 2 
pearsonx

; dhash16 calculates the bloom hash and the pearson hash for the
; string pointed to by N1.  R11 contains the pearson hash, while
; R10 contains the bloom hash
;
; The carry flag will be set if the pearson hash matches N2, and
; the bloom hash will be OR'ed into the bloom filter if that is 
; the case.
;
;inputs
;    N1 (R6) = addr of a string
;    N2 (R7) = current pearson hash
;
;returns
;    C = true iff the generated hash matched the hash index in N2
;    R11 = pearson hash
;    R10 = bloom hash
;
;        hash=pearson[line.length&psize]
;        line.each_byte { |char|
;            hash = char^pearson[hash&psize]
dhash16    
    stx storex
    ;ldy #1
    dey
    sty R14H        ; clear carry
    lda (n+2),y
    and #$1f                    ; seed hash with length
    sta r11
    iny
dhash16a
    dey
    beq dhash16b
    lda (n+2),y
    and #(pearsonx-pearson-1)
    tax
    lda r11
    eor pearson,x       ;        hash=pearson[line.length&psize]
    sta r11
    jmp dhash16a
dhash16b
    lsr
    lsr
    lsr
    lsr
    eor r11
    and #$0f
    sta r11
    eor n+4
    bne dhash16c
    inc R14H        ; set carry
dhash16c
    ldx storex
    rts

; xor TOS with ACC, leaving the result in ACC
;inputs
;    TOS (R4) = some value
;    ACC (R0) = some other value
;returns
;    ACC = TOS^ACC
xor16
    lda tos
    eor r0
    sta r0
    lda tos+1
    eor r0+1
    sta r0+1
    rts

; mask off just the length portion of the packet header
;
;inputs
;    ACC (R0) = packet header
;returns
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
pktheader16
    ;ldy #1
    dey
    sty 2*N2
    sty 2*N3
    lda r0
    sta 2*N1                    ; packet header (low)
    sta r11                     ; packet length (low)
    ldy r0+1
    tya
    sta 1+2*N1                  ; packet header (high)
    and #$7
    sta r11+1                   ; packet length
    tya
    and #$80
    sta 1+2*N2                  ; editable? to N2(high)
    tya
    and #$40
    sta 1+2*N3                  ; uncompressed? to N3(high)
    ;ldx #r11
;inputs
;   X = Sweet16 register address e.g. TOS = 8
;returns
;   decrements that 16-bit register twice (X)=(X)-2
twodec
    jsr DCR
    jmp DCR

;
;
;inputs
;   TOS (R4) = addr
;   N0 (R5) = addr+size
;   N1 (R6) = count 
;returns
;   TOS = addr (unchanged)
;   N0 = addr of last non-blank character (= addr if all are blank)
    ;clc
dashtrailing16
    ldy #0
    dec n+1                     ; n0 high
    dec n+3                     ; count high
    bpl dashtrailing16c
    lda tos
    sta n
    lda tos+1                   ; set up for last page
    sta n+1
    ldy n+2
    beq dashtrailing16e
    sec
dashtrailing16c
    dey
    lda (n),y
    iny
    eor #' '
    bne dashtrailing16d
    dey
    bne dashtrailing16c
    bcc dashtrailing16
dashtrailing16d
    clc
    tya
    adc n
    sta n                       ; count
    bcc dashtrailing16e
    inc n+1
dashtrailing16e
    rts

; core-numword.a65
#echo .       core-numword.a65          NUMBER and WORD

;--------------------------------------------------------------
;
;		SYMBUF   ( -- symbuf )
;
; Analagous to HERE, but the place where the next symbol goes, 
; and temporary storage during INTERPET
;
#ifdef HEADERS
symbuflfa
	.byt $de,$ad
	.byt (_symbuf-*-1)|bit7
	.asc "SYMBU","F"|bit7
#endif
_symbuf
#include "enter.i65"
	.word symtail
#include "page.i65"
	.word fetch
#include "page.i65"
	.word twoplus
#include "page.i65"
	.word exit

;--------------------------------------------------------------
;
;       DIGIT    ( char base -- digit true | false )
;
; Converts a single character to a digit using the current number
; base.  A flag on TOS indicates whether the conversion succeeded.
;~wut? possible to code golf this down with BCD tricks?
;"http://www.6502.org/tutorials/decimal_mode.html
#ifdef HEADERS
digitlfa
    .byt $de,$ad
    .byt (digit-*-1)|bit7
    .asc "DIGI","T"|bit7
#endif
digit
    ldy #$ff        ; assume success
    lda stackl,x    ; get the character
    sec
    sbc #'0'
    bcc digit02     ; char was < '0'? not a digit, fail
    cmp #10
    bcc digit01     ; digit is in the range 00-09
    sbc #7          ; no? alphabet adjust 'A' --> $0a
digit01
    cmp tos         ; compare to current number base
    bcs digit02     ; not in current number base? fail
    sta stackl,x    ; digit in the current number base
    .byt $2c        ; BIT xxyy, skip the next two bytes
digit02
    iny             ; fail, set flag to 0
    inx             ; drop the stack

    tya             ; ya = flag word $0000 or $ffff
    jmp put         ; next!

;--------------------------------------------------------------
;
;       SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
#ifdef SWEET16
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit
#endif
;--------------------------------------------------------------
;
;       SCAN   ( addr count char -- addr count )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scan
#ifdef SWEET16
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt rtn
    lda n
    ldy n+1
    jmp pushya
#endif

;--------------------------------------------------------------
;
;       HOLD   ( char -- )
;
; * 83 interpreter
;
; Inserts  character into a pictured numeric out-
; put string.
; char is inserted into a pictured numeric output
; string.  Typically used between  <#  and  #> .
#ifdef HEADERS
holdlfa
    .byt $de,$ad
    .byt (_hold-*-1)|bit7
    .asc "HOL","D"|bit7
#endif
_hold
#include "enter.i65"
    .word minusone
#include "page.i65"
    .word hld
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       'STREAM   ( -- addr size )
;
;" : 'stream
;       blk @ ?dup
;       if      block b/buf
;       else    tib #tib @
;       then
;       >in @ over min >r swap r@ + swap r> - ;
#ifdef HEADERS
tickstreamlfa
   .byt $de,$ad
    .byt (_tickstream-*-1)|bit7
    .asc "'STREA","M"|bit7
#endif
_tickstream
#include "enter.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qdup              ; ( 0 | blk blk )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(tickstream01-*+1)
#include "pad.i65"
    ; input from block device
    .word clit
    .byt 9
#include "pad.i65"
    .word fail
#include "page.i65"
    ; this is where the BLOCK i/o goes
    ; _block bperbuf        ; ( addr )
    .word branch            ; ELSE
    .byt <(tickstream02-*+1)	; this code never executes
#include "pad.i65"
tickstream01                ; input from terminal
    .word tib               ; ( tib )
#include "page.i65"
    .word numtib            ; ( tib #tib.uarea )
#include "page.i65"
    .word fetch             ; ( tib #tib )
#include "page.i65"         ; THEN
tickstream02
    .word toin              ; ( buf size >in )
#include "page.i65"
    .word fetch             ; ( buf size offset )
#include "page.i65"
    .word over              ; ( buf size offset size )
#include "page.i65"
    .word _min              ; ( buf size offset )
#include "page.i65"
    .word tor               ; ( buf size )
#include "page.i65"
    .word swap              ; ( size buf )
#include "page.i65"
    .word rfetch            ; ( size buf offset )
#include "page.i65"
    .word plus              ; ( size addr )
#include "page.i65"
    .word swap              ; ( addr size )
#include "page.i65"
    .word rfrom             ; ( addr size offset )
#include "page.i65"
    .word minus             ; ( addr remaining )
#include "page.i65"
    .word exit

;               .word to6502
;               ldy #2
;               jsr locals
;               brk
;               .byt ldd  | TOS         ; >in @
;               .byt cpr  | N0          ; #tib or b/buf
;               .byt bm,  <(tickstream03-*-2)
;               .byt ld   | N0
;tickstream03   .byt st   | N2          ; smaller of (#tib or b/buf, >in)
;               .byt ld   | N1          ; tib
;               .byt add  | N2          ; cursor position
;               .byt st   | TOS
;               .byt ld   | N0
;               .byt sub  | N2          ; bytes remaining
;               .byt push               ; ( addr remaining )
;               .byt rtn
;               jmp exit
;#include "toforth.i65"
;               .word exit

;--------------------------------------------------------------
;
;       WORD   ( char -- addr )
;
; * 83 interpreter 
;
; Generates a counted string by non-destructively accepting
; characters from the input stream until the delimiting
; character char is encountered or the input stream is
; exhausted.  Leading delimiters are ignored.  The entire
; character string is stored in memory beginning at addr as a
; sequence of bytes.  The string is followed by a blank which
; is not included in the count.  The first byte of the string
; is the number of characters {0..255}.  If the string is
; longer than 255 characters, the count is unspecified.  If
; the input stream is already exhausted as WORD is called,
; then a zero length character string will result.
;
; If the delimiter is not found the value of >IN is the size
; of the input stream.  If the delimiter is found >IN is
; adjusted to indicate the offset to the character following
; the delimiter.  #TIB is unmodified.           ; ( 0100 0104 0107 0009 )
;
; The counted string returned by WORD may reside in the "free"
; dictionary area at HERE or above.  Note that the text
; interpreter may also use this area.
;"See: http://forth.sourceforge.net/std/fst83/fst83-5.htm#input.stream
;
; fig high level
;" : word   ( c -- addr )
;       blk @  if  blk @ block  else  tib @  then
;       >in @ + swap enclose here 34 blank >in +!
;       over - >r r@ here c! + here 1+ r> cmove ;
;
;" : word   ( c -- nfa )
;      >r                              ; ( -- ) ( R; c )
;  ( ) ( R; c )
;      'stream
;  ( addr size ) ( R; c )
;      under
;  ( addr addr size ) ( R; c )
;      r@ skip
;  ( addr addr2 count2 ) ( R; c )
;      under
;  ( addr addr2 addr2 count2 ) ( R; c )
;      r> scan
;  ( addr addr2 addr3 count )
;      drop 2dup swap -
;  ( addr addr2 addr3 size )
;      >r
;  ( addr addr2 addr3 ) ( R; size )
;      rot - 1+
;  ( addr2 addr3 size2 ) ( R; size )
;      >in +!
;  ( addr2 addr3 ) ( R; size )
;      r> here
;  ( addr2 addr3 size here )
;      2dup c!
;  ( addr2 addr3 size here )
;      1+ swap cmove
;  ( addr2 )
;      here bl over
;  ( addr2 here bl here )
;      count + c! ;
;  ( addr2 here )
#ifdef HEADERS
wordlfa
    .byt $de,$ad
    .byt (_word-*-1)|bit7
    .asc "WOR","D"|bit7
#endif
_word
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word under
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word skip
#include "page.i65"
    .word under
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word twodup
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _here
#include "page.i65"
    .word twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _here
#include "page.i65"
    .word bl
#include "page.i65"
    .word over
#include "page.i65"
    .word count
#include "page.i65"
    .word plus
#include "page.i65"
    .word cstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NUMBER    ( addr -- d )
;
; Convert the counted string at addr, to a signed
; 32-bit integer, using the value of BASE .  If numeric
; conversion is not possible, an error condition exists.  The
; string may contain a preceding minus sign.
;
; \ There is a string that is probably a number stored from addrlow..addrhigh 
; \ convert a counted string to a signed double, keeping track of the decimal 
;": number  ( addr -- d )
;  ( addr )
;     0 0 rot count
;  ( 0 0 addr+1 len )
;     over c@ [ ascii - ] literal  =   
;  ( 0 0 addr+1 len negative? )
;     dup>r 
;  ( 0 0 addr+1 len negative? ) ( R; -- negative? )
;     + 
;  ( 0 0 addr+1 lenadj ; adjust length for sign char )
;     over + r@ -
;  ( 0 0 addr+1 addrhigh+1 )
;     swap  r@ - 
;  ( 0 0 addrhigh+1 addrlow )
;     dpl on
;     ?do 
;  ( d )
;         base @ >r 
;  ( d ) ( R; base negative? )
;         i c@  r@  digit 
;  ( -- d currdigit~?~ flag )
;         if
;             swap r@ um*
;             drop rot
;             r@ um* d+
;             dpl @ 1+  0= negate dpl +!
;         else
;             i c@ [ ascii . ] literal  =
;             dpl @ 0<  and
;             if
;                 dpl off
;             else
;                 3 fail ( abort" not found" )
;             then
;         then
;         r> drop 
;  ( R; negative? ; discard base )
;     loop
;     r>  if  dnegate  then ;
;
#ifdef HEADERS
numberlfa
    .byt $de,$ad
    .byt (_number-*-1)|bit7
    .asc "NUMBE","R"|bit7
#endif
_number
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word rot
#include "page.i65"
    .word count
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word duptor
#include "page.i65"
    .word plus
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word on
#include "page.i65"
    .word pqdo
    .byt <(number05-*+1)
#include "pad.i65"
number01
    .word base
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word digit
#include "page.i65"
    .word qbranch
    .byt <(number02-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word umstar
#include "page.i65"
	.word drop
#include "page.i65"
	.word rot
#include "page.i65"
	.word rfetch
#include "page.i65"
	.word umstar
#include "page.i65"
    .word dplus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word dpl
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word branch
    .byt <(number04-*+1)
#include "pad.i65"
number02
    .word i
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zlt
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(number03-*+1)
#include "pad.i65"
    .word dpl
#include "page.i65"
    .word off
#include "page.i65"
    .word branch
    .byt <(number04-*+1)
#include "pad.i65"
number03
    .word three
#include "page.i65"
    .word fail
#include "page.i65"
number04			; then then
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word ploop
    .byt <(number01-*+1)
#include "pad.i65"
number05
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(number07-*+1)
#include "pad.i65"
    .word dnegate
#include "page.i65"
number07
    .word exit

;--------------------------------------------------------------
;
;       <#   ( -- )
;
; * 83 interpreter
;
#ifdef HEADERS
ltsharplfa
    .byt $de,$ad
    .byt (_ltsharp-*-1)|bit7
    .asc "<","#"|bit7
#endif
_ltsharp
#include "enter.i65"
    .word _pad              ; ( pad )
#include "page.i65"
    .word hld               ; ( pad hld )
#include "page.i65"
    .word store             ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       #>
;
; * 83 interpreter
;
#ifdef HEADERS
sharpgtlfa
    .byt $de,$ad
    .byt (_sharpgt-*-1)|bit7
    .asc "#",">"|bit7
#endif
_sharpgt
#include "enter.i65"
    .word twodrop
#include "page.i65"
    .word hld
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pad
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
    .word exit

;--------------------------------------------------------------
;
;       SIGN    ( n -- )
;
; * 83 interpreter
;
; If n is negative, an ASCII "-" (minus sign) is appended to the
; pictured numeric output string.  Typically used between <# and #> .
;
#ifdef HEADERS
signlfa
    .byt $de,$ad
    .byt (_sign-*-1)|bit7
    .asc "SIG","N"|bit7
#endif
_sign
#include "enter.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(sign01-*+1)
#include "pad.i65"
    .word clit
    .byt '-'
#include "pad.i65"
    .word _hold
#include "page.i65"
sign01
    .word exit

;--------------------------------------------------------------
;
;       #   ( +d1 -- +d2 )
;
; * 83 interpreter
;
; +d1 is divided by BASE and the quotient is
; placed onto the stack.  The remainder is con-
; verted to an ASCII character and appended to
; the output string toward lower memory ad-
; dresses.
; The remainder of +d1 divided by the value of
; BASE is converted to an ASCII character and ap-
; pended to the output string toward lower memory
; addresses.  +d2 is the quotient and is main-
; tained for further processing.  Typically used
; between <# and #> .
#ifdef HEADERS
sharplfa
    .byt $de,$ad
    .byt (_sharp-*-1)|bit7
    .asc "#"|bit7
#endif
_sharp
#include "enter.i65"
    .word base              ; ( d base )
#include "page.i65"
    .word fetch             ; ( d @base )
#include "page.i65"
    .word udslashmod        ; ( rem d )
#include "page.i65"
    .word rot               ; ( d rem )
#include "page.i65"
    .word to6502
    lda tos
    sed
    cmp #10
    adc #'0'
    cld
    sta tos                 ; ( d char )
#include "toforth.i65"
    .word _hold             ; ( d )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       #S   ( d -- )
;
; * 83 interpreter
;
#ifdef HEADERS
sharpslfa
    .byt $de,$ad
    .byt (_sharps-*-1)|bit7
    .asc "#","S"|bit7
#endif
_sharps
#include "enter.i65"
sharps01        .word _sharp            ; ( d )
#include "page.i65"
    .word twodup           ; ( d d )
#include "page.i65"
    .word dzeq              ; ( d flag )
#include "page.i65"
    .word qbranch
    .byt <(sharps01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       (U.)
;
;#ifdef HEADERS
;pudotlfa
;    .byt $de,$ad
;    .byt (_pudot-*-1)|bit7
;    .asc "(U.",")"|bit7
;#endif
_pudot
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       U.
;
; * 83 interpreter
;
#ifdef HEADERS
udotlfa
    .byt $de,$ad
    .byt (_udot-*-1)|bit7
    .asc "U","."|bit7
#endif
_udot
#include "enter.i65"
    .word _pudot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       U.R    ( u n -- )
;
; u is converted using the value of BASE and then
; displayed as an unsigned number right-aligned
; in a field +n characters wide.  If the number
; of characters required to display u is greater
; than +n, an error condition exists.

#ifdef HEADERS
udotrlfa
    .byt $de,$ad
    .byt (_udotr-*-1)|bit7
    .asc "U.","R"|bit7
#endif
_udotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pudot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (.)   ( n -- )
;
;#ifdef HEADERS
;pdotlfa
;    .byt $de,$ad
;    .byt (_pdot-*-1)|bit7
;    .asc "(.",")"|bit7
;#endif
_pdot
#include "enter.i65"
    .word dup               ; ( n n )
#include "page.i65"
    .word abs               ; ( n +n )
#include "page.i65"
    .word zero              ; ( n +d )
#include "page.i65"
    .word _ltsharp          ; ( n +d )
#include "page.i65"
    .word _sharps           ; (
#include "page.i65"
    .word rot
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .   ( n -- )
;
; * 83 interpreter
;
; The value of n is displayed in a free field for-
; mat with a leading minus sign if n is negative.
#ifdef HEADERS
dotlfa
    .byt $de,$ad
    .byt (_dot-*-1)|bit7
    .asc "."|bit7
#endif
_dot
#include "enter.i65"
    .word _pdot             ; ( addr count )
#include "page.i65"
    .word type              ; ( )
#include "page.i65"
    .word _space            ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .R
;
#ifdef HEADERS
dotrlfa
    .byt $de,$ad
    .byt (_dotr-*-1)|bit7
    .asc ".","R"|bit7
#endif
_dotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pdot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (UD.)
;
;#ifdef HEADERS
;puddotlfa
;    .byt $de,$ad
;    .byt (_puddot-*-1)|bit7
;    .asc "(UD.",")"|bit7
;#endif
_puddot
#include "enter.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word _sharpgt
    .word exit

;--------------------------------------------------------------
;
;       UD.
;
#ifdef HEADERS
uddotlfa
    .byt $de,$ad
    .byt (_uddot-*-1)|bit7
    .asc "UD","."|bit7
#endif
_uddot
#include "enter.i65"
    .word _puddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       UD.R
;
#ifdef HEADERS
uddotrlfa
    .byt $de,$ad
    .byt (_uddotr-*-1)|bit7
    .asc "UD.","R"|bit7
#endif
_uddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _puddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (D.)
;
;#ifdef HEADERS
;pdddotlfa
;    .byt $de,$ad
;    .byt (_pddot-*-1)|bit7
;    .asc "(D.",")"|bit7
;#endif
_pddot
#include "enter.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word dabs
#include "page.i65"
    .word _ltsharp
#include "page.i65"
    .word _sharps
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _sign
#include "page.i65"
    .word _sharpgt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       D.
;
#ifdef HEADERS
ddotlfa
    .byt $de,$ad
    .byt (_ddot-*-1)|bit7
    .asc "D","."|bit7
#endif
_ddot
#include "enter.i65"
    .word _pddot
#include "page.i65"
    .word type
#include "page.i65"
    .word _space
    .word exit

;--------------------------------------------------------------
;
;       D.R
;
#ifdef HEADERS
ddotrlfa
    .byt $de,$ad
    .byt (_ddotr-*-1)|bit7
    .asc "D.","R"|bit7
#endif
_ddotr
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _pddot
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _spaces
#include "page.i65"
    .word type
    .word exit

;--------------------------------------------------------------
;
;       ?
;
#ifdef HEADERS
questionlfa
    .byt $de,$ad
    .byt (_question-*-1)|bit7
    .asc "?"|bit7
#endif
_question
#include "enter.i65"
    .word fetch
#include "page.i65"
    .word _dot
#include "page.i65"
    .word exit


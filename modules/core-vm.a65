; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
;
;       B/BUF   ( -- n )
;
#ifdef HEADERS
bperbuflfa
    .byt $de,$ad
    .byt (bperbuf-*-1)|bit7
    .asc "B/BU","F"|bit7
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
;
;       B/SCR   ( -- n )
;
; Bytes per screen.  Not what it usually means in other Forths,
; (not blocks per screen = 1)
;
#ifdef HEADERS
bperscrlfa
    .byt $de,$ad
    .byt (bperscr-*-1)|bit7
    .asc "B/SC","R"|bit7
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
;
;       BLKBUF   ( -- addr )
;
; return the address of the 1K block buffer
;
#ifdef HEADERS
blkbuflfa
    .byt $de,$ad
    .byt (_blkbuf-*-1)|bit7
    .asc "BLKBU","F"|bit7
#endif
_blkbuf
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
;
; test cases --
; vvwwxxyyyzz
; xxyyzz
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
#ifdef SWEET16
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R10   ; input counter - when this hits zero, we're done
    .byt st | R11   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R10   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R11   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R10
    .byt sti | N1   ; write output stream
    .byt dcr | R11
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R10
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | R10
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R10              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R11
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt
#endif

;--------------------------------------------------------------
;
;       RLDECODE ( srcaddr targaddr srclen -- )
;
; decode length {srclen} bytes beginning at source address
; {srcaddr} to the target address (targaddr).
;
;       RLDECODE ( srcaddr targaddr srclen -- )
#ifdef HEADERS
rldecodelfa
    .byt $de,$ad
    .byt (rldecode-*-1)|bit7
    .asc "RLDECOD","E"|bit7
#endif
rldecode
#ifdef SWEET16
    ldy #2
    jsr locals
    brk
    .byt set | R9
    .word $100
rldecode01
    .byt ld | R9
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | R9
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt
#endif

;--------------------------------------------------------------
;
;       >PKT   ( n -- packet )
;
; Return the packet address of block n
;
;": >pkt   ( n -- packet )
;     blkbuf 2-
;     begin
;         over 0>
;     while
;         dup @
;         - swap 1- swap
;     repeat
;     swap drop ;
;
#ifdef HEADERS
topktlfa
    .byt $de,$ad
    .byt (_topkt-*-1)|bit7
    .asc ">PK","T"|bit7
#endif
_topkt
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topkt01
    .word over
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(topkt02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word branch
    .byt <(topkt01-*+1)
#include "pad.i65"
topkt02
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PKT+ ( editable? -- packet )
;
; Append a new packet to the bottom of vmbuf, return its address
; flag = false for data packet, true for editor packet
;
;": pkt+   ( editable? -- packet )
;                                 ( editable? )
;     >r vmbuf @ 14 r@ 9 and -      \ packet length editor=5 data=14
; ( vmtail size )
;     2dup - dup third erase        \ clear packet and new tail
;     dup 2+ 3 r@ fill              \ first 3 bytes of packet = flag
;     vmbuf !                       \ update vmbuf to new tail
;     VIDRAM r> and or over !       \ set packet length
;     #vmpkt 1+! ;                  \ increment packet counter )
;     ( vmbuf )                     \ packet address
;
#ifdef HEADERS
pktpluslfa
    .byt $de,$ad
    .byt (_pktplus-*-1)|bit7
    .asc "PKT","+"|bit7
#endif
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word clit
    .byt 9
#include "pad.i65"
    .word andx
#include "page.i65"
    .word minus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word third
#include "page.i65"
    .word _erase
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word three
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word fill
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       UNPKT ( packet -- blkbuf )
;
; Given the address of a packet (its size/flags word, at the top)
; this will unpack the packet to the block buffer and return
; the address of the unpacked block. Distinguishes among
; compressed/uncompressed and editable/uneditable packets
;
;": unpkt   ( packet -- blkbuf )
;     dup @ dup 0< editblk !
;  ( packet header )
;     dup 2* 0< >r
;  ( packet header ) ( R; uncompressed? )
;     $7ff and 2dup - 2+
;  ( packet size data ) ( R; uncompressed? )
;     blkbuf dup>r rswap dup b/buf blank
;  ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
;     editblk @
;  ( packet size data blkbuf editable? ) ( R; blkbuf uncompressed? )
;     if
;  ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
;         over 3c@ third 3c!
;         3+ rot 3- rot 3+ rot
;     then
;     rot 2- r>
;  ( packet data blkbuf size uncompressed? ) ( R; blkbuf )
;     if
;         cmove
;     else
;         rldecode
;     then
;    rfrom nip ;
;
#ifdef HEADERS
unpktlfa
    .byt $de,$ad
    .byt (_unpkt-*-1)|bit7
    .asc "UNPK","T"|bit7
#endif
_unpkt
#include "enter.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word zlt
#include "page.i65"
    .word writableq
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word twostar
#include "page.i65"
    .word zlt
#include "page.i65"
    .word tor
#include "page.i65"
    .word plit
    .word $7ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word duptor
#include "page.i65"
    .word rswap
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank
#include "page.i65"
    .word writableq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(unpkt01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word third
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word rot
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rot
#include "page.i65"
unpkt01
    .word rot
#include "page.i65"
    .word twominus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(unpkt02-*+1)
#include "pad.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt03-*+1)
#include "pad.i65"
unpkt02
    .word rldecode
#include "page.i65"
unpkt03
    .word rfrom
#include "page.i65"
    .word nip
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (BLOCK)   ( blk -- blkbuf new? )
;
; Retrieves or creates the VM block "blk" and returns the block
; buffer address.  If the block was created, "new?" is true
; flag is true if the block is new, false if it already exists
;
; New packets are created as data blocks (1024 zeroes) or as editor
; screens (3 bytes linewrap + 1000 spaces) if EDITMODE is set
;
;": (block)   ( blk -- blkbuf )
;     dup 1+ #vmpkt @  >  dup>r
; ( blk new? )
;     if
; ( blk )
;         #vmpkt @ - 0
; ( howmany junk )
;         begin
; ( howmany junk )
;             drop 1-
; ( howmany )
;             editmode @ pkt+
; ( howmany packet )
;             over 0<
;         until
; ( howmany packet )
;         nip
; ( howmany packet )
;     else
; ( blk )
;         >pkt
; ( packet )
;     then
; ( packet )
;     unpkt  r> ;
; ( blkbuf new? )
;
;#ifdef HEADERS
;pblocklfa
;    .byt $de,$ad
;    .byt (_pblock-*-1)|bit7|bit5
;    .asc "(BLOCK",")"|bit7
;    .byt 1
;#endif
_pblock
#include "enter.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word zero
#include "page.i65"
pblock01                        ; BEGIN
    .word drop
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word editingq
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word over
#include "page.i65"
    .word zlt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock02                        ; ELSE
    .word _topkt
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BLOCK   ( n -- addr )
;
#ifdef HEADERS
blocklfa
    .byt $de,$ad
    .byt (_block-*-1)|bit7
    .asc "BLOC","K"|bit7
#endif
_block
#include "enter.i65"
    .word _pblock
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;		DISC   ( -- )
;
; To start a disk session, insert a blank formatted disk and type
;
;  EMPTY-BUFFERS DISC
;
#ifdef HEADERS
disclfa
	.byt $de,$ad
	.byt (_disc-*-1)|bit7
	.asc "DIS","C"|bit7
#endif
_disc

;--------------------------------------------------------------
;
;		SAVE-BUFFERS   ( -- )
;
; Performs the equivalent of STOP-S in the editor
;
#ifdef HEADERS
savebufferslfa
	.byt $de,$ad
	.byt (_savebuffers-*-1)|bit7
	.asc "SAVE-BUFFER","S"|bit7
#endif
_savebuffers

;--------------------------------------------------------------
;
;        UPDATE   ( -- )
;
; Copies the block buffer to the packet buffer at BLK
;
#ifdef HEADERS
updatelfa
    .byt $de,$ad
    .byt (_update-*-1)|bit7
    .asc "UPDAT","E"|bit7
#endif
_update
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EMPTY-BUFFERS
;
; Unassign all virtual memory.  UPDATEed blocks are not written
; to mass storage.
;
;": empty-buffers   ( -- )
;     #vmpkt off blkbuf 2- dup off vmbuf ! ;
;
#ifdef HEADERS
emptybufferslfa
    .byt $de,$ad
    .byt (_emptybuffers-*-1)|bit7
    .asc "EMPTY-BUFFER","S"|bit7
#endif
_emptybuffers
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word exit


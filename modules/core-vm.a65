; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
;
;       WRAP!   ( d -- )
;
; Updates the linewrap table at $E0 to reflect the bits
; stored in d.  Since line 0 is *always* $80, never a continuation 
; line, only 24 bits are required, not 25.
;
;#ifdef HEADERS
;wrapstorelfa
;    .byt $de,$ad
;    .byt (wrapstore-*-1)|bit7|bit5
;    .asc "WRAP","!"|bit7
;    .byt 1
;#endif
wrapstore
    ldy #1
    jsr locals
    stx storex
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       B/BUF   ( -- n )
;
#ifdef HEADERS
bperbuflfa
    .byt $de,$ad
    .byt (bperbuf-*-1)|bit7
    .asc "B/BU","F"|bit7
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
;
;       B/SCR   ( -- n )
;
; Bytes per screen.  Not what it usually means in other Forths,
; (not blocks per screen = 1)
;
#ifdef HEADERS
bperscrlfa
    .byt $de,$ad
    .byt (bperscr-*-1)|bit7
    .asc "B/SC","R"|bit7
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
;
;       BLKBUF
;
; return the address of the block buffer
;
#ifdef HEADERS
blkbuflfa
    .byt $de,$ad
    .byt (_blkbuf-*-1)|bit7
    .asc "BLKBU","F"|bit7
#endif
_blkbuf
#include "enter.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;        UPDATE   ( -- )
;
; mark the current block as updated
;
#ifdef HEADERS
updatelfa
    .byt $de,$ad
    .byt (_update-*-1)|bit7
    .asc "UPDAT","E"|bit7
#endif
_update
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
;
; test cases -- 
; vvwwxxyyyzz
; xxyyzz
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
#ifdef SWEET16
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R10   ; input counter - when this hits zero, we're done
    .byt st | R11   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R10   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R11   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R10
    .byt sti | N1   ; write output stream
    .byt dcr | R11
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R10
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | R10
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R10              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R11
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt
#endif

;--------------------------------------------------------------
;
;       RLDECODE ( srcaddr targaddr srclen -- )
;
; decode length {srclen} bytes beginning at source address
; {srcaddr} to the target address (targaddr).
;
;       RLDECODE ( srcaddr targaddr srclen -- )
#ifdef HEADERS
rldecodelfa
    .byt $de,$ad
    .byt (rldecode-*-1)|bit7
    .asc "RLDECOD","E"|bit7
#endif
rldecode
#ifdef SWEET16
    ldy #2
    jsr locals
    brk
    .byt set | R9
    .word $100
rldecode01
    .byt ld | R9
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | R9
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt
#endif

;--------------------------------------------------------------
;
;       (BLOCK)   ( blk -- blkbuf new? )
;
; return the buffer address of block N. Create it if necessary.
; flag is true if the block is new, false if it already exists
;
; *** TRICK ALERT ***
; Uses the address on the return stack to determine if the caller 
; was the screen editor.  Then does an OR with $8000 (VIDRAM)
; on the packet length, setting the "editable" flag on the block.
;
; Any other caller creates a data block.
;
;": (block)   ( blk -- blkbuf )
;     #vmpkt @ over -
;                                 ( blk #vmpkt-blk )
;     dup 0>
;                                 ( blk #vmpkt-blk exists? )
;     if
;                                 ( blk #vmpkt-blk )
;         drop pkt@
;                                 ( packet )
;     else
;                                 ( blk #vmpkt-blk )
;         r@ usingeditor = >r
;                                 ( junk #vmpkt-blk ) ( R; editor? )
;         begin
;                                 ( packet #vmpkt-blk ) ( R; editor? )
;             swap drop 1+ r@
;                                 ( #vmpkt-blk+ editor? ) ( R; editor? )
;             pkt+
;                                 ( #vmpkt-blk+ packet ) ( R; editor? )
;             swap dup 0>
;                                 ( packet #vmpkt-blk+ enough? ) ( R; editor? )
;         until
;                                 ( packet #vmpkt-blk+ ) ( R; editor? )
;         r> 2drop
;                                 ( #vmpkt-blk+ )
;     then
;                                 ( packet )
;     unpkt ; 
;                                 ( blkbuf )
;
;#ifdef HEADERS
;pblocklfa
;    .byt $de,$ad
;    .byt (_pblock-*-1)|bit7|bit5
;    .asc "(BLOCK",")"|bit7
;    .byt 1
;#endif
_pblock
#include "enter.i65"
    .word numvmpkt
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _pktfetch
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock01                        ; ELSE
    .word rfetch
#include "page.i65"
    .word plit
    .word usingeditor
#include "pad.i65"
    .word eq
#include "page.i65"
    .word tor
#include "page.i65"
pblock02                        ; BEGIN
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word rfrom
#include "pad.i65"
    .word twodrop
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITABLE?   ( -- addr )
;
; Variable reflecting whether the current screen is text (true)
; or a data block (false)
;
;#ifdef HEADERS
;iseditablelfa
;    .byt $de,$ad
;    .byt (iseditable-*-1)|bit7|bit5
;    .asc "EDITABLE","?"|bit7
;    .byt 1
;#endif
iseditable
    jsr docreate
    .word 0

;--------------------------------------------------------------
;
;       BLOCK   ( n -- addr )
;
#ifdef HEADERS
blocklfa
    .byt $de,$ad
    .byt (_block-*-1)|bit7
    .asc "BLOC","K"|bit7
#endif
_block
#include "enter.i65"
    .word _pblock
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SCR@   ( scr -- )
;
; Locate or create the packet for this screen, set the current
; screen variable SCR, and display it with linewrap
;
;": scr@   ( scr -- )
;     dup scr ! (block)
;                               ( blkbuf )
;     editable? @
;                               ( blkbuf editable? )
;     if
;                               ( blkbuf )
;         dup 3c@ wrap!
;                               ( blkbuf )
;         3 +
;                               ( blkbuf+3 )
;     then
;                               ( blkbuf|blkbuf+3 )
;     vidram b/scr
;                               ( blkbuf $8000 1000 )
;     cmove ;
;
;#ifdef HEADERS
;scrfetchlfa
;    .byt $de,$ad
;    .byt (_scrfetch-*-1)|bit7|bit5
;    .asc "SCR","@"|bit7
;    .byt 1
;#endif
_scrfetch
#include "enter.i65"
    .word dup
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
usingeditor                     ; this address is tested for by (BLOCK) to see if it's the editor calling
    .word _pblock
#include "page.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(scrfetch01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
scrfetch01
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       UNPKT ( packet -- blkbuf )
;
; Given the address of a packet (its size/flags word, at the top)
; this will unpack the packet to the block buffer and return
; the address of the unpacked block. Distinguishes among 
; compressed/uncompressed and editable/uneditable packets
;
;#ifdef HEADERS
;unpktlfa
;    .byt $de,$ad
;    .byt (_unpkt-*-1)|bit7|bit5
;    .asc "UNPK","T"|bit7
;    .byt 1
;#endif
_unpkt
#ifdef SWEET16
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank                ; blank the block buffer
#include "page.i65"
    .word to6502
    brk                         ; ( packet blkbuf )
    .byt ld | TOS
    .byt st | R9                ; blkbuf
    .byt st | R10               ; "to"
    .byt pull
    .byt st | N0                ; packet address
    .byt ldd | TOS              ; get packet header
    .byt ext             
    .word pktheader16              ; get R11=packet length, N2=editable? N3=uncompressed? 
    .byt ld | N0
    .byt sub | R11              ; packet data
    .byt st | R13               ; "from" (don't use R12, it turns the packet into the Sweet16 return stack!)
    .byt ld | N2
    .byt bz , <(unpkt01-*-2)    ; data packet?
    .byt ldi | R13              ; copy 3 bytes of linewrap from packet
    .byt sti | R10
    .byt dcr | R11              ; subtract 3 from length
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
unpkt01                         ; start stacking it back up
    .byt ld | R9
    .byt st | TOS               ; blkbuf
    .byt ld | R13
    .byt push                   ; from
    .byt ld | R10
    .byt push                   ; to
    .byt ld | R11
    .byt push                   ; howmany
    .byt ld | N3
    .byt push                   ; uncompressed?
    .byt ld | N2
    .byt push                   ; editable?
    .byt rtn
#include "toforth.i65"
    .word iseditable
#include "page.i65"
    .word store
#include "page.i65"
    .word qbranch               ; IF
    .byt <(unpkt03-*+1)
#include "page.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt04-*+1)
#include "page.i65"
unpkt03                         ; ELSE
    .word rldecode
#include "page.i65"
unpkt04                         ; THEN
    .word exit
                                ; ( blkbuf )
#endif

;--------------------------------------------------------------
;
;       WRAP^   ( logline -- d )
;
; Reads (a portion of) the linewrap table above the current physical
; line (stored at $d8) up to but not including the current logical line.  
; Returns a right-aligned double with a copy of those high bit values
;
;#ifdef HEADERS
;wrapabovelfa
;    .byt $de,$ad
;    .byt (wrapabove-*-1)|bit7
;    .asc "WRAP",94|bit7
;#endif
wrapabove
    stx storex      ; preserve Forth data stack pointer
    ldx #0
    stx n+1
    stx n
    stx tos+1
    ldy tos         ; first physical line of this logical line
    stx tos
    tya
    beq wrapabove03
    sty n+2
    dex
wrapabove02
    inx
    cpx n+2         ; are we there yet?
    beq wrapabove03 ; leave if done
    lda $e0,x 
    asl             ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1         ; append the next high bit to the double
    beq wrapabove02 ; this should always take the branch
wrapabove03
    lda n
    ldy n+1         ; high half of the double is going on the stack
    ldx storex      ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
;
;       WRAP+   ( d 40|80 -- d flag )
;
; Shift and append one or two bits to the double.  Return nonzero
; once 25 bits have been stored.  40 = <<,1; 80 = <<,1 <<,0
;
;#ifdef HEADERS
;wrappluslfa
;    .byt $de,$ad
;    .byt (wrapplus-*-1)|bit7
;    .asc "WRAP","+"|bit7
;#endif
wrapplus
    sec             ; always shift in a 1
wrapplus01
    ldy stackh,x
    bne wrapplus03
    rol stackl+1,x  ; shift in a single bit
    rol stackh+1,x
    rol stackl,x
    rol stackh,x
    lda #40
    cmp tos
    sta tos         ; so we only do this once
    bcc wrapplus01  ; maybe shift in a 0 (if 80-column)
wrapplus03
    ldy stackh,x
    tya
    jmp put

;--------------------------------------------------------------
;
;       PKT@ ( n -- packet )
;
; Return the packet address of block n
;
;": pkt@   ( n -- packet )
;     blkbuf 2-
;     begin
;         over 0>
;     while
;         dup @
;         - swap 1- swap
;     repeat
;     swap drop ;
;
;#ifdef HEADERS
;pktfetchlfa
;    .byt $de,$ad
;    .byt (_pktfetch-*-1)|bit7
;    .asc "PKT","@"|bit7
;#endif
_pktfetch
#ifdef SWEET16
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word swap
#include "page.i65"
    .word to6502
    brk                         ; ( blkbuf blk )
    .byt ld | TOS
    .byt st | N0
    .byt pull
pktfetch01
    .byt popd | TOS
    .byt bz , <(pktfetch02-*-2)
    .byt dcr | N0
    .byt bm , <(pktfetch02-*-2)
    .byt ext
    .word pktheader16
    .byt ld | TOS
    .byt sub | R11
    .byt st | TOS
    .byt br , <(pktfetch01-*-2)
pktfetch02
    .byt rtn
#include "toforth.i65"
    .word exit
#endif

;--------------------------------------------------------------
;
;       PKT+ ( editable? -- packet )
;
; Append a new packet to the bottom of vmbuf, return its address
; flag = false for data packet, true for editor packet
;
;": pkt+   ( editable? -- packet )
;                                 ( editable? )
;     >r vmbuf @ 14 r@
;                                 ( vmbuf 14 editable? ) ( R; editable? )
;     if
;                                 ( vmbuf 14 ) ( R; editable? )
;         drop 5
;                                 ( vmbuf 5 ) ( R; editable? )
;     then
;                                 ( vmbuf 5 ) ( R; editable? )
;     2dup 2dup 2dup - over
;                                 ( vmbuf 5 vmbuf 5 vmbuf 5 vmbuf-5 5 ) ( R; flag )
;     erase
;                                 ( vmbuf 5 vmbuf 5 vmbuf 5 ; clear packet ) ( R; flag )
;     VIDRAM r@ and or swap
;                                 ( vmbuf 5 vmbuf 5 VIDRAM|5 vmbuf ) ( R; flag )
;     !
;                                 ( vmbuf 5 vmbuf 5 ; set packet length ) ( R; flag )
;     - dup vmbuf !
;                                 ( vmbuf 5 vmbuf-5 ; update vmbuf to point to new tail )
;     2+ r> tuck over ! 1+ !
;                                 ( vmbuf 5 ; set first three bytes of packet = flag )
;     #vmpkt 1+!
;                                 ( vmbuf 5 ; increment packet counter )
;     drop ;
;                                 ( vmbuf ; packet address )
;
;#ifdef HEADERS
;pktpluslfa
;    .byt $de,$ad
;    .byt (_pktplus-*-1)|bit7
;    .asc "PKT","+"|bit7
;#endif
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word qbranch
    .byt <(pktplus01-*+1)
#include "page.i65"
    .word drop
#include "page.i65"
    .word clit
    .byt 5
#include "pad.i65"
pktplus01
    .word twodup
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word over
#include "page.i65"
    .word _erase
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _tuck
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word store
#include "page.i65"
    .word numvmpkt
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrap^
;                                 ( blkbuf d )
;     rot dup >r
;                                 ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r
;                                 ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!
;                                 ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing
;                                 ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
;     r> swap
;                                 ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
;     rlencode
;                                 ( targend uncompressed? ) ( R; blkbuf )
;     over r> - >r
;                                 ( targend uncompressed? ) ( R; size )
;     r@ 2+ or vidram or swap !
;                                 ( ) ( R; size )
;     r> ;
;                                 ( size )
;
;#ifdef HEADERS
;mkpktlfa
;    .byt $de,$ad
;    .byt (_mkpkt-*-1)|bit7
;    .asc "MKPK","T"|bit7
;#endif
_mkpkt
#include "enter.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word wrapabove
#include "page.i65"
    .word rot
#include "page.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word _dashtrailing
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word tor
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word orx
#include "page.i65"
    .word vidram
#include "page.i65"
    .word orx
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit


;core-device.a65

;--------------------------------------------------------------
;
;       EMIT
;
; * 83 device
;
#ifdef HEADERS
emitlfa
    .byt $de,$ad
    .byt (emit-*-1)|bit7
    .asc "EMI","T"|bit7
#endif
emit
    jmp emitvector
emitvector
    ldy numout+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bne emit01
    iny
    clc
    lda (up),y
    adc #1
    sta (up),y
emit01
    lda tos
    jsr CHROUT
    jmp pops

;--------------------------------------------------------------
;
;       KEY
;
; * 83 device
;
#ifdef HEADERS
keylfa
    .byt $de,$ad
    .byt (key-*-1)|bit7
    .asc "KE","Y"|bit7
#endif
key
    stx storex
key01
    jsr GETIN
    beq key01
    ldx storex
    ldy #0
    jmp pushya

;--------------------------------------------------------------
;
;       ?TERMINAL   ( -- flag )
;
; true if stop key pressed
;
#ifdef HEADERS
qterminallfa
    .byt $de,$ad
    .byt (qterminal-*-1)|bit7
    .asc "?TERMINA","L"|bit7
#endif
qterminal
    ldy #0
    lda $9b
    cmp #$ef            ; check STOP key
    bne qterminal01
    dey
qterminal01
    tya
    jmp pushya

;--------------------------------------------------------------
;
;       CR
;
; * 83 device
;
#ifdef HEADERS
crlfa
    .byt $de,$ad
    .byt (cr-*-1)|bit7
    .asc "C","R"|bit7
#endif
cr
    jmp crvector
crvector
    lda #$0d
    jsr CHROUT
    lda #0
    ldy numout+3
    sta (up),y
    iny
    sta (up),y
    ldy numline+3
    clc
    lda (up),y
    adc #1
    sta (up),y
    bcc cr01
    iny
    lda (up),y
    adc #0
    sta (up),y
cr01
    jmp next

;--------------------------------------------------------------
;
;       B/BUF   ( -- n )
;
#ifdef HEADERS
bperbuflfa
    .byt $de,$ad
    .byt (bperbuf-*-1)|bit7
    .asc "B/BU","F"|bit7
#endif
bperbuf
    jsr doconst
    .word 1024

;--------------------------------------------------------------
;
;       B/SCR   ( -- n )
;
; Bytes per screen.  Not what it usually means in other Forths,
; (not blocks per screen = 1)
;
#ifdef HEADERS
bperscrlfa
    .byt $de,$ad
    .byt (bperscr-*-1)|bit7
    .asc "B/SC","R"|bit7
#endif
bperscr
    jsr doconst
    .word 1000

;--------------------------------------------------------------
;
;       VIDRAM   ( -- addr )
;
; address of PET video memory $8000
;
#ifdef HEADERS
vidramlfa
    .byt $de,$ad
    .byt (vidram-*-1)|bit7
    .asc "VIDRA","M"|bit7
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
;
;       MON    ( char base -- digit true | false )
;
; sets the BRK vector to either TIM or Sweet16
; (TIM exits to BASIC)
;~wut? this only works the first time
;
#ifdef HEADERS
monlfa
    .byt $de,$ad
    .byt (mon-*-1)|bit7
    .asc "MO","N"|bit7
#endif
mon
    jsr swapzp      ; restore BASIC zpage
sw16
    ldy #2
    lda brktoggle-1,y
    eor CBINV-1,y
    sta CBINV-1,y
    dey
    bne sw16+2
    brk
    .byt rtn
plover              ; if we get here, it's unimplemented
xyzzy
    jmp next        ; used as a breakpoint in secondaries

;--------------------------------------------------------------
;
;       SPACE
;
; * 83 device
;
#ifdef HEADERS
spacelfa
    .byt $de,$ad
    .byt (_space-*-1)|bit7
    .asc "SPAC","E"|bit7
#endif
_space
#include "enter.i65"
    .word bl
#include "page.i65"
    .word emit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SPACES
;
; * 83 device
;
#ifdef HEADERS
spaceslfa
    .byt $de,$ad
    .byt (_spaces-*-1)|bit7
    .asc "SPACE","S"|bit7
#endif
_spaces
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(spaces02-*+1)
#include "pad.i65"
spaces01
    .word _space
#include "page.i65"
    .word ploop
    .byt <(spaces01-*+1)
#include "pad.i65"
spaces02
    .word exit

;--------------------------------------------------------------
;
;       JIFFY@   ( --  djiffyclock )
;
; returns number of jiffies since powerup or midnight as a double
;
;jiffyfetch
;    sei
;    jsr slip
;    lda TIME+2
;    sta tos
;    lda TIME+1
;    sta tos+1
;    ldy #0
;    lda TIME
;    cli
;    jmp pushya ; [20]
;
#ifdef HEADERS
jiffyfetchlfa
    .byt $de,$ad
    .byt (_jiffyfetch-*-1)|bit7
    .asc "JIFFY","@"|bit7
#endif
_jiffyfetch
#include "enter.i65"
    .word irqflip
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word irqflip
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
;
;       CMDOFF
;
#ifdef HEADERS
cmdofflfa
    .byt $de,$ad
    .byt (cmdoff-*-1)|bit7
    .asc "CMDOF","F"|bit7
#endif
cmdoff
    stx storex
    jsr CLRCHN
    ldx storex
    jmp next

;--------------------------------------------------------------
;
;       (.")   ( -- )
;
; * headerless
;
; types the inline counted string from the dictionary and moves IP
; to just after the string, paging if necessary
;
;#ifdef HEADERS
;pdqlfa
;    .byt $de,$ad
;    .byt (_pdq-*-1)|bit7
;    .asc "(.",'"',")"|bit7
;#endif
_pdq
#include "enter.i65"
    .word rfrom             ; ( cstring-2 )
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word type
#include "page.i65"
    .word plus
#include "page.i65"
    .word to6502
skipinline
    lda tos+1
    sta ip+1
    lda tos
    sta ip
    jsr slide
    lda #0
    jmp pad

;--------------------------------------------------------------
;
;       .S ( -- )
;
; Output the data stack
#ifdef HEADERS
dotslfa
    .byt $de,$ad
    .byt (_dots-*-1)|bit7
    .asc ".","S"|bit7
#endif
_dots
#include "enter.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word _pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit

;--------------------------------------------------------------
;
;       EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.
#ifdef HEADERS
expectlfa
    .byt $de,$ad
    .byt (expect-*-1)|bit7
    .asc "EXPEC","T"|bit7
#endif
expect
    jmp expectvector
expectvector
    ldy #1
    jsr locals
    stx storex
    dey
expect01
    iny
    cpy tos
    bcs expect02
    jsr CHRIN
    cmp #$0d
    beq expect02
    sta (n),y
    bne expect01
expect02
    tya
    ldy span+3
    sta (up),y
    iny
    lda #0
    sta (up),y
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       BLKBUF
;
; return the address of the block buffer (usu. $7C00 on a 32K PET)
;
#ifdef HEADERS
blkbuflfa
    .byt $de,$ad
    .byt (_blkbuf-*-1)|bit7
    .asc "BLKBU","F"|bit7
#endif
_blkbuf
#include "enter.i65"
    .word memsiz
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;        UPDATE   ( -- )
;
; mark the current block as updated
;
#ifdef HEADERS
updatelfa
    .byt $de,$ad
    .byt (_update-*-1)|bit7
    .asc "UPDAT","E"|bit7
#endif
_update
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EMPTY-BUFFERS
;
; Unassign all virtual memory.  UPDATEed blocks are not written
; to mass storage.
;
;": empty-buffers   ( -- )
;     vmsiz off blkbuf 2- dup off vmbuf ! ;
;
#ifdef HEADERS
emptybufferslfa
    .byt $de,$ad
    .byt (_emptybuffers-*-1)|bit7
    .asc "EMPTY-BUFFER","S"|bit7
#endif
_emptybuffers
#include "enter.i65"
    .word vmsiz
#include "page.i65"
    .word off
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
;
; test cases -- 
; vvwwxxyyyzz
; xxyyzz
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R10   ; input counter - when this hits zero, we're done
    .byt st | R11   ; out counter - when this goes negative, we're in negative compression

    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr
                    ; ( srclen targaddr srcaddr )

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R10   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R11   ; are we in the red?
    .byt bm , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R10
    .byt sti | N1   ; write output stream
    .byt dcr | R11
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R10
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0                ; get from input stream
    .byt dcr | R10
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R10              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R11
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       RLDECODE ( srcaddr targaddr srclen -- )
;
; decode length {srclen} bytes beginning at source address
; {srcaddr} to the target address (targaddr).
;
;       RLDECODE ( srcaddr targaddr srclen -- )
#ifdef HEADERS
rldecodelfa
    .byt $de,$ad
    .byt (rldecode-*-1)|bit7
    .asc "RLDECOD","E"|bit7
#endif
rldecode
    ldy #2
    jsr locals
    brk
    .byt set | R9
    .word $100
rldecode01
    .byt ld | R9
    .byt st | N2        ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; read source stream
    .byt sti | N1       ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2)    ; different? go get more
rldecode03
    .byt dcr | TOS      ; decrement source counter
    .byt ldi | N0       ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | R9
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1       ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull           ; drop srclen
    .byt nxt

;--------------------------------------------------------------
;
;       BLOCK   ( n -- addr )
;
#ifdef HEADERS
blocklfa
    .byt $de,$ad
    .byt (_block-*-1)|bit7
    .asc "BLOC","K"|bit7
#endif
_block
#include "enter.i65"
    .word _block
#include "page.i65"
    .word exit


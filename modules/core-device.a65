; core-device.a65
#echo .       core-device.a65           I/O 

;--------------------------------------------------------------
;
;       SPACE
;
; * 83 device
;
#ifdef HEADERS
spacelfa
    .byt $de,$ad
    .byt (_space-*-1)|bit7
    .asc "SPAC","E"|bit7
#endif
_space
#include "enter.i65"
    .word bl
#include "page.i65"
    .word emit
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SPACES
;
; * 83 device
;
#ifdef HEADERS
spaceslfa
    .byt $de,$ad
    .byt (_spaces-*-1)|bit7
    .asc "SPACE","S"|bit7
#endif
_spaces
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _max
#include "page.i65"
    .word zero
#include "page.i65"
    .word pqdo
    .byt <(spaces02-*+1)
#include "pad.i65"
spaces01
    .word _space
#include "page.i65"
    .word ploop
    .byt <(spaces01-*+1)
#include "pad.i65"
spaces02
    .word exit

;--------------------------------------------------------------
;
;       COUNT   ( addr1 -- addr2 n1 )
;
; * 83 nucleus
;
; Leaves the address, addr2 and the character
; count +n of text beginning at addr1.
; addr2 is addr1+1 and n1 is the length of the
; counted string at addr1.  The byte at addr1 con-
; tains the byte count +n.  Range of +n is
; {0...255}.
#ifdef HEADERS
countlfa
    .byt $de,$ad
    .byt (count-*-1)|bit7
    .asc "COUN","T"|bit7
#endif
count
    ldy #0
    lda (tos),y
    inc tos
    bne count01
    inc tos+1
count01         jmp pushya

;--------------------------------------------------------------
;
;       TYPE   ( addr count -- )
;
; * 83 device
;
#ifdef HEADERS
typelfa
    .byt $de,$ad
    .byt (type-*-1)|bit7
    .asc "TYP","E"|bit7
#endif
type
    ldy #1
    jsr locals
    clc
    lda tos
    ldy numout+3
    adc (up),y
    sta (up),y
    iny
    lda tos+1
    adc (up),y
    sta (up),y
    ldy #0
type01
    cpy tos
    bne type02
    dec tos+1
    bpl type02
    jmp pops
type02
    lda (n),y
    jsr CHROUT
    iny
    bne type01
    inc n+1
    bne type01

;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
#ifdef HEADERS
dashtrailinglfa
    .byt $de,$ad
    .byt (dashtrailing-*-1)|bit7
    .asc "-TRAILIN","G"|bit7
#endif
dashtrailing
    brk
    .byt ld | TOS
    .byt st | N1
    .byt pull
    .byt add | N1
    .byt st | N0
    .byt ext
    .word dashtrailing16
    .byt ld | N0
    .byt sub | TOS
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       (.")   ( -- )
;
; * headerless
;
; types the inline counted string from the dictionary and moves IP
; to just after the string, paging if necessary
;
;#ifdef HEADERS
;pdqlfa
;    .byt $de,$ad
;    .byt (_pdq-*-1)|bit7
;    .asc "(.",'"',")"|bit7
;#endif
_pdq
#include "enter.i65"
    .word rfrom             ; ( cstring-2 )
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word count
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word type
#include "page.i65"
    .word plus
#include "page.i65"
    .word to6502
skipinline
    lda tos+1
    sta ip+1
    lda tos
    sta ip
    jsr slide
    lda #0
    jmp pad

;--------------------------------------------------------------
;
;       .S ( -- )
;
; Output the data stack
#ifdef HEADERS
dotslfa
    .byt $de,$ad
    .byt (_dots-*-1)|bit7
    .asc ".","S"|bit7
#endif
_dots
#include "enter.i65"
    .word depth
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(dots02-*+1)
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
dots01
    .word depth
#include "page.i65"
    .word i
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word pick
#include "page.i65"
    .word clit
    .byt 7
#include "pad.i65"
    .word _udotr
#include "page.i65"
    .word _space
#include "page.i65"
    .word ploop
    .byt <(dots01-*+1)
#include "pad.i65"
    .word branch
    .byt <(dots03-*+1)
#include "pad.i65"
dots02
    .word _pdq
    .byt dots04-*-1
    .asc "STACK EMPTY"
dots04
#include "pad.i65"
dots03
    .word exit


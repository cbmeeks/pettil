; pettil-outer.a65
#echo .       pettil-outer.a65          Outer Interpreter

;--------------------------------------------------------------
;
; Tables used by Pearson hash function and Bloom filter for root
; vocabulary.  The Pearson hash is used by hash1 to evenly distribute
; words among the multiple threads of the dictionary. The Bloom
; filter lets us skip looking for things that we know aren't in
; the dictionary (e.g. numbers).  For now, keep bloom and lfalist
; consecutive in memory, with bloom first so RETHREAD won't break
bloom
;    .dsb 8,$b1      ; 64-bit, used by hash2 (bloom filter)
bloomx

lfalist
;    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
;    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
    ; heads of link threads for root vocabulary


;==============================================================
;==== Error messages                                       ====
;==============================================================
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08

msg01
    .byt msg02-*-1
    .asc "STACK EMPTY"
msg02   
    .byt msg03-*-1
    .asc "STACK FULL"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09


;--------------------------------------------------------------
;
;       INTERPRET
;
; tdict
;
;
;": interpret   ( )
;       begin   ?stack
;               exists?
;               if      link>
;                       execute
;               else    number dpl @ 1+ 0=
;                       if      drop
;                       then
;               then
;               false
;               quit?
;       again ;
;
#ifdef HEADERS
interpretlfa
    .byt $de,$ad
    .byt (_interpret-*-1)|bit7
    .asc "INTERPRE","T"|bit7
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack            ; ( )
#include "page.i65"
    .word _existsq          ; ( addr flag )
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word execute
#include "page.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(interpret03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
interpret03
    .word false
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORTH
;
; * 83 interpreter tdict
;
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
#ifdef HEADERS
forthlfa
    .byt $de,$ad
    .byt (forth-*-1)|bit7
    .asc "FORT","H"|bit7
#endif
forth
    jsr vocabdoes
    .word 0                 ; flag as root vocabulary
    .byt 1|bit7
    .byt ' '|bit7           ; $a081
lastvoc
    .word 0                 ; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;       DEFINITIONS
;
; * 83 interpreter tdict
;
#ifdef HEADERS
definitionslfa
  .byt $de,$ad
    .byt (_definitions-*-1)|bit7
    .asc "DEFINITION","S"|bit7
#endif
_definitions
#include "enter.i65"
    .word context
#include "page.i65"
    .word fetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (
;
; * 83 interpreter tdict
;
#ifdef HEADERS
lparenlfa
    .byt $de,$ad
    .byt (_lparen-*-1)|bit7
    .asc "("|bit7
#endif
_lparen
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT
;
; * 83 interpreter tdict
;
#ifdef HEADERS
abortlfa
    .byt $de,$ad
    .byt (_abort-*-1)|bit7
    .asc "ABOR","T"|bit7
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _quit
#include "page.i65"
    .word exit      ; make the decompiler happy

;--------------------------------------------------------------
;
;       QUIT
;
; tdict
;
;"This is the infinite outer interpreter loop:
;       - resets the return stack (RP!)
;       - outputs a carriage return (CR)
;       - waits for a line of user input (QUERY)
;       - interprets that line
; * 83 interpreter outer
;
#ifdef HEADERS
quitlfa
    .byt $de,$ad
    .byt (_quit-*-1)|bit7
    .asc "QUI","T"|bit7
#endif
_quit
#include "enter.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _lbracket         ; STATE OFF
#include "page.i65"
quit01                                  ; BEGIN
    .word rpstore
#include "page.i65"
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       '   ( -- cfa )
;
; * 83 interpreter tdict
;
; scans ahead in the input stream for the next word and finds
; it in the dictionary, else ABORT" NOT FOUND"
;
#ifdef HEADERS
ticklfa
    .byt $de,$ad
    .byt (_tick-*-1)|bit7
    .asc "'"|bit7
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qfind
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       QUERY
;
; tdict
;
#ifdef HEADERS
querylfa
    .byt $de,$ad
    .byt (_query-*-1)|bit7
    .asc "QUER","Y"|bit7
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; tdict
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table 
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?         (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$3f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
; DEBUG
;    jsr debug               ; print out some entertainment
; /DEBUG
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya

;DEBUG
; hex dump the byte in A
;debug
;    pha
;    pha
;    and #$0f
;    jsr print
;    pla
;    lsr
;    lsr
;    lsr
;    lsr
;    jsr print
;    pla
;dbout
;    rts
;print
;    sed
;    cmp #10
;    adc #'0'
;    cld
;    jmp CHROUT
; ;/DEBUG

;--------------------------------------------------------------
;
;       DHASH@   ( hashkey -- LFA )
;
; tdict
;
; retrieve the head of this hash thread
;
;#ifdef HEADERS
;dhashfetchlfa
;  .byt $de,$ad
;    .byt (dhashfetch-*-1)|bit7
;    .asc "DHASH","@"|bit7
;#endif
dhashfetch
    brk
    .byt set  | ACC
    .word lfalist
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | TOS
    .byt ldd  | TOS
    .byt st   | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       BLOOM!   ( hash -- )
;
; tdict
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;#ifdef HEADERS
;bloomstorelfa
;  .byt $de,$ad
;    .byt (bloomstore-*-1)|bit7
;    .asc "BLOOM","!"|bit7
;#endif
bloomstore
    lda tos                 ; set bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
;    and #(bloomx-bloom-1)   ; don't write outside filter area  ~wut?
    and #7   ; don't write outside filter area
    tay
    lda n
    ora bloom,y
    sta bloom,y
    jmp pops

;--------------------------------------------------------------
;
;       BLOOM@   ( hash -- flag )
;
; tdict
;
; test a bit in the filter
; hash indexes a single bit in the bloom filter
; input value is in the range 0-63, representing which bit to test
;
; flag values
; false = it can't be in there (bit was clear)
; true = it might be in there (bit was set)
;#ifdef HEADERS
;bloomfetchlfa
;    .byt $de,$ad
;    .byt (bloomfetch-*-1)|bit7
;    .asc "BLOOM","@"|bit7
;#endif
bloomfetch
    lda tos                 ; read bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
;    and #(bloomx-bloom-1)   ; don't write outside filter area  ~wut?
    and #7   ; don't write outside filter area
    tay
    lda bloom,y
    ldy #0
    and n
    beq bloomfetch01
    dey
bloomfetch01
    tya
    jmp put

;--------------------------------------------------------------
;
;       DHASH!   ( LFAnew hash1 -- )
;
; tdict
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
; sweet16 saved 51 bytes vs. 6502
;#ifdef HEADERS
;dhashstorelfa
;    .byt $de,$ad
;    .byt (dhashstore-*-1)|bit7
;    .asc "DHASH","!"|bit7
;#endif
dhashstore
    ldy #1
    jsr locals               ; LFAnew -> N0
    brk
    .byt set  | R11
    .word lfalist
    .byt sub  | ACC
    .byt st   | N2          ; 0 -> N2
    .byt ld   | R11
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | R11         ; R11+hash1*2 -> R11
    .byt ldd  | R11
    .byt popd | R11         ; back up the pointer
    .byt bnz, <(dhashstore01-*-2)
    .byt set  | ACC
    .word 0 ; was rootlfa  ~wut?
    .byt std  | R11
    .byt popd | R11
dhashstore01
    .byt st   | N1          ; head -> N1
    .byt rtn
    ldy #2
    lda (n),y
    and #$1f
    sta n+7                 ; length of name being inserted
dhashstore02
    lda (n+2),y
    and #$1f
    sta n+6
    lda n+7
    cmp n+6                 ; compare lengths
    bcc dhashstore05
    bne dhashstore04
    ;sec
    adc #1
    tay                     ; last char in names
dhashstore03
    lda (n),y
    eor (n+2),y
    asl                     ; compare char ignoring bit7
    bne dhashstore04
    dey
    cpy #2
    bne dhashstore03        ; stop at first char
    dey
    brk
    .byt set  | ACC
    .byt $de,$ad
    .byt std  | N1
    .byt rtn
dhashstore04
    brk
    .byt ld   | N1
    .byt st   | N2          ; keep track of where we've just been
    .byt ldd  | N1
    .byt st   | N1          ; (N1) -> N1
    .byt rtn
    ldy #2
    bne dhashstore02
dhashstore05
    brk
    .byt ld   | N2
    .byt bnz, <(dhashstore06-*-2)
    .byt ld   | R11         ; empty list, insert at the head
    .byt st   | N2          ; head -> N2
dhashstore06
    .byt ld   | N0
    .byt std  | N2          ; N0 -> (N2)
    .byt ld   | N1
    .byt std  | N0          ; N1 -> (N0)
    .byt pull               ; drop the hash
    .byt nxt

;--------------------------------------------------------------
;
;       (FIND)   ( name nfa fflag -- name false | cfa flag )
;
; * outer interpreter 
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the list
; fflag is the type of search we are doing
;	0 = corelist - names are in ascending order by size
;	1 = newlist - names are random sizes, with a 0-length name to terminate
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
#ifdef HEADERS
pfindlfa
    .byt $de,$ad
    .byt (pfind-*-1)|bit7
    .asc "(FIND",")"|bit7
#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"                    ; ( name )
    .word context           ; ( name context )
#include "page.i65"
    .word fetch             ; ( name vocabulary )
#include "page.i65"
    .word fetch             ; ( name LFA|0 )
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"                      ; ( name LFA )
    .word clit
    .byt 7
#include "pad.i65"
    .word fail              ; vocabularies unimplemented
#include "page.i65"
find01                                  ; ( name )
    .word dup               ; ( name name )
#include "page.i65"
    .word dhash             ; ( name hash1 hash2 )
#include "page.i65"
    .word bloomfetch        ; ( name hash1 flag )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(find02-*+1)
#include "pad.i65"
    .word dhashfetch        ; ( name LFA )
#include "page.i65"
    .word swap              ; ( LFA name )
#include "page.i65"
    .word twominus          ; ( LFA name-2 )
#include "page.i65"
    .word swap              ; ( name-2 LFA )
#include "page.i65"
    .word pfind             ; ( addr flag )
#include "page.i65"
    .word qdup              ; ( addr flag flag | addr 0 )
#include "page.i65"
    .word zeq               ; ( addr flag 0 | name-2 true )
#include "page.i65"
    .word qbranch           ; found? exit
    .byt <(find03-*+1)
#include "pad.i65"
    ; bloom filter false positive
    .word twoplus           ; ( name )
#include "page.i65"
    .word false             ; ( name false )
#include "page.i65"
    .word branch
    .byt <(find03-*+1)
#include "pad.i65"
find02                                  ; ELSE
    ; bloom filter negative
    ; ( name hash1 )
    .word drop              ; ( name )
#include "page.i65"
    .word false             ; ( here false )
#include "page.i65"
find03                                  ; THEN
    .word exit              ; ( addr flag )

;--------------------------------------------------------------
;
;       EXISTS?   ( -- addr flag )
;
; tdict
;
; scans ahead in the input stream for the next blank-delimited word,
; and returns either
#ifdef HEADERS
existsqlfa
    .byt $de,$ad
    .byt (_existsq-*-1)|bit7
    .asc "EXISTS","?"|bit7
#endif
_existsq
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find             ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit
;--------------------------------------------------------------
;
;		>SYMS   ( -- addr )
;
; returns the address of the symbol portion of the symbol table
;
#ifdef HEADERS
tosymslfa
	.byt $de,$ad
	.byt (_tosyms-*-1)|bit7
	.asc ">SYM","S"|bit7
#endif
_tosyms
#include "enter.i65"
	.word symtab
#include "page.i65"
	.word fetch
#include "page.i65"
	.word clit
	.byt 42
#include "page.i65"
	.word plus
#include "page.i65"
	.word exit

;--------------------------------------------------------------
;
;        SYMSIZ   ( -- n )
;
; returns the size of the symbol table
;
#ifdef HEADERS
symsizlfa
	.byt $de,$ad
	.byt (_symsiz-*-1)|bit7
	.asc "SYMSI","Z"|bit7
#endif
_symsiz
#include "enter.i65"
	.word _tosyms
#include "page.i65"
	.word dup
#include "page.i65"
symsiz01
	.word oneplus
#include "page.i65"
	.word dup
#include "page.i65"
	.word cfetch
#include "page.i65"
	.word zeq
#include "page.i65"
	.word qbranch
	.byt <(symsiz01-*+1)
#include "pad.i65"
	.word swap
#include "page.i65"
	.word minus
#include "page.i65"
	.word exit

;--------------------------------------------------------------
;
;		(REHASH)   ( symbols symdex pad hashnow here -- )
;
; make a pass through pad, calculating hashes for each word.
; copy it to symtab iff
; * the cfa of the word at PAD is < HERE or > SYMTAB
; * the length of the word = i
; * the hash1 of the word = j
; and while we're at it, set the bloom filter bit
;
;#ifdef HEADERS
;prehashlfa
;	.byt $de,$ad
;	.byt (prehash-*-1)|bit7
;	.asc "(REHASH",")"|bit7
;#endif
prehash
	ldy #5			; TOS       N0     N1  N2   N3    R9      R2
	jsr locals 		; here symbols symdex pad hash tdict thislen 
	brk
nextsym
	.byt ldd | N0				; get CFA
	.byt cpr | TOS				; compare to HERE
	.byt bnc , <(seemsok-*-2)	; cfa < here?  we're good!
	.byt cpr | R9				; well how about compare to threadindex?
	.byt bp , <(seemsok-*-2)	; cfa is in high dictionary?  we're good!
notverygood
	.byt ext
	.word wordlen16
	.byt bz , <(weredone-*-2)
nexthop
	.byt set | ACC
	.word 3
	.byt add | R11
	.byt add | N1
	.byt st | N1
	.byt br , <(nextsym-*-2)
seemsok
	.byt ext
	.word wordlen16
	.byt bz , <(weredone-*-2)
	.byt ld | R11
	.byt cpr | R2			; check the length
	.byt bnz , <(nexthop-*-2)
	.byt ext
	.word dhash16
	.byt ld | R11
	.byt cpr | N2
	.byt bnz , <(nexthop-*-2)
	
weredone
	.byt pull
	.byt rtn

;--------------------------------------------------------------
;
;        REHASH   ( -- )
;
; rebuilds the symbol table in high memory.
;
#ifdef HEADERS
rehashlfa
    .byt $de,$ad
    .byt (_rehash-*-1)|bit7
    .asc "REHAS","H"|bit7
#endif
_rehash
#include "enter.i65"
	.word symtab				; ( addr )
#include "page.i65"
	.word fetch					; ( symtab )
#include "page.i65"
	.word clit
	.byt 42						; ( symtab 42 )
#include "pad.i65"
	.word _erase				; ( )
#include "pad.i65"
	.word _tosyms				; ( symbols )
#include "page.i65"
	.word duptor				; ( symbols ) ( R; symbols )
#include "page.i65"
	.word _pad					; ( symbols pad )
#include "page.i65"
	.word _symsiz				; ( symbols pad size )
#include "page.i65"
    .word cmove					; ( ) ( R; symbols )
#include "page.i65"
	.word rfrom					; ( symbols ) 
#include "page.i65"
	.word symtab				; ( symbols addr ) 
#include "page.i65"
	.word fetch					; ( symbols symtab )
#include "page.i65"
	.word clit					; ( symbols symtab 8 )
	.byt 8
#include "page.i65"
	.word plus					; ( symbols symdex )
#include "page.i65"
	.word _twodup			    ; ( symbols symdex symbols symdex )
#include "page.i65"
	.word _pad					; ( symbols symdex symbols symdex pad )
#include "page.i65"
    .word clit					; ( symbols symdex pad 16 )
    .byt 16
#include "pad.i65"
    .word zero					; ( symbols symdex pad 16 0 )
#include "page.i65"
    .word pdo					; ( symbols symdex pad )
#include "page.i65"
rehash01
#include "page.i65"
    .word i						; ( symbols symdex pad hashnow )
#include "page.i65"
	.word twoover				; ( symbols symdex pad hashnow symbols symdex )
#include "page.i65"
	.word store					; ( symbols symdex pad hashnow )
#include "page.i65"
	.word twoswap				; ( pad hashnow symbols symdex )
#include "page.i65"
	.word twoplus				; ( pad hashnow symbols symdex )
#include "page.i65"
	.word twoswap				; ( symbols symdex pad hashnow )
#include "page.i65"
    .word clit					; ( symbols symdex pad hashnow 32 )
    .byt 32
#include "pad.i65"
    .word one					; ( symbols symdex pad hashnow 32 1 )
#include "page.i65"
    .word pdo					; ( symbols symdex pad hashnow )
#include "page.i65"
rehash02
    .word here					; ( symbols symdex pad hashnow here )
#include "page.i65"
    .word tdict
#include "page.i65"
    .word fetch
#include "page.i65"
    .word prehash
#include "page.i65"
    .word ploop
    .byt <(rehash02-*+1)
#include "pad.i65"
    .word ploop
    .byt <(rehash01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORGET   ( -- )
;
;	( cfa -- ; special COLD mode - does not scan input )
;
; * 83 interpreter
;
; checks FENCE, moves DP, sorts symbol table
;
#ifdef HEADERS
forgetlfa
    .byt $de,$ad
    .byt (_forget-*-1)|bit7
    .asc "FORGE","T"|bit7
#endif
_forget
#include "enter.i65"
	.word rfetch				; ( cfa caller )
#include "page.i65"
	.word plit
	.word launch01				; ( cfa caller launch01 )
#include "pad.i65"
	.word eq					; ( cfa iscold? )
#include "page.i65"
	.word qbranch				; ( cfa )
	.byt <(forget01-*+1)
#include "pad.i65"
	.word plit
	.word errptr			; We got here from COLD. Do the things 
#include "pad.i65"			; COLD didn't know how to do.  Don't scan
	.word errmess			; input stream for the next word, because
#include "page.i65"			; there's a CFA on the stack already.
	.word store
#include "page.i65"
	.word branch
	.byt <(forget02-*+1)
#include "pad.i65"
forget01
	.word _tick
#include "page.i65"
forget02
	.word dup
#include "page.i65"
	.word fence
#include "page.i65"
	.word fetch
#include "page.i65"
	.word ult
#include "page.i65"
	.word qbranch
	.byt <(forget03-*+1)
#include "pad.i65"
	.word clit
	.byt 7
#include "pad.i65"
	.word fail					; CAN'T FORGET BELOW FENCE
#include "page.i65"
forget03
	.word dp
#include "page.i65"
	.word store
#include "page.i65"
	.word _rehash
#include "page.i65"
    .word exit



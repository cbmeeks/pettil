;pettil-outer.a65


;--------------------------------------------------------------
pearson
    .byt 150,191,252,0,194,202,129,7
pearsonx

;--------------------------------------------------------------
;
; Tables used by Pearson hash function and Bloom filter for root
; vocabulary.  The Pearson hash is used by hash1 to evenly distribute
; words among the multiple threads of the dictionary. The Bloom
; filter lets us skip looking for things that we know aren't in
; the dictionary (e.g. numbers).  For now, keep bloom and lfalist
; consecutive in memory, with bloom first so RETHREAD won't break
bloom
;    .dsb 8,$b1      ; 64-bit, used by hash2 (bloom filter)
bloomx

lfalist
;    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
;    .word $efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe,$efbe
    ; heads of link threads for root vocabulary


;==============================================================
;==== Error messages                                       ====
;==============================================================
errptr
    .word msg01,msg02,msg03,msg04,msg05,msg06,msg07,msg08

msg01
    .byt msg02-*-1
    .asc "STACK EMPTY"
msg02   
    .byt msg03-*-1
    .asc "STACK FULL"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "DEFINITION UNFINISHED"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09


;--------------------------------------------------------------
;
;       ALLOT
;
; * 83 compiler tdict
;
#ifdef HEADERS
allotlfa
    .byt $de,$ad
    .byt (_allot-*-1)|bit7
    .asc "ALLO","T"|bit7
#endif
_allot
#include "enter.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,   ( w -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
commalfa
    .byt $de,$ad
    .byt (_comma-*-1)|bit7
    .asc ","|bit7
#endif
_comma
#include "enter.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler tdict
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,$   ( ?? -- ?? )
;
; compiler tdict
;
#ifdef HEADERS
commadollarlfa
    .byt $de,$ad
    .byt (_commadollar-*-1)|bit7
    .asc ",","$"|bit7
#endif
_commadollar
#include "enter.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word here
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       HERELSB   ( -- c )
;
; Returns the least significant byte of DP
;
; tdict
;
;#ifdef HEADERS
;herelsblfa
;    .byt $de,$ad
;    .byt (_herelsb-*-1)|bit7
;    .asc "HERELS","B"|bit7
;#endif
_herelsb
#include "enter.i65"
    .word dp
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; create the code field of a new definition, taking page alignment
; into account.
;
; compiler tdict
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ,XT   ( xt -- )
;
; encloses the execution token into the dictionary, paying heed
; to PETTIL's requirement that XTs must be page-aligned and that
; secondaries are responsible for invoking 'page' to cross a page
; boundary
;
; compiler tdict
;
;": ,xt   ( xt -- )
;     herelsb $fc >
;     if
;         ['] page ,
;         herelsb
;         if
;             dp 1+!
;         then
;     then
;     , ;
;
;#ifdef HEADERS
;commaxtlfa
;    .byt $de,$ad
;    .byt (_commaxt-*-1)|bit7
;    .asc ",X","T"|bit7
;#endif
_commaxt
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _herelsb
#include "page.i65"
    .word qbranch
    .byt <(commaxt01-*+1)
#include "page.i65"
    .word dp
#include "pad.i65"
    .word oneplusstore
#include "page.i65"
commaxt01
    .word exit

;--------------------------------------------------------------
;
;       CREATE
;
; * 83 compiler tdict
;
; A defining word executed in the form
;     CREATE <name>                 
;     Creates a dictionary entry for <name>.  After <name> is
;     created, the next available dictionary location is the first
;     byte of <name>'s parameter field.  When <name> is
;     subsequently executed, the address of the first byte of
;     <name>'s parameter field is left on the stack.  CREATE does
;     not allocate space in <name>'s parameter field.
;
;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa ) 
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )                               
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )
#ifdef HEADERS
createlfa
    .byt $de,$ad
    .byt (_create-*-1)|bit7
    .asc "CREAT","E"|bit7
#endif
_create
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word bl                    ; ( bl )
#include "page.i65"
    .word _word                 ; ( nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa )
#include "page.i65"
    .word dup                   ; ( nfa nfa nfa )
#include "page.i65"
    .word _find                 ; ( nfa nfa addr2 flag )
#include "page.i65"
    .word swap                  ; ( nfa nfa flag addr2 )
#include "page.i65"
    .word drop                  ; ( nfa nfa flag )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(create03-*+1)
#include "pad.i65"
    .word clit                  ; ( nfa cfa $12 )
    .byt RVSON
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word over                  ; ( nfa cfa nfa )
#include "page.i65"
    .word count                 ; ( nfa cfa addr+1 len )
#include "page.i65"
    .word type                  ; ( nfa cfa )
#include "page.i65"
    .word clit
    .byt RVSOFF                 ; ( nfa cfa $92 )
#include "pad.i65"
    .word emit                  ; ( nfa cfa )
#include "page.i65"
    .word _pdq
    .byt create02-*-1
    .asc    " EXISTS"           ; ( nfa cfa )
create02
#include "pad.i65"              ; ( nfa addr )
create03                        ; THEN
    .word drop                  ; ( nfa )
#include "page.i65"
    .word tor                   ; ( ) ( R; nfa )
#include "page.i65"
    .word clit                  ; ( $80 )
    .byt $80
#include "page.i65"
    .word rfetch                ; ( $80 nfa ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word _twodup               ; ( $80 len $80 len ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( $80 len len|bit7 ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len len|bit7 nfa ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( $80 len ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( $80 len nfa ) ( R; nfa )
#include "page.i65"
    .word plus                  ; ( $80 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word dup                   ; ( $80 cfa-1 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cfetch                ; ( $80 cfa-1 last ) ( R; nfa )
#include "page.i65"
    .word rot                   ; ( cfa-1 last $80 ) ( R; nfa )
#include "page.i65"
    .word orx                   ; ( cfa-1 last|bit7 ) ( R; nfa )
#include "page.i65"
    .word over                  ; ( cfa-1 last|bit7 cfa-1 ) ( R; nfa )
#include "page.i65"
    .word cstore                ; ( cfa-1 ) ( R; nfa )
#include "page.i65"
    .word oneplus               ; ( cfa ) ( R; nfa )
#include "page.i65"
    .word dp                    ; ( cfa dp ) ( R; nfa )
#include "page.i65"
    .word store                 ; ( )  ( R; nfa )
#include "page.i65"
    .word plit
    .word docreate              ; ( 'docreate ) ( R; nfa )
#include "pad.i65"
    .word _commacfa             ; ( ) ( R; nfa )
#include "page.i65"
    .word rfetch                ; ( nfa ) ( R; nfa )
#include "page.i65"
    .word dhash                 ; ( hash1 hash2 ) ( R; nfa )
#include "page.i65"
    .word bloomstore            ; ( hash1 ) ( R; nfa )
#include "page.i65"
    .word rfrom                 ; ( hash1 nfa ) ( R; nfa )
#include "page.i65"
    .word twominus              ; ( hash1 lfa )
#include "page.i65"
    .word swap                  ; ( lfa hash1 )
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word dhashstore            ; ( )
#include "page.i65"
    .word exit                  ; ( )

;--------------------------------------------------------------
;
;"      :   ( -- sys )
;
; * 83 compiler tdict
;
; "colon"
;" A defining word executed in the form:
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed.
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
    jmp enter

;--------------------------------------------------------------
;
;       ;   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
semilfa
    .byt $de,$ad
    .byt (semi-*-1)|bit7|bit6
    .asc ";"|bit7
#endif
semi
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word exit
#include "page.i65"
    .word _smudge
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       CONSTANT   ( n -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
constantlfa
    .byt $de,$ad
    .byt (_constant-*-1)|bit7
    .asc "CONSTAN","T"|bit7
#endif
_constant
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jmp doconst
    
;--------------------------------------------------------------
;
;       VARIABLE   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
variablelfa
    .byt $de,$ad
    .byt (_variable-*-1)|bit7
    .asc "VARIABL","E"|bit7
#endif
_variable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       USER   ( n -- )
;
; compiler tdict
;
#ifdef HEADERS
userlfa
    .byt $de,$ad
    .byt (user-*-1)|bit7
    .asc "USE","R"|bit7
#endif
user
#include "enter.i65"
    .word _constant
#include "page.i65"
    .word _psemi
    jmp uservar
    
;--------------------------------------------------------------
;
;       +ORIGIN
;
; compiler tdict
;
#ifdef HEADERS
plusoriginlfa
    .byt $de,$ad
    .byt (_plusorigin-*-1)|bit7
    .asc "+ORIGI","N"|bit7
#endif
_plusorigin
#include "enter.i65"
    .word plit
    .word userarea
#include "pad.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FENCE
;
; tdict
;
#ifdef HEADERS
fencelfa
    .byt $de,$ad
    .byt (fence-*-1)|bit7
    .asc "FENC","E"|bit7
#endif
fence
    jsr uservar
    .byt userfence-userarea

;--------------------------------------------------------------
;
;       DP
;
; tdict
;
#ifdef HEADERS
dplfa
    .byt $de,$ad
    .byt (dp-*-1)|bit7
    .asc "D","P"|bit7
#endif
dp
    jsr uservar
    .byt userdp-userarea

;--------------------------------------------------------------
;
;       CONTEXT
;
; tdict
;
#ifdef HEADERS
contextlfa
    .byt $de,$ad
    .byt (context-*-1)|bit7
    .asc "CONTEX","T"|bit7
#endif
context
    jsr uservar
    .byt usercontext-userarea

;--------------------------------------------------------------
;
;       CURRENT
;
; tdict
;
#ifdef HEADERS
currentlfa
    .byt $de,$ad
    .byt (current-*-1)|bit7
    .asc "CURREN","T"|bit7
#endif
current
    jsr uservar
    .byt usercurrent-userarea

;--------------------------------------------------------------
;
;       STATE
;
; * 83 compiler tdict
;
; The address of the user variable containing the
; compilation  state.    A non-zero content indi-
; cates compilation is occuring,  but  the  value
; itself is system dependent.  A Standard Program
; may not modify this variable.
;
#ifdef HEADERS
statelfa
    .byt $de,$ad
    .byt (state-*-1)|bit7
    .asc "STAT","E"|bit7
#endif
state
    jsr uservar
    .byt userstate-userarea

;--------------------------------------------------------------
;
;       CSP
;
; tdict
;
#ifdef HEADERS
csplfa
    .byt $de,$ad
    .byt (csp-*-1)|bit7
    .asc "CS","P"|bit7
#endif
csp
    jsr uservar
    .byt usercsp-userarea

;--------------------------------------------------------------
;
;       SYMTAB   ( -- addr )
;
;   tdict
;
; user variable containing the beginning of the symbol table
;
#ifdef HEADERS
symtablfa
    .byt $de,$ad
    .byt (symtab-*-1)|bit7
    .asc "SYMTA","B"|bit7
#endif
symtab
    jsr uservar
    .byt usersymtab-userarea

;--------------------------------------------------------------
;
;       TRAVERSE   ( addr n -- addr )
;
; * dictionary tdict
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE   ( addr n -- addr )
;"      SWAP
;"      BEGIN
;"              OVER +  127  OVER C@  <
;"      UNTIL
;"      SWAP DROP ;
#ifdef HEADERS
traverselfa
    .byt $de,$ad
    .byt (_traverse-*-1)|bit7
    .asc "TRAVERS","E"|bit7
#endif
_traverse
#include "enter.i65"
    .word swap
#include "page.i65"
traverse01      .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word clit
    .byt $7f
#include "pad.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word lt
#include "page.i65"
    .word qbranch
    .byt <(traverse01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LATEST   ( -- NFA )
;
; tdict
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
#ifdef HEADERS
latestlfa
    .byt $de,$ad
    .byt (_latest-*-1)|bit7
    .asc "LATES","T"|bit7
#endif
_latest
#include "enter.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >BODY   ( cfa -- pfa )
;
; * 83 interpreter tdict
;
; convert the compilation address (CFA) to the address of the parameter field.
#ifdef HEADERS
tobodylfa
    .byt $de,$ad
    .byt (_tobody-*-1)|bit7
    .asc ">BOD","Y"|bit7
#endif
_tobody
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >NAME   ( CFA -- NFA )
;
; tdict
;
; returns the NFA of a given word
;
#ifdef HEADERS
tonamelfa
    .byt $de,$ad
    .byt (_toname-*-1)|bit7
    .asc ">NAM","E"|bit7
#endif
_toname
#include "enter.i65"
    .word oneminus
#include "page.i65"
    .word minusone
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       >LINK   ( CFA -- LFA )
;
; tdict
;
; returns the LFA of a given word
;
#ifdef HEADERS
tolinklfa
    .byt $de,$ad
    .byt (_tolink-*-1)|bit7
    .asc ">LIN","K"|bit7
#endif
_tolink
#include "enter.i65"
    .word _toname
#include "page.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BODY>   ( PFA -- CFA )
;
; tdict
;
#ifdef HEADERS
bodyfromlfa
    .byt $de,$ad
    .byt (_bodyfrom-*-1)|bit7
    .asc "BODY",">"|bit7
#endif
_bodyfrom
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       NAME>   ( nfa -- cfa )
;
; tdict
;
#ifdef HEADERS
namefromlfa
    .byt $de,$ad
    .byt (_namefrom-*-1)|bit7
    .asc "NAME",">"|bit7
#endif
_namefrom
#include "enter.i65"
    .word one
#include "page.i65"
    .word _traverse
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LINK>   ( lfa -- cfa )
;
; tdict
;
#ifdef HEADERS
linkfromlfa
    .byt $de,$ad
    .byt (_linkfrom-*-1)|bit7
    .asc "LINK",">"|bit7
#endif
_linkfrom
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       N>LINK   ( nfa -- lfa )
;
; tdict
;
#ifdef HEADERS
ntolinklfa
    .byt $de,$ad
    .byt (_ntolink-*-1)|bit7
    .asc "N>LIN","K"|bit7
#endif
_ntolink
#include "enter.i65"
    .word twominus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       L>NAME   ( lfa -- nfa )
;
; tdict
;
#ifdef HEADERS
linktonamelfa
    .byt $de,$ad
    .byt (_linktoname-*-1)|bit7
    .asc "L>NAM","E"|bit7
#endif
_linktoname
#include "enter.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       !CSP
;
; tdict
;
#ifdef HEADERS
storecsplfa
    .byt $de,$ad
    .byt (_storecsp-*-1)|bit7
    .asc "!CS","P"|bit7
#endif
_storecsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT"   ( flag -- ) ( -- ; compiling )
;
; * 83 compiler immediate tdict
;
; ~ handle page boundary crossings
#ifdef HEADERS
abortqlfa
    .byt $de,$ad
    .byt (_abortq-*-1)|bit7|bit6
    .asc "ABORT",'"'|bit7
#endif
_abortq
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word _pabortq
#include "page.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?COMP
;
; tdict
;
;#ifdef HEADERS
;qcomplfa
;    .byt $de,$ad
;    .byt (_qcomp-*-1)|bit7
;    .asc "?COM","P"|bit7
;#endif
_qcomp
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(qcomp01-*+1)
#include "pad.i65"
    .word clit
    .byt 5
#include "page.i65"
    .word fail
#include "page.i65"
qcomp01
    .word exit

;--------------------------------------------------------------
;
;       ?FIND
;
; tdict
;
;#ifdef HEADERS
;qfindlfa
;    .byt $de,$ad
;    .byt (_qfind-*-1)|bit7
;    .asc "?FIN","D"|bit7
;#endif
_qfind
#include "enter.i65"
    .word qbranch
    .byt <(qfind01-*+1)
#include "pad.i65"
    .word three
#include "page.i65"
    .word fail
#include "page.i65"
qfind01
    .word exit

;--------------------------------------------------------------
;
;       ?PAIRS
;
; tdict
;
;#ifdef HEADERS
;qpairslfa
;    .byt $de,$ad
;    .byt (_qpairs-*-1)|bit7
;    .asc "?PAIR","S"|bit7
;#endif
_qpairs
#include "enter.i65"
    .word minus
#include "page.i65"
    .word qbranch
    .byt <(qpairs01-*+1)
#include "pad.i65"
    .word clit
    .byt 6
#include "pad.i65"
    .word fail
#include "page.i65"
qpairs01
    .word exit

;--------------------------------------------------------------
;
;       ?CSP
;
; tdict
;
#ifdef HEADERS
qcsplfa
    .byt $de,$ad
    .byt (_qcsp-*-1)|bit7
    .asc "?CS","P"|bit7
#endif
_qcsp
#include "enter.i65"
    .word spfetch
#include "page.i65"
    .word csp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word qbranch           ; IF
    .byt <(qcsp01-*+1)
#include "pad.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word fail
#include "page.i65"
qcsp01                      ; THEN
    .word exit

;--------------------------------------------------------------
;
;       ?CHAR   ( -- )
;
; tdict
;
#ifdef HEADERS
qcharlfa
    .byt $de,$ad
    .byt (_qchar-*-1)|bit7
    .asc "?CHA","R"|bit7
#endif
_qchar
#include "enter.i65"
    .word tor
#include "page.i65"
    .word _tickstream
#include "page.i65"
    .word over
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word scan
#include "page.i65"
    .word drop
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word tor
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word toin
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(qchar02-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word cr
#include "page.i65"
    .word emit
#include "page.i65"
    .word _pdq
    .byt qchar01-*-1
    .asc    " MISSING "
    ;123456789
qchar01
#include "pad.i65"
    .word _abort
#include "page.i65"
qchar02         .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       COMPILE
;
; tdict
;
; * 83 compiler
;
#ifdef HEADERS
compilelfa
    .byt $de,$ad
    .byt (_compile-*-1)|bit7
    .asc "COMPIL","E"|bit7
#endif
_compile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [
;
; * 83 compiler tdict
;
#ifdef HEADERS
lbracketlfa
    .byt $de,$ad
    .byt (_lbracket-*-1)|bit7
    .asc "["|bit7
#endif
_lbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ]
;
; * 83 compiler tdict
;
#ifdef HEADERS
rbracketlfa
    .byt $de,$ad
    .byt (_rbracket-*-1)|bit7
    .asc "]"|bit7
#endif
_rbracket
#include "enter.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
rbracket01      .word qstack
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02      .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04      .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05      .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       SMUDGE
;
; tdict
;
#ifdef HEADERS
smudgelfa
    .byt $de,$ad
    .byt (_smudge-*-1)|bit7
    .asc "SMUDG","E"|bit7
#endif
_smudge
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt bit5       ; $20
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (;CODE)
;
; tdict
;
;#ifdef HEADERS
;psemilfa
;    .byt $de,$ad
;    .byt (_psemi-*-1)|bit7
;    .asc "(;CODE",")"|bit7
;#endif
_psemi
#include "enter.i65"
    .word rfrom
#include "page.i65"
    .word _latest
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       DOES>
;
; * 83 compiler tdict
;
#ifdef HEADERS
doeslfa
    .byt $de,$ad
    .byt (_does-*-1)|bit7
    .asc "DOES",">"|bit7
#endif
_does
#include "enter.i65"
    .word _qcsp
#include "page.i65"
    .word _compile
    .word _psemi
#include "pad.i65"
    .word clit
    .byt $20        ; jsr instruction
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _compile  ; ~ fix paging here
    .word dodoes
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       ."   ( -- )
;
; * 83 compiler tdict
;
#ifdef HEADERS
dotqlfa
    .byt $de,$ad
    .byt (_dotq-*-1)|bit7
    .asc ".",'"'|bit7
#endif
_dotq
#include "enter.i65"
    .word _compile
    .word _pdq
#include "pad.i65"
    .word clit
    .asc '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word _commadollar
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       .(
;
; * 83 interpreter tdict
;
#ifdef HEADERS
dotplfa
    .byt $de,$ad
    .byt (_dotp-*-1)|bit7
    .asc ".","("|bit7
#endif
_dotp
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUERY
;
; tdict
;
#ifdef HEADERS
querylfa
    .byt $de,$ad
    .byt (_query-*-1)|bit7
    .asc "QUER","Y"|bit7
#endif
_query
#include "enter.i65"
    .word tib
#include "page.i65"
    .word clit
    .byt 80
#include "pad.i65"
    .word expect
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word toin
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       QUIT?   ( flag -- flag )
;
; tdict
;
#ifdef HEADERS
quitqlfa
    .byt $de,$ad
    .byt (_quitq-*-1)|bit7
    .asc "QUIT","?"|bit7
#endif
_quitq
#include "enter.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ne
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numtib
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word orx
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (PUNCT?)
;
; tdict
;
;#ifdef HEADERS
;ppunctqlfa
;    .byt $de,$ad
;    .byt (_ppunctq-*-1)|bit7
;    .asc "(PUNCT?",")"|bit7
;#endif
_ppunctq
#include "enter.i65"
    .word clit
    .byt '.'
#include "pad.i65"
    .word eq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PUNCT?
;
;#ifdef HEADERS
;punctqlfa
;    .byt $de,$ad
;    .byt (_punctq-*-1)|bit7
;    .asc "PUNCT","?"|bit7
;#endif
_punctq
#include "enter.i65"
    .word _ppunctq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (FIND)   ( name-2 LFA -- name-2 0 | CFA flag )
;
; * outer interpreter headerless
;
; name-2 is the address-2 of a counted string we are searching for.
; LFA is the LFA at the head of a chain of LFAs
; returns
;       ( CFA -1 ) if found normal word
;       ( CFA 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"                    ; ( name )
    .word context           ; ( name context )
#include "page.i65"
    .word fetch             ; ( name vocabulary )
#include "page.i65"
    .word fetch             ; ( name LFA|0 )
#include "page.i65"
    .word qbranch
    .byt <(find01-*+1)
#include "pad.i65"                      ; ( name LFA )
    .word clit
    .byt 7
#include "pad.i65"
    .word fail              ; vocabularies unimplemented
#include "page.i65"
find01                                  ; ( name )
    .word dup               ; ( name name )
#include "page.i65"
    .word dhash             ; ( name hash1 hash2 )
#include "page.i65"
    .word bloomfetch        ; ( name hash1 flag )
#include "page.i65"
    .word qbranch           ; IF
    .byt <(find02-*+1)
#include "pad.i65"
    .word dhashfetch        ; ( name LFA )
#include "page.i65"
    .word swap              ; ( LFA name )
#include "page.i65"
    .word twominus          ; ( LFA name-2 )
#include "page.i65"
    .word swap              ; ( name-2 LFA )
#include "page.i65"
    .word pfind             ; ( addr flag )
#include "page.i65"
    .word qdup              ; ( addr flag flag | addr 0 )
#include "page.i65"
    .word zeq               ; ( addr flag 0 | name-2 true )
#include "page.i65"
    .word qbranch           ; found? exit
    .byt <(find03-*+1)
#include "pad.i65"
    ; bloom filter false positive
    .word twoplus           ; ( name )
#include "page.i65"
    .word false             ; ( name false )
#include "page.i65"
    .word branch
    .byt <(find03-*+1)
#include "pad.i65"
find02                                  ; ELSE
    ; bloom filter negative
    ; ( name hash1 )
    .word drop              ; ( name )
#include "page.i65"
    .word false             ; ( here false )
#include "page.i65"
find03                                  ; THEN
    .word exit              ; ( addr flag )

;--------------------------------------------------------------
;
;       EXISTS?   ( -- addr flag )
;
; tdict
;
; scans ahead in the input stream for the next blank-delimited word,
; and returns either
#ifdef HEADERS
existsqlfa
    .byt $de,$ad
    .byt (_existsq-*-1)|bit7
    .asc "EXISTS","?"|bit7
#endif
_existsq
#include "enter.i65"
    .word bl                ; ( c )
#include "page.i65"
    .word _word             ; ( nfa )
#include "page.i65"
    .word _find             ; ( nfa -1|+1 | here false )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ID.
;
; tdict
;
#ifdef HEADERS
iddotlfa
    .byt $de,$ad
    .byt (_iddot-*-1)|bit7
    .asc "ID","."|bit7
#endif
_iddot
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word clit
    .byt 32
#include "pad.i65"
    .word clit
    .asc '*'
#include "pad.i65"
    .word fill
#include "page.i65"
    .word dup
#include "page.i65"
    .word _namefrom
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _pad
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word count
#include "page.i65"
    .word clit
    .byt $1f                ; ~ shouldn't this use WIDTH?
#include "pad.i65"
    .word andx
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [COMPILE]
;
; * 83 compiler tdict
;
#ifdef HEADERS
bcompilelfa
    .byt $de,$ad
    .byt (_bcompile-*-1)|bit7
    .asc "[COMPILE","]"|bit7
#endif
_bcompile
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LITERAL
;
; * 83 compiler tdict
;
#ifdef HEADERS
literallfa
    .byt $de,$ad
    .byt (_literal-*-1)|bit7
    .asc "LITERA","L"|bit7
#endif
_literal
#include "enter.i65"
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01       .word _compile
    .word plit
#include "page.i65"
    .word _comma
#include "page.i65"
literal02       .word exit

;--------------------------------------------------------------
;
;       DLITERAL
;
; tdict
;
#ifdef HEADERS
dliterallfa
    .byt $de,$ad
    .byt (_dliteral-*-1)|bit7
    .asc "DLITERA","L"|bit7
#endif
_dliteral
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       INTERPRET
;
; tdict
;
;
;": interpret   ( )
;       begin   ?stack
;               exists?
;               if      link>
;                       execute
;               else    number dpl @ 1+ 0=
;                       if      drop
;                       then
;               then
;               false
;               quit?
;       again ;
;
#ifdef HEADERS
interpretlfa
    .byt $de,$ad
    .byt (_interpret-*-1)|bit7
    .asc "INTERPRE","T"|bit7
#endif
_interpret
#include "enter.i65"
interpret01
    .word qstack            ; ( )
#include "page.i65"
    .word _existsq          ; ( addr flag )
#include "page.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word execute
#include "page.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "pad.i65"
interpret02
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(interpret03-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
interpret03
    .word false
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       IMMEDIATE
;
; tdict
;
; * 83 compiler
;
#ifdef HEADERS
immediatelfa
    .byt $de,$ad
    .byt (_immediate-*-1)|bit7
    .asc "IMMEDIAT","E"|bit7
#endif
_immediate
#include "enter.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $40
#include "pad.i65"
    .word toggle
    .word exit

;--------------------------------------------------------------
;
;       VOCABULARY
;
; * 83 compiler tdict
;
; see FD-V05N3 p. 5
#ifdef HEADERS
vocabularylfa
    .byt $de,$ad
    .byt (_vocabulary-*-1)|bit7
    .asc "VOCABULAR","Y"|bit7
#endif
_vocabulary
#include "enter.i65"
    .word _create
#include "page.i65"
    .word exit
;#include "page.i65"
;               .word current
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word twoplus
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word here
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word fetch
;#include "page.i65"
;               .word _comma
;#include "page.i65"
;               .word voclink
;#include "page.i65"
;               .word store
;#include "page.i65"
;               .word _psemi
vocabdoes
    jsr dodoes
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORTH
;
; * 83 interpreter tdict
;
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
#ifdef HEADERS
forthlfa
    .byt $de,$ad
    .byt (forth-*-1)|bit7
    .asc "FORT","H"|bit7
#endif
forth
    jsr vocabdoes
    .word 0                 ; flag as root vocabulary
    .byt 1|bit7
    .byt ' '|bit7           ; $a081
lastvoc
    .word 0                 ; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;       DEFINITIONS
;
; * 83 interpreter tdict
;
#ifdef HEADERS
definitionslfa
  .byt $de,$ad
    .byt (_definitions-*-1)|bit7
    .asc "DEFINITION","S"|bit7
#endif
_definitions
#include "enter.i65"
    .word context
#include "page.i65"
    .word fetch
#include "page.i65"
    .word current
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (
;
; * 83 interpreter tdict
;
#ifdef HEADERS
lparenlfa
    .byt $de,$ad
    .byt (_lparen-*-1)|bit7
    .asc "("|bit7
#endif
_lparen
#include "enter.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ABORT
;
; * 83 interpreter tdict
;
#ifdef HEADERS
abortlfa
    .byt $de,$ad
    .byt (_abort-*-1)|bit7
    .asc "ABOR","T"|bit7
#endif
_abort
#include "enter.i65"
    .word spstore
#include "page.i65"
    .word _quit
#include "page.i65"
    .word exit      ; make the decompiler happy

;--------------------------------------------------------------
;
;       QUIT
;
; tdict
;
;"This is the infinite outer interpreter loop:
;       - resets the return stack (RP!)
;       - outputs a carriage return (CR)
;       - waits for a line of user input (QUERY)
;       - interprets that line
; * 83 interpreter outer
;
#ifdef HEADERS
quitlfa
    .byt $de,$ad
    .byt (_quit-*-1)|bit7
    .asc "QUI","T"|bit7
#endif
_quit
#include "enter.i65"
    .word blk
#include "page.i65"
    .word off
#include "page.i65"
    .word _lbracket         ; STATE OFF
#include "page.i65"
quit01                                  ; BEGIN
    .word rpstore
#include "page.i65"
    .word cr
#include "page.i65"
    .word _query
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch           ; IF
    .byt <(quit03-*+1)
#include "pad.i65"
    .word _pdq
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "pad.i65"
quit03                                  ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       '
;
; * 83 interpreter tdict
;
#ifdef HEADERS
ticklfa
    .byt $de,$ad
    .byt (_tick-*-1)|bit7
    .asc "'"|bit7
#endif
_tick
#include "enter.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qfind
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       [']
;
; * 83 compiler tdict
;
#ifdef HEADERS
brticklfa
    .byt $de,$ad
    .byt (_brtick-*-1)|bit7
    .asc "['","]"|bit7
#endif
_brtick
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       ?>MARK
;
; tdict
;
;#ifdef HEADERS
;qtomarklfa
;    .byt $de,$ad
;    .byt (_qtomark-*-1)|bit7
;    .asc "?>MAR","K"|bit7
;#endif
_qtomark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?<MARK
;
; tdict
;
;#ifdef HEADERS
;qfrommarklfa
;   .byt $de,$ad
;    .byt (_qfrommark-*-1)|bit7
;    .asc "?<MAR","K"|bit7
;#endif
_qfrommark
#include "enter.i65"
    .word _qcomp
#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?>RESOLVE
;
; tdict
;
;#ifdef HEADERS
;qtoresolvelfa
;  .byt $de,$ad
;    .byt (_qtoresolve-*-1)|bit7
;    .asc "?>RESOLV","E"|bit7
;#endif
_qtoresolve
#include "enter.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word here
#include "page.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
;
;       ?<RESOLVE
;
; tdict
;
;#ifdef HEADERS
;qltresolvelfa
;  .byt $de,$ad
;    .byt (_qltresolve-*-1)|bit7
;    .asc "?<RESOLV","E"|bit7
;#endif
_qltresolve
#include "enter.i65"
    .word swap
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       ADD>MARK
;
; tdict
;
;#ifdef HEADERS
;addtomarklfa
;    .byt $de,$ad
;    .byt (_addtomark-*-1)|bit7
;    .asc "ADD>MAR","K"|bit7
;#endif
_addtomark
#include "enter.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01     .word one
#include "page.i65"
    .word roll
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02     .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BEGIN
;
; * 83 compiler tdict
;
#ifdef HEADERS
beginlfa
    .byt $de,$ad
    .byt (_begin-*-1)|bit7
    .asc "BEGI","N"|bit7
#endif
_begin
#include "enter.i65"
    .word _qfrommark
#include "page.i65"
    .word one
    .word exit

;--------------------------------------------------------------
;
;       THEN
;
; * 83 compiler tdict
;
#ifdef HEADERS
thenlfa
    .byt $de,$ad
    .byt (_then-*-1)|bit7
    .asc "THE","N"|bit7
#endif
_then
#include "enter.i65"
    .word abs
#include "page.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
;
;       DO
;
; * 83 compiler tdict
;
#ifdef HEADERS
dolfa
    .byt $de,$ad
    .byt (_do-*-1)|bit7
    .asc "D","O"|bit7
#endif
_do
#include "enter.i65"
    .word _compile
#include "page.i65"
    .word pdo
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ?DO
;
; tdict
;
#ifdef HEADERS
qdolfa
    .byt $de,$ad
    .byt (_qdo-*-1)|bit7
    .asc "?D","O"|bit7
#endif
_qdo
#include "enter.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word pqdo
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word drop
#include "page.i65"
    .word swap
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LOOP
;
; * 83 compiler tdict
;
#ifdef HEADERS
looplfa
    .byt $de,$ad
    .byt (_loop-*-1)|bit7
    .asc "LOO","P"|bit7
#endif
_loop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word ploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       +LOOP
;
; * 83 compiler tdict
;
#ifdef HEADERS
pluslooplfa
    .byt $de,$ad
    .byt (_plusloop-*-1)|bit7
    .asc "+LOO","P"|bit7
#endif
_plusloop
#include "enter.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word pploop
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       LEAVE
;
; * 83 compiler tdict
;
#ifdef HEADERS
leavelfa
    .byt $de,$ad
    .byt (_leave-*-1)|bit7
    .asc "LEAV","E"|bit7
#endif
_leave
#include "enter.i65"
    .word _compile
    .word pleave
#include "pad.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       ?LEAVE
;
; tdict
;
#ifdef HEADERS
qleavelfa
    .byt $de,$ad
    .byt (_qleave-*-1)|bit7
    .asc "?LEAV","E"|bit7
#endif
_qleave
#include "enter.i65"
    .word _compile
    .word pqleave
#include "page.i65"
    .word three
#include "page.i65"
    .word _addtomark
    .word exit

;--------------------------------------------------------------
;
;       UNTIL
;
; * 83 compiler tdict
;
#ifdef HEADERS
untillfa
    .byt $de,$ad
    .byt (_until-*-1)|bit7
    .asc "UNTI","L"|bit7
#endif
_until
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
    .word exit

;--------------------------------------------------------------
;
;       AGAIN
;
; tdict
;
#ifdef HEADERS
againlfa
    .byt $de,$ad
    .byt (_again-*-1)|bit7
    .asc "AGAI","N"|bit7
#endif
_again
#include "enter.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       REPEAT
;
; * 83 compiler tdict
;
#ifdef HEADERS
repeatlfa
    .byt $de,$ad
    .byt (_repeat-*-1)|bit7
    .asc "REPEA","T"|bit7
#endif
_repeat
#include "enter.i65"
    .word _again
    .word exit

;--------------------------------------------------------------
;
;       IF
;
; * 83 compiler tdict
;
#ifdef HEADERS
iflfa
    .byt $de,$ad
    .byt (_if-*-1)|bit7
    .asc "I","F"|bit7
#endif
_if
#include "enter.i65"
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qtomark
#include "page.i65"
    .word two
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       ELSE
;
; * 83 compiler tdict
;
#ifdef HEADERS
elselfa
    .byt $de,$ad
    .byt (_else-*-1)|bit7
    .asc "ELS","E"|bit7
#endif
_else
#include "enter.i65"
    .word two
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word swap
#include "page.i65"
    .word _qtomark
#include "page.i65"
    .word swap
#include "page.i65"
    .word _qtoresolve
#include "page.i65"
    .word zero
#include "page.i65"
    .word plit
    .word -2
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       WHILE
;
; * 83 compiler tdict
;
#ifdef HEADERS
whilelfa
    .byt $de,$ad
    .byt (_while-*-1)|bit7
    .asc "WHIL","E"|bit7
#endif
_while
#include "enter.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word one
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2CONSTANT
;
; tdict
;
#ifdef HEADERS
twoconstlfa
    .byt $de,$ad
    .byt (_twoconst-*-1)|bit7
    .asc "2CONSTAN","T"|bit7
#endif
_twoconst
#include "enter.i65"
    .word _create
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _psemi
    jsr dodoes
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       2VARIABLE
;
; tdict
;
#ifdef HEADERS
twovariablelfa
  .byt $de,$ad
    .byt (_twovariable-*-1)|bit7
    .asc "2VARIABL","E"|bit7
#endif
_twovariable
#include "enter.i65"
    .word _create
#include "page.i65"
    .word clit
    .byt 4
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       BRINGOUTYERDEAD   ( addr -- deadlfa|0 )
;
; compiler tdict
;
; scans forward in memory returning the address of the next $DE $AD
; in memory that is followed by a name
;" http://www.youtube.com/watch?v=grbSQ6O6kbs
;
;#ifdef HEADERS
;boydlfa
;    .byt $de,$ad
;    .byt (boyd-*-1)|bit7
;    .asc "BRINGOUTYERDEA","D"|bit7
;#endif
boyd
    brk
    .byt set  | R10
    .word $de
    .byt set  | R11
    .byt $de,$ad
    .byt set  | N0
    .word userdp-userarea
    .byt ld   | UP
    .byt add  | N0
    .byt st   | N0
    .byt ldd  | N0
    .byt st   | N0          ; here
    .byt ldd  | N0
    .byt popd | N0          ; restore N0
    .byt st   | N1
    .byt ld   | R11
    .byt std  | N0          ; here+2 -> N0
    .byt rtn
boyd01
    brk
    .byt ldi  | TOS
    .byt cpr  | R10
    .byt bnz, <(boyd01-*-1)
    .byt dcr  | TOS
    .byt ldd  | TOS
    .byt cpr  | R11
    .byt bz,  <(boyd02-*-2)
    .byt dcr  | TOS
    .byt br,  <(boyd01-*-1)
boyd02
    .byt ld   | TOS
    .byt cpr  | N0          ; TOS=here+2?
    .byt bnz, <(boyd03-*-2)
    .byt sub  | ACC
    .byt st   | TOS
    .byt br,  <(boyd06-*-2)
boyd03
    .byt rtn                ; TOS points to probable NFA
    ldy #0
    lda (tos),y
    bpl boyd01              ; NFA length must be negative
    and #$1f
    tay
    lda (tos),y
    bpl boyd01              ; last NFA byte must be negative
boyd04
    dey
    beq boyd05
    lda (tos),y
    bpl boyd04
    bmi boyd01              ; middle NFA bytes must be positive
boyd05
    brk
    .byt popd | TOS         ; point at the LFA
boyd06
    .byt popd | N0          ; back up the pointer
    .byt ld   | N1
    .byt std  | N0          ; restore previous contents of here
    .byt nxt

;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; tdict
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table 
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?         (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$3f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
; DEBUG
;    jsr debug               ; print out some entertainment
; /DEBUG
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya

;DEBUG
; hex dump the byte in A
;debug
;    pha
;    pha
;    and #$0f
;    jsr print
;    pla
;    lsr
;    lsr
;    lsr
;    lsr
;    jsr print
;    pla
;dbout
;    rts
;print
;    sed
;    cmp #10
;    adc #'0'
;    cld
;    jmp CHROUT
; ;/DEBUG

;--------------------------------------------------------------
;
;       DHASH@   ( hashkey -- LFA )
;
; tdict
;
; retrieve the head of this hash thread
;
;#ifdef HEADERS
;dhashfetchlfa
;  .byt $de,$ad
;    .byt (dhashfetch-*-1)|bit7
;    .asc "DHASH","@"|bit7
;#endif
dhashfetch
    brk
    .byt set  | ACC
    .word lfalist
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | TOS
    .byt ldd  | TOS
    .byt st   | TOS
    .byt nxt

;--------------------------------------------------------------
;
;       BLOOM!   ( hash -- )
;
; tdict
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;#ifdef HEADERS
;bloomstorelfa
;  .byt $de,$ad
;    .byt (bloomstore-*-1)|bit7
;    .asc "BLOOM","!"|bit7
;#endif
bloomstore
    lda tos                 ; set bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
;    and #(bloomx-bloom-1)   ; don't write outside filter area  ~wut?
    and #7   ; don't write outside filter area
    tay
    lda n
    ora bloom,y
    sta bloom,y
    jmp pops

;--------------------------------------------------------------
;
;       BLOOM@   ( hash -- flag )
;
; tdict
;
; test a bit in the filter
; hash indexes a single bit in the bloom filter
; input value is in the range 0-63, representing which bit to test
;
; flag values
; false = it can't be in there (bit was clear)
; true = it might be in there (bit was set)
;#ifdef HEADERS
;bloomfetchlfa
;    .byt $de,$ad
;    .byt (bloomfetch-*-1)|bit7
;    .asc "BLOOM","@"|bit7
;#endif
bloomfetch
    lda tos                 ; read bloom filter bit for hash2
    and #7
    tay
    lda power2,y
    sta n
    lda tos
    lsr
    lsr
    lsr
;    and #(bloomx-bloom-1)   ; don't write outside filter area  ~wut?
    and #7   ; don't write outside filter area
    tay
    lda bloom,y
    ldy #0
    and n
    beq bloomfetch01
    dey
bloomfetch01
    tya
    jmp put

;--------------------------------------------------------------
;
;       DHASH!   ( LFAnew hash1 -- )
;
; tdict
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
; sweet16 saved 51 bytes vs. 6502
;#ifdef HEADERS
;dhashstorelfa
;    .byt $de,$ad
;    .byt (dhashstore-*-1)|bit7
;    .asc "DHASH","!"|bit7
;#endif
dhashstore
    ldy #1
    jsr locals               ; LFAnew -> N0
    brk
    .byt set  | R11
    .word lfalist
    .byt sub  | ACC
    .byt st   | N2          ; 0 -> N2
    .byt ld   | R11
    .byt add  | TOS
    .byt add  | TOS
    .byt st   | R11         ; R11+hash1*2 -> R11
    .byt ldd  | R11
    .byt popd | R11         ; back up the pointer
    .byt bnz, <(dhashstore01-*-2)
    .byt set  | ACC
    .word 0 ; was rootlfa  ~wut?
    .byt std  | R11
    .byt popd | R11
dhashstore01
    .byt st   | N1          ; head -> N1
    .byt rtn
    ldy #2
    lda (n),y
    and #$1f
    sta n+7                 ; length of name being inserted
dhashstore02
    lda (n+2),y
    and #$1f
    sta n+6
    lda n+7
    cmp n+6                 ; compare lengths
    bcc dhashstore05
    bne dhashstore04
    ;sec
    adc #1
    tay                     ; last char in names
dhashstore03
    lda (n),y
    eor (n+2),y
    asl                     ; compare char ignoring bit7
    bne dhashstore04
    dey
    cpy #2
    bne dhashstore03        ; stop at first char
    dey
    brk
    .byt set  | ACC
    .byt $de,$ad
    .byt std  | N1
    .byt rtn
dhashstore04
    brk
    .byt ld   | N1
    .byt st   | N2          ; keep track of where we've just been
    .byt ldd  | N1
    .byt st   | N1          ; (N1) -> N1
    .byt rtn
    ldy #2
    bne dhashstore02
dhashstore05
    brk
    .byt ld   | N2
    .byt bnz, <(dhashstore06-*-2)
    .byt ld   | R11         ; empty list, insert at the head
    .byt st   | N2          ; head -> N2
dhashstore06
    .byt ld   | N0
    .byt std  | N2          ; N0 -> (N2)
    .byt ld   | N1
    .byt std  | N0          ; N1 -> (N0)
    .byt pull               ; drop the hash
    .byt nxt

;--------------------------------------------------------------
;
;       RETHREAD   ( -- )
;
; tdict
;
; compiler tdict
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.
; It also marks the last word in the core dictionary.
; links all LFAs
;" : rethread   ( -- )
;       lfalist 40 erase
;       0 +origin
;       begin   bringoutyerdead
;               ?dup
;       while   dup dup 2+
;               dhash
;               bloom!
;               dhash!
;       until ;
;
;#ifdef HEADERS
;rethreadlfa
;    .byt $de,$ad
;    .byt (_rethread-*-1)|bit7
;    .asc "RETHREA","D"|bit7
;#endif
_rethread
#include "enter.i65"
    .word plit
    .word bloom
#include "pad.i65"
    .word clit
    .byt 40                 ; bloom filter (8) and lfalist (32)
#include "pad.i65"
    .word _erase
#include "page.i65"
    .word zero
#include "page.i65"
    .word _plusorigin
#include "page.i65"
rethread01
    .word boyd              ; begin boyd ?dup while ... repeat
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(rethread02-*+1)
#include "pad.i65"
    .word dup               ; ( lfa lfa )
#include "page.i65"
    .word dup               ; ( lfa lfa lfa )
#include "page.i65"
    .word twoplus           ; ( lfa lfa nfa )
#include "page.i65"
    .word dhash             ; ( lfa lfa hash1 hash23 )
#include "page.i65"
    .word bloomstore        ; ( lfa lfa hash1 )
#include "page.i65"
    .word dhashstore        ; ( lfa )
#include "page.i65"
    .word branch
    .byt <(rethread01-*+1)
#include "pad.i65"
rethread02
    .word exit

;--------------------------------------------------------------
;
;       UNTHREAD   ( -- )
;
; tdict
;
; compiler tdict
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;       16 0 do                         ( )
;               i dhash@                ( lfa1 )
;               begin
;                       dup             ( lfa1 lfa1 )
;                       @               ( lfa1 lfa2 )
;                       ?dup            ( lfa1 lfa2 true | lfa1 false )
;               while                   ( lfa1 lfa2 )
;                       $dead           ( lfa1 lfa2 $dead )
;                       rot             ( lfa2 $dead lfa1 )
;~ dup 2- ( nfa ) dup c@ ( nfa len ) $80 or ( nfa len ) swap c! ( )
;                       !               ( lfa2 )
;               repeat
;                                       ( lfa )
;               drop                    ( )
;       loop
;
;#ifdef HEADERS
;unthreadlfa
;    .byt $de,$ad
;    .byt (_unthread-*-1)|bit7
;    .asc "UNTHREA","D"|bit7
;#endif
_unthread
#include "enter.i65"
    .word clit
    .byt 16
#include "pad.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
unthread01      .word i
#include "page.i65"
    .word dhashfetch
#include "page.i65"
unthread02      .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(unthread03-*+1)
#include "pad.i65"
    .word plit
    .byt $de,$ad
#include "pad.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word branch
    .byt <(unthread02-*+1)
#include "page.i65"
unthread03      .word drop
#include "page.i65"
    .word zero
#include "page.i65"
    .word i
#include "page.i65"
    .word dhashstore
#include "page.i65"
    .word ploop
    .byt <(unthread01-*+1)
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;        REHASH   ( -- )
;
; rebuilds the symbol table in high memory.
;
; *** TRICK ALERT ***
; Uses the address on the return stack to determine if the caller 
; was COLD.  Doesn't copy stuff to PAD if that's the case (it's 
; already there from load) 
;
#ifdef HEADERS
rehashlfa
    .byt $de,$ad
    .byt (_rehash-*-1)|bit7
    .asc "REHAS","H"|bit7
#endif
_rehash
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       FORGET
;
; tdict
;
; * 83 interpreter
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
; ~ work this over to use pointers only (no RETHREAD/UNTHREAD)
#ifdef HEADERS
forgetlfa
    .byt $de,$ad
    .byt (_forget-*-1)|bit7
    .asc "FORGE","T"|bit7
#endif
_forget
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       WARM
;
;reset top of the dictionary
;ice
; Preprocessing when PETTIL is started from BASIC
; swapzp - either with a cold image or with contents prior to BASIC mode
; distinguish whether this is a cold or warm start (user variable?)
;
;cold
; PETTIL is invoked for the first time after initial load
; print a welcome banner
; set up top of memory pointers based on BASIC MEMSIZ variable
; REHASH to copy the symbol table up to high memory (it's at PAD now)
; copy TDICT to high memory (it's after the symbol table)
;
;warm
; PETTIL was reinvoked, e.g. after cassette error or after MON
; print a different welcome banner e.g. "<WARM START>"
;
;start
; Postprocessing when PETTIL restarts, common to cold and warm
; reset data and return stack
; set the BRK vector to point to Sweet16
; print start message CR,"WELCOME TO PETTIL!",CR
; EMPTYBUFFERS
; STARTUP @ EXECUTE
;
;ice
    jsr swapzp
    lda CBINV
    eor #<SW16
    sta brktoggle
    lda CBINV+1
    eor #>SW16
    sta brktoggle+1
    bne warm                ; bra       ~ wut? not needed in headless
#ifdef HEADERS
warmlfa
    .byt $de,$ad
    .byt (warm-*-1)|bit7
    .asc "WAR","M"|bit7
#endif
warm
    ldy #uarea-userarea-1
    bne warm01              ; bra

;warm
;    ldy #userwarm-userarea-1

warm01
    lda userup
    sta up
    lda userup+1
    sta up+1
warm02
    lda userarea,y
    sta (up),y
    dey
    bpl warm02
    cld
    jsr CLRCHN
    jsr CLALL
#include "toforth.i65"
    .word sw16              ; set up BRK vector to Sweet16
#include "page.i65"
    .word rpstore           ; and we're off
#include "page.i65"
    .word spstore
#include "page.i65"
    .word plit
    .word zpbuf+MEMSIZ      ; use BASIC memsiz initially
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word memsiz            ; set MEMSIZ uservariable
#include "page.i65"
    .word store
#include "page.i65"
    .word _emptybuffers
#include "page.i65"
    .word _pdq
    .byt (warm03-*-1)
    .asc    CLR,"FORTH FOR THE COMMODORE PET 2001",CR
    .asc    "HTTP:","/","/GITHUB.COM/CHITSELB/PETTIL",CR
    .asc    "VERSION PRE-ALPHA 2014-05-24",CR
            ;123456789.123456789.123456789.123456789.
    .asc    "1607 ENGLISH SETTLERS LAND IN JAMESTOWN", CR
    .asc    "1844 SAMUEL MORSE SENDS FIRST TELEGRAM",CR
warm03
#include "pad.i65"
    .word _rethread
#include "page.i65"
warm05
    .word _decimal
#include "page.i65"
    .word forth
#include "page.i65"
    .word _definitions
#include "page.i65"
    .word _pdq
    .byt (warm04-*-1)
    .asc    CR,"WELCOME TO PETTIL!",CR
warm04
#include "pad.i65"
    .word startup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word execute
#include "page.i65"
    .word exit


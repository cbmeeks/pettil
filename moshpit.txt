moshpit























: ^   ( -- )
    #blk @  scr !
    editing on
    vidram scrpkt !
    0 mkpkts
    update _ ;



: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;

: update   ( -- )
\ are there any blocks?  ?exit
\ scenario B (do not update DATA packet in editor)
    #blk @ 0= ?exit
\ editing? choose vidram blkbuf
    blkbuf
    editing?
    if
\ early exit if editing data packet
\ scenario A (update packet from VIDRAM)
        drop
\ editing & isscr? choose vidram as source
\ editing & !isscr? do not modify this data packet
        isscr?
        ?: vidram exit
    then
    vmbuf b/buf
\ use the packet in `blk`   or `scr`
\ use               `b/buf` or `b/scr`
               b/buf blk
    isscr?
    if
        2drop  b/scr scr
    then
\ spread out the packet by moving everything below it down 1K
    @ >pkt
    (upd1)
    cmove
\ stash 24-bit line wrap info at the front of the packet
    l/scr wrap^
\ set the `scrpkt` bit in the new packet header
    scrpkt
\ shorten the buffer with `-trailing`
    ?: -trailing -nulls
\ attempt to rlencode what is left
    nip rlencode
\ write new packet header
\ squeeze out unused space in new packet, move `vmbuf` to top of packet
    +move
\ recount packets
    #blk! ;

editing     on/off
scrpkt      $8000/0
#blk        min. 1 to play
scr         use if scrpkt & editing
blk         use if !editing
            use if !scrpkt


constants
b/buf   b/scr   l/scr   blkbuf
$0400   1000    25      $5800

editing?: true
isscr?:   true              A   vidram
isscr?:   false             B   exit

editing?: false                 blkbuf
isscr?:   true              C
isscr?:   false             D

exit if no blocks
exit if editing data packet
editing? vidram blkbuf
isscr?   vidram exit



cmove

25 wrap^

scrpkt

?: -trailing -nulls

rlencode

+move

#blk!








rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; n8    size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | N8                ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt ld | N2                ; targ (out)
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | N8                ; size
    .byt add | N7               ; +pristine targ
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt ld | N0
    .byt push
    .byt ld | N7
    .byt push
    .byt ld | N8
    .byt push
    .byt rtn
    jmp cmove


pupd1
    jsr harvests10
    brk
    .byt ldd | N1               ; vmbuf @
    .byt st | N5                ; save for later
    .byt sub | N2               ; vmbuf-1024
    .byt add | TOS              ; vmbuf-1024+size
    .byt dcr | ACC
    .byt dcr | ACC              ; vmbuf-1024+size-2
    .byt st | N6                ; save for later
    ; things we'll need for CMOVE+
    .byt st | TOS               ; =bottom
    .byt ld | N4                ; pkt
    .byt push                   ; =pkt
    .byt sub | N2               ; pkt-1024
    .byt st | N7                ; save for later
    .byt push                   ; =floor
    ; things we'll need for RLENCODE
    .byt push                   ; =dest
    .byt ld | N0                ; blkbuf|vidram
    .byt push                   ; =src
    .byt ld | N3                ; b/buf|b/scr
    .byt push                   ; =srcbufsiz
    ; things we'll need for CMOVE
    .byt ld | N5
    .byt push                   ; =from
    .byt ld | N6
    .byt push                   ; =bottom
    .byt ld | N7
    .byt sub | N6
    .byt push                   ; =howmany
    .byt nxt




pupd2
    jsr harvests10
    lda n+7                     ; N3+1
    sta n+12                    ; N6
    brk
    .byt ldd | TOS              ; isscr?
    .byt st | N5                ; save for later
    .byt bz , <(pupd2b-*-2)
    .byt ldd | TOS              ; editing?
    .byt bnz , <(pupd2a-*-2)
    .byt ldd | N1
    .byt std | N0
    .byt ldi | N1
    .byt sti | N0               ; use linewrap from blkbuf
    .byt br , <(pupd2b-*-2)
pupd2a
    .byt ld | N4
    .byt sti | N0
    .byt ld | N6
    .byt sti | N0
    .byt ld | N3
    .byt sti | N0
;    .byt ld | N3
;    .byt sti | N0
;    .byt ld | N6
;    .byt sti | N0
;    .byt ld | N4
;    .byt sti | N0              ; write linewrap to output
pupd2b
    ; setup for RLENCODE
    .byt ld | N1                ; from
    .byt st | TOS
    .byt ld | N0                ; to
    .byt push
    ; setup for -TRAILING or -NULLS
    .byt ld | N1                ; source
    .byt push
    .byt ld | N2                ; actual size
    .byt push
    .byt ld | N5                ; isscr?
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD3)
stack=( )
tags=vm,nosymbol

||^data|^editing<br/>screen|<|h
|TOS|0|<|<|
|N0|blkbuf|vidram|src|
|N1|b/buf|b/scr|srcbufsiz|
|N2|pkt|<|dst|
|N3|vmbuf|<|bottom|
|N4|b/buf|<|maxbufsiz|

( bottom targend-1 pkt-targend )
+move #blk! ;

~#packrat
#endif
pupd3
    lda tos+1                   ; SCRPKT flag bit to Carry
    ora stackh,x                ; UNCOMPRESSED? flag
    and #$c0
    sta tos+1
    jsr harvests8
    sty tos                     ; low byte of packet flags
    brk
    .byt ld | N2
    .byt sub | N1
    .byt add | TOS
    .byt st | N3                ; packet header
    .byt ldd | N3               ; +2
    .byt ld | N2
    .byt st | TOS
    .byt ld | N0
    .byt sub | TOS
    .byt dcr | TOS              ; =targend-1
    .byt push                   ; =pkt-targend
    .byt ld | N3
    .byt std | N0
    .byt nxt



















2r> @ (2const) >(const) >(cconst) caller callers r> rput >(create) >(does)
enter dlit uservar >(vocab)
^\ \ \ \ pla(.*)\n\ \ \ \ (sta|ta)

block 88
30 (upd1)
38 (upd2)
28 (upd3)
88 update

core   5918
symtab 3345
tdict  5289

cfetch
    clc
    .byt $29                    ; AND #
fetch
    sec
    ;
    ldy #0
    lda (tos),y
    bcc put

; out; YA = (tos),Y+1 (tos),Y
; in; Y = offset
; C = clear
; A = low byte
fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts
dotwoconst
    pla                         ; ~#callers
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom
doconst
    sec
    .byt $29                    ; AND #
docconst
    clc
    ;
    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put                     ; bra

    lda #<(doconst01)
    ldy #>(doconst01)
    bne somethingelse           ; bra
doconst01


twodrop
    inx
    ; fall through
drop
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next




padjust
    sec                         ; A = offset to be added to IP
    adc ip
    bcs padjust05               ; wrap the page?
    cmp #$FD                    ; IP $xxFE $xxFF will not blend
    bcc padjust06               ; same page?
    lda #$FE                    ; tail.  will it blend?
padjust05
    inc ip+1
padjust06
    sta ip
    rts
somethingelse
    sta ACC
    sty ACC+1
    clc
    .byt $29                    ; AND #
dodoes
    sec
    ;
    pla             ;{4}
    tay             ;{2}
    pla             ;{4}
    sta z           ;{3}
    jsr slip        ;{.}
    pla             ;{4}
    sta tos         ;{3}
    pla             ;{4}
    sta tos+1       ;{3}
    jsr inctos      ;{.}
    bcs enter01     ;{3}        ; branch for `>does`
    jmp (ACC)
enter
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta z           ;[3]
enter01
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda z           ;[3]
    iny
    bne jumpay      ;[3] bra `jsr enter` never goes at $xxFD
yikes
    sec
    bcs exit01                  ; bra



unloop
    ldy #$fc
unloop01
    pla
    sta zi-$fc,y  ; effective address $FF7C,y wraps around
    iny
    bne unloop01
    ;fall through
exit
    lda #2          ; [2]
exit04
    clc             ; [2]
exit05
    sta ip          ; [3]       ; entry A is added to IP
    pla             ; [4]
    adc ip          ; [3]
    tay             ; [2]
    pla             ; [4]
exit01
    adc #0          ; [2] = [12]
jumpay
    sta ip+1        ; [3]
exit03
    sty ip          ; [3]
    jmp nexto       ; [3]
toforth
    pla
    cmp #$FF
    tay
    pla
    iny
    adc #0
    jmp jumpay



i
    ldy zi+1
    lda zi
    ; fall through
pushya
    pha
    dex
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    pla
    jmp put
spfetch
    txa
push0a
    ldy #0
    beq pushya                  ; bra
dlit
    ldy #5
dlit01
    lda (ip),y
    pha
    dey
    bne dlit01
    pla
    lda #3
    jsr padjust
    jmp tworfrom                ; move IP past double constant, `2r>`
rfetch
j
    stx z           ; {3}
    tsx             ; {2}
    ldy $0102,x     ; {4}
    lda $0101,x     ; {4}
    ldx z           ; {3}
    jmp pushya      ; {14|15}
caller
    jsr slip
    pla
    tay
    pla
    sta z
    pla
    sta tos
    pla
    sta tos+1
    lda z
    pha
    tya
    pha
    jmp next



twofetch
    ldy #3
twofetch01
    lda (tos),y
    pha
    dey
    bpl twofetch01
    jsr slide
    ; fall through
tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next
rfrom
    jsr slip
rput
    pla
    sta tos
    pla
    sta tos+1
    jmp next



cstoreplus
    ldy tos
    jsr slide
    tya
    ldy #0
    sta (tos),y
    beq oneplus                 ; bra
docreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    ; fall through
oneplus
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
    ;fall through
inctos
    inc tos
    bne inctos01
    inc tos+1
inctos01
    rts



uservar
    clc
    ldy #1
    pla
    sta n
    pla
    sta n+1
    lda (n),y
    adc up
    ldy up+1
    bcc uservar02
    iny
uservar02
    jmp pushya



































































dovocabmosh
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocabm01
    dey
    bmi dovocabm03
    lda uservocabs,y
    beq dovocabm01
    cmp z
    beq dovocabm01
dovocabm02
    pha
    bne dovocabm01               ; bra
dovocabm03
    lda z
    pha
    ;ldy #$FF
dovocabm04
    iny
    pla
    sta uservocabs,y
    bne dovocabm04
    jmp next
[40]

vocabdedup
    ldy #0                      ; start after JSR DOVOCAB and new vocabid
vdedup02
    lda uservocabs+1,y
    beq vdedup04                ; all done when we hit FORTH vocab
    eor uservocabs              ; compare to new vocabid
    beq vdedup03                ; this vocabulary is a duplicate?
    iny
    bne vdedup02                ; bra
vdedup03
    iny
    lda uservocabs,y
    sta uservocabs-1,y
    bne vdedup03
vdedup04
    jmp next
[27]

_vdrop
    jsr enter
    .word vocabs
    .word oneplus
    .word vocabs
    .word nine
    .word cmove
    .word exit
[15]
[82]

: name
     ?refill 'stream swap >n6 2drop
     dup skip dup>r 1- <n6 +
     swap scan r> - >n8 dup
     if  over c! in 1+!
     else
          nip
     then ;

     if  over c! in 1+!
     dup \ something for nip
     then nip ;

_name
    jsr enter
    .word _qrefill
    .word _tickstream
    .word swap
    .word tozp
    .byt ACC+2*N6               ; set up buffer pointer `n6`
    .word twodrop
    .word dup
    .word skip
    .word duptor
    .word oneminus
    .word zpfrom
    .byt ACC+2*N6               ; buf
    .word plus
    .word swap
    .word scan
    .word rfrom
    .word minus
    .word tozp
    .byt ACC+2*N8
    .word dup
    .word qbranch
    .byt <(name01-*+1)
    .word over
    .word cstore
    .word in
    .word oneplusstore
    .word branch
    .byt <(name02-*+1)
name01
    .word nip
name02
    .word exit


_prefixzpfrom
    jsr enter
    .word exit

_prefixtozp
    jsr enter
    .word exit


_prefixs16reg
    jsr enter
    .word exit

: prefixnreg
     ?comp <n6 msb ;
_prefixnreg
    jsr enter
    .word _qcomp                ; must be compiling
    .word zpfrom
    .byt ACC+2*N6
    .word msb                   ; the flags
    .word exit

_prefixescopy
    jsr enter
    .word _qcomp                ; compilation only


    lda ACC+2*N6+1              ; flags ->N$
    lsr                         ; check `base` flag
    bcc notfound
    sec
    rol                         ; turn on `base` flag
    sta ACC+2*N6+1              ; flags ->N$
_prefixesregister
    jsr enter
    .word _qcomp
    .word caller
    .word

_prefixesbase
    jsr enter
    .word caller
    .word firstchar

_prefixdecimal
    jsr _prefixesbase
    .byt 10

_prefixhex
    jsr _prefixesbase
    .byt 16

_prefixboolean
    jsr _prefixesbase
    .byt 2

; set the negation flag in `r?h`
;
prefixnegate
    lda ACC+2*N6+1              ; no other flags can be on yet
    ;and #$FF
    beq pfneg01
numfail
    ldy #3
    jmp error                   ; abort" not found"
pfneg01
    lda #%11110000              ; $87
    sta ACC+2*N6+1
    jmp next

prefixes
     .byt prefixes01-*-1        ; number of prefixes
     .asc "-<>RN#$%"
prefixes01
    .word prefixnegate
    .word _prefixzpfrom
    .word _prefixtozp
    .word _prefixs16reg
    .word _prefixnreg
    .word _prefixdecimal
    .word _prefixhex
    .word _prefixboolean

firstchar
    ldy #0
    sty ACC+2*N6+1              ; negate, tofrom, reg, base flags--init all off
    sty ACC+2*N8+1              ; pointer to this prefix char
    lda (ACC+2*N7),y
    sta ACC+2*N8                ; length of number

nextchar
    inc ACC+2*N8+1
    ldy ACC+2*N8+1              ; pointer to next char
    lda (ACC+2*N7),y            ; get char
    jmp push0a


: prefix?   ( -- )
    'prefixes 1stchar >$15 ( n8h ) 2dup >idx ;
_prefixq
    jsr enter
    .word plit
    .word prefixes
    .word firstchar
    .word tozp
    .byt ACC+2*N8+1             ; n8h = the character under consideration
    .word twodup
    .word _toidx
    .word exit

pnumber
    brk
    .byt sub | ACC
    .byt st | N0
    .byt st | N1                ; zero out quotient
    .byt ldd | TOS
    .byt st | N6                ; set default `base` and flags to 0
    .byt pull
    .byt st | N7
    .byt pull
    .byt nxt


: number   ( addr -- d )
     base (number) prefix? ;
_devnumber
    jsr enter
    .word base
    .word xyzzy
    .word pnumber               ; more setup
    .word _prefixq              ; handle prefix characters
    .word exit



pla / sta / pla / sta pattern




tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next

fetch
    sec
    ldy #0
    lda (tos),y
    bcc put

; out; YA = (tos),Y+1 (tos),Y
; in; Y = offset
; C = clear
; A = low byte
fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of a word defined by 2CONSTANT
#endif
dotwoconst
    pla
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom


doconst
    sec
    .byt $29                    ; AND #
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT

docconst
    clc
    jsr callers
    lda (ACC),y
    bcs fetchyax
    ;ldy #1                     ; thanks, `callers`
    dey
    bcc put                     ; bra

    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put
#endif

[7]
_docconst
#include "align.i65"
    jsr dodoes
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word exit

~[19]
docconst
    clc
    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put                     ; bra


fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

dotwoconst
    pla                         ; ~#callers
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom

caller
    jsr slip
    pla
    tay
    pla
    sta z
    pla
    sta tos
    pla
    sta tos+1
    lda z
    pha
    tya
    pha
    jmp next

: addvocab   ( voc -- ) 		\ prepend to `vocab` list, without duplicates
	vocabs 10

	ld TOS
	st N2 						; counter
	pull
	add N2
	st N1 						; last vocab
	pull
	st N0 						; voc to add
	pull
avoc1
	dcr N2 						; countdown
	bz , avoc2
	pop N1 						; pointer
	bz , avoc1
	cpr N0
	bz , avoc1
	inr N1
	sti N1
	dcr N1
	br , avoc1
avoc2
	ld N0
	sti N1
	nxt

new
callers                         ; ~#callers
    pla
    sta ACC
    pla
    sta ACC+1
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

callers                         ; ~#callers
    pla
    tay
    pla
    sta z
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

rfrom
    jsr slip
rput
    pla
    sta tos
    pla
    sta tos+1
    jmp next

xxxdocreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

xxxdodoes
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta z           ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    jmp enter01

docreate
	ldy #<next
	lda #>next
	bne dodoes01

    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

dodoes
	ldy #<(enter01-1)
	lda #>(enter01-1)
	sty ACC
	sta ACC+1
    pla             ;[4]
    tay 			;[2]
    pla             ;[4]
dodoes01
    sty ACC         ;[3]
    sta ACC+1       ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    inc ACC
    bne dodoes02
    inc ACC+1
dodoes02
	jmp (ACC)

enter
    pla             ;[4]
    tay
    pla             ;[4]
    sta ACC+1       ;[2]
enter01
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda ACC+1       ;[3]
    iny
    bne jumpay      ;[3] bra `jsr enter` never goes at $xxFD
yikes
    sec
    bcs exit01

dlit
    ldy #5
dlit01
    lda (ip),y
    pha
    dey
    bne dlit01
    pla
    lda #3
    jsr padjust
    jmp tworfrom                ; move IP past double constant, `2r>`

uservar
    clc
    ldy #1
    pla
    sta n
    pla
    sta n+1
    lda (n),y
    adc up
    ldy up+1
    bcc uservar02
    iny
uservar02
    jmp pushya

dovocab
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocab01
    dey
    bmi dovocab03
    lda uservocabs,y
    beq dovocab01
    cmp z
    beq dovocab01
dovocab02
    pha
    bne dovocab01               ; bra
dovocab03
    lda z
    pha
    ;ldy #$FF
dovocab04
    iny
    pla
    sta uservocabs,y
    bne dovocab04
    jmp next



core diffs



diff --git a/core/src/core-double.a65 b/core/src/core-double.a65
index f61d733..bfee3c7 100644
--- a/core/src/core-double.a65
+++ b/core/src/core-double.a65
@@ -355,27 +355,26 @@ twofetch01
     dey
     bpl twofetch01
     jsr slide
-    ; fall through
+    bne tworfrom
+
 ;--------------------------------------------------------------
 #if 0
-name=2R>
-stack=( -- x1 x2 ) ( R; x1 x2 -- )
-tags=double,stack,ext
-
-Transfer cell pair x1 x2 from the return stack. Semantically equivalent to `R> R> SWAP`
+name=DO2CONST
+stack=( -- d )
+tags=nosymbol,inner
+Runtime behavior of a word defined by 2CONSTANT
 #endif
-tworfrom
-    jsr slip
-    dex
-    pla
-    sta tos
+dotwoconst
     pla
-    sta tos+1
-    pla
-    sta stackl,x
+    sta n
     pla
-    sta stackh,x
-    jmp next
+    sta n+1
+    ldy #4
+dotwoconst01
+    lda (n),y
+    pha
+    dey
+    bne dotwoconst01

 ;--------------------------------------------------------------
 #if 0
diff --git a/core/src/core-inner.a65 b/core/src/core-inner.a65
index 62eba05..d7d78a2 100644
--- a/core/src/core-inner.a65
+++ b/core/src/core-inner.a65
@@ -146,26 +146,6 @@ fetchyax

 ;--------------------------------------------------------------
 #if 0
-name=DO2CONST
-stack=( -- d )
-tags=nosymbol,inner
-Runtime behavior of a word defined by 2CONSTANT
-#endif
-dotwoconst
-    pla                         ; ~#callers
-    sta n
-    pla
-    sta n+1
-    ldy #4
-dotwoconst01
-    lda (n),y
-    pha
-    dey
-    bne dotwoconst01
-    jmp tworfrom
-
-;--------------------------------------------------------------
-#if 0
 name=DOCONST
 stack=( -- c )
 tags=nosymbol,inner
@@ -181,41 +161,13 @@ stack=( -- n )
 tags=nosymbol,inner,primitive
 Runtime behavior of a word defined by CCONSTANT

-docconst
-    clc
-    jsr callers
-    lda (ACC),y
-    bcs fetchyax
-    ;ldy #1                     ; thanks, `callers`
-    dey
-    bcc put                     ; bra
-
-    jsr slip
-    pla
-    sta tos
-    pla                         ; ~#callers
-    sta tos+1
-    ldy #1
-    lda (tos),y
-    bcs fetchyax
-    dey
-    bcc put
-
-_docconst
-#include "align.i65"
-    jsr dodoes
-#include "page.i65"
-    .word cfetch
-#include "pass.i65"
-    .word exit
-
 #endif

moshpit
2r> @ (2const) >(const) >(cconst) caller callers r> rput >(create) >(does)
enter dlit uservar >(vocab)
^\ \ \ \ pla(.*)\n\ \ \ \ (sta|ta)

dovocabmosh
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocabm01
    dey
    bmi dovocabm03
    lda uservocabs,y
    beq dovocabm01
    cmp z
    beq dovocabm01
dovocabm02
    pha
    bne dovocabm01               ; bra
dovocabm03
    lda z
    pha
    ;ldy #$FF
dovocabm04
    iny
    pla
    sta uservocabs,y
    bne dovocabm04
    jmp next
[40]

vocabdedup
    ldy #0                      ; start after JSR DOVOCAB and new vocabid
vdedup02
    lda uservocabs+1,y
    beq vdedup04                ; all done when we hit FORTH vocab
    eor uservocabs              ; compare to new vocabid
    beq vdedup03                ; this vocabulary is a duplicate?
    iny
    bne vdedup02                ; bra
vdedup03
    iny
    lda uservocabs,y
    sta uservocabs-1,y
    bne vdedup03
vdedup04
    jmp next
[27]

_vdrop
    jsr enter
    .word vocabs
    .word oneplus
    .word vocabs
    .word nine
    .word cmove
    .word exit
[15]
[82]

: name
     ?refill 'stream swap >n6 2drop
     dup skip dup>r 1- <n6 +
     swap scan r> - >n8 dup
     if  over c! in 1+!
     else
          nip
     then ;

     if  over c! in 1+!
     dup \ something for nip
     then nip ;

_name
    jsr enter
    .word _qrefill
    .word _tickstream
    .word swap
    .word tozp
    .byt ACC+2*N6               ; set up buffer pointer `n6`
    .word twodrop
    .word dup
    .word skip
    .word duptor
    .word oneminus
    .word zpfrom
    .byt ACC+2*N6               ; buf
    .word plus
    .word swap
    .word scan
    .word rfrom
    .word minus
    .word tozp
    .byt ACC+2*N8
    .word dup
    .word qbranch
    .byt <(name01-*+1)
    .word over
    .word cstore
    .word in
    .word oneplusstore
    .word branch
    .byt <(name02-*+1)
name01
    .word nip
name02
    .word exit


_prefixzpfrom
    jsr enter
    .word exit

_prefixtozp
    jsr enter
    .word exit


_prefixs16reg
    jsr enter
    .word exit

: prefixnreg
     ?comp <n6 msb ;
_prefixnreg
    jsr enter
    .word _qcomp                ; must be compiling
    .word zpfrom
    .byt ACC+2*N6
    .word msb                   ; the flags
    .word exit

_prefixescopy
    jsr enter
    .word _qcomp                ; compilation only


    lda ACC+2*N6+1              ; flags ->N$
    lsr                         ; check `base` flag
    bcc notfound
    sec
    rol                         ; turn on `base` flag
    sta ACC+2*N6+1              ; flags ->N$
_prefixesregister
    jsr enter
    .word _qcomp
    .word caller
    .word

_prefixesbase
    jsr enter
    .word caller
    .word firstchar

_prefixdecimal
    jsr _prefixesbase
    .byt 10

_prefixhex
    jsr _prefixesbase
    .byt 16

_prefixboolean
    jsr _prefixesbase
    .byt 2

; set the negation flag in `r?h`
;
prefixnegate
    lda ACC+2*N6+1              ; no other flags can be on yet
    ;and #$FF
    beq pfneg01
numfail
    ldy #3
    jmp error                   ; abort" not found"
pfneg01
    lda #%11110000              ; $87
    sta ACC+2*N6+1
    jmp next

prefixes
     .byt prefixes01-*-1        ; number of prefixes
     .asc "-<>RN#$%"
prefixes01
    .word prefixnegate
    .word _prefixzpfrom
    .word _prefixtozp
    .word _prefixs16reg
    .word _prefixnreg
    .word _prefixdecimal
    .word _prefixhex
    .word _prefixboolean

firstchar
    ldy #0
    sty ACC+2*N6+1              ; negate, tofrom, reg, base flags--init all off
    sty ACC+2*N8+1              ; pointer to this prefix char
    lda (ACC+2*N7),y
    sta ACC+2*N8                ; length of number

nextchar
    inc ACC+2*N8+1
    ldy ACC+2*N8+1              ; pointer to next char
    lda (ACC+2*N7),y            ; get char
    jmp push0a


: prefix?   ( -- )
    'prefixes 1stchar >$15 ( n8h ) 2dup >idx ;
_prefixq
    jsr enter
    .word plit
    .word prefixes
    .word firstchar
    .word tozp
    .byt ACC+2*N8+1             ; n8h = the character under consideration
    .word twodup
    .word _toidx
    .word exit

pnumber
    brk
    .byt sub | ACC
    .byt st | N0
    .byt st | N1                ; zero out quotient
    .byt ldd | TOS
    .byt st | N6                ; set default `base` and flags to 0
    .byt pull
    .byt st | N7
    .byt pull
    .byt nxt


: number   ( addr -- d )
     base (number) prefix? ;
_devnumber
    jsr enter
    .word base
    .word xyzzy
    .word pnumber               ; more setup
    .word _prefixq              ; handle prefix characters
    .word exit



pla / sta / pla / sta pattern




tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next

fetch
    sec
    ldy #0
    lda (tos),y
    bcc put

; out; YA = (tos),Y+1 (tos),Y
; in; Y = offset
; C = clear
; A = low byte
fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of a word defined by 2CONSTANT
#endif
dotwoconst
    pla
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom


doconst
    sec
    .byt $29                    ; AND #
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT

docconst
    clc
    jsr callers
    lda (ACC),y
    bcs fetchyax
    ;ldy #1                     ; thanks, `callers`
    dey
    bcc put                     ; bra

    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put
#endif

[7]
_docconst
#include "align.i65"
    jsr dodoes
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word exit

~[19]
docconst
    clc
    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put                     ; bra


fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

dotwoconst
    pla                         ; ~#callers
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom

caller
    jsr slip
    pla
    tay
    pla
    sta z
    pla
    sta tos
    pla
    sta tos+1
    lda z
    pha
    tya
    pha
    jmp next

: addvocab   ( voc -- ) 		\ prepend to `vocab` list, without duplicates
	vocabs 10

	ld TOS
	st N2 						; counter
	pull
	add N2
	st N1 						; last vocab
	pull
	st N0 						; voc to add
	pull
avoc1
	dcr N2 						; countdown
	bz , avoc2
	pop N1 						; pointer
	bz , avoc1
	cpr N0
	bz , avoc1
	inr N1
	sti N1
	dcr N1
	br , avoc1
avoc2
	ld N0
	sti N1
	nxt

new
callers                         ; ~#callers
    pla
    sta ACC
    pla
    sta ACC+1
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

callers                         ; ~#callers
    pla
    tay
    pla
    sta z
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

rfrom
    jsr slip
rput
    pla
    sta tos
    pla
    sta tos+1
    jmp next

xxxdocreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

xxxdodoes
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta z           ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    jmp enter01

docreate
	ldy #<next
	lda #>next
	bne dodoes01

    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

dodoes
	ldy #<(enter01-1)
	lda #>(enter01-1)
	sty ACC
	sta ACC+1
    pla             ;[4]
    tay 			;[2]
    pla             ;[4]
dodoes01
    sty ACC         ;[3]
    sta ACC+1       ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    inc ACC
    bne dodoes02
    inc ACC+1
dodoes02
	jmp (ACC)

enter
    pla             ;[4]
    tay
    pla             ;[4]
    sta ACC+1       ;[2]
enter01
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda ACC+1       ;[3]
    iny
    bne jumpay      ;[3] bra `jsr enter` never goes at $xxFD
yikes
    sec
    bcs exit01

dlit
    ldy #5
dlit01
    lda (ip),y
    pha
    dey
    bne dlit01
    pla
    lda #3
    jsr padjust
    jmp tworfrom                ; move IP past double constant, `2r>`

uservar
    clc
    ldy #1
    pla
    sta n
    pla
    sta n+1
    lda (n),y
    adc up
    ldy up+1
    bcc uservar02
    iny
uservar02
    jmp pushya

dovocab
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocab01
    dey
    bmi dovocab03
    lda uservocabs,y
    beq dovocab01
    cmp z
    beq dovocab01
dovocab02
    pha
    bne dovocab01               ; bra
dovocab03
    lda z
    pha
    ;ldy #$FF
dovocab04
    iny
    pla
    sta uservocabs,y
    bne dovocab04
    jmp next



core diffs



diff --git a/core/src/core-double.a65 b/core/src/core-double.a65
index f61d733..bfee3c7 100644
--- a/core/src/core-double.a65
+++ b/core/src/core-double.a65
@@ -355,27 +355,26 @@ twofetch01
     dey
     bpl twofetch01
     jsr slide
-    ; fall through
+    bne tworfrom
+
 ;--------------------------------------------------------------
 #if 0
-name=2R>
-stack=( -- x1 x2 ) ( R; x1 x2 -- )
-tags=double,stack,ext
-
-Transfer cell pair x1 x2 from the return stack. Semantically equivalent to `R> R> SWAP`
+name=DO2CONST
+stack=( -- d )
+tags=nosymbol,inner
+Runtime behavior of a word defined by 2CONSTANT
 #endif
-tworfrom
-    jsr slip
-    dex
-    pla
-    sta tos
+dotwoconst
     pla
-    sta tos+1
-    pla
-    sta stackl,x
+    sta n
     pla
-    sta stackh,x
-    jmp next
+    sta n+1
+    ldy #4
+dotwoconst01
+    lda (n),y
+    pha
+    dey
+    bne dotwoconst01

 ;--------------------------------------------------------------
 #if 0
diff --git a/core/src/core-inner.a65 b/core/src/core-inner.a65
index 62eba05..d7d78a2 100644
--- a/core/src/core-inner.a65
+++ b/core/src/core-inner.a65
@@ -146,26 +146,6 @@ fetchyax

 ;--------------------------------------------------------------
 #if 0
-name=DO2CONST
-stack=( -- d )
-tags=nosymbol,inner
-Runtime behavior of a word defined by 2CONSTANT
-#endif
-dotwoconst
-    pla                         ; ~#callers
-    sta n
-    pla
-    sta n+1
-    ldy #4
-dotwoconst01
-    lda (n),y
-    pha
-    dey
-    bne dotwoconst01
-    jmp tworfrom
-
-;--------------------------------------------------------------
-#if 0
 name=DOCONST
 stack=( -- c )
 tags=nosymbol,inner
@@ -181,41 +161,13 @@ stack=( -- n )
 tags=nosymbol,inner,primitive
 Runtime behavior of a word defined by CCONSTANT

-docconst
-    clc
-    jsr callers
-    lda (ACC),y
-    bcs fetchyax
-    ;ldy #1                     ; thanks, `callers`
-    dey
-    bcc put                     ; bra
-
-    jsr slip
-    pla
-    sta tos
-    pla                         ; ~#callers
-    sta tos+1
-    ldy #1
-    lda (tos),y
-    bcs fetchyax
-    dey
-    bcc put
-
-_docconst
-#include "align.i65"
-    jsr dodoes
-#include "page.i65"
-    .word cfetch
-#include "pass.i65"
-    .word exit
-
 #endif

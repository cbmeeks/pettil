moshpit

pkt-1024

vmbuf
vmbuf-1024+size-2
pkt-size-vmbuf+2
                                cmove
                                wrap@ rot 3c!
vidram
pkt-1024+3
vidram b/scr -trailing nip
                                rlencode


vmbuf
pkt size - 1+
b/buf negate
57f9 57fa -1024 +move

vmbuf
pkt size - 1+
b/buf negate +move

vidram 1000 -trailing
pkt b/buf -
wrap@ third 3c! 3+
swap rlencode


36864,4         horizontal pos
36865,26        vertical pos

objective: `update` works in all four scenarios

`update` makes a two-bit number combining the bits of `isscr?` and `editing?`
and uses the rts trick to deploy its handler
editing
A    screen
B    data
interpret
C    screen
D    data


current focus: 'A' editing screen


scr @ >pkt
pkt.size
vidram
wrap@
bperscr
(upd1)
vmbuf


+move





vmbuf
blkbuf
scr
pkt
pkt.floor  pkt-1024
1024
1000
wrap
rlencode.end
uncompressed?   $4000
isscr?          $8000
editing?
newpkt.length   rlencode.end-pkt.floor

`from` `to` `howmany` shouldn't surprise anyone who uses `cmove`
`end` address where the next byte would be written
`uncompressed?` is $4000 if it was cheaper to store the buffer, else 0

code rlencode   ( from to howmany -- end uncompressed? )
    tos     ld,
    n1      st,                 \ copies of `size`
    n3      st,
    n8      st,                 \ pristine copy
            pull,
    n2      st,                 \ `targ`
    n7      st,
            pull,
    n0      st,
    $100
    n6      set, ,
rlencode01
    n6      ld,
rlencode02
    n5      st,



src
targ



















: ^   ( -- )
    #blk @  scr !
    editing on
    vidram scrpkt !
    0 mkpkts
    update _ ;



: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;

: update   ( -- )
\ are there any blocks?  ?exit
\ scenario B (do not update DATA packet in editor)
    #blk @ 0= ?exit
\ editing? choose vidram blkbuf
    blkbuf
    editing?
    if
\ early exit if editing data packet
\ scenario A (update packet from VIDRAM)
        drop
\ editing & isscr? choose vidram as source
\ editing & !isscr? do not modify this data packet
        isscr?
        ?: vidram exit
    then
    vmbuf b/buf
\ use the packet in `blk`   or `scr`
\ use               `b/buf` or `b/scr`
               b/buf blk
    isscr?
    if
        2drop  b/scr scr
    then
\ spread out the packet by moving everything below it down 1K
    @ >pkt
    (upd1)
    cmove
\ stash 24-bit line wrap info at the front of the packet
    l/scr wrap^
\ set the `scrpkt` bit in the new packet header
    scrpkt
\ shorten the buffer with `-trailing`
    ?: -trailing -nulls
\ attempt to rlencode what is left
    nip rlencode
\ write new packet header
\ squeeze out unused space in new packet, move `vmbuf` to top of packet
    +move
\ recount packets
    #blk! ;

editing     on/off
scrpkt      $8000/0
#blk        min. 1 to play
scr         use if scrpkt & editing
blk         use if !editing
            use if !scrpkt


                    brk,
    n0              set,
    userediting     ,
    n0              ldd,






constants
b/buf   b/scr   l/scr   blkbuf
$0400   1000    25      $5800

editing?: true
isscr?:   true              A   vidram
isscr?:   false             B   exit

editing?: false                 blkbuf
isscr?:   true              C
isscr?:   false             D

exit if no blocks
exit if editing data packet
editing? vidram blkbuf
isscr?   vidram exit



cmove

25 wrap^

scrpkt

?: -trailing -nulls

rlencode

+move

#blk!








rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; n8    size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | N8                ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt ld | N2                ; targ (out)
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | N8                ; size
    .byt add | N7               ; +pristine targ
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt ld | N0
    .byt push
    .byt ld | N7
    .byt push
    .byt ld | N8
    .byt push
    .byt rtn
    jmp cmove


pupd1
    jsr harvests10
    brk
    .byt ldd | N1               ; vmbuf @
    .byt st | N5                ; save for later
    .byt sub | N2               ; vmbuf-1024
    .byt add | TOS              ; vmbuf-1024+size
    .byt dcr | ACC
    .byt dcr | ACC              ; vmbuf-1024+size-2
    .byt st | N6                ; save for later
    ; things we'll need for CMOVE+
    .byt st | TOS               ; =bottom
    .byt ld | N4                ; pkt
    .byt push                   ; =pkt
    .byt sub | N2               ; pkt-1024
    .byt st | N7                ; save for later
    .byt push                   ; =floor
    ; things we'll need for RLENCODE
    .byt push                   ; =dest
    .byt ld | N0                ; blkbuf|vidram
    .byt push                   ; =src
    .byt ld | N3                ; b/buf|b/scr
    .byt push                   ; =srcbufsiz
    ; things we'll need for CMOVE
    .byt ld | N5
    .byt push                   ; =from
    .byt ld | N6
    .byt push                   ; =bottom
    .byt ld | N7
    .byt sub | N6
    .byt push                   ; =howmany
    .byt nxt




pupd2
    jsr harvests10
    lda n+7                     ; N3+1
    sta n+12                    ; N6
    brk
    .byt ldd | TOS              ; isscr?
    .byt st | N5                ; save for later
    .byt bz , <(pupd2b-*-2)
    .byt ldd | TOS              ; editing?
    .byt bnz , <(pupd2a-*-2)
    .byt ldd | N1
    .byt std | N0
    .byt ldi | N1
    .byt sti | N0               ; use linewrap from blkbuf
    .byt br , <(pupd2b-*-2)
pupd2a
    .byt ld | N4
    .byt sti | N0
    .byt ld | N6
    .byt sti | N0
    .byt ld | N3
    .byt sti | N0
;    .byt ld | N3
;    .byt sti | N0
;    .byt ld | N6
;    .byt sti | N0
;    .byt ld | N4
;    .byt sti | N0              ; write linewrap to output
pupd2b
    ; setup for RLENCODE
    .byt ld | N1                ; from
    .byt st | TOS
    .byt ld | N0                ; to
    .byt push
    ; setup for -TRAILING or -NULLS
    .byt ld | N1                ; source
    .byt push
    .byt ld | N2                ; actual size
    .byt push
    .byt ld | N5                ; isscr?
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD3)
stack=( )
tags=vm,nosymbol

||^data|^editing<br/>screen|<|h
|TOS|0|<|<|
|N0|blkbuf|vidram|src|
|N1|b/buf|b/scr|srcbufsiz|
|N2|pkt|<|dst|
|N3|vmbuf|<|bottom|
|N4|b/buf|<|maxbufsiz|

( bottom targend-1 pkt-targend )
+move #blk! ;

~#packrat
#endif
pupd3
    lda tos+1                   ; SCRPKT flag bit to Carry
    ora stackh,x                ; UNCOMPRESSED? flag
    and #$c0
    sta tos+1
    jsr harvests8
    sty tos                     ; low byte of packet flags
    brk
    .byt ld | N2
    .byt sub | N1
    .byt add | TOS
    .byt st | N3                ; packet header
    .byt ldd | N3               ; +2
    .byt ld | N2
    .byt st | TOS
    .byt ld | N0
    .byt sub | TOS
    .byt dcr | TOS              ; =targend-1
    .byt push                   ; =pkt-targend
    .byt ld | N3
    .byt std | N0
    .byt nxt



















2r> @ (2const) >(const) >(cconst) caller callers r> rput >(create) >(does)
enter dlit uservar >(vocab)
^\ \ \ \ pla(.*)\n\ \ \ \ (sta|ta)

block 88
30 (upd1)
38 (upd2)
28 (upd3)
88 update

core   5918
symtab 3345
tdict  5289

cfetch
    clc
    .byt $29                    ; AND #
fetch
    sec
    ;
    ldy #0
    lda (tos),y
    bcc put

; out; YA = (tos),Y+1 (tos),Y
; in; Y = offset
; C = clear
; A = low byte
fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts
dotwoconst
    pla                         ; ~#callers
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom
doconst
    sec
    .byt $29                    ; AND #
docconst
    clc
    ;
    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put                     ; bra

    lda #<(doconst01)
    ldy #>(doconst01)
    bne somethingelse           ; bra
doconst01


twodrop
    inx
    ; fall through
drop
    ldy stackh,x
    lda stackl,x
    inx
put
    sty tos+1
    sta tos
    jmp next




padjust
    sec                         ; A = offset to be added to IP
    adc ip
    bcs padjust05               ; wrap the page?
    cmp #$FD                    ; IP $xxFE $xxFF will not blend
    bcc padjust06               ; same page?
    lda #$FE                    ; tail.  will it blend?
padjust05
    inc ip+1
padjust06
    sta ip
    rts
somethingelse
    sta ACC
    sty ACC+1
    clc
    .byt $29                    ; AND #
dodoes
    sec
    ;
    pla             ;{4}
    tay             ;{2}
    pla             ;{4}
    sta z           ;{3}
    jsr slip        ;{.}
    pla             ;{4}
    sta tos         ;{3}
    pla             ;{4}
    sta tos+1       ;{3}
    jsr inctos      ;{.}
    bcs enter01     ;{3}        ; branch for `>does`
    jmp (ACC)
enter
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta z           ;[3]
enter01
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda z           ;[3]
    iny
    bne jumpay      ;[3] bra `jsr enter` never goes at $xxFD
yikes
    sec
    bcs exit01                  ; bra



unloop
    ldy #$fc
unloop01
    pla
    sta zi-$fc,y  ; effective address $FF7C,y wraps around
    iny
    bne unloop01
    ;fall through
exit
    lda #2          ; [2]
exit04
    clc             ; [2]
exit05
    sta ip          ; [3]       ; entry A is added to IP
    pla             ; [4]
    adc ip          ; [3]
    tay             ; [2]
    pla             ; [4]
exit01
    adc #0          ; [2] = [12]
jumpay
    sta ip+1        ; [3]
exit03
    sty ip          ; [3]
    jmp nexto       ; [3]
toforth
    pla
    cmp #$FF
    tay
    pla
    iny
    adc #0
    jmp jumpay



i
    ldy zi+1
    lda zi
    ; fall through
pushya
    pha
    dex
    lda tos+1
    sta stackh,x
    lda tos
    sta stackl,x
    pla
    jmp put
spfetch
    txa
push0a
    ldy #0
    beq pushya                  ; bra
dlit
    ldy #5
dlit01
    lda (ip),y
    pha
    dey
    bne dlit01
    pla
    lda #3
    jsr padjust
    jmp tworfrom                ; move IP past double constant, `2r>`
rfetch
j
    stx z           ; {3}
    tsx             ; {2}
    ldy $0102,x     ; {4}
    lda $0101,x     ; {4}
    ldx z           ; {3}
    jmp pushya      ; {14|15}
caller
    jsr slip
    pla
    tay
    pla
    sta z
    pla
    sta tos
    pla
    sta tos+1
    lda z
    pha
    tya
    pha
    jmp next



twofetch
    ldy #3
twofetch01
    lda (tos),y
    pha
    dey
    bpl twofetch01
    jsr slide
    ; fall through
tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next
rfrom
    jsr slip
rput
    pla
    sta tos
    pla
    sta tos+1
    jmp next



cstoreplus
    ldy tos
    jsr slide
    tya
    ldy #0
    sta (tos),y
    beq oneplus                 ; bra
docreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    ; fall through
oneplus
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
    ;fall through
inctos
    inc tos
    bne inctos01
    inc tos+1
inctos01
    rts



uservar
    clc
    ldy #1
    pla
    sta n
    pla
    sta n+1
    lda (n),y
    adc up
    ldy up+1
    bcc uservar02
    iny
uservar02
    jmp pushya



































































dovocabmosh
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocabm01
    dey
    bmi dovocabm03
    lda uservocabs,y
    beq dovocabm01
    cmp z
    beq dovocabm01
dovocabm02
    pha
    bne dovocabm01               ; bra
dovocabm03
    lda z
    pha
    ;ldy #$FF
dovocabm04
    iny
    pla
    sta uservocabs,y
    bne dovocabm04
    jmp next
[40]

vocabdedup
    ldy #0                      ; start after JSR DOVOCAB and new vocabid
vdedup02
    lda uservocabs+1,y
    beq vdedup04                ; all done when we hit FORTH vocab
    eor uservocabs              ; compare to new vocabid
    beq vdedup03                ; this vocabulary is a duplicate?
    iny
    bne vdedup02                ; bra
vdedup03
    iny
    lda uservocabs,y
    sta uservocabs-1,y
    bne vdedup03
vdedup04
    jmp next
[27]

_vdrop
    jsr enter
    .word vocabs
    .word oneplus
    .word vocabs
    .word nine
    .word cmove
    .word exit
[15]
[82]

: name
     ?refill 'stream swap >n6 2drop
     dup skip dup>r 1- <n6 +
     swap scan r> - >n8 dup
     if  over c! in 1+!
     else
          nip
     then ;

     if  over c! in 1+!
     dup \ something for nip
     then nip ;

_name
    jsr enter
    .word _qrefill
    .word _tickstream
    .word swap
    .word tozp
    .byt ACC+2*N6               ; set up buffer pointer `n6`
    .word twodrop
    .word dup
    .word skip
    .word duptor
    .word oneminus
    .word zpfrom
    .byt ACC+2*N6               ; buf
    .word plus
    .word swap
    .word scan
    .word rfrom
    .word minus
    .word tozp
    .byt ACC+2*N8
    .word dup
    .word qbranch
    .byt <(name01-*+1)
    .word over
    .word cstore
    .word in
    .word oneplusstore
    .word branch
    .byt <(name02-*+1)
name01
    .word nip
name02
    .word exit


_prefixzpfrom
    jsr enter
    .word exit

_prefixtozp
    jsr enter
    .word exit


_prefixs16reg
    jsr enter
    .word exit

: prefixnreg
     ?comp <n6 msb ;
_prefixnreg
    jsr enter
    .word _qcomp                ; must be compiling
    .word zpfrom
    .byt ACC+2*N6
    .word msb                   ; the flags
    .word exit

_prefixescopy
    jsr enter
    .word _qcomp                ; compilation only


    lda ACC+2*N6+1              ; flags ->N$
    lsr                         ; check `base` flag
    bcc notfound
    sec
    rol                         ; turn on `base` flag
    sta ACC+2*N6+1              ; flags ->N$
_prefixesregister
    jsr enter
    .word _qcomp
    .word caller
    .word

_prefixesbase
    jsr enter
    .word caller
    .word firstchar

_prefixdecimal
    jsr _prefixesbase
    .byt 10

_prefixhex
    jsr _prefixesbase
    .byt 16

_prefixboolean
    jsr _prefixesbase
    .byt 2

; set the negation flag in `r?h`
;
prefixnegate
    lda ACC+2*N6+1              ; no other flags can be on yet
    ;and #$FF
    beq pfneg01
numfail
    ldy #3
    jmp error                   ; abort" not found"
pfneg01
    lda #%11110000              ; $87
    sta ACC+2*N6+1
    jmp next

prefixes
     .byt prefixes01-*-1        ; number of prefixes
     .asc "-<>RN#$%"
prefixes01
    .word prefixnegate
    .word _prefixzpfrom
    .word _prefixtozp
    .word _prefixs16reg
    .word _prefixnreg
    .word _prefixdecimal
    .word _prefixhex
    .word _prefixboolean

firstchar
    ldy #0
    sty ACC+2*N6+1              ; negate, tofrom, reg, base flags--init all off
    sty ACC+2*N8+1              ; pointer to this prefix char
    lda (ACC+2*N7),y
    sta ACC+2*N8                ; length of number

nextchar
    inc ACC+2*N8+1
    ldy ACC+2*N8+1              ; pointer to next char
    lda (ACC+2*N7),y            ; get char
    jmp push0a


: prefix?   ( -- )
    'prefixes 1stchar >$15 ( n8h ) 2dup >idx ;
_prefixq
    jsr enter
    .word plit
    .word prefixes
    .word firstchar
    .word tozp
    .byt ACC+2*N8+1             ; n8h = the character under consideration
    .word twodup
    .word _toidx
    .word exit

pnumber
    brk
    .byt sub | ACC
    .byt st | N0
    .byt st | N1                ; zero out quotient
    .byt ldd | TOS
    .byt st | N6                ; set default `base` and flags to 0
    .byt pull
    .byt st | N7
    .byt pull
    .byt nxt


: number   ( addr -- d )
     base (number) prefix? ;
_devnumber
    jsr enter
    .word base
    .word xyzzy
    .word pnumber               ; more setup
    .word _prefixq              ; handle prefix characters
    .word exit



pla / sta / pla / sta pattern




tworfrom
    jsr slip
    dex
    pla
    sta tos
    pla
    sta tos+1
    pla
    sta stackl,x
    pla
    sta stackh,x
    jmp next

fetch
    sec
    ldy #0
    lda (tos),y
    bcc put

; out; YA = (tos),Y+1 (tos),Y
; in; Y = offset
; C = clear
; A = low byte
fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

;--------------------------------------------------------------
#if 0
name=DO2CONST
stack=( -- d )
tags=nosymbol,inner
Runtime behavior of a word defined by 2CONSTANT
#endif
dotwoconst
    pla
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom


doconst
    sec
    .byt $29                    ; AND #
;--------------------------------------------------------------
#if 0
name=DOCCONST
stack=( -- n )
tags=nosymbol,inner,primitive
Runtime behavior of a word defined by CCONSTANT

docconst
    clc
    jsr callers
    lda (ACC),y
    bcs fetchyax
    ;ldy #1                     ; thanks, `callers`
    dey
    bcc put                     ; bra

    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put
#endif

[7]
_docconst
#include "align.i65"
    jsr dodoes
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word exit

~[19]
docconst
    clc
    jsr slip
    pla
    sta tos
    pla                         ; ~#callers
    sta tos+1
    ldy #1
    lda (tos),y
    bcs fetchyax
    dey
    bcc put                     ; bra


fetchyax
    pha
    iny
    lda (tos),y
    tay
    pla
    bcs put         ; bra
    rts

dotwoconst
    pla                         ; ~#callers
    sta n
    pla
    sta n+1
    ldy #4
dotwoconst01
    lda (n),y
    pha
    dey
    bne dotwoconst01
    jmp tworfrom

caller
    jsr slip
    pla
    tay
    pla
    sta z
    pla
    sta tos
    pla
    sta tos+1
    lda z
    pha
    tya
    pha
    jmp next

: addvocab   ( voc -- ) 		\ prepend to `vocab` list, without duplicates
	vocabs 10

	ld TOS
	st N2 						; counter
	pull
	add N2
	st N1 						; last vocab
	pull
	st N0 						; voc to add
	pull
avoc1
	dcr N2 						; countdown
	bz , avoc2
	pop N1 						; pointer
	bz , avoc1
	cpr N0
	bz , avoc1
	inr N1
	sti N1
	dcr N1
	br , avoc1
avoc2
	ld N0
	sti N1
	nxt

new
callers                         ; ~#callers
    pla
    sta ACC
    pla
    sta ACC+1
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

callers                         ; ~#callers
    pla
    tay
    pla
    sta z
    pla
    sta ACC
    pla
    sta ACC+1
    lda z
    pha
    tya
    pha
    ldy #1
    rts

rfrom
    jsr slip
rput
    pla
    sta tos
    pla
    sta tos+1
    jmp next

xxxdocreate
    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

xxxdodoes
    pla             ;[4]
    tay             ;[2]
    pla             ;[4]
    sta z           ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    jmp enter01

docreate
	ldy #<next
	lda #>next
	bne dodoes01

    jsr slip
    pla
    sta tos
    pla
    sta tos+1
    jmp oneplus

dodoes
	ldy #<(enter01-1)
	lda #>(enter01-1)
	sty ACC
	sta ACC+1
    pla             ;[4]
    tay 			;[2]
    pla             ;[4]
dodoes01
    sty ACC         ;[3]
    sta ACC+1       ;[3]
    jsr slip        ;[.]
    pla             ;[4]
    sta tos         ;[3]
    pla             ;[4]
    sta tos+1       ;[3]
    jsr inctos      ;[.]
    inc ACC
    bne dodoes02
    inc ACC+1
dodoes02
	jmp (ACC)

enter
    pla             ;[4]
    tay
    pla             ;[4]
    sta ACC+1       ;[2]
enter01
    lda ip+1        ;[3]
    pha             ;[3]
    lda ip          ;[3]
    pha             ;[3]
    lda ACC+1       ;[3]
    iny
    bne jumpay      ;[3] bra `jsr enter` never goes at $xxFD
yikes
    sec
    bcs exit01

dlit
    ldy #5
dlit01
    lda (ip),y
    pha
    dey
    bne dlit01
    pla
    lda #3
    jsr padjust
    jmp tworfrom                ; move IP past double constant, `2r>`

uservar
    clc
    ldy #1
    pla
    sta n
    pla
    sta n+1
    lda (n),y
    adc up
    ldy up+1
    bcc uservar02
    iny
uservar02
    jmp pushya

dovocab
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocab01
    dey
    bmi dovocab03
    lda uservocabs,y
    beq dovocab01
    cmp z
    beq dovocab01
dovocab02
    pha
    bne dovocab01               ; bra
dovocab03
    lda z
    pha
    ;ldy #$FF
dovocab04
    iny
    pla
    sta uservocabs,y
    bne dovocab04
    jmp next



core diffs



diff --git a/core/src/core-double.a65 b/core/src/core-double.a65
index f61d733..bfee3c7 100644
--- a/core/src/core-double.a65
+++ b/core/src/core-double.a65
@@ -355,27 +355,26 @@ twofetch01
     dey
     bpl twofetch01
     jsr slide
-    ; fall through
+    bne tworfrom
+
 ;--------------------------------------------------------------
 #if 0
-name=2R>
-stack=( -- x1 x2 ) ( R; x1 x2 -- )
-tags=double,stack,ext
-
-Transfer cell pair x1 x2 from the return stack. Semantically equivalent to `R> R> SWAP`
+name=DO2CONST
+stack=( -- d )
+tags=nosymbol,inner
+Runtime behavior of a word defined by 2CONSTANT
 #endif
-tworfrom
-    jsr slip
-    dex
-    pla
-    sta tos
+dotwoconst
     pla
-    sta tos+1
-    pla
-    sta stackl,x
+    sta n
     pla
-    sta stackh,x
-    jmp next
+    sta n+1
+    ldy #4
+dotwoconst01
+    lda (n),y
+    pha
+    dey
+    bne dotwoconst01

 ;--------------------------------------------------------------
 #if 0
diff --git a/core/src/core-inner.a65 b/core/src/core-inner.a65
index 62eba05..d7d78a2 100644
--- a/core/src/core-inner.a65
+++ b/core/src/core-inner.a65
@@ -146,26 +146,6 @@ fetchyax

 ;--------------------------------------------------------------
 #if 0
-name=DO2CONST
-stack=( -- d )
-tags=nosymbol,inner
-Runtime behavior of a word defined by 2CONSTANT
-#endif
-dotwoconst
-    pla                         ; ~#callers
-    sta n
-    pla
-    sta n+1
-    ldy #4
-dotwoconst01
-    lda (n),y
-    pha
-    dey
-    bne dotwoconst01
-    jmp tworfrom
-
-;--------------------------------------------------------------
-#if 0
 name=DOCONST
 stack=( -- c )
 tags=nosymbol,inner
@@ -181,41 +161,13 @@ stack=( -- n )
 tags=nosymbol,inner,primitive
 Runtime behavior of a word defined by CCONSTANT

-docconst
-    clc
-    jsr callers
-    lda (ACC),y
-    bcs fetchyax
-    ;ldy #1                     ; thanks, `callers`
-    dey
-    bcc put                     ; bra
-
-    jsr slip
-    pla
-    sta tos
-    pla                         ; ~#callers
-    sta tos+1
-    ldy #1
-    lda (tos),y
-    bcs fetchyax
-    dey
-    bcc put
-
-_docconst
-#include "align.i65"
-    jsr dodoes
-#include "page.i65"
-    .word cfetch
-#include "pass.i65"
-    .word exit
-
 #endif













: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;



: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;
```

: ^   ( -- )
    #blk @  scr !
    editing on
    vidram scrpkt !
    0 mkpkts
    update _ ;

: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;


scenario 1 - most typical, editing a code screen
    editing?        true
    isscr?          true
                                vidram
                                scr >pkt
                                b/scr

                                wrap! -trailing ?rlencode


scenario 2 - editing a data packet (read-only)
    editing?        true
    isscr?          false
                                exit

scenario 3 - not editing, `update` from blkbuf
    editing?        false
    isscr?          true

scenario 4 - user typed `update` (`editing? true` is the only other cause)
scenario 4
    !editing?
    isscr?


```
: update   ( -- )
    editing? 0=
    editing? isscr? and or      \ `data` packets are read-only in the editor
    #blk @ and                  \ there would have to be some blocks
    if
        >pkt
        cmove
        +move
        #blk!
    then ;

    editing? isscr? 0= blk @ and 0= ?exit
    #blk @
    editing?
    if isscr? xor
    then

     0=: screen blkbuf
    editing?

    if
        drop
;
: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;

: update   ( -- )
    #blk @  0= ?exit
    editing? isscr? 2* - 2*


```
    .word minus
    .word twostar
    .word blkbuf
    .word editingq
    .word qbranch
    .byt <(update01-*+1)
    .word drop
    .word isscrq
    .word pquerycolon
    .word vidram
    .word exit
update01
    .word vmbuf
    .word bperbuf
    .word bperbuf
    .word blk
    .word isscrq
    .word qbranch
    .byt <(update02-*+1)
    .word twodrop
    .word bperscr
    .word scr
update02
    .word fetch
    .word _to pkt
    .word _pktsize
    .word pupd1
    .word cmove
    .word lperscr               ; `l/scr` is 25 on a PET
    .word wrapabove
    .word scrpkt
    .word pupd2
    .word pquerycolon
    .word dashtrailing
    .word dashnulls
    .word nip
    .word rlencode
    .word isscrq
    .word pupd3
    .word _plusmove
    .word _numblkstore
    .word exit

update
    asl userscrpkt
    bit userediting
    php
    pla
    rol
    rol
    and #$03
    tay
    lda table+4,y
    pha
    lda table,y
    pha
    rts

table
    .byt <updatedata-1, <exit-1, <updatescrbuf-1, <updatescrvid-1
    .byt >updatedata-1, >exit-1, >updatescrbuf-1, >updatescrvid-1




0 scrpkt off, editing off (updates a data block)
2 scrpkt off, editing on (do not update data block, exit)
4 scrpkt on, editing off
6 scrpkt on, editing on





    bcc update01
    ; size = 1000               n1
    ; source = scr
    ;   @ >pkt                  >n2
    ;
update01
    bit userediting
    bmi

update01


update
    jsr enter
    .word numblk
    .word fetch
    .word zeq
    .word _qexit
    .word plit
    .word pupdtable+8
    .word editingq
    .word isscrq
    .word *+2
    brk
    .byt ld | TOS
    .byt st | N4                ; `n4` isscr?
    .byt pull
    .byt st | N5                ; `n5` editing?
    .byt add | N5               ; editing*2
    .byt add | N4               ; editing*2+isscr
    .byt add | ACC
    .byt st | N0
    .byt pull
    .byt add | N0
    .byt st | N0
    .byt ldd | N0
    .byt rtn
    jmp (ACC)
    .word ewwsville
    .word ewwsville             ; editin? isscr? both on
    .word exit
    .word ewwsville             ; editing? false; isscr? true

ewwsville
    .word exit


design:
 data types by naming convention
 '2','D' double e.g. `2!` `du<`
 '3C' triple byte e.g. `3c@`
    wrap


diff --git a/core/src/core-nucleus.a65 b/core/src/core-nucleus.a65
index 3beb507..3354048 100644
--- a/core/src/core-nucleus.a65
+++ b/core/src/core-nucleus.a65
@@ -1896,7 +1896,6 @@ dashtrailing03
     iny
     tya
     ldy tos+1
-    iny
     rts

 ;--------------------------------------------------------------
diff --git a/core/src/core-vm.a65 b/core/src/core-vm.a65
index f154f20..d150254 100644
--- a/core/src/core-vm.a65
+++ b/core/src/core-vm.a65
@@ -156,12 +156,12 @@ rlencode
     ; n5    prev
     ; n6    $100
     ; n7    targ (pristine)
-    ; n8    size (pristine)
+    ; r11   size (pristine)
     brk
     .byt ld | TOS               ; size
     .byt st | N1                ; size (in)
     .byt st | N3                ; size (out)
-    .byt st | N8                ; size (pristine)
+    .byt st | R11               ; size (pristine)
     .byt pull                   ; to
     .byt st | N2                ; targ (out)
     .byt st | N7                ; targ (pristine)
@@ -215,9 +215,11 @@ rlencode06                      ; win
 ;( targend uncompressed?        ; floor  pkt )

 rlencode07                      ; lose - copy
+    .byt ext
+    .word plugh
     .byt ld | TOS
     .byt st | N0                ; keep pristine TOS
-    .byt ld | N8                ; size
+    .byt ld | R11               ; size
     .byt add | N7               ; +pristine targ
     .byt st | TOS
     .byt set | ACC
@@ -227,10 +229,10 @@ rlencode07                      ; lose - copy
     .byt push
     .byt ld | N7
     .byt push
-    .byt ld | N8
+    .byt ld | R11
     .byt push
-    .byt rtn
-    jmp cmove
+    .byt ext
+    .word cmove

 ;--------------------------------------------------------------
 #if 0
@@ -308,9 +310,9 @@ pronounced: "packet-size"
 #include "align.i65"
 _pktsize
     jsr enter
-#include "pass.i65"
-    .word tozp
-    .byt ACC+2*N5               ; `n5` addr of this packet header
+#include "page.i65"
+    .word zpfrom
+    .byt ACC+2*N8
 #include "page.i65"
     .word dup
 #include "page.i65"
@@ -321,9 +323,6 @@ _pktsize
 #include "page.i65"
     .word andx
 #include "pass.i65"
-    .word tozp
-    .byt ACC+2*N8               ; `n8` size of this packet header
-#include "pass.i65"
     .word exit

 ;--------------------------------------------------------------
@@ -374,6 +373,9 @@ topktb01
 topktb02
     .word nip
 #include "pass.i65"
+    .word tozp
+    .byt ACC+2*N8               ; `n8` addr of this packet header
+#include "pass.i65"
     .word exit

 ;--------------------------------------------------------------
@@ -725,12 +727,12 @@ wrapfetch
 wrapfetch01
     lda LDTB1,y                 ;$E0 = 0, always $80  $E1-$F8
     asl
-    ror tos
-    ror stackh,x
     ror stackl,x
+    ror tos+1
+    ror tos                     ; weird inverted byte order here
     dey
     bne wrapfetch01
-    sty tos+1
+    sty stackh,x
     jmp next

 ;--------------------------------------------------------------
@@ -1564,9 +1566,6 @@ along with a couple values that are required later.
 |N5|b/buf|<|maxbufsiz|
 ( bottom pkt floor / src dest src srcbufsiz / vmbuf vmbuf-b/buf pkt-vmbuf )

-~#packrat
-#endif
-#include "align.i65"
 pupd1
     jsr harvests10
     brk
@@ -1600,26 +1599,6 @@ pupd1
     .byt push                   ; =howmany
     .byt nxt

-;--------------------------------------------------------------
-#if 0
-name=(UPD2)
-stack=( source floor actualsize wrapd 'scrpkt -- )
-tags=vm,nosymbol
-Sets up the linewrap bits in the output buffer (if needed) and
-gets ready for RLENCODE and squeezing out unused space
-
-||^data|^editing<br/>screen|<|h
-|TOS|'scrpkt|<|<|
-|N0|floor|<|<|
-|N1|blkbuf|vidram|src|
-|N2|b/buf|b/scr|srcbufsiz|
-|N3|wrapdlo|<|<|
-|N4|wrapdhi|<|<|
-
-need 3C@ and 3C! for linewrap
-
-~#packrat
-#endif
 pupd2
     jsr harvests10
     lda n+7                     ; N3+1
@@ -1663,25 +1642,6 @@ pupd2b
     .byt push
     .byt nxt

-;--------------------------------------------------------------
-#if 0
-name=(UPD3)
-stack=( )
-tags=vm,nosymbol
-
-||^data|^editing<br/>screen|<|h
-|TOS|0|<|<|
-|N0|blkbuf|vidram|src|
-|N1|b/buf|b/scr|srcbufsiz|
-|N2|pkt|<|dst|
-|N3|vmbuf|<|bottom|
-|N4|b/buf|<|maxbufsiz|
-
-( bottom targend-1 pkt-targend )
-+move #blk! ;
-
-~#packrat
-#endif
 pupd3
     lda tos+1                   ; SCRPKT flag bit to Carry
     ora stackh,x                ; UNCOMPRESSED? flag
@@ -1705,6 +1665,10 @@ pupd3
     .byt std | N0
     .byt nxt

+~#packrat
+#endif
+pupd3
+
 ;--------------------------------------------------------------
 #if 0
 name=UPDATE
@@ -1786,6 +1750,7 @@ updatedata
 updatescrvid
     ;sec                        ; thanks, `update`
     ror userscrpkt              ; output will be a screen packet
+                                ;( )
 #include "align.i65"
     jsr enter
 #include "page.i65"
@@ -1798,48 +1763,48 @@ updatescrvid
     .word _pktsize              ; ~ maybe fold this inside `>pkt`
 #include "page.i65"             ; `n5` pkt   `n8` pkt.size
     .word bperbuf
-#include "pass.i65"             ; `n5` pkt   `n8` pkt.size
-    .word tozp
-    .byt ACC+2*N4               ; `n4` is $0400 1024 b/buf
 #include "page.i65"
     .word twoplus
 #include "page.i65"
     .word minus
 #include "page.i65"
+    .word xyzzy
+
+
+#ifdef pigsfly
+: update
+    scr @  >pkt
+#endif
+
+
+
+
+                                ;( 57fe fc03 )
+#include "page.i65"
     .word _vmmove
 #include "page.i65"
     .word vidram                ; `from`
 #include "page.i65"
-    .word xyzzy
+    .word bperscr               ; 1000, max source size for screens
 #include "page.i65"
-    .word wrapfetch
+    .word dashtrailing
 #include "page.i65"
-    .word *+2
-
-wrap@ order is inverted
+    .word wrapfetch

-    brk
-    .byt ld | N5                ; pkt
-    .byt sub | N4               ; pkt-1024
-    .byt st | N7                ; floor
-    .byt ld | TOS               ; wrap.lo
-    .byt sti | N7
-    .byt pull                   ; wrap.mid wrap.hi
-    .byt std | N7
+; ~ wrap@ byte order is inverted for `(upd1)`, should probably be a `3c` type

-    .byt ld | N7                ; floor+3 `to`
-    .byt push
-    .byt nxt
-#include "align.i65"
-    jsr toforth
 #include "page.i65"
-    .word bperbuf
+    .word pupd1
 #include "page.i65"
-    .word dashtrailing
-
-                                    ;( vidram pkt-1024+3 1000-trailing )
+    .word swap
 #include "page.i65"
     .word rlencode
+#include "page.i65"
+    .word xyzzy
+
+  ;  1024-$577C+5401
+                                ;( targend uncompressed )
+                                    ;( vidram pkt-1024+3 1000-trailing )

 ;"from: screen
 ;"to:  pkt-1K
@@ -1893,5 +1858,18 @@ _vmmove
 #include "pass.i65"
     .word exit

+;(UPDATE1)
+pupd1
+    brk
+    .byt ld | N5                ; pkt
+    .byt sub | N4               ; pkt-1024
+    .byt st | N7                ; pkt.floor
+    .byt ld | TOS               ; wrap.mid wrap.hi
+    .byt std | N7
+    .byt pull                   ; wrap.lo
+    .byt sti | N7
+    .byt ld | N7
+    .byt st | TOS
+    .byt nxt

 #print (*-bperbuf)

moshpit


editing?
base1
base2

base1
5 ff ff ff 05 80
base2
2 02 80


count

vmbuf @
cmove


( blk )





todo:
fix update
set up axiom 49 keyboard with ubuntu studio
start Queen Bee design TiddlyWiki
PETTIL test automation
PETTIL test plan
PETTIL TiddlyWiki plugins
update tests

does not alter the stack
editing on|off
scrpkt $8000|0




^   pkt+ update _







: ^   ( -- )
    #blk @  scr !
    editing on
    vidram scrpkt !
    0 mkpkts
    update _ ;



: update   ( -- )
    #blk @ 0= ?exit                   \ early exit if buffer empty
    blkbuf  editing? if
        drop  isscr? ?: vidram exit     \ early exit if editing data
    then
    vmbuf b/buf
    b/buf blk  isscr? if
        2drop  b/scr scr
    then
    @ >pkt
    (upd1)
    cmove
    25 wrap^ scrpkt
    (upd2)
    ?: -trailing -nulls  nip rlencode isscr?
    (upd3)
    +move #blk! ;

: update   ( -- )
\ are there any blocks?  ?exit
\ scenario B (do not update DATA packet in editor)
    #blk @ 0= ?exit
\ editing? choose vidram blkbuf
    blkbuf
    editing?
    if
\ early exit if editing data packet
\ scenario A (update packet from VIDRAM)
        drop
\ editing & isscr? choose vidram as source
\ editing & !isscr? do not modify this data packet
        isscr?
        ?: vidram exit
    then
    vmbuf b/buf
\ use the packet in `blk`   or `scr`
\ use               `b/buf` or `b/scr`
               b/buf blk
    isscr?
    if
        2drop  b/scr scr
    then
\ spread out the packet by moving everything below it down 1K
    @ >pkt
    (upd1)
    cmove
\ stash 24-bit line wrap info at the front of the packet
    l/scr wrap^
\ set the `scrpkt` bit in the new packet header
    scrpkt
\ shorten the buffer with `-trailing`
    ?: -trailing -nulls
\ attempt to rlencode what is left
    nip rlencode
\ write new packet header
\ squeeze out unused space in new packet, move `vmbuf` to top of packet
    +move
\ recount packets
    #blk! ;

editing     on/off
scrpkt      $8000/0
#blk        min. 1 to play
scr         use if scrpkt & editing
blk         use if !editing
            use if !scrpkt


                    brk,
    n0              set,
    userediting     ,
    n0              ldd,






constants
b/buf   b/scr   l/scr   blkbuf
$0400   1000    25      $5800

editing?: true
isscr?:   true              A   vidram
isscr?:   false             B   exit

editing?: false                 blkbuf
isscr?:   true              C
isscr?:   false             D

exit if no blocks
exit if editing data packet
editing? vidram blkbuf
isscr?   vidram exit



cmove

25 wrap^

scrpkt

?: -trailing -nulls

rlencode

+move

#blk!

































dovocabmosh
    jsr callers                 ; ~ #callers
    lda (ACC),y                 ; this vocabulary id
    sta z
    lda #0
    pha                         ; sentinel value
    ldy #10                     ; bytes to move +1
dovocabm01
    dey
    bmi dovocabm03
    lda uservocabs,y
    beq dovocabm01
    cmp z
    beq dovocabm01
dovocabm02
    pha
    bne dovocabm01               ; bra
dovocabm03
    lda z
    pha
    ;ldy #$FF
dovocabm04
    iny
    pla
    sta uservocabs,y
    bne dovocabm04
    jmp next
[40]

vocabdedup
    ldy #0                      ; start after JSR DOVOCAB and new vocabid
vdedup02
    lda uservocabs+1,y
    beq vdedup04                ; all done when we hit FORTH vocab
    eor uservocabs              ; compare to new vocabid
    beq vdedup03                ; this vocabulary is a duplicate?
    iny
    bne vdedup02                ; bra
vdedup03
    iny
    lda uservocabs,y
    sta uservocabs-1,y
    bne vdedup03
vdedup04
    jmp next
[27]

_vdrop
    jsr enter
    .word vocabs
    .word oneplus
    .word vocabs
    .word nine
    .word cmove
    .word exit
[15]
[82]

: name
     ?refill 'stream swap >n6 2drop
     dup skip dup>r 1- <n6 +
     swap scan r> - >n8 dup
     if  over c! in 1+!
     else
          nip
     then ;

     if  over c! in 1+!
     dup \ something for nip
     then nip ;

_name
    jsr enter
    .word _qrefill
    .word _tickstream
    .word swap
    .word tozp
    .byt ACC+2*N6               ; set up buffer pointer `n6`
    .word twodrop
    .word dup
    .word skip
    .word duptor
    .word oneminus
    .word zpfrom
    .byt ACC+2*N6               ; buf
    .word plus
    .word swap
    .word scan
    .word rfrom
    .word minus
    .word tozp
    .byt ACC+2*N8
    .word dup
    .word qbranch
    .byt <(name01-*+1)
    .word over
    .word cstore
    .word in
    .word oneplusstore
    .word branch
    .byt <(name02-*+1)
name01
    .word nip
name02
    .word exit


_prefixzpfrom
    jsr enter
    .word exit

_prefixtozp
    jsr enter
    .word exit


_prefixs16reg
    jsr enter
    .word exit

: prefixnreg
     ?comp <n6 msb ;
_prefixnreg
    jsr enter
    .word _qcomp                ; must be compiling
    .word zpfrom
    .byt ACC+2*N6
    .word msb                   ; the flags
    .word exit

_prefixescopy
    jsr enter
    .word _qcomp                ; compilation only


    lda ACC+2*N6+1              ; flags ->N$
    lsr                         ; check `base` flag
    bcc notfound
    sec
    rol                         ; turn on `base` flag
    sta ACC+2*N6+1              ; flags ->N$
_prefixesregister
    jsr enter
    .word _qcomp
    .word caller
    .word

_prefixesbase
    jsr enter
    .word caller
    .word firstchar

_prefixdecimal
    jsr _prefixesbase
    .byt 10

_prefixhex
    jsr _prefixesbase
    .byt 16

_prefixboolean
    jsr _prefixesbase
    .byt 2

; set the negation flag in `r?h`
;
prefixnegate
    lda ACC+2*N6+1              ; no other flags can be on yet
    ;and #$FF
    beq pfneg01
numfail
    ldy #3
    jmp error                   ; abort" not found"
pfneg01
    lda #%11110000              ; $87
    sta ACC+2*N6+1
    jmp next

prefixes
     .byt prefixes01-*-1        ; number of prefixes
     .asc "-<>RN#$%"
prefixes01
    .word prefixnegate
    .word _prefixzpfrom
    .word _prefixtozp
    .word _prefixs16reg
    .word _prefixnreg
    .word _prefixdecimal
    .word _prefixhex
    .word _prefixboolean

firstchar
    ldy #0
    sty ACC+2*N6+1              ; negate, tofrom, reg, base flags--init all off
    sty ACC+2*N8+1              ; pointer to this prefix char
    lda (ACC+2*N7),y
    sta ACC+2*N8                ; length of number

nextchar
    inc ACC+2*N8+1
    ldy ACC+2*N8+1              ; pointer to next char
    lda (ACC+2*N7),y            ; get char
    jmp push0a


: prefix?   ( -- )
    'prefixes 1stchar >$15 ( n8h ) 2dup >idx ;
_prefixq
    jsr enter
    .word plit
    .word prefixes
    .word firstchar
    .word tozp
    .byt ACC+2*N8+1             ; n8h = the character under consideration
    .word twodup
    .word _toidx
    .word exit

pnumber
    brk
    .byt sub | ACC
    .byt st | N0
    .byt st | N1                ; zero out quotient
    .byt ldd | TOS
    .byt st | N6                ; set default `base` and flags to 0
    .byt pull
    .byt st | N7
    .byt pull
    .byt nxt


: number   ( addr -- d )
     base (number) prefix? ;
_devnumber
    jsr enter
    .word base
    .word xyzzy
    .word pnumber               ; more setup
    .word _prefixq              ; handle prefix characters
    .word exit



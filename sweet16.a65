; based on "http://6502.org/source/interpreters/sweet16.htm
;"********************************
;"*				 *
;"*   APPLE-II  PSEUDO MACHINE	 *
;"*	   INTERPRETER		 *
;"*				 *
;"*	COPYRIGHT (C) 1977	 *
;"*     APPLE COMPUTER,  INC	 *
;"*				 *
;"*     ALL  RIGHTS RESERVED	 *
;"*				 *
;"*	   S. WOZNIAK		 *
;"*				 *
;"********************************
;"*				 *
;"* TITLE:  SWEET 16 INTERPRETER *
;"*				 *
;"********************************
#define	set		$10
#define	ld		$20
#define	st		$30
#define	ldi		$40
#define	sti		$50
#define	ldd		$60
#define	std		$70
#define	pop		$80
#define	stpx		$90
#define	add		$A0
#define	sub		$B0
#define	popd		$C0
#define	cpr		$D0
#define	inr		$E0
#define	dcr		$F0
#define	rtn		$00
#define	br		$01
#define	bnc		$02
#define	bc		$03
#define	bp		$04
#define	bm		$05
#define	bz		$06
#define	bnz		$07
#define	bm1		$08
#define	bnm1		$09
#define	bk		$0A	; this is pretty worthless.  NEXT?
#define	rs		$0B
#define	bs		$0C
#define	ext		$0D ;general purpose extension, jumps via R0 to 6502
#define	pull		$0E ;drop TOS on the Forth data stack
#define	push		$0F ;push ACC to the Forth data stack

R0	=		$0	; ACC
#define R1		$1	; TOS
r1	=		2*R1
#define R2		$2	; UP
r2	=		2*R2
#define R3		$3	; I
r3	=		2*R3
#define R4		$4	; ILIMIT
r4	=		2*R4
#define R5		$5	; N0
r5	=		2*R5
#define R6		$6	; N1
r6	=		2*R6
#define R7		$7	; N2
r7	=		2*R7
#define R8		$8	; N3
r8	=		2*R8
#define R9		$9
r9	=		2*R9
#define R10		$a
r10	=		2*R10
#define R11		$b
r11	=		2*R11
#define R12		$c
r12	=		2*R12
#define R13		$d	; cpr result
r13	=		2*R13
#define R14		$e	; flags
r14	=		2*R14
#define R15		$f	; Sweet16 PC
r15	=		2*R15

#define	ACC		$0
#define	TOS		$1
#define	UP		$2
#define	IREG		$3
#define	ILIMIT		$4
#define	N0		$5
#define	N1		$6
#define	N2		$7
#define	N3		$8

#define	R0L		$0
#define	R0H		R0L+$1
#define	R14H		R0L+$1d
#define	R15L		R0L+$1e
#define	R15H		R0L+$1f

SW16	ldy $0106,x	;INIT SWEET16 PC
	lda $0105,x	;ADDRESS
	sec
	sbc #2
	bcs sw16a
	dey
sw16a	sty R15H
	sta R15L
SW16B	JSR SW16C	;INTERPRET AND EXECUTE
	JMP SW16B	;ONE SWEET16 INSTR.
SW16C 	INC R15L
	BNE SW16D	;INCR SWEET16 PC FOR FETCH
	INC R15H
SW16D	LDA #>SET	;COMMON HIGH BYTE FOR ALL ROUTINES
	PHA		;PUSH ON STACK FOR RTS
	LDY #0
	LDA (R15L),Y	;FETCH INSTR
	AND #$0F	;MASK REG SPECIFICATION
	ASL		;DOUBLE FOR TWO BYTE REGISTERS
	TAX		;TO X REG FOR INDEXING
	LSR
	EOR (R15L),Y	;NOW HAVE OPCODE
	BEQ TOBR	;IF ZERO THEN NON-REG OP
	STX R14H	;INDICATE "PRIOR RESULT REG"
	LSR
	LSR		;OPCODE*2 TO LSB'S
	LSR
	TAY		;TO Y REG FOR INDEXING
	LDA OPTBL-2,Y	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK
disp2	RTS		;GOTO REG-OP ROUTINE
TOBR	CPX #$1C
	BCS TOBR2	;0E, 0F instructions are single byte
	INC R15L
	BNE TOBR2	;INCR PC
	INC R15H
TOBR2	LDA BRTBL,X	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK FOR NON-REG OP
	LDA R14H	;"PRIOR RESULT REG" INDEX
	LSR		;PREPARE CARRY FOR BC, BNC.
disp1	RTS		;GOTO NON-REG OP ROUTINE
RTNZ	pla
	pla
	tsx
	lda R15L
	sta $0105,x
	lda R15H
	sta $0106,x
	PLA
	TAY
	PLA
	TAX
	PLA
	RTI
SETZ	LDA (R15L),Y	;HIGH ORDER BYTE OF CONSTANT
	STA R0H,X
	DEY
	LDA (R15L),Y	;LOW ORDER BYTE OF CONSTANT
	STA R0L,X
	TYA		;Y REG CONTAINS 1
	SEC
	ADC R15L	;ADD 2 TO PC
	STA R15L
	BCC SET2
	INC R15H
SET2	RTS
RSZ	LDX #$18	;12*2 FOR R12 AS STACK POINTER
	JSR DCR		;DECR STACK POINTER
	LDA (R0L,X)	;POP HIGH RETURN ADDRESS TO PC
	STA R15H
	JSR DCR		;SAME FOR LOW ORDER BYTE
	LDA (R0L,X)
	STA R15L
	RTS

OPTBL	.BYT <SET-1	;1X
BRTBL	.BYT <RTN-1	;0
	.BYT <LD-1	;2X
	.BYT <BR-1	;1
	.BYT <ST-1	;3X
	.BYT <BNC-1	;2
	.BYT <LDAT-1	;4X
	.BYT <BC-1	;3
	.BYT <STAT-1	;5X
	.BYT <BP-1	;4
	.BYT <LDDAT-1	;6X
	.BYT <BM-1	;5
	.BYT <STDAT-1	;7X
	.BYT <BZ-1	;6
	.BYT <POP-1	;8X
	.BYT <BNZ-1	;7
	.BYT <STPAT-1	;9X
	.BYT <BM1-1	;8
	.BYT <ADD-1	;AX
	.BYT <BNM1-1	;9
	.BYT <SUB-1	;BX
	.BYT <BK-1	;A
	.BYT <POPD-1	;CX
	.BYT <RS-1	;B
	.BYT <CPR-1	;DX
	.BYT <BS-1	;C
	.BYT <INR-1	;EX
	.BYT <EXT-1	;D
	.BYT <DCR-1	;FX
	.BYT <PULL-1	;E
	.BYT 0		;UNUSED
	.BYT <PUSH-1	;F

;* FOLLOWING CODE MUST BE
;* CONTAINED ON A SINGLE PAGE!

SET	BPL SETZ	;ALWAYS TAKEN
LD	LDA R0L,X
	STA R0L
	LDA R0H,X	;MOVE RX TO R0
	STA R0H
	RTS
ST	LDA R0L
	STA R0L,X	;MOVE R0 TO RX
	LDA R0H
	STA R0H,X
	RTS
STAT	LDA R0L
STAT2	STA (R0L,X)	;STORE BYTE INDIRECT
	LDY #0
STAT3	STY R14H	;INDICATE R0 IS RESULT NEG
INR	INC R0L,X
	BNE INR2	;INCR RX
	INC R0H,X
INR2	RTS
LDAT	LDA (R0L,X)	;LOAD INDIRECT (RX)
	STA R0L		;TO R0
	LDY #0
	STY R0H		;ZERO HIGH ORDER R0 BYTE
	BEQ STAT3	;ALWAYS TAKEN
POP	LDY #0		;HIGH ORDER BYTE = 0
	BEQ POP2	;ALWAYS TAKEN
POPD	JSR DCR		;DECR RX
	LDA (R0L,X)	;POP HIGH ORDER BYTE @RX
	TAY		;SAVE IN Y REG
POP2	JSR DCR		;DECR RX
	LDA (R0L,X)	;LOW ORDER BYTE
	STA R0L		;TO R0
	STY R0H
POP3	LDY #0		;INDICATE R0 AS LAST RESULT REG
	STY R14H
	RTS
LDDAT	JSR LDAT	;LOW ORDER BYTE TO R0, INCR RX
	LDA (R0L,X)	;HIGH ORDER BYTE TO R0
	STA R0H
	JMP INR		;INCR RX
STDAT	JSR STAT	;STORE INDIRECT LOW ORDER
	LDA R0H		;BYTE AND INCR RX. THEN
	STA (R0L,X)	;STORE HIGH ORDER BYTE.
	JMP INR		;INCR RX AND RETURN
STPAT	JSR DCR		;DECR RX
	LDA R0L
	STA (R0L,X)	;STORE R0 LOW BYTE @RX
	JMP POP3	;INDICATE R0 AS LAST RESULT REG
DCR	LDA R0L,X
	BNE DCR2	;DECR RX
	DEC R0H,X
DCR2	DEC R0L,X
	RTS
SUB	LDY #0		;RESULT TO R0
CPR	SEC		;NOTE Y REG = 13*2 FOR CPR
	LDA R0L
	SBC R0L,X
	STA R0L,Y	;R0-RX TO RY
	LDA R0H
	SBC R0H,X
SUB2	STA R0H,Y
	TYA		;LAST RESULT REG*2
	ADC #0		;CARRY TO LSB
	STA R14H
	RTS
ADD	LDA R0L
	ADC R0L,X
	STA R0L		;R0+RX TO R0
	LDA R0H
	ADC R0H,X
	LDY #0		;R0 FOR RESULT
	BEQ SUB2	;FINISH ADD
BS	LDA R15L	;NOTE X REG IS 12*2!
	JSR STAT2	;PUSH LOW PC BYTE VIA R12
	LDA R15H
	JSR STAT2	;PUSH HIGH ORDER PC BYTE
BR	CLC
BNC	BCS BNC2	;NO CARRY TEST
BR1	LDA (R15L),Y	;DISPLACEMENT BYTE
	BPL BR2
	DEY
BR2	ADC R15L	;ADD TO PC
	STA R15L
	TYA
	ADC R15H
	STA R15H
BNC2	RTS
BC	BCS BR
	RTS
BP	ASL		;DOUBLE RESULT-REG INDEX
	TAX		;TO X REG FOR INDEXING
	LDA R0H,X	;TEST FOR PLUS
	BPL BR1		;BRANCH IF SO
	RTS
BM	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0H,X	;TEST FOR MINUS
	BMI BR1
	RTS
BZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR ZERO
	ORA R0H,X	;(BOTH BYTES)
	BEQ BR1		;BRANCH IF SO
	RTS
BNZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR NON-ZERO
	ORA R0H,X	;(BOTH BYTES)
	BNE BR1		;BRANCH IF SO
	RTS
BM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;CHECK BOTH BYTES
	AND R0H,X	;FOR $FF (MINUS 1)
	EOR #$FF
	BEQ BR1		;BRANCH IF SO
	RTS
BNM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X
	AND R0H,X	;CHECK BOTH BYTES FOR NO $FF
	EOR #$FF
	BNE BR1		;BRANCH IF NOT MINUS 1
BK	RTS
RS	JMP RSZ
RTN	JMP RTNZ
EXT	LDX #r8		; SETZ will use R8 for the indirect transfer
	LDY #1		; point to high byte of transfer address
	JSR SETZ
	JMP (r8)	; implement your 6502 extension to Sweet16 here!
PULL	BPL PULLZ	; bra
PUSH	JSR getpstack	; get PETTIL stack pointer
	JSR slip	; push TOS -> Forth data stack (DUP in Forth)
	JSR putpstack	; update PETTIL stack pointer
	LDX #2
	JMP ST
PULLZ	JSR getpstack	; get PETTIL stack pointer
	JSR slide	; remove item from Forth data stack (DROP in Forth)
	JMP putpstack	; update PETTIL stack pointer

; return the parameter stack pointer in X
getpstack	tsx
		lda $0106,x
		tax
		rts

; set the parameter stack pointer on return from X
putpstack	txa
		tsx
		sta $0106,x
		rts

; pop the stack
slide		lda stackh,x		; slide something off of the stack
		sta tos+1
		lda stackl,x
		sta tos
		inx
		rts

; push TOS to the stack (DUP)
slip		dex			; slip something onto the stack
		lda tos+1
		sta stackh,x
		lda tos
		sta stackl,x
		rts


; compares the counted string at TOS
; vs the counted string pointed to by
; N0 and returns Z flag = true if the
; strings match, otherwise Z is false
; returns C flag = true iff the word in
; dictionary is longer than string it is
; being compared to, used for early
; exit when the chain is sorted by size
; in the core source
strcmp16	ldy #2
		lda (
		rts


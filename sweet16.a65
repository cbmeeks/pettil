;"http://6502.org/source/interpreters/sweet16.htm
;"********************************
;"*				*
;"*   APPLE-II  PSEUDO MACHINE	*
;"*	   INTERPRETER		*
;"*				*
;"*	COPYRIGHT (C) 1977	*
;"*     APPLE COMPUTER,  INC	*
;"*				*
;"*     ALL  RIGHTS RESERVED	*
;"*				*
;"*	   S. WOZNIAK		*
;"*				*
;"********************************
;"*				*
;"* TITLE:  SWEET 16 INTERPRETER *
;"*				*
;"********************************
set	= $10
ld	= $20
st	= $30
ldi	= $40
sti	= $50
ldd	= $60
std	= $70
pop	= $80
stpx	= $90
add	= $A0
sub	= $B0
popd	= $C0
cpr	= $D0
inr	= $E0
dcr	= $F0
rtn	= $00
br	= $01
bnc	= $02
bc	= $03
bp	= $04
bm	= $05
bz	= $06
bnz	= $07
bm1	= $08
bnm1	= $09
bk	= $0A ;(Unassigned)
rs	= $0B
bs	= $0C
	; $0D (Unassigned)
	; $0E (Unassigned)
	; $0F (Unassigned)

ACC	= $0
R0	= $0
R1	= $1
TOS	= $1
R2	= $2
N0	= $2
R3	= $3
N1	= $3
R4	= $4
N2	= $4
R5	= $5
N3	= $5
R6	= $6
UP	= $6
R7	= $7
R8	= $8
R9	= $9
R10	= $a
R11	= $b
R12	= $c
R13	= $d
R14	= $e
R15	= $f

R0L	= tos-2
R0H	= R0L+1
R14H	= R0L+29
R15L	= R0L+30
R15H	= R0L+31


;        AST  32

SW16	ldy $0106,x	;INIT SWEET16 PC
	lda $0105,x	;ADDRESS
	sec
	sbc #2
	bcs sw16a
	dey
sw16a	sty R15H
	sta R15L
SW16B	JSR SW16C	;INTERPRET AND EXECUTE
	JMP SW16B	;ONE SWEET16 INSTR.
SW16C 	INC R15L
	BNE SW16D	;INCR SWEET16 PC FOR FETCH
	INC R15H
SW16D	LDA #>SET	;COMMON HIGH BYTE FOR ALL ROUTINES
	PHA		;PUSH ON STACK FOR RTS
	LDY #0
	LDA (R15L),Y	;FETCH INSTR
	AND #$0F	;MASK REG SPECIFICATION
	ASL		;DOUBLE FOR TWO BYTE REGISTERS
	TAX		;TO X REG FOR INDEXING
	LSR
	EOR (R15L),Y	;NOW HAVE OPCODE
	BEQ TOBR	;IF ZERO THEN NON-REG OP
	STX R14H	;INDICATE "PRIOR RESULT REG"
	LSR
	LSR		;OPCODE*2 TO LSB'S
	LSR
	TAY		;TO Y REG FOR INDEXING
	LDA OPTBL-2,Y	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK
	RTS		;GOTO REG-OP ROUTINE
TOBR	INC R15L
	BNE TOBR2	;INCR PC
	INC R15H
TOBR2	LDA BRTBL,X	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK FOR NON-REG OP
	LDA R14H	;"PRIOR RESULT REG" INDEX
	LSR		;PREPARE CARRY FOR BC, BNC.
	RTS		;GOTO NON-REG OP ROUTINE
RTNZ	pla
	pla
	tsx
	lda R15L
	sta $0105,x
	lda R15H
	sta $0106,x
	PLA
	TAY
	PLA
	TAX
	PLA
	RTI
SETZ	LDA (R15L),Y	;HIGH ORDER BYTE OF CONSTANT
	STA R0H,X
	DEY
	LDA (R15L),Y	;LOW ORDER BYTE OF CONSTANT
	STA R0L,X
	TYA		;Y REG CONTAINS 1
	SEC
	ADC R15L	;ADD 2 TO PC
	STA R15L
	BCC SET2
	INC R15H
SET2	RTS
OPTBL	.BYT <SET-1	;1X
BRTBL	.BYT <RTN-1	;0
	.BYT <LD-1	;2X
	.BYT <BR-1	;1
	.BYT <ST-1	;3X
	.BYT <BNC-1	;2
	.BYT <LDAT-1	;4X
	.BYT <BC-1	;3
	.BYT <STAT-1	;5X
	.BYT <BP-1	;4
	.BYT <LDDAT-1	;6X
	.BYT <BM-1	;5
	.BYT <STDAT-1	;7X
	.BYT <BZ-1	;6
	.BYT <POP-1	;8X
	.BYT <BNZ-1	;7
	.BYT <STPAT-1	;9X
	.BYT <BM1-1	;8
	.BYT <ADD-1	;AX
	.BYT <BNM1-1	;9
	.BYT <SUB-1	;BX
	.BYT <BK-1	;A
	.BYT <POPD-1	;CX
	.BYT <RS-1	;B
	.BYT <CPR-1	;DX
	.BYT <BS-1	;C
	.BYT <INR-1	;EX
	.BYT <NUL-1	;D
	.BYT <DCR-1	;FX
	.BYT <NUL-1	;E
	.BYT <NUL-1	;UNUSED
	.BYT <NUL-1	;F

;* FOLLOWING CODE MUST BE
;* CONTAINED ON A SINGLE PAGE!

SET	BPL SETZ	;ALWAYS TAKEN
LD	LDA R0L,X
	STA R0L
	LDA R0H,X	;MOVE RX TO R0
	STA R0H
	RTS
ST	LDA R0L
	STA R0L,X	;MOVE R0 TO RX
	LDA R0H
	STA R0H,X
	RTS
STAT	LDA R0L
STAT2	STA (R0L,X)	;STORE BYTE INDIRECT
	LDY #0
BK	= *-1
STAT3	STY R14H	;INDICATE R0 IS RESULT NEG
INR	INC R0L,X
	BNE INR2	;INCR RX
	INC R0H,X
INR2	RTS
LDAT	LDA (R0L,X)	;LOAD INDIRECT (RX)
	STA R0L		;TO R0
	LDY #0
	STY R0H		;ZERO HIGH ORDER R0 BYTE
	BEQ STAT3	;ALWAYS TAKEN
POP	LDY #0		;HIGH ORDER BYTE = 0
	BEQ POP2	;ALWAYS TAKEN
POPD	JSR DCR		;DECR RX
	LDA (R0L,X)	;POP HIGH ORDER BYTE @RX
	TAY		;SAVE IN Y REG
POP2	JSR DCR		;DECR RX
	LDA (R0L,X)	;LOW ORDER BYTE
	STA R0L		;TO R0
	STY R0H
POP3	LDY #0		;INDICATE R0 AS LAST RESULT REG
	STY R14H
	RTS
LDDAT	JSR LDAT	;LOW ORDER BYTE TO R0, INCR RX
	LDA (R0L,X)	;HIGH ORDER BYTE TO R0
	STA R0H
	JMP INR		;INCR RX
STDAT	JSR STAT	;STORE INDIRECT LOW ORDER
	LDA R0H		;BYTE AND INCR RX. THEN
	STA (R0L,X)	;STORE HIGH ORDER BYTE.
	JMP INR		;INCR RX AND RETURN
STPAT	JSR DCR		;DECR RX
	LDA R0L
	STA (R0L,X)	;STORE R0 LOW BYTE @RX
	JMP POP3	;INDICATE R0 AS LAST RESULT REG
DCR	LDA R0L,X
	BNE DCR2	;DECR RX
	DEC R0H,X
DCR2	DEC R0L,X
	RTS
SUB	LDY #0		;RESULT TO R0
	CPR SEC		;NOTE Y REG = 13*2 FOR CPR
	LDA R0L
	SBC R0L,X
	STA R0L,Y	;R0-RX TO RY
	LDA R0H
	SBC R0H,X
SUB2	STA R0H,Y
	TYA		;LAST RESULT REG*2
	ADC #0		;CARRY TO LSB
	STA R14H
	RTS
ADD	LDA R0L
	ADC R0L,X
	STA R0L		;R0+RX TO R0
	LDA R0H
	ADC R0H,X
	LDY #0		;R0 FOR RESULT
	BEQ SUB2	;FINISH ADD
BS	LDA R15L	;NOTE X REG IS 12*2!
	JSR STAT2	;PUSH LOW PC BYTE VIA R12
	LDA R15H
	JSR STAT2	;PUSH HIGH ORDER PC BYTE
BR	CLC
BNC	BCS BNC2	;NO CARRY TEST
BR1	LDA (R15L),Y	;DISPLACEMENT BYTE
	BPL BR2
	DEY
BR2	ADC R15L	;ADD TO PC
	STA R15L
	TYA
	ADC R15H
	STA R15H
BNC2	RTS
BC	BCS BR
	RTS
BP	ASL		;DOUBLE RESULT-REG INDEX
	TAX		;TO X REG FOR INDEXING
	LDA R0H,X	;TEST FOR PLUS
	BPL BR1		;BRANCH IF SO
	RTS
BM	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0H,X	;TEST FOR MINUS
	BMI BR1
	RTS
BZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR ZERO
	ORA R0H,X	;(BOTH BYTES)
	BEQ BR1		;BRANCH IF SO
	RTS
BNZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR NON-ZERO
	ORA R0H,X	;(BOTH BYTES)
	BNE BR1		;BRANCH IF SO
	RTS
BM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;CHECK BOTH BYTES
	AND R0H,X	;FOR $FF (MINUS 1)
	EOR #$FF
	BEQ BR1		;BRANCH IF SO
	RTS
BNM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X
	AND R0H,X	;CHECK BOTH BYTES FOR NO $FF
	EOR #$FF
	BNE BR1		;BRANCH IF NOT MINUS 1
NUL	RTS
RS	LDX #$18	;12*2 FOR R12 AS STACK POINTER
	JSR DCR		;DECR STACK POINTER
	LDA (R0L,X)	;POP HIGH RETURN ADDRESS TO PC
	STA R15H
	JSR DCR		;SAME FOR LOW ORDER BYTE
	LDA (R0L,X)
	STA R15L
	RTS
RTN	JMP RTNZ


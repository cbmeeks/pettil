; based on "http://6502.org/source/interpreters/sweet16.htm
;"********************************
;"*				 *
;"*   APPLE-II  PSEUDO MACHINE	 *
;"*	   INTERPRETER		 *
;"*				 *
;"*	COPYRIGHT (C) 1977	 *
;"*     APPLE COMPUTER,  INC	 *
;"*				 *
;"*     ALL  RIGHTS RESERVED	 *
;"*				 *
;"*	   S. WOZNIAK		 *
;"*				 *
;"********************************
;"*				 *
;"* TITLE:  SWEET 16 INTERPRETER *
;"*				 *
;"********************************
; set Rn, constant		Rn <-- constant
#define	set		$10

; load Rn			R0 <-- Rn
#define	ld		$20

; store Rn			Rn <-- R0
#define	st		$30

; load indirect	Rn		R0L <-- (Rn++); R0H <-- 0
#define	ldi		$40

; store indirect Rn		(Rn++) <-- R0L
#define	sti		$50

; load double indirect Rn	R0L <-- (Rn++); R0H <-- (Rn++)
#define	ldd		$60

; store double indirect Rn	(Rn++) <-- R0L; (Rn++) <-- R0H
#define	std		$70

; pop indirect Rn		R0L <-- (--Rn); R0H <-- 0
#define	pop		$80

; store pop indirect Rn		(--Rn) <-- R0L
#define	stpx		$90

; add Rn			R0 <-- R0 + Rn
#define	add		$A0

; sub Rn			R0 <-- R0 - Rn
#define	sub		$B0

; pop double indirect Rn	R0H <-- (--Rn); R0L <-- (--Rn)
#define	popd		$C0

; compare Rn			R13 <-- R0 - Rn
#define	cpr		$D0

; increment Rn			Rn++
#define	inr		$E0

; decrement Rn			Rn--
#define	dcr		$F0

; return to 6502 mode
#define	rtn		$00

; branch always, offset		R15 <-- R15 +/- offset
#define	br		$01

; branch if no carry, offset	R15 <-- R15 +/- offset if R14L bit 1 is clear
#define	bnc		$02

; branch if carry, offset	R15 <-- R15 +/- offset if R14L bit 1 is set
#define	bc		$03

; branch if plus, offset	R15 <-- R15 +/- offset if prior result is positive
#define	bp		$04

; branch if minus, offset	R15 <-- R15 +/- offset if prior result is negative
#define	bm		$05

; branch if zero, offset	R15 <-- R15 +/- offset if prior result is 0
#define	bz		$06

; branch if not zero, offset	R15 <-- R15 +/- offset if prior result is not 0
#define	bnz		$07

; branch if -1, offset		R15 <-- R15 +/- offset if prior result is -1
#define	bm1		$08

; branch if not -1, offset	R15 <-- R15 +/- offset if prior result is not -1
#define	bnm1		$09

; break				executes a break instruction ~wut?
#define	bk		$0A

; return from subroutine	R15 <-- (R12--); R12--
#define	rs		$0B

; branch to subroutine, offset	(R12++) <-- R15; R12++ ; R15 <-- R15 +/- offset
#define	bs		$0C

; extension, address		jumps via R8 to native 6502 code, ended by RTS
#define	ext		$0D

; pull TOS from the Forth data stack
#define	pull		$0E

; push R0 to the Forth data stack
#define	push		$0F

#define R0		$0
r0	=		2*R0	; ACC
#define R1		$1
r1	=		2*R1	; TOS
#define R2		$2
r2	=		2*R2	; UP
#define R3		$3
r3	=		2*R3	; I
#define R4		$4
r4	=		2*R4	; ILIMIT
#define R5		$5
r5	=		2*R5	; N0
#define R6		$6
r6	=		2*R6	; N1
#define R7		$7
r7	=		2*R7	; N2
#define R8		$8
r8	=		2*R8	; N3
#define R9		$9
r9	=		2*R9
#define R10		$a
r10	=		2*R10
#define R11		$b
r11	=		2*R11
#define R12		$c
r12	=		2*R12
#define R13		$d
r13	=		2*R13	; cpr result
#define R14		$e
r14	=		2*R14	; flags
#define R15		$f
r15	=		2*R15	; Sweet16 PC

#define	ACC		$0
#define	TOS		$1
#define	UP		$2
#define	IREG		$3
#define	ILIMIT		$4
#define	N0		$5
#define	N1		$6
#define	N2		$7
#define	N3		$8

#define	R0L		$0
#define	R0H		R0L+$1
#define	R14H		R0L+$1d
#define	R15L		R0L+$1e
#define	R15H		R0L+$1f

SW16	ldy $0106,x	;INIT SWEET16 PC
	lda $0105,x	;ADDRESS
	sec
	sbc #2
	bcs sw16a
	dey
sw16a	sty R15H
	sta R15L
SW16B	JSR SW16C	;INTERPRET AND EXECUTE
	JMP SW16B	;ONE SWEET16 INSTR.
SW16C 	INC R15L
	BNE SW16D	;INCR SWEET16 PC FOR FETCH
	INC R15H
SW16D	LDA #>SET	;COMMON HIGH BYTE FOR ALL ROUTINES
	PHA		;PUSH ON STACK FOR RTS
	LDY #0
	LDA (R15L),Y	;FETCH INSTR
	AND #$0F	;MASK REG SPECIFICATION
	ASL		;DOUBLE FOR TWO BYTE REGISTERS
	TAX		;TO X REG FOR INDEXING
	LSR
	EOR (R15L),Y	;NOW HAVE OPCODE
	BEQ TOBR	;IF ZERO THEN NON-REG OP
	STX R14H	;INDICATE "PRIOR RESULT REG"
	LSR
	LSR		;OPCODE*2 TO LSB'S
	LSR
	TAY		;TO Y REG FOR INDEXING
	LDA OPTBL-2,Y	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK
disp1	RTS		;GOTO REG-OP ROUTINE
TOBR	CPX #$1C
	BCS TOBR2	;0E, 0F instructions are single byte
	INC R15L
	BNE TOBR2	;INCR PC
	INC R15H
TOBR2	LDA BRTBL,X	;LOW ORDER ADR BYTE
	PHA		;ONTO STACK FOR NON-REG OP
	LDA R14H	;"PRIOR RESULT REG" INDEX
	LSR		;PREPARE CARRY FOR BC, BNC.
disp2	RTS		;GOTO NON-REG OP ROUTINE
RTNZ	pla
	pla
	tsx
	lda R15L
	sta $0105,x
	lda R15H
	sta $0106,x
	PLA
	TAY
	PLA
	TAX
	PLA
	RTI
SETZ	LDA (R15L),Y	;HIGH ORDER BYTE OF CONSTANT
	STA R0H,X
	DEY
	LDA (R15L),Y	;LOW ORDER BYTE OF CONSTANT
	STA R0L,X
	TYA		;Y REG CONTAINS 1
	SEC
	ADC R15L	;ADD 2 TO PC
	STA R15L
	BCC SET2
	INC R15H
SET2	RTS
RSZ	LDX #$18	;12*2 FOR R12 AS STACK POINTER
	JSR DCR		;DECR STACK POINTER
	LDA (R0L,X)	;POP HIGH RETURN ADDRESS TO PC
	STA R15H
	JSR DCR		;SAME FOR LOW ORDER BYTE
	LDA (R0L,X)
	STA R15L
	RTS

OPTBL	.BYT <SET-1	;1X
BRTBL	.BYT <RTN-1	;0
	.BYT <LD-1	;2X
	.BYT <BR-1	;1
	.BYT <ST-1	;3X
	.BYT <BNC-1	;2
	.BYT <LDAT-1	;4X
	.BYT <BC-1	;3
	.BYT <STAT-1	;5X
	.BYT <BP-1	;4
	.BYT <LDDAT-1	;6X
	.BYT <BM-1	;5
	.BYT <STDAT-1	;7X
	.BYT <BZ-1	;6
	.BYT <POP-1	;8X
	.BYT <BNZ-1	;7
	.BYT <STPAT-1	;9X
	.BYT <BM1-1	;8
	.BYT <ADD-1	;AX
	.BYT <BNM1-1	;9
	.BYT <SUB-1	;BX
	.BYT <BK-1	;A
	.BYT <POPD-1	;CX
	.BYT <RS-1	;B
	.BYT <CPR-1	;DX
	.BYT <BS-1	;C
	.BYT <INR-1	;EX
	.BYT <EXT-1	;D
	.BYT <DCR-1	;FX
	.BYT <PULL-1	;E
	.BYT 0		;UNUSED
	.BYT <PUSH-1	;F

;* FOLLOWING CODE MUST BE
;* CONTAINED ON A SINGLE PAGE!

SET	BPL SETZ	;ALWAYS TAKEN
LD	LDA R0L,X
	STA R0L
	LDA R0H,X	;MOVE RX TO R0
	STA R0H
	RTS
ST	LDA R0L
	STA R0L,X	;MOVE R0 TO RX
	LDA R0H
	STA R0H,X
	RTS
STAT	LDA R0L
STAT2	STA (R0L,X)	;STORE BYTE INDIRECT
	LDY #0
STAT3	STY R14H	;INDICATE R0 IS RESULT NEG
INR	INC R0L,X
	BNE INR2	;INCR RX
	INC R0H,X
INR2	RTS
LDAT	LDA (R0L,X)	;LOAD INDIRECT (RX)
	STA R0L		;TO R0
	LDY #0
	STY R0H		;ZERO HIGH ORDER R0 BYTE
	BEQ STAT3	;ALWAYS TAKEN
POP	LDY #0		;HIGH ORDER BYTE = 0
	BEQ POP2	;ALWAYS TAKEN
POPD	JSR DCR		;DECR RX
	LDA (R0L,X)	;POP HIGH ORDER BYTE @RX
	TAY		;SAVE IN Y REG
POP2	JSR DCR		;DECR RX
	LDA (R0L,X)	;LOW ORDER BYTE
	STA R0L		;TO R0
	STY R0H
POP3	LDY #0		;INDICATE R0 AS LAST RESULT REG
	STY R14H
	RTS
LDDAT	JSR LDAT	;LOW ORDER BYTE TO R0, INCR RX
	LDA (R0L,X)	;HIGH ORDER BYTE TO R0
	STA R0H
	JMP INR		;INCR RX
STDAT	JSR STAT	;STORE INDIRECT LOW ORDER
	LDA R0H		;BYTE AND INCR RX. THEN
	STA (R0L,X)	;STORE HIGH ORDER BYTE.
	JMP INR		;INCR RX AND RETURN
STPAT	JSR DCR		;DECR RX
	LDA R0L
	STA (R0L,X)	;STORE R0 LOW BYTE @RX
	JMP POP3	;INDICATE R0 AS LAST RESULT REG
DCR	LDA R0L,X
	BNE DCR2	;DECR RX
	DEC R0H,X
DCR2	DEC R0L,X
	RTS
SUB	LDY #0		;RESULT TO R0
CPR	SEC		;NOTE Y REG = 13*2 FOR CPR
	LDA R0L
	SBC R0L,X
	STA R0L,Y	;R0-RX TO RY
	LDA R0H
	SBC R0H,X
SUB2	STA R0H,Y
	TYA		;LAST RESULT REG*2
	ADC #0		;CARRY TO LSB
	STA R14H
	RTS
ADD	LDA R0L
	ADC R0L,X
	STA R0L		;R0+RX TO R0
	LDA R0H
	ADC R0H,X
	LDY #0		;R0 FOR RESULT
	BEQ SUB2	;FINISH ADD
BS	LDA R15L	;NOTE X REG IS 12*2!
	JSR STAT2	;PUSH LOW PC BYTE VIA R12
	LDA R15H
	JSR STAT2	;PUSH HIGH ORDER PC BYTE
BR	CLC
BNC	BCS BNC2	;NO CARRY TEST
BR1	LDA (R15L),Y	;DISPLACEMENT BYTE
	BPL BR2
	DEY
BR2	ADC R15L	;ADD TO PC
	STA R15L
	TYA
	ADC R15H
	STA R15H
BNC2	RTS
BC	BCS BR
	RTS
BP	ASL		;DOUBLE RESULT-REG INDEX
	TAX		;TO X REG FOR INDEXING
	LDA R0H,X	;TEST FOR PLUS
	BPL BR1		;BRANCH IF SO
	RTS
BM	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0H,X	;TEST FOR MINUS
	BMI BR1
	RTS
BZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR ZERO
	ORA R0H,X	;(BOTH BYTES)
	BEQ BR1		;BRANCH IF SO
	RTS
BNZ	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;TEST FOR NON-ZERO
	ORA R0H,X	;(BOTH BYTES)
	BNE BR1		;BRANCH IF SO
	RTS
BM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X	;CHECK BOTH BYTES
	AND R0H,X	;FOR $FF (MINUS 1)
	EOR #$FF
	BEQ BR1		;BRANCH IF SO
	RTS
BNM1	ASL		;DOUBLE RESULT-REG INDEX
	TAX
	LDA R0L,X
	AND R0H,X	;CHECK BOTH BYTES FOR NO $FF
	EOR #$FF
	BNE BR1		;BRANCH IF NOT MINUS 1
BK	RTS
RS	JMP RSZ
RTN	JMP RTNZ
EXT	LDA #R6		; SETZ will use R6 for the indirect transfer
	STA R14H
	ASL
	TAX
	LDY #1		; point to high byte of transfer address
	JSR SETZ
	JMP (r6)	; implement your 6502 extension to Sweet16 here!
PULL	BPL PULLZ	; bra
PUSH	JSR getpstack	; get PETTIL stack pointer
	JSR slip	; push TOS -> Forth data stack (DUP in Forth)
	JSR putpstack	; update PETTIL stack pointer
	LDX #2
	JMP ST
PULLZ	JSR getpstack	; get PETTIL stack pointer
	JSR slide	; remove item from Forth data stack (DROP in Forth)
	JMP putpstack	; update PETTIL stack pointer

; return the parameter stack pointer in X
getpstack	tsx
		lda $0106,x
		tax
		rts

; set the parameter stack pointer on return from X
putpstack	txa
		tsx
		sta $0106,x
		rts

; pop the stack
slide		lda stackh,x		; slide something off of the stack
		sta tos+1
		lda stackl,x
		sta tos
		inx
		rts

; push TOS to the stack (DUP)
slip		dex			; slip something onto the stack
		lda tos+1
		sta stackh,x
		lda tos
		sta stackl,x
		rts


; compares the counted string at TOS vs
; the strings in the dictionary pointed 
; to by N0 (originally 2OS) 
;inputs
;	TOS (R1) = address of the counted string we are searching for, -2
;	N0 (R5) = current LFA in the dictionary chain (initially the last LFA)
;returns
;	N1 (R6) =	0 if not a match
;			1 if found immediate word
;			-1 if found non-immediate word
;	R14H prior result register points to R6
;	R14H carry bit (lsb) is clear if word in dictionary is longer
;		than the word being searched for, indicating the word
;		is not in the dictionary (because they're sorted by
;		length)
strcmp16	;ldy #0		; unneeded because EXT clears Y
		sty n+3
		sty n+2		; assume not a match in N1 (R6)
		ldy #2
		lda (n),y	; dictionary
		sta n+5
		and #$3f
		sta n+4
		sec		; keep searching after a smudged word				
		and #bit5	; dictionary is smudged? fail
		bne strcmp16d	
		lda (tos),y	; counted string to search for
		and #$1f
		cmp n+4
		bne strcmp16d	; different length? fail
		;sec		; unneeded because carry is already set
		adc #1		; effectively add 2 (C flag was set)
		tay		; pointer to last character
strcmp16b	lda (n),y
		eor (tos),y
		asl		; ignore bit7
		bne strcmp16d	; different? outtie fail
		dey
		cpy #2
		bne strcmp16b	; C flag is set on successful strcmp
				; winner winner!
		; put the CFA into N0
		ldy n+4
		iny
		iny
		tya
		adc n
		sta n
		bcc strcmp16a
		inc n+1
strcmp16a	sec
		ldy #1
		bit n+5		; immediate bit in V flag
		bvs strcmp16c	; return 1 if immediate
		dec n+3
		ldy #$ff	; return -1 non-immediate
strcmp16c	sty n+2		; Y = 1 or Y = -1
strcmp16d	rol R14H	; tell Sweet16 about the C flag
		rts


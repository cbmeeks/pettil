;--------------------------------------------------------------
;
;       WRAPABOVE   ( -- d )
;
; Reads (a portion of) the linewrap table above the current physical
; line (stored at $d8) up to but not including the current line.  
; Returns a right-aligned double with copies of those high bit values
;
; $d8 = Current Cursor Physical Line Number
;
wrapabove
    jsr slip        ; make room on the stack for the low half of the double
    stx storex      ; preserve Forth data stack pointer
    ldx $d8         ; calculate the first physical line of this logical line
    lda $e0,x
    bmi wrapabove01 ; we are already on the first line
    dex
wrapabove01
    stx n+2         ; when X reaches this line, we are done
    ldx #0
    stx tos
    stx tos+1
    stx n           ; set least significant bit of the double to 1.  
    stx n+1         ; When this bit makes its way to the 4th byte, that
    inc tos         ; indicates we have rotated in 24 bits ("full")
wrapabove02
    inx
    cpx n+2         ; are we there yet?
    beq wrapabove03 ; leave if done
    lda $e0,x 
    asl             ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1         ; append the next high bit to the double
    beq wrapabove02 ; this should always take the branch
wrapabove03
    lda n
    ldy n+1         ; high half of the double is going on the stack
    ldx storex      ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
;
;       WRAPFILL   ( d 40|80 -- d flag )
;
; Shift and append one or two bits to the double.  Return nonzero
; once 25 bits have been stored.  40 = <<,1; 80 = <<,1 <<,0
;
wrapfill
    sec             ; always shift in a 1
wrapfill01
    ldy stackh,x
    bne wrapfill03
    rol stackl+1,x  ; shift in a single bit
    rol stackh+1,x
    rol stackl,x
    rol stackh,x
    lda #40
    cmp tos
    sta tos         ; so we only do this once
    bcc wrapfill01  ; maybe shift in a 0 (if 80-column)
wrapfill03
    ldy stackh,x
    tya
    jmp put

;--------------------------------------------------------------
;
;       WRAP!   ( d -- )
;
; Updates the linewrap table at $E0 to reflect the bits
; stored in d.  Since line 0 is *always* $80, never a continuation 
; line, only 24 bits are required, not 25.
;
wrapstore
    ldy #1
    jsr setup
    stx storex
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       LINESIZE   ( physline -- 40|80 )
;
; return the length of the logical line
; physline must already point to the first line of the logical line
;
;lineinfolfa
;    .byt $de,$ad
;    .byt (linesize-*-1)|bit7
;    .asc "LINESIZ","E"|bit7
linesize
    stx storex
    ldx tos
    lda #40
    cpx #24
    beq lineinfo02
    ldy $e1,x
    bmi lineinfo02
    asl                     ; 80 char
linesize02
    ldy #0
    ldx storex
    jmp puts

;--------------------------------------------------------------
;
;       LINEPHYS   ( addr -- physline )
;
; converts a video memory address to its physical line 0..24
;
  ;  VIDRAM - 40 / ;
    
;": linephys   ( addr -- physline )
;     0
;     begin
;         1+
;         swap 40 -
;         swap over 0>
;     until
;     swap drop 1- ;
linephyslfa
    .byt $de,$ad
    .byt (_linephys-*-1)|bit7
    .asc "LINEPHY","S"|bit7
_linephys
#include "enter.i65"
    .word zero
#include "page.i65"
linephys01
    .word oneplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word clit
    .byt 40
#include "pad.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word over
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch
    .byt <(linephys01-*+1)
#include "pad.i65"
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       CURRLINE   ( -- addr physline )
;
; return the starting address of the logical line at the cursor, 
; and its physical line number
;
;" : currline   ( -- addr 40|80 physline )
;    c4 @  d5 c@ 1+ d8 c@ ; [22]
;
;": currline   ( -- addr 40|80 )
;     c4 @  physline  lineinfo ;
;
;": currline   ( -- addr 40|80 )
;     d8 c@  lineinfo ;
;
; A man with a watch always knows what time it is.  A man 
; with two watches is neer sure.
;
;currlinelfa
;    .byt $de,$ad
;    .byt (currline-*-1)|bit7
;    .asc "CURRLIN","E"|bit7
_currline
#include "enter.i65"
    .word clit
    .byt $c4
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d8
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word to6502
    
    brk
    .byt push
    .byt set | TOS
    .word $c4
    .byt ldd | TOS
    .byt st TOS
    .byt rtn
    stx storex
    ldx $d8
    inx
currline01
    dex
    lda $e0,x
    bpl currline01
    txa
    ldy #0
    ldx storex
    jmp pushya
    
    #include "page.i65"
    .word lineinfo
#include "page.i65"

;--------------------------------------------------------------
;
;       PASTE   ( -- addr )
;
; Return the tail of the paste buffer, marked by 0
;
; The paste buffer begins at PAD and consists of zero or more
; screen lines, stored as a length (40|80) followed by that many
; screen codes.  Each record is 41 or 81 bytes long.
;
;pastelfa
;    .byt $de,$ad
;    .byt (paste-*-1)|bit7
;    .asc "PAST","E"|bit7
;": paste
;    pad                     ( pad )
;    begin
;        dup                 ( addr addr )
;        c@                  ( addr len )
;        ?dup                ( addr 0 | addr len len )
;    while                   ( addr len )
;        +                   ( len+addr )
;        1+                  ( newaddr )
;    repeat                  ( addr )
;
_paste
#include "enter.i65"
    .word _pad
#include "page.i65"
paste01                      ; BEGIN
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch               ; WHILE
    .byt <(paste02-*+1)
#include "pad.i65"
    .word plus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word branch               ; REPEAT
    .byt <(paste01-*+1)
#include "pad.i65"
paste02
    .word exit

;--------------------------------------------------------------
;
;       >PASTE   ( paste screen 40|80 -- paste+ screen+ )
;
; append the line on the screen to the paste buffer 
;
;    >r swap r@ over c!   ( screen paste ; 40|80 )
;    1+ 2dup r@ cmove   ( screen paste+1 ) 
;    r@ + dup off swap r> + ;
;topastelfa
;    .byt $de,$ad
;    .byt (_topaste-*-1)|bit7
;    .asc ">PAST","E"|bit7
_topaste
#include "enter.i65"
    .word tor
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word off
#include "page.i65"
    .word swap
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit
     
;--------------------------------------------------------------
;
;       EOS>PASTE   ( paste screen -- )
;
; append every line from screen to the end of screen to the paste
; buffer 
;    
;eostopastelfa
;    .byt $de,$ad
;    .byt (_eostopaste-*-1)|bit7
;    .asc "EOS>PAST","E"|bit7
_eostopaste

;--------------------------------------------------------------
;
;       PASTE>   ( paste screen -- paste+ screen+ flag )
;
; copy logical line from the paste buffer to screen
; returns true when end of screen hit
; or when paste buffer exhausted
;
;    over c@ >r swap 1+ 2dup swap r@
;    2dup + 33767 > if drop 40 then 
;    cmove   ( screen paste+1 )
;    r@ + swap r> +   ( paste+ screen+ flag )
;    2dup 33767 > swap c@ 0= or ;   ( paste+ screen+ flag )
;
;topastelfa
;    .byt $de,$ad
;    .byt (_pastefrom-*-1)|bit7
;    .asc "PASTE",">"|bit7
_pastefrom
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITCOPY   ( -- )
;
; STOP-C   Copy current line to end of paste buffer
;
;": editcopy
;    currline >paste 2drop ;
;
;editcopylfa
;    .byt $de,$ad
;    .byt (_editcopy-*-1)|bit7
;    .asc "EDITCOP","Y"|bit7
_editcopy
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _paste
#include "page.i65"
    .word _currline         ; ( paste screen size )
#include "page.i65"
    .word _topaste          ; ( )
#include "page.i65"
    .word _twodrop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITDEL   ( -- )
;
; delete the current line, appending it to the paste buffer
;
;": editdel
;    editcopy 
;    paste dup currline + eos>paste
;    wrapabove
;	   rot currline 
;    begin
;        over c@ >r 2swap r> wrapfill 2swap
;        paste>
;    until
;    33768 over - blank drop
;    begin
;        40 wrapfill
;    until
;    wrap! off ;
;		
;    wrapabove  nextphysline wrapbelow  begin  1 wrapfill  until
;    currline
;    2dup + dup 2swap >r 33768 dup >r rot - cmove r> r@ - r> blank
;    wrap!
;
; copy the current line
; copy linewrap table above this line
; append linewrap table below this line
; roll in 1 bits until there are 24 linewrap bits
; move everything below this line to end of screen up to here
; erase the last 40 or 80 characters, same size as currline
; write the new linewrap table to $e0
;
;editdellfa
;    .byt $de,$ad
;    .byt (editdel-*-1)|bit7
;    .asc "EDITDE","L"|bit7
_editdel
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _editcopy
#include "page.i65"
    .word _paste
#include "page.i65"
    .word dup
#include "page.i65"
    .word _currline
#include "page.i65"
    .word plus
#include "page.i65"
    .word _linephys
#include "page.i65"
editdel01                       ; BEGIN
    .word tor
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(editdel02-*+1)       ; WHILE
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word _topaste
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word branch                ; REPEAT
    .byt <(editdel01-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word _blank
#include "page.i65"
    .word _currline
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word twoswap
#include "page.i65"
editdel03                       ; BEGIN
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch               ; WHILE
    .byt <(editdel05-*+1)
#include "pad.i65"
    .word tor
    .word tor
    .word one
    .word wrapfill
    .word rfetch
    .word over
    .word clit
    .byt 80
    .word eq
    
    .word _pastefrom
#include "page.i65"
    .word branch
    .byt <(editdel03-*+1)       ; REPEAT
#include "pad.i65"
editdel05
    .word 
#include "page.i65"
    .word 
#include "page.i65"
    .word 
#include "page.i65"
    .word 
#include "page.i65"
    .word 
#include "page.i65"
    .word 
    .word exit

;--------------------------------------------------------------
;
;       EDITPASTE   ( -- )
;
; insert the paste buffer before the current line
;
;": editpaste   ( -- )
;     paste >r  26 nextphysline ?do  editdel  loop  wrapabove
;     currline drop pad 2swap
;     begin
;         2swap dup c@ >r 1+ swap 2dup r@ cmove
;         r@ + swap  r@ + swap
;         2swap  1 wrapfill  dup 0= r> 80 = and  if  ( 0 ) wrapfill  then
;     until  2swap 2drop  wrap!  r> off ;
;
; Cut goes up to line 26 because we actually begin with the current
; logical line, not the next physical line, so it's off by one.  
; Worst case scenario is initially empty paste buffer and all 40-column
; lines below and including currline.  This gets us enough to refill 
; the screen
;
;": editpaste
;    paste >r
;    26 nextphysline ?do  editdel  loop
;    currline drop
;    pad 
;    begin
;        dup c@ >r 1+       ( screen paste+1 ) ( R; buftail len )        
;		 r@ over + rot      ( from paste+ screen ) ( R; buftail len )
;        r> 2dup +          ( from paste+ screen len screen+len ) ( R; buftail )
;        VIDRAM+999 > >r    ( from paste+len+1 screen len flag )
;        r@ if drop 40 then ( from paste+len+1 screen adjlen )
;        rot >r             ( from screen adjlen ) ( R; buftail flag paste+ )
;        2dup + >r          ( from to howmany ) ( R; buftail flag paste+ screen+ )
;        cmove              ( ) ( R; buftail flag paste+ screen+ )
;        r> r> r>           ( screen+ paste+ flag ) ( R; buftail )
;    until
;    2drop                  ( ) ( R; buftail )
;    wrapabove
;    pad >r
;    begin                     ( d )       ( R; buftail paste )
;        r@ c@ r> 1+           ( d len paste+1 ) ( R; buftail )
;        over + >r >r          ( d )       ( R; buftail paste+ len )
;        1 wrapfill            ( d full? ) ( R; buftail paste+ len )
;        r> 80 =               ( d full? >40? ) ( R; buftail paste+ )
;        if                    ( d full? ) ( R; buftail paste+ )
;            drop              ( d )       ( R; buftail paste+ )
;            0 wrapfill        ( d full? ) ( R; buftail paste+ )
;        then
;    until
;    r> drop
;    wrap!
;    r> off ;
;
;editpastelfa
;    .byt $de,$ad
;    .byt (_editpaste-*-1)|bit7
;    .asc "EDITPAST","E"|bit7
_editpaste
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word _paste             ; ( buftail )
#include "page.i65"
    .word tor                   ; ( ) ( R; buftail )
#include "page.i65"
    .word clit
    .byt 26                     ; ( 26 ) ( R; buftail )
#include "pad.i65"
    .word _linephys          ; ( 26 line ) ( R; buftail )
#include "page.i65"
    .word pqdo                  ; ( ) ( R; buftail )
    .byt <(editpaste02-*+1)
#include "pad.i65"
editpaste01
    .word _editdel              ; ( ) ( R; buftail )
#include "page.i65"
    .word ploop
    .byt <(editpaste01-*+1)
#include "pad.i65"
editpaste02
    .word _currline
#include "page.i65"
    .word drop
#include "page.i65"
    .word _pad
#include "page.i65"
editpaste03                     ; BEGIN
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word tor
#include "page.i65"
    .word oneplus               ; ( screen paste+1 ) ( R; buftail len )
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word rot                   ; ( from paste+ screen ) ( R; buftail len )
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word plus                  ; ( from paste+ screen len screen+len ) ( R; buftail )
#include "page.i65"
    .word plit
    .word VIDRAM+999
#include "pad.i65"
    .word gt
#include "page.i65"
    .word tor                   ; ( from paste+ screen len flag )
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editpaste04-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word clit
    .byt 40
#include "page.i65"             ; ( from paste+len+1 screen adjlen )                                
editpaste04                     ; THEN
    .word rot
#include "page.i65"
    .word tor                   ; ( from screen adjlen ) ( R; buftail flag paste+ )
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor    ; ( from to howmany ) ( R; buftail flag paste+ screen+ )
#include "page.i65"
    .word cmove                 ; ( ) ( R; buftail flag paste+ screen+ )
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom                 ; ( screen+ paste+ flag ) ( R; buftail )
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(editpaste03-*+1)
#include "pad.i65"
    .word twodrop               ; ( ) ( R; buftail )
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word tor
#include "page.i65"             ; BEGIN
editpaste05                     ; ( d ) ( R; buftail paste )
    .word rfetch
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word oneplus               ; ( d len paste+1 ) ( R; buftail )
#include "page.i65"
    .word over
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word tor                   ; ( d )       ( R; buftail paste+ len )
#include "page.i65"
    .word one
#include "page.i65"
    .word wrapfill              ; ( d full? ) ( R; buftail paste+ len )
#include "page.i65"
    .word rfrom                 ; ( d full? len )
#include "page.i65"
    .word clit
    .byt 80                     ; ( d full? len 80 )
#include "pad.i65"
    .word eq                    ; ( d full? >40? ) ( R; buftail paste+ )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editpaste06-*+1)     ; ( d full? ) ( R; buftail paste+ )
#include "pad.i65"
    .word drop                  ; ( d )       ( R; buftail paste+ )
#include "page.i65"
    .word zero
#include "page.i65"
    .word wrapfill              ; ( d full? ) ( R; buftail paste+ )
#include "page.i65"
editpaste06                     ; THEN
    .word qbranch
    .byt <(editpaste05-*+1)     ; UNTIL
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITINDEX   ( -- )
;
; STOP-I   Present an index screen and let the user select one to edit
;
;editindexlfa
;    .byt $de,$ad
;    .byt (editindex-*-1)|bit7
;    .asc "EDITINDE","X"|bit7
editindex
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITSAVE   ( -- )
;
; STOP-S   Save all buffers to a PRG file
;
;editsavelfa
;    .byt $de,$ad
;    .byt (editsave-*-1)|bit7
;    .asc "EDITSAV","E"|bit7
editsave
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITLOAD   ( -- )
;
; STOP-L   Load a group of buffers from a PRG file
;
;editloadlfa
;    .byt $de,$ad
;    .byt (editload-*-1)|bit7
;    .asc "EDITLOA","D"|bit7
_editload
#include "enter.i65"
    .word _pdq
    .byt editload02-*-1
    .asc    CLR,"LOADING"
editload02
#include "pad.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITVERIFY   ( -- )
;
; STOP-V   Verify a buffer file vs. memory
;
;editverifylfa
;    .byt $de,$ad
;    .byt (editverify-*-1)|bit7
;    .asc "EDITVERIF","Y"|bit7
editverify
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITZILCH   ( -- )
;
; STOP-Z   Zilch the paste buffer
;
;": editzilch   ( -- )
;     pad off ;
;
;editzilchlfa
;    .byt $de,$ad
;    .byt (editzilch-*-1)|bit7
;    .asc "EDITZILC","H"|bit7
_editzilch
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITRESTORE   ( -- )
;
; STOP-R   Restore the current screen from the buffer
;
editrestorelfa
    .byt $de,$ad
    .byt (editrestore-*-1)|bit7
    .asc "EDITRESTOR","E"|bit7
editrestore
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITDELSCR   ( -- )
;
; delete the current screen.  restore from next, then prev, then blank
;
;editdelscrlfa
;    .byt $de,$ad
;    .byt (editdelscr-*-1)|bit7
;    .asc "EDITDELSC","R"|bit7
editdelscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITINSSCR   ( -- )
;
; insert a new, blank screen
;
;editinsscrlfa
;    .byt $de,$ad
;    .byt (editinsscr-*-1)|bit7
;    .asc "EDITINSSC","R"|bit7
editinsscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITTOPSCR   ( -- )
;
; restore from the top (first) screen
;
edittopscrlfa
    .byt $de,$ad
    .byt (edittopscr-*-1)|bit7
    .asc "EDITTOP","R"|bit7
edittopscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNOWRAP   ( -- )
;
; reset the linewrap table
;
;editnowraplfa
;    .byt $de,$ad
;    .byt (editnowrap-*-1)|bit7
;    .asc "EDITNOWRA","P"|bit7
editnowrap
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNEXTSCR   ( -- )
;
; restore from the next screen or append a blank one
;
editnextscrlfa
    .byt $de,$ad
    .byt (editnextscr-*-1)|bit7
    .asc "EDITNEXTSC","R"|bit7
editnextscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPREVSCR   ( -- )
;
; restore from the previous screen or insert a blank one
;
editprevscrlfa
    .byt $de,$ad
    .byt (editprevscr-*-1)|bit7
    .asc "EDITPREVSC","R"|bit7
editprevscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITQUIT   ( -- )
;
; STOP-Q   Quit the editor
;
;editquitlfa
;    .byt $de,$ad
;    .byt (editquit-*-1)|bit7
;    .asc "EDITQUI","T"|bit7
editquit
#include "enter.i65"
    .word rfrom         ; discard returns
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word drop          ; we won't be needing these
#include "page.i65"
    .word exit          ; exiting from EDIT

;--------------------------------------------------------------
;
;       EDITSCR   ( -- addr )
;
; a variable used to hold the current screen (e.g. 1 = top)
;
; put this at $7bfe 
; =0 means screen buffer is empty
; else most recently edited block #
;
;editscrlfa
;    .byt $de,$ad
;    .byt (editscr-*-1)|bit7
;    .asc "EDITSC","R"|bit7
editscr
    jsr docreate
    .word 0

;--------------------------------------------------------------
;
;       EDITINIT   ( -- )
;
; prepare before we drop into the editor infinite loop
;
;editinitlfa
;    .byt $de,$ad
;    .byt (editinit-*-1)|bit7
;    .asc "EDITINI","T"|bit7
editinit
#include "enter.i65"
    .word _editzilch
#include "page.i65"
    .word cr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITMENU   ( -- addr )
;
; returns the address of a counted string of menu commands
;
;editmenulfa
;    .byt $de,$ad
;    .byt (editmenu-*-1)|bit7
;    .asc "EDITMEN","U"|bit7
editmenu
     jsr docreate
     .byt editmenu01-*-1        ; number of menu items = 16
     .asc "QISLVZRDCP"          ; command keys
     .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenu01
     .word editquit             ; CFA of corresponding Forth word
     .word editindex
     .word editsave
     .word _editload
     .word editverify
     .word _editzilch
     .word editrestore
     .word _editdel
     .word _editcopy
     .word _editpaste
     .word editdelscr
     .word editinsscr
     .word edittopscr
     .word editnowrap
     .word editnextscr
     .word editprevscr

;--------------------------------------------------------------
;
;       EDITCMD   ( -- )
;
; get a key and perform that command
;
;editcmdlfa
;    .byt $de,$ad
;    .byt (_editcmd-*-1)|bit7
;    .asc "EDITCM","D"|bit7
_editcmd
#include "enter.i65"
    .word editmenu              ; ( editmenu )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex              ; ( index|0 )
#include "page.i65"
    .word qdup                  ; ( index index | 0 )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editcmd01-*+1)
#include "pad.i65"
    .word twostar               ; ( 2*index )
#include "page.i65"
    .word editmenu              ; ( 2*index editmenu ) 
#include "page.i65"
    .word dup                   ; ( 2*index editmenu editmenu ) 
#include "page.i65"
    .word cfetch                ; ( 2*index editmenu #items ) 
#include "page.i65"
    .word plus                  ; ( 2*index editmenu+#items ) 
#include "page.i65"
    .word plus                  ; ( 2*index+editmenu+#items ) 
#include "page.i65"
    .word oneminus              ; ( 2*index+editmenu+#items-1 ) 
#include "page.i65"
    .word fetch                 ; ( editcmdcfa )
#include "page.i65"
    .word execute               ; ( )
#include "page.i65"
editcmd01                       ; THEN
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITIRQTOGGLE   ( -- )
;
; Enable or disable the IRQ handler within EDIT that checks for
; the STOP key in the screen editor.
;
;editirqtogglelfa
;    .byt $de,$ad
;    .byt (editirqtoggle-*-1)|bit7
;    .asc "EDITIRQTOGGL","E"|bit7
_editirqtoggle
#include "enter.i65"
    .word plit
    .word (MAINIRQ^edit02)
#include "pad.i65"
    .word clit
    .byt <CINV       ; $90
#include "pad.i65"
    .word toggleirq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDIT   ( -- )
;
editlfa
    .byt $de,$ad
    .byt (_edit-*-1)|bit7
    .asc "EDI","T"|bit7
_edit
#include "enter.i65"
    .word editinit
#include "page.i65"
edit00              ; reentry to editor here
    .word _editirqtoggle   ; enable STOP key trap
#include "page.i65"
    .word to6502
    stx storex      ; preserve Forth data stack pointer
    tsx
    stx n           ; preserve machine stack frame pointer

edit01              ; PET screen editor forever loop
    jsr CHRIN       ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #$0d        ; don't just leave the cursor two characters past end of line
    jsr CHROUT      ; Kernel - so echo the carriage return
    jmp edit01      ; ... do this forever

edit02              ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda $9b         ; copy of contents of PIA1 Port B for testing STOP key, etc...
    cmp #$ef        ; test STOP key
    bne edit03
                    ; looks like someone pressed STOP. Exit the editor
                    ; but not so fast!  Are we in quotes or inserts?
    lda $cd         ; nonzero is quotes mode
    ora $dc         ; number of inserts pending
    beq edit04
edit03
    jmp MAINIRQ     ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
edit04
    jsr UDTIM       ; keep the clock running even if someone leans on STOP
    ;sec            ; because f7a1 debounce loop always sets carry
    inc $a7         ; turn off cursor
    lda $a9         ; true character at cursor position
    jsr FIX_CHR     ; ROM $E606 on 40-column BASIC4 PET
    ;jsr UNFLIP_CRSR ; ~wut? probably need to flip off the cursor
    ldx n
    txs             ; reset stack frame
    ldx storex      ; restore Forth stack pointer
#include "toforth.i65"
    .word _editirqtoggle        ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd  ; get and perform editor command
#include "page.i65"
    .word branch
    .byt <(edit00-*+1)
#include "pad.i65" ; this never executes. editquit breaks out by dropping returns
    .word exit

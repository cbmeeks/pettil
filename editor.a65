;--------------------------------------------------------------
;
;       WRAPABOVE   ( logline -- d )
;
; Reads (a portion of) the linewrap table above the current physical
; line (stored at $d8) up to but not including the current logical line.  
; Returns a right-aligned double with a copy of those high bit values
;
;wrapabovelfa
;    .byt $de,$ad
;    .byt (wrapabove-*-1)|bit7
;    .asc "WRAPABOV","E"|bit7
wrapabove
    stx storex      ; preserve Forth data stack pointer
    ldy tos         ; first physical line of this logical line
    sty n+2
    ldx #0
    stx n+1
    stx n
    stx tos+1
    stx tos
    ldx #$ff
wrapabove02
    inx
    cpx n+2         ; are we there yet?
    beq wrapabove03 ; leave if done
    lda $e0,x 
    asl             ; nondestructively
    rol tos
    rol tos+1
    rol n
    rol n+1         ; append the next high bit to the double
    beq wrapabove02 ; this should always take the branch
wrapabove03
    lda n
    ldy n+1         ; high half of the double is going on the stack
    ldx storex      ; restore Forth data stack pointer
    jmp pushya

;--------------------------------------------------------------
;
;       WRAP+   ( d 40|80 -- d flag )
;
; Shift and append one or two bits to the double.  Return nonzero
; once 25 bits have been stored.  40 = <<,1; 80 = <<,1 <<,0
;
;wrappluslfa
;    .byt $de,$ad
;    .byt (wrapplus-*-1)|bit7
;    .asc "WRAP","+"|bit7
wrapplus
    sec             ; always shift in a 1
wrapplus01
    ldy stackh,x
    bne wrapplus03
    rol stackl+1,x  ; shift in a single bit
    rol stackh+1,x
    rol stackl,x
    rol stackh,x
    lda #40
    cmp tos
    sta tos         ; so we only do this once
    bcc wrapplus01  ; maybe shift in a 0 (if 80-column)
wrapplus03
    ldy stackh,x
    tya
    jmp put

;--------------------------------------------------------------
;
;       WRAP!   ( d -- )
;
; Updates the linewrap table at $E0 to reflect the bits
; stored in d.  Since line 0 is *always* $80, never a continuation 
; line, only 24 bits are required, not 25.
;
wrapstore
    ldy #1
    jsr locals
    stx storex
    ldx #24
wrapstore01
    asl $e0,x
    lsr tos+1
    ror tos
    ror n+1
    ror n
    ror $e0,x
    dex
    bne wrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       LINEINFO   ( logline -- addr 40|80 )
;
; return the start address and length of the logical line
; logline must already point to the first line of the logical line
;
;lineinfolfa
;    .byt $de,$ad
;    .byt (lineinfo-*-1)|bit7
;    .asc "LINEINF","O"|bit7
lineinfo
    stx storex
    ldx tos
    lda WRAPLO,x
    sta tos
    lda $e0,x
    sta tos+1
    lda #40
    cpx #24
    beq lineinfo01
    ldy $e1,x
    bmi lineinfo01
    asl                     ; 80 char
lineinfo01
    ldy #0
    ldx storex
    jmp pushya

;--------------------------------------------------------------
;
;       LOGLINE   ( -- logline )
;
; return the physical line number of the current logical line.
; The return value is the first line of the logical line, which
; may be the physical line of the cursor or the line above it.
; From this position, leapfrogging forward through the screen will
; always return addresses with bit7 set.
;
; A man with a watch always knows what time it is.  A man 
; with two watches is never sure.
;
;loglinelfa
;    .byt $de,$ad
;    .byt (logline-*-1)|bit7
;    .asc "LOGLIN","E"|bit7
logline
    stx storex
    ldx $d8
    inx
logline01
    dex
    ldy $e0,x
    bpl logline01
    txa
    ldy #0
    ldx storex
    jmp pushya

;--------------------------------------------------------------
;
;       LOGLINE+   ( logline -- logline+|0 )
;
; Return the next logical line number or 0 after bottom of screen
;
;loglinepluslfa
;    .byt $de,$ad
;    .byt (_loglineplus-*-1)|bit7
;    .asc "LOGLINE","+"|bit7
loglineplus
    stx storex
    lda #0
    ldx tos
loglineplus01
    cpx #24
    beq loglineplus02
    inx
    ldy $e0,x
    bpl loglineplus01
    txa
loglineplus02
    ldy #0
    ldx storex
    jmp put

;--------------------------------------------------------------
;
;       PASTE   ( -- addr )
;
; Return the tail of the paste buffer, marked by 0
;
; The paste buffer begins at PAD and consists of zero or more
; screen lines, stored as a length (40|80) followed by that many
; screen codes.  Each record is 41 or 81 bytes long.
;
;": paste
;    pad                     ( pad )
;    begin
;        dup                 ( addr addr )
;        c@                  ( addr len )
;        ?dup                ( addr 0 | addr len len )
;    while                   ( addr len )
;        +                   ( len+addr )
;        1+                  ( newaddr )
;    repeat ; [19]           ( addr )
;
pastelfa
    .byt $de,$ad
    .byt (_paste-*-1)|bit7
    .asc "PAST","E"|bit7
_paste
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word to6502
    brk
paste01
    .byt ldi | TOS
    .byt bz , <(paste02-*-2)
    .byt add | TOS
    .byt st | TOS
    .byt br , <(paste01-*-2)
paste02
    .byt nxt    ; [16]

;--------------------------------------------------------------
;
;       (>PASTE)   ( paste screen 40|80 -- paste+len+1 screen+len screen paste+1 len )
;
; set up the stack to append the line on the screen to the paste buffer with cmove
;
;": (>paste)
;     >r swap r@ over c!   ( screen paste ; 40|80 )
;     1+ 2dup r@ cmove   ( screen paste+1 ) 
;     r@ + dup off swap r> + ; [37]
;
;
;ptopastelfa
;    .byt $de,$ad
;    .byt (ptopaste-*-1)|bit7
;    .asc "(>PASTE",")"|bit7
;_ptopaste
;#include "enter.i65"
;    .word tor
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word over
;#include "page.i65"
;    .word cstore
;#include "page.i65"
;    .word oneplus
;#include "page.i65"
;    .word _twodup
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word cmove
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word plus
;#include "page.i65"
;    .word dup
;#include "page.i65"
;    .word off
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word plus
;#include "page.i65"
;    .word exit
;
ptopaste
    ldy #2
    jsr locals
    brk                         ; TOS = len; N0 = paste; N1 = screen
    .byt ld | TOS
    .byt sti | N0               ; len paste c! paste 1+!
    .byt st | N2                ; copy of len
    .byt add | N0
    .byt st | TOS               ; paste+len+1
    .byt st | N3
    .byt sub | R0
    .byt std | N3               ; off
    .byt ld | N1
    .byt add | N2
    .byt push                   ; screen+len
    .byt ld | N1
    .byt push                   ; screen
    .byt ld | N0
    .byt push                   ; paste+1
    .byt ld | N2
    .byt push                   ; len
    .byt nxt                    ; [27]

;--------------------------------------------------------------
;
;       EOS>PASTE   ( paste logline -- )
;
; append every line from the logical line passed in (expected to be
; nonzero ) to the end of screen to the paste buffer.
;    
;": eos>paste   ( paste logline -- )
;     begin
;         ?dup
;     while
;         dup logline+ >r       ( paste logline ) ( R; logline+ )
;         lineinfo              ( paste screen 40|80 ) ( R; logline+ )
;         >paste drop           ( paste+ ) ( R; logline+ )
;         r>
;     repeat
;     drop ;
;
;eostopastelfa
;    .byt $de,$ad
;    .byt (_eostopaste-*-1)|bit7
;    .asc "EOS>PAST","E"|bit7
_eostopaste
#include "enter.i65"
eostopaste01                    ; BEGIN
    .word qdup
#include "page.i65"
    .word qbranch               ; WHILE
    .byt <(eostopaste02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word loglineplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lineinfo
#include "page.i65"
    .word ptopaste              ; ( paste+ screen+ screen paste+1 len )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word branch                ; REPEAT
    .byt <(eostopaste01-*+1)
#include "pad.i65"
eostopaste02
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       WRAPPASTE   ( -- dwrap )
;
; Leave a double of screenwrap bits on the stack, treating the
; current cursor position as the target of a paste (above from
; linewrap table $E0-F8, at and below from paste buffer)
;
;": wrappaste   ( -- dwrap )
;     wrapabove   ( dwrap )
;     pad >r
;     true
;     begin
;         r@ c@ dup   ( dwrap len len )
;         r> + 1+ >r
;         and
;     while
;         wrap+ 0=
;     repeat
;     r> drop ;   ( d )
;
#include "enter.i65"
    .word wrapabove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word tor
#include "page.i65"
wrappaste01
    .word rfetch
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word qbranch
    .byt <(wrappaste02-*+1)
#include "pad.i65"
    .word wrapplus
#include "page.i65"
    .word branch
    .byt <(wrappaste01-*+1)
#include "pad.i65"
wrappaste02
    .word rfrom
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       TEST25   ( screenaddr offset -- screenaddr offset|40 )
;
; Adjusts the offset from anything to 40 if offset+screenaddr is 
; beyond the end of the screen
;   a) to prevent overflowing the screen
;   b) for use as a flag
;
;": test25   ( offset screenaddr -- offset' screenaddr )
;     2dup + 33767 >
;     if
;         drop 40
;     then ;
;~wut? this is awful
_test25
#include "enter.i65"
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word plit
    .word VIDRAM+1000
#include "pad.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(test2501-*+1)        ; IF
#include "pad.i65"
    .word drop
#include "page.i65"
    .word clit
    .byt 40
#include "pad.i65"
test2501                        ; THEN
    .word exit

;--------------------------------------------------------------
;
;       FLAGAB   ( paste screen -- flagab )
;
; true if we've hit exit condition A or B
;
;flagablfa
;    .byt $de,$ad
;    .byt (_flagab-*-1)|bit7
;    .asc "FLAGA","B"|bit7
_flagab
#include "enter.i65"
    .word zero                  ; ( paste screen 0 )
#include "page.i65"
    .word _test25               ; ( paste screen 0|40 )
#include "page.i65"
    .word rot                   ; ( screen flagb paste )
#include "page.i65"
    .word cfetch                ; ( screen flagb len )
#include "page.i65"
    .word zeq                   ; ( screen flagb flaga )
#include "page.i65"
    .word orx                   ; ( screen flagab )
#include "page.i65"
    .word swap                  ; ( flagab screen )
#include "page.i65"
    .word drop                  ; ( flagab )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PASTE>   ( paste screen -- d paste+ screen+ )
;
; copy logical lines from the paste buffer to screen until
;   a) we exhaust the paste buffer
;   b) we run past the bottom of the screen
;   c) we fill up the linewrap table
;
; returns a double with the linewrap bits from line 0 until
; PASTE> reaches an exit condition, also the next paste
; buffer source address and next screen target address
;
;": paste>
;     logline ?dup
;     if
;         wrapabove             ( paste screen d )
;     else
;         1 0
;     then
;     2swap
;     begin
;         2dup flagab dup >r 0= ( d paste screen !flagab ) ( R; flagab )
;         if
;             over c@           ( d paste screen len ) ( R; flagab )
;             swap over test25  ( d paste len screen len' ) ( R; flagab )
;             2dup + >r         ( d paste len screen len' ) ( R; flagab screen' )
;             2over + 1+ >r     ( d paste len screen len' ) ( R; flagab screen' paste' )
;             2swap swap 1+     ( d screen len' len paste+1 ) ( R; flagab screen' paste' )
;             2swap cmove       ( d len ) ( R; flagab screen' paste' )
;             wrapfill          ( d flag ) ( R; flagab screen' paste' )
;             r> r> rot r>      ( d flag paste' screen' flagc flagab ) ( R; )
;             or >r             ( d paste' screen' ) ( R; flagabc )
;         then
;         r>
;     until ;
;
;pastefromlfa
;    .byt $de,$ad
;    .byt (_pastefrom-*-1)|bit7
;    .asc "PASTE",">"|bit7
_pastefrom
#include "enter.i65"
    .word logline               ; ( paste screen logline )
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pastefrom01-*+1)
#include "page.i65"
    .word wrapabove
#include "page.i65"
    .word branch                ; ELSE
    .byt <(pastefrom02-*+1)
#include "page.i65"
pastefrom01
    .word zero
#include "page.i65"
    .word zero
#include "page.i65"
pastefrom02                     ; THEN
#include "page.i65"
    .word twoswap               ; ( d paste screen )
#include "page.i65"
pastefrom03
    .word _twodup               ; ( d paste screen paste screen )
#include "page.i65"
    .word _flagab               ; ( d paste screen flagab )
#include "page.i65"
    .word dup                   ; ( d paste screen flagab flagab )
#include "page.i65"
    .word tor                   ; ( d paste screen flagab ) ( R; flagab )
#include "page.i65"
    .word zeq                   ; ( d paste screen !flagab ) ( R; flagab )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pastefrom04-*+1)
#include "pad.i65"
    .word over                  ; ( d paste screen paste ) ( R; flagab )
#include "page.i65"
    .word cfetch                ; ( d paste screen len ) ( R; flagab )
#include "page.i65"
    .word swap                  ; ( d paste len screen ) ( R; flagab )
#include "page.i65"
    .word over                  ; ( d paste len screen len ) ( R; flagab )
#include "page.i65"
    .word _test25               ; ( d paste len screen len' ) ( R; flagab )
#include "page.i65"
    .word _twodup               ; ( d paste len screen len' screen len' ) ( R; flagab )
#include "page.i65"
    .word plus                  ; ( d paste len screen len' screen' ) ( R; flagab )
#include "page.i65"
    .word tor                   ; ( d paste len screen len' ) ( R; flagab screen' )
#include "page.i65"
    .word twoover               ; ( d paste len screen len' paste len ) ( R; flagab screen' )
#include "page.i65"
    .word plus                  ; ( d paste len screen len' paste+len ) ( R; flagab screen' )
#include "page.i65"
    .word oneplus               ; ( d paste len screen len' paste' ) ( R; flagab screen' )
#include "page.i65"
    .word tor                   ; ( d paste len screen len' ) ( R; flagab screen' paste' )
#include "page.i65"
    .word twoswap               ; ( d screen len' paste len ) ( R; flagab screen' paste' )
#include "page.i65"
    .word swap                  ; ( d screen len' len paste ) ( R; flagab screen' paste' )
#include "page.i65"
    .word oneplus               ; ( d screen len' len paste+1 ) ( R; flagab screen' paste' )
#include "page.i65"
    .word twoswap               ; ( d len paste+1 screen len' ) ( R; flagab screen' paste' )
#include "page.i65"
    .word cmove                 ; ( d len ) ( R; flagab screen' paste' )
#include "page.i65"
    .word wrapplus              ; ( d flagc ) ( R; flagab screen' paste' )
#include "page.i65"
    .word rfrom                 ; ( d flagc paste' ) ( R; flagab screen' )
#include "page.i65"
    .word rfrom                 ; ( d flagc paste' screen' ) ( R; flagab )
#include "page.i65"
    .word rot                   ; ( d paste' screen' flagc ) ( R; flagab )
#include "page.i65"
    .word rfrom                 ; ( d paste' screen' flagc flagab ) ( R; )
#include "page.i65"
    .word orx                   ; ( d paste' screen' flagabc ) ( R; )
#include "page.i65"
    .word tor                   ; ( d paste' screen' ) ( R; flagabc )
#include "page.i65"
pastefrom04                     ; THEN
    .word rfrom
#include "page.i65"
    .word qbranch               ; UNTIL 
    .byt <(pastefrom03-*+1)
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       PKT@ ( n -- packet )
;
; Return the packet address of block n
;
;": pkt@   ( n -- packet )
;     blkbuf 2-
;     begin
;         over 0>
;     while
;         dup @
;         - swap 1- swap
;     repeat
;     swap drop ;
;
pktfetchlfa
    .byt $de,$ad
    .byt (_pktfetch-*-1)|bit7
    .asc "PKT","@"|bit7
_pktfetch
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word swap
#include "page.i65"
    .word to6502
    brk                         ; ( blkbuf blk )
    .byt ld | TOS
    .byt st | N0
    .byt pull
pktfetch01
    .byt popd | TOS
    .byt bz , <(pktfetch02-*-2)
    .byt dcr | N0
    .byt bm , <(pktfetch02-*-2)
    .byt ext
    .word pktheader16
    .byt ld | TOS
    .byt sub | R11
    .byt st | TOS
    .byt br , <(pktfetch01-*-2)
pktfetch02
    .byt rtn
#include "toforth.i65"
    .word exit

;_pktfetch
;#include "enter.i65"
;    .word _blkbuf
;#include "page.i65"
;    .word twominus
;#include "page.i65"
;pktfetch01
;    .word over
;#include "page.i65"
;    .word zgt
;#include "page.i65"
;    .word qbranch
;    .byt <(pktfetch02-*+1)
;#include "pad.i65"
;    .word dup
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word minus
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word oneminus
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word branch
;    .byt <(pktfetch01-*+1)
;#include "pad.i65"
;pktfetch02
;    .word swap
;#include "page.i65"
;    .word drop
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
;
;       PKT+ ( editable? -- packet )
;
; Append a new packet to the bottom of vmbuf, return its address
; flag = false for data packet, true for editor packet
;
;": pkt+   ( editable? -- packet )
;                                 ( editable? )
;     >r vmbuf @ 14 r@
;                                 ( vmbuf 14 editable? ) ( R; editable? )
;     if
;                                 ( vmbuf 14 ) ( R; editable? )
;         drop 5
;                                 ( vmbuf 5 ) ( R; editable? )
;     then
;                                 ( vmbuf 5 ) ( R; editable? )
;     2dup 2dup 2dup - over
;                                 ( vmbuf 5 vmbuf 5 vmbuf 5 vmbuf-5 5 ) ( R; flag )
;     erase
;                                 ( vmbuf 5 vmbuf 5 vmbuf 5 ; clear packet ) ( R; flag )
;     VIDRAM r@ and or swap
;                                 ( vmbuf 5 vmbuf 5 VIDRAM|5 vmbuf ) ( R; flag )
;     !
;                                 ( vmbuf 5 vmbuf 5 ; set packet length ) ( R; flag )
;     - dup vmbuf !
;                                 ( vmbuf 5 vmbuf-5 ; update vmbuf to point to new tail )
;     2+ r> tuck over ! 1+ !
;                                 ( vmbuf 5 ; set first three bytes of packet = flag )
;     vmsiz 1+!
;                                 ( vmbuf 5 ; increment packet counter )
;     drop ;
;                                 ( vmbuf ; packet address )
;
pktpluslfa
    .byt $de,$ad
    .byt (_pktplus-*-1)|bit7
    .asc "PKT","+"|bit7
_pktplus
#include "enter.i65"
    .word tor
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt 14
#include "pad.i65"
    .word rfetch
#include "page.i65"
    .word qbranch
    .byt <(pktplus01-*+1)
#include "page.i65"
    .word drop
#include "page.i65"
    .word clit
    .byt 5
#include "pad.i65"
pktplus01
    .word _twodup
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word minus
#include "page.i65"
    .word over
#include "page.i65"
    .word _erase
#include "page.i65"
    .word vidram
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word andx
#include "page.i65"
    .word orx
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _tuck
#include "page.i65"
    .word over
#include "page.i65"
    .word store
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word store
#include "page.i65"
    .word vmsiz
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the 
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize               
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt
    
;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs 
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;~wut? need to skip uneditable screens
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( pkt blkbuf pkt blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( pkt blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;         move move 0
;     then 
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       UNPKT ( packet -- blkbuf )
;
; Given the address of a packet (its size/flags word, at the top)
; this will unpack the packet to the block buffer and return
; the address of the unpacked block. Distinguishes among 
; compressed/uncompressed and editable/uneditable packets
;
unpktlfa
    .byt $de,$ad
    .byt (_unpkt-*-1)|bit7
    .asc "UNPK","T"|bit7
_unpkt
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank                ; blank the block buffer
#include "page.i65"
    .word to6502
    brk                         ; ( packet blkbuf )
    .byt ld | TOS
    .byt st | R9                ; blkbuf
    .byt st | R10               ; "to"
    .byt pull
    .byt st | N0                ; packet address
    .byt ldd | TOS              ; get packet header
    .byt ext             
    .word pktheader16              ; get R11=packet length, N2=editable? N3=uncompressed? 
    .byt ld | N0
    .byt sub | R11              ; packet data
    .byt st | R13               ; "from" (don't use R12, it turns the packet into the Sweet16 return stack!)
    .byt ld | N2
    .byt bz , <(unpkt01-*-2)    ; data packet?
    .byt ldi | R13              ; copy 3 bytes of linewrap from packet
    .byt sti | R10
    .byt dcr | R11              ; subtract 3 from length
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
unpkt01                         ; start stacking it back up
    .byt ld | R9
    .byt st | TOS               ; blkbuf
    .byt ld | R13
    .byt push                   ; from
    .byt ld | R10
    .byt push                   ; to
    .byt ld | R11
    .byt push                   ; howmany
    .byt ld | N3
    .byt push                   ; uncompressed?
    .byt ld | N2
    .byt push                   ; editable?
    .byt rtn
#include "toforth.i65"
    .word iseditable
#include "page.i65"
    .word store
#include "page.i65"
    .word qbranch               ; IF
    .byt <(unpkt03-*+1)
#include "page.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt04-*+1)
#include "page.i65"
unpkt03                         ; ELSE
    .word rldecode
#include "page.i65"
unpkt04                         ; THEN
    .word exit
                                ; ( blkbuf )

;--------------------------------------------------------------
;
;       (BLOCK)   ( blk -- blkbuf new? )
;
; return the buffer address of block N. Create it if necessary.
; flag is true if the block is new, false if it already exists
;
; *** TRICK ALERT ***
; Uses the address on the return stack to determine if the caller 
; was the screen editor.  Then does an OR with $8000 (VIDRAM)
; on the packet length, setting the "editable" flag on the block.
;
; Any other caller creates a data block.
;
;": (block)   ( blk -- blkbuf )
;     vmsize @ over -
;                                 ( blk vmsize-blk )
;     dup 0>
;                                 ( blk vmsize-blk exists? )
;     if
;                                 ( blk vmsize-blk )
;         drop pkt@
;                                 ( packet )
;     else
;                                 ( blk vmsize-blk )
;         r@ usingeditor = >r
;                                 ( junk vmsize-blk ) ( R; editor? )
;         begin
;                                 ( packet vmsize-blk ) ( R; editor? )
;             swap drop 1+ r@
;                                 ( vmsize-blk+ editor? ) ( R; editor? )
;             pkt+
;                                 ( vmsize-blk+ packet ) ( R; editor? )
;             swap dup 0>
;                                 ( packet vmsize-blk+ enough? ) ( R; editor? )
;         until
;                                 ( packet vmsize-blk+ ) ( R; editor? )
;         r> 2drop
;                                 ( vmsize-blk+ )
;     then
;                                 ( packet )
;     unpkt ; 
;                                 ( blkbuf )
;
pblocklfa
    .byt $de,$ad
    .byt (_pblock-*-1)|bit7
    .asc "(BLOCK",")"|bit7
_pblock
#include "enter.i65"
    .word vmsiz
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch               ; IF
    .byt <(pblock01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word _pktfetch
#include "page.i65"
    .word branch
    .byt <(pblock03-*+1)
#include "pad.i65"
pblock01                        ; ELSE
    .word rfetch
#include "page.i65"
    .word plit
    .word usingeditor
#include "pad.i65"
    .word eq
#include "page.i65"
    .word tor
#include "page.i65"
pblock02                        ; BEGIN
    .word swap
#include "page.i65"
    .word drop
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word dup
#include "page.i65"
    .word zgt
#include "page.i65"
    .word qbranch               ; UNTIL
    .byt <(pblock02-*+1)
#include "pad.i65"
    .word rfrom
#include "pad.i65"
    .word twodrop
#include "page.i65"
pblock03                        ; THEN
    .word _unpkt
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITABLE?   ( -- addr )
;
; Variable reflecting whether the current screen is text (true)
; or a data block (false)
;
iseditablelfa
    .byt $de,$ad
    .byt (iseditable-*-1)|bit7
    .asc "EDITABLE","?"|bit7
iseditable
    jsr docreate
    .word 0

;--------------------------------------------------------------
;
;       SCR@   ( scr -- )
;
; Locate or create the packet for this screen, set the current
; screen variable SCR, and display it with linewrap
;
;": scr@   ( scr -- )
;     dup scr ! (block)
;                               ( blkbuf )
;     editable? @
;                               ( blkbuf editable? )
;     if
;                               ( blkbuf )
;         dup 3c@ wrap!
;                               ( blkbuf )
;         3 +
;                               ( blkbuf+3 )
;     then
;                               ( blkbuf|blkbuf+3 )
;     vidram b/scr
;                               ( blkbuf $8000 1000 )
;     cmove ;
;
;scrfetchlfa
;    .byt $de,$ad
;    .byt (_scrfetch-*-1)|bit7
;    .asc "SCR","@"|bit7
_scrfetch
#include "enter.i65"
    .word dup
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
usingeditor                     ; this address is tested for by (BLOCK) to see if it's the editor calling
    .word _pblock
#include "page.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch               ; IF
    .byt <(scrfetch01-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
scrfetch01
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SCRDEL   ( scr -- packet )
;
; delete the screen from the packet buffer.
;
;": scrdel   ( scr -- packet )
;     blk@
;     dup @ 
;     vmbuf @ 2dup +
;     dup
;     vmbuf ! rot
;     cmove
;     vmsiz 1-! ;
;
;scrdelfa
;    .byt $de,$ad
;    .byt (_scrdel-*-1)|bit7
;    .asc "SCRDE","L"|bit7
_scrdel
#include "enter.i65"
    .word _pktfetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store
#include "page.i65"
    .word rot
#include "page.i65"
    .word cmove
#include "page.i65"
    .word vmsiz
#include "page.i65"
    .word oneminusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- size/flags )
;
; Create a new packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded screen codes,
; and the last two bytes of the packet is the total size.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrapabove                  ( blkbuf d )
;     rot dup >r                    ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r                    ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!                           ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing        ( vidram nonblanksiz ) ( R; blkbuf blkbuf+3 )
;     r> swap                       ( vidram blkbuf+3 nonblanksiz ) ( R; blkbuf )
;     rlencode                      ( targend ) ( R; blkbuf )
;     dup 2+ r>                     ( targend targend+2 blkbuf )
;     - dup rot ! ;                 ( size )
;
mkpktlfa
    .byt $de,$ad
    .byt (_mkpkt-*-1)|bit7
    .asc "MKPK","T"|bit7
_mkpkt
#include "enter.i65"
    .word clit
    .byt 25
#include "pad.i65"
    .word wrapabove
#include "page.i65"
    .word rot
#include "page.i65"
    .word dup
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "page.i65"
    .word threecstore
#include "page.i65"
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word _dashtrailing
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word swap
#include "page.i65"
    .word rlencode
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus             ; ( addr size )
#include "page.i65"
    .word dup
#include "page.i65"
    .word rot
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       SCRINS   ( scr -- )
;
; insert the current screen into the packet buffer.
;
;": scrins   ( scr -- )
;     25 wrapabove
;     blkbuf dup >r dup 3 + >r 3c!
;     vidram r> 1000 rlencode
;     r> - >r
;     blk@                        
;     vmbuf @ dup r@ - r@
;     cmove>
;     r@ over !
;     r@ - 2+ blkbuf swap r>
;     cmove 
;     vmsiz 1+! ;
;
;scrinslfa
;    .byt $de,$ad
;    .byt (_scrins-*-1)|bit7
;    .asc "SCRIN","S"|bit7
;_scrins
;#include "enter.i65"
;    .word clit
;    .byt 25
;#include "pad.i65"
;    .word wrapabove
;#include "page.i65"
;    .word _blkbuf
;#include "page.i65"
;    .word dup
;#include "page.i65"
;    .word tor
;#include "page.i65"
;    .word dup
;#include "page.i65"
;    .word three
;#include "page.i65"
;    .word plus
;#include "page.i65"
;    .word tor
;#include "page.i65"
;    .word threecstore
;#include "page.i65"
;    .word vidram
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word plit
;    .word 1000
;#include "pad.i65"
;    .word rlencode
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word minus
;#include "page.i65"
;    .word tor
;#include "page.i65"
;    .word _pktfetch
;#include "page.i65"
;    .word vmbuf
;#include "page.i65"
;    .word fetch
;#include "page.i65"
;    .word dup
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word minus
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word cmovegt
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word over
;#include "page.i65"
;    .word store
;#include "page.i65"
;    .word rfetch
;#include "page.i65"
;    .word minus
;#include "page.i65"
;    .word twoplus
;#include "page.i65"
;    .word _blkbuf
;#include "page.i65"
;    .word swap
;#include "page.i65"
;    .word rfrom
;#include "page.i65"
;    .word cmove
;#include "page.i65"
;    .word vmsiz
;#include "page.i65"
;    .word oneplusstore
;#include "page.i65"
;    .word exit

;--------------------------------------------------------------
;
;       EDITCOPY   ( -- )
;
; STOP-C   Copy current line to end of paste buffer
;
;": editcopy
;    currline >paste 2drop ;
;
;editcopylfa
;    .byt $de,$ad
;    .byt (_editcopy-*-1)|bit7
;    .asc "EDITCOP","Y"|bit7
_editcopy
#include "enter.i65"
    .word _paste
#include "page.i65"
    .word logline           ; ( paste line )
#include "page.i65"
    .word lineinfo          ; ( paste screen 40|80 )
#include "page.i65"
    .word ptopaste          ; ( paste+ screen+ screen paste+1 len )
#include "page.i65"
    .word cmove
#include "page.i65"
    .word twodrop          ; ( )
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITDEL   ( -- )
;
; delete the current line, appending it to the paste buffer
;
;": editdel
;    \ append the current line to the paste buffer
;    editcopy
;    \ mark the tail of the paste buffer and start a new buffer here
;    paste dup >r               ( tpaste ) ( R; tpaste )
;    \ append all lines from the next one to the bottom of screen to paste
;    logline logline+ eos>paste ( ) ( R; tpaste )
;    \ put everything back, with linewrap
;    r@ logline lineinfo drop   ( tpaste screen ) ( R; tpaste )
;    paste>                     ( d tpaste+ screen+ )
;    VIDRAM+1000 over - blank   ( d tpaste+ ) ( R; tpaste )
;    drop r> off                ( d )
;    begin
;        40 wrapfill            ( d flag )
;    until
;    wrap! ;
;
;editdellfa
;    .byt $de,$ad
;    .byt (editdel-*-1)|bit7
;    .asc "EDITDE","L"|bit7
_editdel
#include "enter.i65"
    .word _editcopy             ; ( )
#include "page.i65"
    .word _paste                ; ( pastebuf2 )
#include "page.i65"
    .word dup                   ; ( pastebuf2 pastebuf2 )
#include "page.i65"
    .word tor                   ; ( pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word logline               ; ( pastebuf2 logline ) ( R; pastebuf2 )
#include "page.i65"
    .word loglineplus           ; ( pastebuf2 logline+ ) ( R; pastebuf2 )
#include "page.i65"
    .word _eostopaste           ; ( ) ( R; pastebuf2 ) send nextline...EOS to pastebuf2
#include "page.i65"
    .word rfetch                ; ( pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word logline               ; ( pastebuf2 logline ) ( R; pastebuf2 )
#include "page.i65"
    .word lineinfo              ; ( pastebuf2 screen 40|80 ) ( R; pastebuf2 )
#include "page.i65"
    .word drop                  ; ( pastebuf2 screen ) ( R; pastebuf2 )
#include "page.i65"
    .word _pastefrom            ; ( pastebuf2 screen ) ( R; pastebuf2 ) should exhaust the pastebuffer
#include "page.i65"
    .word plit                  ; ( d pastebuf2 screen 33768 ) ( R; pastebuf2 )
    .word VIDRAM+1000
#include "pad.i65"              
    .word over                  ; ( d pastebuf2 screen 33768 screen ) ( R; pastebuf2 ) 
#include "page.i65"
    .word minus                 ; should always get 40 or 80
#include "page.i65"
    .word _blank                ; ( d pastebuf2 ) ( R; pastebuf2 )
#include "page.i65"
    .word drop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word off
#include "page.i65"
editdel01                       ; BEGIN
    .word clit
    .byt 40
#include "pad.i65"
    .word wrapplus
#include "page.i65"
    .word qbranch
    .byt <(editdel01-*+1)       ; UNTIL
#include "pad.i65"
    .word wrapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPASTE   ( -- )
;
; STOP-P 
; insert the paste buffer before the current line
;
;": editpaste   ( -- )
;     \ mark the current tail of the paste buffer
;     paste dup >r                      ( tpaste ) ( R; tpaste )
;     \ append everything to end of screen to secondary paste buffer
;     logline eos>paste                 ( ) ( R; tpaste )
;     \
;     pad logline lineinfo drop         ( paste screen ) ( R; tpaste )
;     \ put everything back
;     paste>                            ( d paste+ screen+ ) ( R; tpaste )
;     2drop  r> off  wrap! ;
;
;editpastelfa
;    .byt $de,$ad
;    .byt (_editpaste-*-1)|bit7
;    .asc "EDITPAST","E"|bit7
_editpaste
#include "enter.i65"
    .word _paste                        ; ( tpaste )
#include "page.i65"
    .word dup                           ; ( tpaste tpaste )
#include "page.i65"
    .word tor                           ; ( tpaste ) ( R; tpaste )
#include "page.i65"
    .word logline                       ; ( tpaste logline ) ( R; tpaste )
#include "page.i65"
    .word _eostopaste                   ; ( ) ( R; tpaste )
#include "page.i65"
    .word _pad                          ; ( paste )
#include "page.i65"
    .word logline                       ; ( paste logline ) ( R; tpaste )
#include "page.i65"
    .word lineinfo                      ; ( paste screen 40|80 ) ( R; tpaste )
#include "page.i65"
    .word drop                          ; ( paste screen ) ( R; tpaste )
#include "page.i65"
    .word _pastefrom                    ; ( d paste+ screen+ ) ( R; tpaste )
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word off
#include "page.i65"
    .word wrapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITZILCH   ( -- )
;
; STOP-Z   Zilch the paste buffer
;
;": editzilch   ( -- )
;     pad off ;
;
;editzilchlfa
;    .byt $de,$ad
;    .byt (editzilch-*-1)|bit7
;    .asc "EDITZILC","H"|bit7
_editzilch
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNOWRAP   ( -- )
;
; reset the linewrap table and make this screen writeable
;
;editnowraplfa
;    .byt $de,$ad
;    .byt (_editnowrap-*-1)|bit7
;    .asc "EDITNOWRA","P"|bit7
_editnowrap
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word on
#include "page.i65"
    .word to6502
    stx storex
    ldx #24
editnowrap01
    asl $e0,x
    sec
    ror $e0,x
    dex
    bpl editnowrap01
    ldx storex
    jmp next

;--------------------------------------------------------------
;
;       EDITTOPSCR   ( -- )
;
; restore from the top (first) screen
;
;edittopscrlfa
;    .byt $de,$ad
;    .byt (edittopscr-*-1)|bit7
;    .asc "EDITTOPSC","R"|bit7
edittopscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNEXTSCR   ( -- )
;
; restore from the next screen or append a blank one
;
;editnextscrlfa
;    .byt $de,$ad
;    .byt (editnextscr-*-1)|bit7
;    .asc "EDITNEXTSC","R"|bit7
editnextscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPREVSCR   ( -- )
;
; restore from the previous screen or insert a blank one
;
editprevscrlfa
    .byt $de,$ad
    .byt (editprevscr-*-1)|bit7
    .asc "EDITPREVSC","R"|bit7
editprevscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITQUIT   ( -- )
;
; STOP-Q   Quit the editor
;
;editquitlfa
;    .byt $de,$ad
;    .byt (editquit-*-1)|bit7
;    .asc "EDITQUI","T"|bit7
_editquit
#include "enter.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _scrstore
#include "page.i65"
    .word rfrom         ; discard returns
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word drop          ; we won't be needing these
#include "page.i65"
    .word exit          ; exiting from EDIT

;--------------------------------------------------------------
;
;       EDITINDEX   ( -- )
;
; STOP-I   Present an index screen and let the user select one to edit
;
;editindexlfa
;    .byt $de,$ad
;    .byt (editindex-*-1)|bit7
;    .asc "EDITINDE","X"|bit7
editindex
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITSAVE   ( -- )
;
; STOP-S   Save all buffers to a PRG file
;
;editsavelfa
;    .byt $de,$ad
;    .byt (editsave-*-1)|bit7
;    .asc "EDITSAV","E"|bit7
editsave
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITLOAD   ( -- )
;
; STOP-L   Load a group of buffers from a PRG file
;
;editloadlfa
;    .byt $de,$ad
;    .byt (editload-*-1)|bit7
;    .asc "EDITLOA","D"|bit7
_editload
#include "enter.i65"
    .word _pdq
    .byt editload02-*-1
    .asc    CLR,"LOADING"
editload02
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITVERIFY   ( -- )
;
; STOP-V   Verify a buffer file vs. memory
;
;editverifylfa
;    .byt $de,$ad
;    .byt (editverify-*-1)|bit7
;    .asc "EDITVERIF","Y"|bit7
editverify
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITRESTORE   ( -- )
;
; STOP-R   Restore the current screen from the buffer
;
editrestorelfa
    .byt $de,$ad
    .byt (editrestore-*-1)|bit7
    .asc "EDITRESTOR","E"|bit7
editrestore
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITDELSCR   ( -- )
;
; delete the current screen.  restore from next, then prev, then blank
;
;editdelscrlfa
;    .byt $de,$ad
;    .byt (editdelscr-*-1)|bit7
;    .asc "EDITDELSC","R"|bit7
editdelscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITINSSCR   ( -- )
;
; insert a new, blank screen
;
;editinsscrlfa
;    .byt $de,$ad
;    .byt (editinsscr-*-1)|bit7
;    .asc "EDITINSSC","R"|bit7
editinsscr
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITINIT   ( scr -- )
;
; prepare before we drop into the editor infinite loop
;
;": editinit   ( scr -- )
;     scr@ editzilch ;
;
;editinitlfa
;    .byt $de,$ad
;    .byt (_editinit-*-1)|bit7
;    .asc "EDITINI","T"|bit7
_editinit
#include "enter.i65"
    .word _scrfetch
#include "page.i65"
    .word _editzilch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITMENU   ( -- addr )
;
; returns the address of a counted string of menu commands
;
;editmenulfa
;    .byt $de,$ad
;    .byt (editmenu-*-1)|bit7
;    .asc "EDITMEN","U"|bit7
editmenu
     jsr docreate
     .byt editmenu01-*-1        ; number of menu items = 16
     .asc "QISLVZRDCP"          ; command keys
     .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenu01
     .word _editquit             ; CFA of corresponding Forth word
     .word editindex
     .word editsave
     .word _editload
     .word editverify
     .word _editzilch
     .word editrestore
     .word _editdel
     .word _editcopy
     .word _editpaste
     .word editdelscr
     .word editinsscr
     .word edittopscr
     .word _editnowrap
     .word editnextscr
     .word editprevscr

;--------------------------------------------------------------
;
;       EDITCMD   ( -- )
;
; get a key and perform that command
;
;editcmdlfa
;    .byt $de,$ad
;    .byt (_editcmd-*-1)|bit7
;    .asc "EDITCM","D"|bit7
_editcmd
#include "enter.i65"
    .word editmenu              ; ( editmenu )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex              ; ( index|0 )
#include "page.i65"
    .word qdup                  ; ( index index | 0 )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editcmd01-*+1)
#include "pad.i65"
    .word twostar               ; ( 2*index )
#include "page.i65"
    .word editmenu              ; ( 2*index editmenu ) 
#include "page.i65"
    .word dup                   ; ( 2*index editmenu editmenu ) 
#include "page.i65"
    .word cfetch                ; ( 2*index editmenu #items ) 
#include "page.i65"
    .word plus                  ; ( 2*index editmenu+#items ) 
#include "page.i65"
    .word plus                  ; ( 2*index+editmenu+#items ) 
#include "page.i65"
    .word oneminus              ; ( 2*index+editmenu+#items-1 ) 
#include "page.i65"
    .word fetch                 ; ( editcmdcfa )
#include "page.i65"
    .word execute               ; ( )
#include "page.i65"
editcmd01                       ; THEN
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITIRQTOGGLE   ( -- )
;
; Enable or disable the IRQ handler within EDIT that checks for
; the STOP key in the screen editor.
;
;editirqtogglelfa
;    .byt $de,$ad
;    .byt (editirqtoggle-*-1)|bit7
;    .asc "EDITIRQTOGGL","E"|bit7
_editirqtoggle
#include "enter.i65"
    .word plit
    .word (MAINIRQ^edit02)
#include "pad.i65"
    .word clit
    .byt <CINV       ; $90
#include "pad.i65"
    .word togglevector
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDIT   ( scr -- )
;
editlfa
    .byt $de,$ad
    .byt (_edit-*-1)|bit7
    .asc "EDI","T"|bit7
_edit
#include "enter.i65"
    .word _editinit
#include "page.i65"
edit00              ; reentry to editor here
    .word _editirqtoggle   ; enable STOP key trap
#include "page.i65"
    .word to6502
    stx storex      ; preserve Forth data stack pointer
    tsx
    stx n           ; preserve machine stack frame pointer

edit01              ; PET screen editor forever loop
    jsr CHRIN       ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #$0d        ; don't just leave the cursor two characters past end of line
    jsr CHROUT      ; Kernel - so echo the carriage return
    jmp edit01      ; ... do this forever

edit02              ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda $9b         ; copy of contents of PIA1 Port B for testing STOP key, etc...
    cmp #$ef        ; test STOP key
    bne edit03
                    ; looks like someone pressed STOP. Exit the editor
                    ; but not so fast!  Are we in quotes or inserts?
    lda $cd         ; nonzero is quotes mode
    ora $dc         ; number of inserts pending
    beq edit04
edit03
    jmp MAINIRQ     ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
edit04
    jsr UDTIM       ; keep the clock running even if someone leans on STOP
    ;sec            ; because f7a1 debounce loop always sets carry
    inc $a7         ; turn off cursor
    lda $a9         ; true character at cursor position
    jsr FIX_CHR     ; ROM $E606 on 40-column BASIC4 PET
    ;jsr UNFLIP_CRSR ; ~wut? probably need to flip off the cursor
    ldx n
    txs             ; reset stack frame
    ldx storex      ; restore Forth stack pointer
#include "toforth.i65"
    .word _editirqtoggle        ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd  ; get and perform editor command
#include "page.i65"
    .word branch
    .byt <(edit00-*+1)
#include "pad.i65" ; this never executes. editquit breaks out by dropping returns
    .word exit

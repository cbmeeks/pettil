;--------------------------------------------------------------
;
;       EDITIRQTOGGLE   ( -- )
;
; Enable or disable the IRQ handler within EDIT that checks for
; the STOP key in the screen editor.
;
;editirqtogglelfa
;    .byt $de,$ad
;    .byt (editirqtoggle-*-1)|bit7
;    .asc "EDITIRQTOGGL","E"|bit7
_editirqtoggle
#include "enter.i65"
    .word plit
    .word (MAINIRQ^edit02)
#include "pad.i65"
    .word clit
    .byt <CINV       ; $90
#include "pad.i65"
    .word toggleirq
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITWRAP!   ( d startline -- )
;
; Updates a portion of the linewrap table at $E0 to reflect the bits
; stored in d, beginning at startline to end of the screen
; e.g. -1 -1 18 editwrap! would set lines 18-24 as 40-column
; line 1 is *always* $80, never a continuation line, so only 24 bits
; are used, not 25.  Put another way, 2 <= startline <= 25
;
editwrapstore
    ldy #2
    jsr setup
    stx storex
    ldx #24
editwrapstore01
    asl $e0,x
    lsr n+2
    ror n+1
    ror n
    ror $e0,x
    dex
    cpx tos
    bne editwrapstore01
    ldx storex
    jmp pops

;--------------------------------------------------------------
;
;       EDITWRAP@   ( d startline -- d )
;
; Reads (a portion of) the linewrap table in $E0, nondestructively
; shifting the high bits into a double, beginning at startline.
; e.g. 9 editwrap@ would return 
;
editwrapfetch
    ldy #2
    jsr setup
    ldy tos
editwrapfetch01
    asl $e0,y
    rol n
    rol n+1
    rol n+2
    lsr $e0,y
    inx
    cpx #24
    bne editwrapfetch01
    lda n
    sta tos
    lda n+1
    sta tos+1
    lda n+2
    ldy n+3
    jmp pushya

;--------------------------------------------------------------
;
;       EDITWRAPTOP@   ( -- d )
;
; Reads (a portion of) the linewrap table above the current physical
; line (stored at $D8) up to but not including the current line.  
; Returns a right-aligned double with copies of those high bit values
;
; $D8 = Current Cursor Physical Line Number
;
editwraptopfetch
    jsr slip
    iny
editwraptopfetch01
    cpy $d8
    beq editwraptopfetch02  ; done
    asl $e0,y
    rol tos
    rol tos+1
    rol n
    lsr $e0,y
    iny
    bne editwraptopfetch01  ; bra
editwraptopfetch02
    lda n
    ; high byte will be ignored
    jmp pushya

;--------------------------------------------------------------
;
;       EDITCURRLINE   ( -- addr 40|80 )
;
; return the starting address of the line at the cursor, and its length
;
;" : editcurrline   ( -- addr 40|80 )
;    c4 @  d5 c@ 1+ ;
;
;editcurrlinelfa
;    .byt $de,$ad
;    .byt (editcurrline-*-1)|bit7
;    .asc "EDITCURRLIN","E"|bit7
_editcurrline
#include "enter.i65"
    .word clit
    .byt $c4
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word clit
    .byt $d5
#include "pad.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPASTEBUF   ( -- addr )
;
; Return the address of the end of the paste buffer (marked by 0)
; The paste buffer consists of zero or more screen lines, stored as
; a length (40|80) followed by that many screen codes
;
;editpastebuflfa
;    .byt $de,$ad
;    .byt (pastebuf-*-1)|bit7
;    .asc "PASTEBU","F"|bit7
;": editpastebuf
;    pad                     ( pad )
;    begin
;        dup c@              ( addr len )
;        qdup                ( addr 0 | addr len len )
;    while                   ( addr len )
;        1+                  ( addr len+1 )
;        +                   ( newaddr )
;    repeat                  ( addr )
;
_editpastebuf
#include "enter.i65"
    .word _pad
#include "page.i65"
editpastebuf01                      ; BEGIN
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch               ; WHILE
    .byt <(editpastebuf02-*+1)
#include "pad.i65"
    .word oneplus
#include "page.i65"
    .word plus
#include "page.i65"
    .word branch               ; REPEAT
    .byt <(editpastebuf01-*+1)
#include "pad.i65"
editpastebuf02
    .word exit

;--------------------------------------------------------------
;
;       EDITINDEX   ( -- )
;
; STOP-I   Present an index screen and let the user select one to edit
;
;editindexlfa
;    .byt $de,$ad
;    .byt (editindex-*-1)|bit7
;    .asc "EDITINDE","X"|bit7
editindex
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITSAVE   ( -- )
;
; STOP-S   Save all buffers to a PRG file
;
;editsavelfa
;    .byt $de,$ad
;    .byt (editsave-*-1)|bit7
;    .asc "EDITSAV","E"|bit7
editsave
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITLOAD   ( -- )
;
; STOP-L   Load a group of buffers from a PRG file
;
;editloadlfa
;    .byt $de,$ad
;    .byt (editload-*-1)|bit7
;    .asc "EDITLOA","D"|bit7
_editload
#include "enter.i65"
    .word _pdq
    .byt editload02-*-1
    .asc    CLR,"LOADING"
editload02
#include "pad.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITVERIFY   ( -- )
;
; STOP-V   Verify a buffer file vs. memory
;
;editverifylfa
;    .byt $de,$ad
;    .byt (editverify-*-1)|bit7
;    .asc "EDITVERIF","Y"|bit7
editverify
#include "enter.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITZILCH   ( -- )
;
; STOP-Z   Zilch the paste buffer
;
editzilchlfa
    .byt $de,$ad
    .byt (editzilch-*-1)|bit7
    .asc "EDITZILC","H"|bit7
editzilch
#include "enter.i65"
    .word _pad
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITRESTORE   ( -- )
;
; STOP-R   Restore the current screen from the buffer
;
editrestorelfa
    .byt $de,$ad
    .byt (editrestore-*-1)|bit7
    .asc "EDITRESTOR","E"|bit7
editrestore
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITCOPYLINE   ( -- )
;
; STOP-C   Copy current line to end of paste buffer
;
; D5 has the length of the current line (39 or 79)
; C4 is the address of the start of the line
; _pad is the start of the paste buffer
;
;": editcopyline
;    editcurrline pastebuf 2dup c!
;    1+ swap cmove ;
;
;editcopylinelfa
;    .byt $de,$ad
;    .byt (editcopyline-*-1)|bit7
;    .asc "EDITCOPYLIN","E"|bit7
editcopyline
#include "enter.i65"
    .word _editcurrline    ; ( addr size )
#include "page.i65"
    .word _editpastebuf        ; ( addr size buf )
#include "page.i65"
    .word _twodup          ; ( addr size buf size buf )
#include "page.i65"
    .word cstore           ; ( addr size buf )
#include "page.i65"
    .word oneplus          ; ( addr size buf+1 )
#include "page.i65"
    .word swap             ; ( addr buf+1 size )
#include "page.i65"
    .word _twodup          ; ( addr buf+1 size buf+1 size )
#include "page.i65"
    .word plus             ; ( addr buf+1 size buf+1+size )
#include "page.i65"
    .word off              ; ( addr buf+1 size )
#include "page.i65"
    .word cmove            ; ( )
#include "page.i65"
    .word exit

nextphysline
    ldy $d8 ; cursor physical line 0..24
    ldy d8
    lda $e0,y
    iny
    bmi +
    iny
    tya
    jmp pushya
    
; move everything below this line up to here

    lda #4
    cmp $e0+1,y ; 00 01 02 03=set carry 80 81 82 83=clear carry
    tya
    adc #1
    jmp pushya  ; [15]

;--------------------------------------------------------------
;
;       EDITDELLINE   ( -- )
;
; delete the current line, appending it to the paste buffer
;
;": editdelline
;    editcopyline 
;    editcurrline dup   ( lineaddr 40|80 40|80 )
80 = negate   ( lineaddr 40|80 0|1 )
;    editwraptop@   ( lineaddr 40|80 0|1 d )
;    d8 c@ editwrap@   ( lineaddr 40|80 0|1 d )
rot -1 do
  d2* 1 m+
  loop   >r >r
  2dup + lrot cmove
  
;    d8 c@ over 40 / +    ( d lineaddr 40|80 (d8)++ )
;    swap >r 0 do  ( d -- ; r; lineaddr )
;    
;    editcurrline pastebuf 2dup c!
;    1+ swap cmove ;
;
; copy the current line
; copy linewrap table above this line
; append linewrap table below this line
; roll in 1 or 2 40-column bits
; move everything below this line up to here
; write the new linewrap table to $e0
;
;editdellinelfa
;    .byt $de,$ad
;    .byt (editdelline-*-1)|bit7
;    .asc "EDITDELLIN","E"|bit7
editdelline
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPASTE   ( -- )
;
; insert the paste buffer at the cursor position
;
editpastelfa
    .byt $de,$ad
    .byt (editpaste-*-1)|bit7
    .asc "EDITPAST","E"|bit7
editpaste
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITDELSCR   ( -- )
;
; delete the current screen.  restore from next, then prev, then blank
;
;editdelscrlfa
;    .byt $de,$ad
;    .byt (editdelscr-*-1)|bit7
;    .asc "EDITDELSC","R"|bit7
editdelscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITINSSCR   ( -- )
;
; insert a new, blank screen
;
;editinsscrlfa
;    .byt $de,$ad
;    .byt (editinsscr-*-1)|bit7
;    .asc "EDITINSSC","R"|bit7
editinsscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITTOPSCR   ( -- )
;
; restore from the top (first) screen
;
edittopscrlfa
    .byt $de,$ad
    .byt (edittopscr-*-1)|bit7
    .asc "EDITTOP","R"|bit7
edittopscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNOWRAP   ( -- )
;
; reset the linewrap table
;
;editnowraplfa
;    .byt $de,$ad
;    .byt (editnowrap-*-1)|bit7
;    .asc "EDITNOWRA","P"|bit7
editnowrap
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITNEXTSCR   ( -- )
;
; restore from the next screen or append a blank one
;
editnextscrlfa
    .byt $de,$ad
    .byt (editnextscr-*-1)|bit7
    .asc "EDITNEXTSC","R"|bit7
editnextscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITPREVSCR   ( -- )
;
; restore from the previous screen or insert a blank one
;
editprevscrlfa
    .byt $de,$ad
    .byt (editprevscr-*-1)|bit7
    .asc "EDITPREVSC","R"|bit7
editprevscr
#include "enter.i65"
    .word xyzzy
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITQUIT   ( -- )
;
; STOP-Q   Quit the editor
;
;editquitlfa
;    .byt $de,$ad
;    .byt (editquit-*-1)|bit7
;    .asc "EDITQUI","T"|bit7
editquit
#include "enter.i65"
    .word rfrom         ; discard returns
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twodrop
#include "page.i65"
    .word drop          ; we won't be needing these
#include "page.i65"
    .word exit          ; exiting from EDIT

;--------------------------------------------------------------
;
;       EDITSCR   ( -- addr )
;
; a variable used to hold the current screen (e.g. 1 = top)
;
;editscrlfa
;    .byt $de,$ad
;    .byt (editscr-*-1)|bit7
;    .asc "EDITSC","R"|bit7
editscr
    jsr docreate
    .word 0

;--------------------------------------------------------------
;
;       EDITINIT   ( -- )
;
; prepare before we drop into the editor infinite loop
;
;editinitlfa
;    .byt $de,$ad
;    .byt (editinit-*-1)|bit7
;    .asc "EDITINI","T"|bit7
editinit
#include "enter.i65"
    .word editzilch
#include "page.i65"
    .word cr
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDITMENU   ( -- addr )
;
; returns the address of a counted string of menu commands
;
editmenulfa
    .byt $de,$ad
    .byt (editmenu-*-1)|bit7
    .asc "EDITMEN","U"|bit7
editmenu
     jsr docreate
     .byt editmenu01-*-1        ; number of menu items = 16
     .asc "QISLVZRDCP"          ; command keys
     .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenu01
     .word editquit             ; CFA of corresponding Forth word
     .word editindex
     .word editsave
     .word _editload
     .word editverify
     .word editzilch
     .word editrestore
     .word editdelline
     .word editcopyline
     .word editpaste
     .word editdelscr
     .word editinsscr
     .word edittopscr
     .word editnowrap
     .word editnextscr
     .word editprevscr

;--------------------------------------------------------------
;
;       EDITCMD   ( -- )
;
; get a key and perform that command
;
;editcmdlfa
;    .byt $de,$ad
;    .byt (_editcmd-*-1)|bit7
;    .asc "EDITCM","D"|bit7
_editcmd
#include "enter.i65"
    .word editmenu              ; ( editmenu )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex              ; ( index|0 )
#include "page.i65"
    .word qdup                  ; ( index index | 0 )
#include "page.i65"
    .word qbranch               ; IF
    .byt <(editcmd01-*+1)
#include "pad.i65"
    .word twostar               ; ( 2*index )
#include "page.i65"
    .word editmenu              ; ( 2*index editmenu ) 
#include "page.i65"
    .word dup                   ; ( 2*index editmenu editmenu ) 
#include "page.i65"
    .word cfetch                ; ( 2*index editmenu #items ) 
#include "page.i65"
    .word plus                  ; ( 2*index editmenu+#items ) 
#include "page.i65"
    .word plus                  ; ( 2*index+editmenu+#items ) 
#include "page.i65"
    .word oneminus              ; ( 2*index+editmenu+#items-1 ) 
#include "page.i65"
    .word fetch                 ; ( editcmdcfa )
#include "page.i65"
    .word execute               ; ( )
#include "page.i65"
editcmd01                       ; THEN
#include "page.i65"
    .word exit

;--------------------------------------------------------------
;
;       EDIT   ( -- )
;
editlfa
    .byt $de,$ad
    .byt (_edit-*-1)|bit7
    .asc "EDI","T"|bit7
_edit
#include "enter.i65"
    .word editinit
#include "page.i65"
edit00              ; reentry to editor here
    .word _editirqtoggle   ; enable STOP key trap
#include "page.i65"
    .word to6502
    stx storex      ; preserve Forth data stack pointer
    tsx
    stx n           ; preserve machine stack frame pointer

edit01              ; PET screen editor forever loop
    jsr CHRIN       ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #$0d        ; don't just leave the cursor two characters past end of line
    jsr CHROUT      ; Kernel - so echo the carriage return
    jmp edit01      ; ... do this forever

edit02              ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda $9b         ; copy of contents of PIA1 Port B for testing STOP key, etc...
    cmp #$ef        ; test STOP key
    bne edit03
                    ; looks like someone pressed STOP. Exit the editor
                    ; but not so fast!  Are we in quotes or inserts?
    lda $cd         ; nonzero is quotes mode
    ora $dc         ; number of inserts pending
    beq edit04
edit03
    jmp MAINIRQ     ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
edit04
    jsr UDTIM       ; keep the clock running even if someone leans on STOP
    ;sec            ; because f7a1 debounce loop always sets carry
    inc $a7         ; turn off cursor
    lda $a9         ; true character at cursor position
    jsr FIX_CHR     ; ROM $E606 on 40-column BASIC4 PET
    ;jsr UNFLIP_CRSR ; ~wut? probably need to flip off the cursor
    ldx n
    txs             ; reset stack frame
    ldx storex      ; restore Forth stack pointer
#include "toforth.i65"
    .word _editirqtoggle        ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd  ; get and perform editor command
#include "page.i65"
    .word branch
    .byt <(edit00-*+1)
#include "page.i65" ; this never executes. editquit breaks out by dropping returns
    .word exit


; PETTIL16
; Personal Electronics Transactor Threaded Interpreted Language
;
; (A Forth-like language for my venerable Commodore PET 2001)
;
;" ven-er-a-ble (adj.)
;" 3 a : calling forth respect through age, character and attainments
;"   <a venerable jazz musician>; broadly : conveying an impression of
;"   aged goodness and benevolence <encouraged by the venerable doctor's
;"   head-nodding>
;
; chitselb 2010
;" http://chitselb.com
;" http://github.com/chitselb/pettil
; this code is in the public domain
;
; Dedicated to those heroes of mine I share a first name with
;
; Charles Henry Hitselberger - my dad, for teaching me to play chess
; Charles Allan Williams - my grandfather, for showing me how to tinker
; Charles Henry Hitselberger - my son, for tolerating me
; Michael Andrew Hitselberger - my son, even though he isn't a Charles, for
;     being as jazzed as I was when we turned on the PET after 25 years. 
; Chuck Peddle - creator of the 6502 and the Commodore PET
; Charles Moore - creator of Forth
; Charles M. Schultz - creator of Peanuts
; Charlie Brown - for teaching me how to read
;
;pettil16.a65
;
#include cbm.def

;bitmasks
bit7	= $80		; marks first/last bytes of name field
bit6	= $40		; immediate
bit5	= $20		; smudge

; zero page usage
stackl	= $00		; stackl = $00..$3a (59 bytes)
stackh	= $30		; stackh = $3b..$75 (59 bytes)
;stackh	= $3b		; stackh = $3b..$75 (59 bytes)
bos	= stackh-stackl	; includes TOS
tos	= $62		; top of stack
n	= tos+2		; scratch space, contiguous with tos.  see (?DO)
up	= tos+10	; user area pointer
zi	= tos+12	; innermost DO LOOP counter/limit
storex	= $ff		; unused zeropage for temporary stashing X register

next	= $86
;0086 next	inc ip
;0088		inc ip
nexto	= $8a
;008a nexto	jmp ($cafe)
ip	= $8b

;$8d..$ff kernel zeropage area

curindev	= $99
curoutdev	= $9a
inbuf		= $200

outputted	= cas2buf+(usercold-userarea+4)		; #out
inputted	= cas2buf+(usercold-userarea+20)	; span
linesout	= cas2buf+(usercold-userarea+32)	; #line

basic		= $0400
		.word basic+1		; PET BASIC storage starts here
*		= basic+1
		.word basend
		.word 10
		.byt $9e
		.asc " 1038",0		; sys $040e
basend		.word 0

coldvector	jmp cold
warmvector	jmp warm

		; user area initialization data
		; this gets copied to the cassette buffer
		; and is pointed to by the UP (user pointer)
userarea
userup		.word cas2buf				; 0..1		W
usersp0		.word bos				; 2..3		A
userrp0		.word $01ff				; 4..5		R
userwidth	.word 31				; 6..7		M
userwarning	.word -1				; 8..9		.
userwarm
userfence	.word forgetfence			; 10..11	C
userdp		.word endofile				; 12..13	O
uservoclink	.word lastvoc				; 14..15	L
userviewquery	.word 2					; 16..17	D
usermlmon	.word $d478				; 18..19	.
usercold

lfalist		.dsb 32,0	; heads of link threads
bloom2		.dsb 8,0	; Forth vocabulary bloom filter for hash2
bloom2x
pearson		.byt 150,191,252,0,194,202,129,7
power2		.byt $01,$02,$04,$08,$10,$20,$40,$80

; Juggle things around as necessary to keep SET..PUSH within a single page

#include sweet16.a65

;--------------------------------------------------------------
; Drop down from high-level Forth to inline 6502
; ~ might want to take the sweetness out for speed here
to6502lfa	.word $adde
		.byt (to6502-*-1)|bit7
		.asc ">650","2"|bit7
to6502		brk
		.byt set  | N0
		.word ip
		.byt ldd  | N0
		.byt inr  | ACC
		.byt inr  | ACC
		.byt rtn
		jmp (R0L)

;--------------------------------------------------------------
; Jump up to high-level Forth from inline 6502
;
; Page boundary crossing is handled by the compiler inserting 'page'
; when the DP gets to $xxFD or $xxFE.  IP = $xxFF is never supposed
; to occur, and indicates an error in the compiler.
;
; Pad is used by LITERAL and string routines to offset IP at runtime
;
;~" todo: make an ASSEMBLER vocabulary word >FORTH to insert the call
; and handle pagination properly like the "toforth.i65" include file
toforth		pla
		sta ip
		pla
		sta ip+1
		lda #1

		; pass A = offset added to IP
pad		clc
		adc ip
		bcs pagen		; check for page boundary crossing
		cmp #$ff
		bne pado		; check for xxFF at end of page
page		lda #0
pagen		inc ip+1		; cross the page
pado		sta ip
		jmp nexto

;--------------------------------------------------------------
sweet16on	lda #<SW16
		sta BRKVEC
		lda #>SW16
		sta BRKVEC+1		; set up Sweet-16
		rts

;--------------------------------------------------------------
slide		lda stackl,x		; slide something off of the stack
		sta tos
		lda stackh,x
		sta tos+1
		inx
		rts

;--------------------------------------------------------------
slip		dex			; slip something onto the stack
		lda tos+1
		sta stackh,x
		lda tos
		sta stackl,x
		rts

;--------------------------------------------------------------
		; pops up to 4 words from the split stack to N area
		; Y = how many words to pop (valid range 1-4)
		; returns
		; Y = 0
		; TOS unchanged
		; 2OS -> N0, 3OS -> N1, 4OS -> N2, 5OS -> N3
		;      1          2          3          4
setup		sty storex
		ldy #0
setup01		lda stackl,x
		sta n,y
		lda stackh,x
		sta n+1,y
		iny
		iny
		inx
		dec storex
		bne setup01
		ldy #0
		rts

;--------------------------------------------------------------
		; push up to 4 words from the N area to the data stack
		; Y = how many words to push (valid range 1-4)
		; returns
		; Y = 0
		; TOS unchanged
		; N0 -> 2OS, N1 -> 3OS, N2 -> 4OS, N3 -> 5OS
		;      1          2          3          4
restack		tya
		asl
		tay
restack01	dex
		lda n-2,y
		sta stackl,x
		lda n-1,y
		sta stackh,x
		dey
		dey
		bne restack01
		rts

;--------------------------------------------------------------
;
;	NEXT
;
; * inner interpreter headerless
;
;		+IP
;		[IP] -> PC
;
; minimalist NEXT, copied to zeropage by COLD
zpnext	inc ip
	inc ip
	jmp ($cafe)
zpend

;--------------------------------------------------------------
rootlfa		.word 0
		.byt 31			; longest word in the dictionary

;--------------------------------------------------------------
;
;	EXECUTE
;
; * 83 nucleus
;
; Executes the definition found at addr.
;
;"	: execute ( cfa --- )
;"		jmp cfa ;
;
; [SP+] -> [W1]
; IP -> [W1+4]
; W1 -> IP
; NEXTO
executelfa	.word $adde		; <-- link field address
		.byt (execute-*-1)|bit7	; <-- name field address
		.asc "EXECUT","E"|bit7
execute		lda tos			; <-- code field address
		sta w1			; in direct-threaded models, this
		lda tos+1		; contains code instead of a pointer
		sta w1+1		; [SP] -> [W1]
		lda ip+1
		pha
		lda ip
		pha
		lda #<(w1-2)
		sta ip
		lda #>(w1-2)
		sta ip+1
		jmp pops
w1		.word $dead		; (for when you just need a W register)
		.word exit		; 'fragment secondary' used by EXECUTE

;--------------------------------------------------------------
; first fix the brk instruction so we can use TIM instead of Sweet16
mon		ldy #(usermlmon-userarea)
		lda (up),y
		sta BRKVEC
		iny
		lda (up),y
		sta BRKVEC+1
 		brk			; presumably we return here
		jsr sweet16on
		jmp next

;--------------------------------------------------------------
;
;	(LIT)
;
; * inner interpreter headerless
;
; push the word of memory following (IP)
;
;plitlfa	.word $adde
;		.byt (plit-*-1)|bit7
;		.asc "(LIT",")"|bit7
plit		jsr slip
		ldy #3
		lda (ip),y
		inc ip
		ldy #1
		jmp lithi

;--------------------------------------------------------------
;
;	CLIT
;
; * inner interpreter headerless
;
; takes the byte of memory following and pushes it to the data stack
;
;clitlfa	.word $adde
;		.byt (clit-*-1)|bit7
;		.asc "CLI","T"|bit7
clit		jsr slip
		lda #0
		ldy #2
lithi		sta tos+1
		lda (ip),y
		sta tos
		lda #3
		jmp pad

;--------------------------------------------------------------
;
;	?BRANCH   ( flag -- )
;
; * inner interpreter control headerless
;
;qbranchlfa	.word $adde
;		.byt (qbranch-*-1)|bit7
;		.asc "?BRANC","H"|bit7
qbranch		lda tos
		ora tos+1
		ldy stackl,x
		sty tos
		ldy stackh,x
		sty tos+1
		inx		; drop
		tay		; to set the Z flag
		beq branch
bump		lda #4
		jmp pad

;--------------------------------------------------------------
;
;	(?DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; Performs a do-loop if end<>begin
;pqdolfa	.word $adde
;		.byt (pqdo-*-1)|bit7
;		.asc "(?DO",")"|bit7
pqdo		ldy #1
		jsr setup		; end -> N0
		lda tos
		eor n
		sta n+2
		lda tos+1
		eor n+1
		ora n+2
		tay			; Y=0 means no loop
		beq pqdo02
		ldy #3
pqdo01		lda zi,y		; set up for a loop
		pha
		lda tos,y		; tos & n must be adjacent in zeropage
		sta zi,y
		dey
		bpl pqdo01		; Y=FF means perform the loop
pqdo02		jsr slide
		tya			; sets the Z flag
		beq branch		; zero means end = begin (no loop)
		jmp bump

;--------------------------------------------------------------
;
;	BRANCH   ( -- )
;
; * inner interpreter control headerless
;
; Compiles an unconditional branch operation.
;" When used in the form: COMPILE BRANCH
; an unconditional branch operation is compiled.
; A one-byte branch offset must immediately follow
; this compilation address.  The branch address 
; is typically generated by following BRANCH
; with <RESOLVE or >MARK .
;
;"	: branch ( -- )
;
;branchlfa	.word $adde
;		.byt (branch-*-1)|bit7
;		.asc "BRANC","H"|bit7
; IP = address of 'branch' (you are here)
; IP+2 = absolute address of the target
branch		ldy #3		; [2]
		lda (ip),y	; [5]
		pha		; [3]
		dey		; [2]
		lda (ip),y	; [5]
		sta ip		; [3]
		pla		; [4]
		sta ip+1	; [3] (IP+2) -> IP
		jmp nexto	; [3]	[30]

;--------------------------------------------------------------
;
;	(+LOOP)   ( n -- )
;
; * inner interpreter control headerless
;
; add n to inner loop index.  If loop index exceeds loop limit,
; then iterate to the (do), otherwise skip past the branch and
; proceed
;pplooplfa	.word $adde
;		.byt (pploop-*-1)|bit7
;		.asc "(+LOOP",")"|bit7
pploop		clc
		lda tos
		adc zi
		sta zi
		lda tos+1
		adc zi+1
		sta zi+1
		lda zi+2
		cmp zi
		lda zi+3
		sbc zi+1
		ldy tos+1
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
		inx
		tay
		bcc pploop01
		eor #$80
pploop01	bmi branch
		bpl bump

;--------------------------------------------------------------
;
;	(LOOP)
;
; * inner interpreter control headerless
;
;plooplfa	.word $adde
;		.byt (ploop-*-1)|bit7
;		.asc "(LOOP",")"|bit7
ploop		inc zi
		bne ploop01
		inc zi+1
ploop01		lda zi+2
		eor zi
		bne branch
		lda zi+3
		eor zi+1
		bne branch
		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp bump

;--------------------------------------------------------------
;
;	(DO)   ( end begin -- )
;
; * inner interpreter control headerless
;
; loops from 'begin' to 'end'
;pdolfa		.word $adde
;		.byt (pdo-*-1)|bit7
;		.asc "(DO",")"|bit7
pdo		lda stackh,x
		sta n+1
		lda stackl,x
		sta n			; end -> N0
		ldy #3
pdo01		lda zi,y		; set up for a loop
		pha
		lda tos,y		; takes advantage of tos being
		sta zi,y		; adjacent to zi area
		dey
		bpl pdo01
poptwo		inx
pops		ldy stackh,x
		lda stackl,x
		inx
put		sty tos+1
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	I
;
; * 83 nucleus
;
ilfa		.word $adde
		.byt (i-*-1)|bit7
		.asc "I"|bit7
i		ldy zi+1
		lda zi
		; pass YA = value to push/put on stack
pushya		pha
		jsr slip
		pla
		jmp put

;--------------------------------------------------------------
;
;	J
;
; * 83 nucleus
;
jlfa		.word $adde
		.byt (j-*-1)|bit7
		.asc "J"|bit7
j		stx storex
		tsx
		ldy $0102,x
		lda $0101,x		; ~ test this
		ldx storex
		jmp pushya

;--------------------------------------------------------------
;
;	(LEAVE)
;
; * inner interpreter control headerless
;
;pleavelfa	.word $adde
;		.byt (pleave-*-1)|bit7
;		.asc "(LEAVE",")"|bit7
pleave		pla
		sta zi
		pla
		sta zi+1
		pla
		sta zi+2
		pla
		sta zi+3
		jmp branch

;--------------------------------------------------------------
;
;	(?LEAVE)
;
; * inner interpreter control headerless
;
;pqleavelfa	.word $adde
;		.byt (pqleave-*-1)|bit7
;		.asc "(?LEAVE",")"|bit7
pqleave		lda tos
		ora tos+1
		php
		jsr slide
		plp
		bne pleave
		jmp bump

;--------------------------------------------------------------
;
;	DIGIT    ( char base -- digit true | false )
;
digitlfa	.word $adde
		.byt (digit-*-1)|bit7
		.asc "DIGI","T"|bit7
digit		ldy #0			; presume failure
		sec
		lda stackl,x
		sbc #'0'
		bmi digit02		; no num
		cmp #10
		bmi digit01		; is num
		sec
		sbc #7
		cmp #10
		bmi digit02
digit01		cmp tos
		bpl digit02
		sta stackl,x
		dey
		bmi digit03
digit02		inx
digit03		tya
		jmp put

;--------------------------------------------------------------
;
;	(FIND)   ( addr1 addr2 -- addr flag )
;
; * outer interpreter headerless
;
; addr1 is the address-2 of a counted string we are searching for.
; addr2 is the LFA at the head of a chain of LFAs
; returns
;	( CFA true ) if found normal word
;	( CFA 1 ) if found immediate word
;	( addr1+2 false ) if not found
;
;pfindlfa	.word $adde
;		.byt (pfind-*-1)|bit7
;		.asc "(FIND",")"|bit7
pfind		ldy #1
		jsr setup		; name -> N0
		sty n+5			; return flag = 0
		ldy #2
		lda (n),y
		and #$1f
		sta n+2			; length of name we are seeking
pfind01		lda (tos),y
		sta n+4			; raw length & flags
		and #$1f
		sta n+3			; just the length
		lda n+2
		cmp n+3			; compare lengths
		bcc pfind05		; found something longer, fail
		bne pfind04		; found something shorter, hop
		lda n+4			; just right
		and #bit5		; what about the smudge bit?
		bne pfind04		; hop if smudged
		lda n+3			; or n+2... doesn't matter
		adc #1			; adds 2 with carry already set
		tay
pfind02		lda (tos),y		; compare strings back-to-front
		eor (n),y
		asl			; ignoring bit7
		bne pfind04		; mismatch in strcmp, hop
		dey
		cpy #2
		bne pfind02
		;sec			; winner winner pizza dinner!
		ldy n+3			; let's return ( CFA flag )
		iny			; skip past LFA
		iny
		iny			; skip past length byte
		tya
		adc n
		sta tos
		ldy n+1
		bcc pfind03
		iny			; LFA+len+name might cross a page
pfind03		sty tos+1		; CFA -> TOS
		lda n+4
		asl
		asl			; bit6 is now in C flag
		bcs pfind06		; immediate word
		dec n+5
		bcc pfind06		; normal word

pfind04		ldy #0			; here's where we hop
		lda (tos),y
		pha
		iny
		lda (tos),y
		sta tos+1
		pla
		sta tos
		iny			; Y=2
		bne pfind01		; bra

pfind05		;clc			; not found
		lda n+1
		sta tos+1
		lda n
		adc #2
		sta tos
		bcc pfind06
		inc tos+1
		clc
pfind06		ldy n+5
		tya
		adc #0
		jmp pushya

;--------------------------------------------------------------
;
;	SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless selfmodifying
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skiplfa		.word $adde
		.byt (skip-*-1)|bit7
		.asc "SKI","P"|bit7
skip		lda #$d0		; BNE intruction
		sta skip02
skipscan	ldy #2
		jsr setup		; size1 -> N0; addr1 -> N1
		stx storex
		ldx n			; sizelo
skip01		txa
		ora n+1			; sizehi
		beq skip05
		lda (n+2),y		; addr1,y
		eor tos
		asl			; ignore bit7
skip02		bne skip05
		iny
		bne skip03
		inc n+3
skip03		txa
		bne skip04
		dec n+1
skip04		dex
		jmp skip01
skip05		stx n
		ldx storex
		clc
		tya
		adc n+2
		sta tos
		ldy n+3
		bcc skip06
		iny
skip06		sty tos+1
		ldy n+1
		lda n
		jmp pushya

;--------------------------------------------------------------
;
;	SCAN   ( addr count char -- addr count )
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scanlfa		.word $adde
		.byt (scan-*-1)|bit7
		.asc "SCA","N"|bit7
scan		lda #$f0		; BNE intruction
		sta skip02
		jmp skipscan

;--------------------------------------------------------------
;
;	EMIT
;
; * 83 device
;
emitlfa		.word $adde
		.byt (emit-*-1)|bit7
		.asc "EMI","T"|bit7
emit		jmp emitvector
emitvector	inc outputted
		bne emit01
		inc outputted+1
emit01		lda tos
		jsr CHROUT
		jmp pops

;--------------------------------------------------------------
;
;	KEY
;
; * 83 device
;
keylfa		.word $adde
		.byt (key-*-1)|bit7
		.asc "KE","Y"|bit7
key		jmp keyvector
keyvector	stx n
key01		jsr GETIN
		beq key01
		ldx n
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	?TERMINAL
;
qterminallfa	.word $adde
		.byt (qterminal-*-1)|bit7
		.asc "?TERMINA","L"|bit7
qterminal	jmp qtermvector
qtermvector	stx n
		ldy #0
		jsr STOP
		bne qterminal01
		dey
qterminal01	tya
		pha
		ldx n
		jmp pushya

;--------------------------------------------------------------
;
;	CR
;
; * 83 device
;
crlfa		.word $adde
		.byt (cr-*-1)|bit7
		.asc "C","R"|bit7
cr		jmp crvector
crvector	lda #$0d
		jsr CHROUT
		ldy #0
		sty outputted
		sty outputted+1
		inc linesout
		bne cr01
		inc linesout+1
cr01		jmp next

;--------------------------------------------------------------
;
;	CMOVE   ( from to howmany -- )
;
; * 83 nucleus
;
;"~ see http://6502.org/source/general/memory_move.html
cmovelfa	.word $adde
		.byt (cmove-*-1)|bit7
		.asc "CMOV","E"|bit7
cmove		ldy #2
		jsr setup	; to -> N0; from -> N1
		stx storex
		inc tos+1
		ldx tos
		beq cmove03
cmove01		lda (n+2),y
		sta (n),y
		iny
		bne cmove02
		inc n+1
		inc n+3
cmove02		dex
		bne cmove01
cmove03		dec tos+1
		bne cmove01
		ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	CMOVE>   ( from to howmany -- )
;
; * 83 nucleus
;
cmovegtlfa	.word $adde
		.byt (cmovegt-*-1)|bit7
		.asc "CMOVE",">"|bit7
cmovegt		ldy #2
		jsr setup		; to -> N0; from -> N1
		stx storex
		lda tos+1
		pha
		clc
		adc n+3
		sta n+3
		pla
		clc
		adc n+1
		sta n+1
		ldy tos
		beq cmovegt02
cmovegt01	dey
		lda (n+2),y
		sta (n),y
		cpy #0
		bne cmovegt01
cmovegt02	ldx tos+1
		beq cmovegt05
cmovegt03	dec n+3
		dec n+1
cmovegt04	dey
		lda (n+2),y
		sta (n),y
		cpy #0
		bne cmovegt04
		dex
		bne cmovegt03
cmovegt05	ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	FILL   ( addr howmany value -- )
;
; * 83 nucleus
;
; ~ check this for howmany > 255
filllfa		.word $adde
		.byt (fill-*-1)|bit7
		.asc "FIL","L"|bit7
fill		ldy #2
		jsr setup	; howmany -> N0; addr -> N1
		stx storex
		lda tos
		ldx n+1
		beq fill02	; last page?
fill01		sta (n+2),y	; fill from here to end of this page
		iny
		bne fill01
		inc n+3
		dex
		bne fill01
fill02		ldx n
		beq fill04
fill03		sta (n+2),y
		iny
		dex
		bne fill03
fill04		ldx storex
		jmp next

;"~ check http://6502.org/source/ for multiply and divide and stuff
;--------------------------------------------------------------
;
;	UM*   ( u1 u2 -- ud )
;
; * 83 nucleus
;
; multiply u1 times u2 returning the double length product ud.
; All values and arithmetic are unsigned.
umstarlfa	.word $adde
		.byt (umstar-*-1)|bit7
		.asc "UM","*"|bit7
umstar		lda stackl,x
		sta n+4
		lda stackh,x		;multiplicand in tos
		sta n+5			;multiplier in N2
		jsr multiply		;16 bit unsigned multiply
		lda n
		sta stackl,x
		lda n+1
		sta stackh,x
		lda n+2
		sta tos
		lda n+3
		sta tos+1
		jmp next

multiply	lda #0			; unsigned multiply tos*N2 destroys tos
		sta n+2			;clear upper half of product
		sta n+3
		ldy #16
rshift		lsr tos+1
		ror tos
		bcc rrot		;Go rotate right if c = 0
		clc			; and add multiplicand to
		lda n+2			;Get upper half of product
		adc n+4			; it
		sta n+2
		lda n+3
		adc n+5
rrot		ror			;shift partial product right
		sta n+3
		ror n+2
		ror n+1
		ror n
		dey			;Decrement bit count and
		bne rshift
		rts

;--------------------------------------------------------------
;
;	UM/MOD   ( ud u -- rem quot )
;
; * 83 nucleus
;
;	~ needs a lot of work
;"	http://6502.org/source/integers/ummodfix/ummodfix.htm
umslashmodlfa	.word $adde
		.byt (umslashmod-*-1)|bit7
		.asc "UM/MO","D"|bit7
umslashmod	ldy #2
		jsr setup	; udhi -> N0; udlo -> N1
modulo		sec
		lda n+2		; Subtract hi cell of dividend by
		sbc n		; divisor to see if there's an overflow condition.
		lda n+3
		sbc n+1
		bcs modulo02	; Branch if /0 or overflow.
		;clc
		txa
		pha		; preserve data stack pointer
		ldx #16		; loop 16x
modulo01	rol n+4		; Rotate dividend lo cell left one bit.
		rol n+5
		dex		; loop counter
		bmi modulo03
		rol n+2
		rol n+3
		lda #0
		sta n+6
		rol n+6
		sec
		lda n+2
		sbc n
		sta n+7
		lda n+3
		sbc n+1
		tay
		lda n+6
		sbc #0
		bcc modulo01
		lda n+7
		sta n+2
		sty n+3
		bcs modulo01	; bra
modulo02	lda #$ff
		sta n+2
		sta n+3
		sta n+4
		sta n+5
modulo03	pla
		tax
		jmp swap	; more to do here... put stuff back on the stack

;--------------------------------------------------------------
;
;	AND   ( n1 n2 -- n1&n2 )
;
; * 83 nucleus
;
andxlfa		.word $adde
		.byt (andx-*-1)|bit7
		.asc "AN","D"|bit7
andx		lda tos
		and stackl,x
		sta tos
		lda tos+1
		and stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	OR   ( n1 n2 -- n1|n2 )
;
; * 83 nucleus
;
orxlfa		.word $adde
		.byt (orx-*-1)|bit7
		.asc "O","R"|bit7
orx		lda tos
		ora stackl,x
		sta tos
		lda tos+1
		ora stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	XOR   ( n1 n2 -- n1^n2 )
;
; * 83 nucleus
;
xorlfa	.word $adde
		.byt (xor-*-1)|bit7
		.asc "XO","R"|bit7
xor		lda tos
		eor stackl,x
		sta tos
		lda tos+1
		eor stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;
;	NOT   ( n -- !n )
;
; * 83 nucleus
;
notlfa		.word $adde
		.byt (not-*-1)|bit7
		.asc "NO","T"|bit7
not		lda tos
		eor #$ff
		sta tos
		lda tos+1
		eor #$ff
		sta tos+1
		jmp next

;--------------------------------------------------------------
;
;	SP@   ( -- sp )
;
spfetchlfa	.word $adde
		.byt (spfetch-*-1)|bit7
		.asc "SP","@"|bit7
spfetch		txa
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	SP!   ( -- )
;
spstorelfa	.word $adde
		.byt (spstore-*-1)|bit7
		.asc "SP","!"|bit7
spstore		ldy #usersp0-userarea
		lda (up),y
		tax
		jmp next

;--------------------------------------------------------------
;
;	RP!   ( -- )
;
rpstorelfa	.word $adde
		.byt (rpstore-*-1)|bit7
		.asc "RP","!"|bit7
rpstore		stx storex
		ldy #userrp0-userarea
		lda (up),y
		tax
		txs
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	EXIT   ( -- )
;
; * 83 nucleus
;
;		[RP+] -> IP
;		NEXT
; 09/15/10 cah
exitlfa		.word $adde
		.byt (exit-*-1)|bit7
		.asc "EXI","T"|bit7
exit		pla
		sta ip
		pla
		sta ip+1	; [RP+] -> IP
		jmp next	; NEXT

;--------------------------------------------------------------
;
;	>R   ( n -- )
;
; * 83 nucleus
;
torlfa		.word $adde
		.byt (tor-*-1)|bit7
		.asc ">","R"|bit7
tor		lda tos+1
		pha
		lda tos
		pha
		jmp pops

;--------------------------------------------------------------
;
;	R>   ( -- n )
;
; * 83 nucleus
;
rfromlfa	.word $adde
		.byt (rfrom-*-1)|bit7
		.asc "R",">"|bit7
rfrom		pla
		sta n
		pla
		tay
		lda n
		jmp pushya

;--------------------------------------------------------------
;
;	R@   ( -- n )
;
; * 83 nucleus
;
rfetchlfa	.word $adde
		.byt (rfetch-*-1)|bit7
		.asc "R","@"|bit7
rfetch		stx n
		tsx
		ldy $0102,x
		lda $0101,x
		ldx n
		jmp pushya

;--------------------------------------------------------------
;
;	0>   ( n -- flag )
;
; * 83 nucleus
;
zgtlfa		.word $adde
		.byt (zgt-*-1)|bit7
		.asc "0",">"|bit7
zgt		ldy #$ff
		bit tos+1
		bpl zgt01
		iny
zgt01		tya
		jmp put

;--------------------------------------------------------------
;
;	<>   ( n1 n2 -- flag )
;
nelfa	.word $adde
		.byt (ne-*-1)|bit7
		.asc "<",">"|bit7
ne		ldy #$ff		; assume inequality
		lda tos
		eor stackl,x
		bne ne01
		lda tos+1
		eor stackh,x
		bne ne01
		iny			; they're equal
ne01		tya
		inx
		jmp put

;--------------------------------------------------------------
;
;	ON   ( addr -- )
;
; store -1 at ADDR
onlfa		.word $adde
		.byt (on-*-1)|bit7
		.asc "O","N"|bit7
on		lda #$ff
on1		ldy #0
		sta (tos),y
		iny
		sta (tos),y
		jmp pops

;--------------------------------------------------------------
;
;	OFF   ( addr -- )
;
; store 0 at ADDR
offlfa		.word $adde
		.byt (off-*-1)|bit7
		.asc "OF","F"|bit7
off		lda #$00
		beq on1

;--------------------------------------------------------------
;
;	+   ( n1 n2 -- n1+n2 )
;
; * 83 nucleus
;
; 09/15/10 cah
pluslfa		.word $adde
		.byt (plus-*-1)|bit7
		.asc "+"|bit7
plus		clc
		lda tos
		adc stackl,x
		sta tos
		lda tos+1
		adc stackh,x
		sta tos+1
		inx
		jmp next

;--------------------------------------------------------------
;	
;	D+   ( d1 d2 -- d1+d2 )
;
; * 83 nucleus
;
dpluslfa	.word $adde
		.byt (dplus-*-1)|bit7
		.asc "D","+"|bit7
dplus		clc
		lda stackl,x
		adc stackl+2,x
		sta stackl+2,x
		lda stackh,x
		adc stackh+2,x
		sta stackh+2,x
		lda tos
		adc stackl+1,x
		sta stackl+1,x
		lda tos+1
		adc stackh+1,x
		sta stackh+1,x
		jmp poptwo

;--------------------------------------------------------------
;
;	D<   ( d1 d2 -- flag )
;
; * 83 nucleus
;
dltlfa		.word $adde
		.byt (dlt-*-1)|bit7
		.asc "D","<"|bit7
dlt		ldy #0		; false
		jsr dcmp
		bvc dlt01
		eor #$80
dlt01		bpl dlt02
		dey		; true
dlt02		sty tos
		sty tos+1
		inx
		inx
		inx
		jmp next
dcmp		sec
		lda stackl+2,x
		sbc stackl,x
		lda stackh+2,x
		sbc stackh,x
		lda stackl+1,x
		sbc tos
		lda stackh+1,x
		sbc tos+1
		rts
	
;--------------------------------------------------------------
;
;	NEGATE   ( n -- -n )
;
; * 83 nucleus
;
; 09/15/10 cah
negatelfa	.word $adde
		.byt (negate-*-1)|bit7
		.asc "NEGAT","E"|bit7
negate		jsr donegate
		jmp next
donegate	sec
neg2		lda #0
		sbc tos
		sta tos
		lda #0
		sbc tos+1
		sta tos+1
		rts

;--------------------------------------------------------------
;
;	DNEGATE   ( d -- -d )
;
; * 83 nucleus
;
dnegatelfa	.word $adde
		.byt (dnegate-*-1)|bit7
		.asc "DNEGAT","E"|bit7
dnegate		jsr dodnegate
		jmp next
dodnegate	sec
		lda #0
		sbc stackl,x
		sta stackl,x
		lda #0
		sbc stackh,x
		sta stackh,x
		jmp neg2

;--------------------------------------------------------------
;
;	OVER   ( n1 n2 -- n1 n2 n1 )
;
; * 83 nucleus
;
; 09/15/10 cah
overlfa		.word $adde
		.byt (over-*-1)|bit7
		.asc "OVE","R"|bit7
over		ldy stackh,x
		lda stackl,x
		jmp pushya

;--------------------------------------------------------------
;
;	DROP   ( n -- )
;
; * 83 nucleus
;
droplfa	.word $adde
		.byt (drop-*-1)|bit7
		.asc "DRO","P"|bit7
drop		jmp pops

;--------------------------------------------------------------
;
;	SWAP   ( n1 n2 -- n2 n1 )
;
; * 83 nucleus
;
swaplfa		.word $adde
		.byt (swap-*-1)|bit7
		.asc "SWA","P"|bit7
swap		ldy tos+1
		lda stackh,x
		sta tos+1
		sty stackh,x
		ldy tos
		lda stackl,x
		sta tos
		sty stackl,x
		jmp next

;--------------------------------------------------------------
;
;	DUP   ( n -- n n )
;
; * 83 nucleus
;
duplfa		.word $adde
		.byt (dup-*-1)|bit7
		.asc "DU","P"|bit7
dup		lda tos
		ldy tos+1
		jmp pushya

;--------------------------------------------------------------
;
;	+!   ( n addr -- )
;
; * 83 nucleus
;
; add N to the cell at ADDR
plusstorelfa	.word $adde
		.byt (plusstore-*-1)|bit7
		.asc "+","!"|bit7
plusstore	ldy #0
		clc
		lda stackl,x
		adc (tos),y
		sta (tos),y
		iny
		lda stackh,x
		adc (tos),y
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	TOGGLE   ( addr bitmask -- )
;
; Toggles setting of bits with bitmask at addr

togglelfa	.word $adde
		.byt (toggle-*-1)|bit7
		.asc "TOGGL","E"|bit7
toggle		lda stackl,x
		sta n
		lda stackh,x
		sta n+1
		ldy #0
		lda (n),y
		eor tos
		sta (n),y
		jmp poptwo

;--------------------------------------------------------------
;
;	@   ( addr -- n )
;
; * 83 nucleus
;
fetchlfa	.word $adde
		.byt (fetch-*-1)|bit7
		.asc "@"|bit7
fetch		ldy #0
		lda (tos),y
		sta n
		iny
		lda (tos),y
		sta tos+1
		lda n
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	C@   ( addr -- 8b )
;
; * 83 nucleus
;
; "c-fetch" 
; 8b is the contents of the byte at addr.
;
cfetchlfa	.word $adde
		.byt (cfetch-*-1)|bit7
		.asc "C","@"|bit7
cfetch		ldy #0
		lda (tos),y
		sta tos
		sty tos+1
		jmp next

;--------------------------------------------------------------
;
;	!   ( 16b addr -- )
;
; * 83 nucleus
;
; "store" 
; 16b is stored at addr.
storelfa	.word $adde
		.byt (store-*-1)|bit7
		.asc "!"|bit7
store		ldy #0
		lda stackl,x
		sta (tos),y
		iny
		lda stackh,x
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;	C!   ( 8b addr -- )
;
; * 83 nucleus
;
; "c-store"
; The least-significant 8 bits of 16b are stored into the byte
; at addr.
;
cstorelfa	.word $adde
		.byt (cstore-*-1)|bit7
		.asc "C","!"|bit7
cstore		lda stackl,x
		ldy #0
		sta (tos),y
		jmp poptwo

;--------------------------------------------------------------
;
;"	:   ( -- sys )
;
; * 83 compiler
;
; "colon"
;" A defining word executed in the form: 
;" : <name> ... ;
; Create a word definition for <name> in the compilation
; vocabulary and set compilation state.  The search order is
; changed so that the first vocabulary in the search order is
; changed so that the first vocabulary in the search order is
; replaced by the compilation vocabulary.  The compilation
; vocabulary is unchanged.  The text from the input stream is
; subsequently compiled.  <name> is called a "colon
; definition".  The newly created word definition for <name>
; cannot be found in the dictionary until the corresponding ;
; or ;CODE is successfully processed. 
;
; An error condition exists if a word is not found and cannot
; be converted to a number or if, during compilation from mass
; storage, the input stream is exhausted before encountering ;
; or ;CODE .  sys is balanced with its corresponding ; .
;
colonlfa	.word $adde
		.byt (_colon-*-1)|bit7
		.asc ":"|bit7
_colon		.word _storecsp
		.word current
		.word fetch
		.word context
		.word store
		.word _create
		.word _smudge
		.word _rbracket
		.word _psemi
;--------------------------------------------------------------
;
;	ENTER
;
;		IP -> -[RP]
;		W -> IP
;		NEXT
;
enter		pla		;[4]
		tay		;[2]
		pla		;[4]
		sta storex	;[3]
		lda ip+1	;[3]
		pha		;[3]
		lda ip		;[3]
		pha		;[3]
		lda storex	;[3]
		sta ip+1	;[3]
		iny		;[2]
		beq enter02	;[2]
enter01		sty ip		;[3]
		jmp nexto	;[3]
enter02		inc ip+1
		bne enter01

;--------------------------------------------------------------
;
;	;   ( -- )
;
; * 83 compiler
;
semilfa		.word $adde
		.byt (semi-*-1)|bit7|bit6
		.asc ";"|bit7
semi
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word exit
#include "page.i65"
		.word _smudge
#include "page.i65"
		.word _lbracket
		.word exit

;--------------------------------------------------------------
;
;	CONSTANT   ( n -- )
;
; * 83 compiler
;
constantlfa	.word $adde
		.byt (_constant-*-1)|bit7
		.asc "CONSTAN","T"|bit7
_constant
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
; 09/15/10 cah
doconst		pla
		sta n
		pla
		sta n+1
		ldy #2
		lda (n),y
		sta n+2		; high byte
		dey
		lda (n),y	; low byte
		ldy n+2
		jmp pushya

;--------------------------------------------------------------
;
;	VARIABLE   ( -- )
;
; * 83 compiler
;
variablelfa	.word $adde
		.byt (_variable-*-1)|bit7
		.asc "VARIABL","E"|bit7
_variable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	USER   ( n -- )
;
userlfa		.word $adde
		.byt (user-*-1)|bit7
		.asc "USE","R"|bit7
user
#include "enter.i65"
		.word _constant
#include "page.i65"
		.word _psemi
uservar		pla
		tay
		pla
		sta n+1
		iny
		bne uservar01
		inc n+1
uservar01	sty n
		ldy #0
		clc
		lda up
		adc (n),y
		sta n
		lda up+1
		adc #0
		tay
		lda n
		jmp pushya

;--------------------------------------------------------------
;
;	+ORIGIN
;
plusoriginlfa	.word $adde
		.byt (_plusorigin-*-1)|bit7
		.asc "+ORIGI","N"|bit7
_plusorigin	
#include "enter.i65"
		.word plit
		.word userarea
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	SP0
;
spzlfa		.word $adde
		.byt (sp0-*-1)|bit7
		.asc "SP","0"|bit7
sp0		jsr uservar
		.byt usersp0-userarea

;--------------------------------------------------------------
;
;	RP0
;
rpzlfa		.word $adde
		.byt (rp0-*-1)|bit7
		.asc "RP","0"|bit7
rp0		jsr uservar
		.byt userrp0-userarea

;--------------------------------------------------------------
;
;	WIDTH
;
widthlfa	.word $adde
		.byt (width-*-1)|bit7
		.asc "WIDT","H"|bit7
width		jsr uservar
		.byt userwidth-userarea

;--------------------------------------------------------------
;
;	WARNING
;
warninglfa	.word $adde
		.byt (warning-*-1)|bit7
		.asc "WARNIN","G"|bit7
warning		jsr uservar
		.byt userwarning-userarea

; ^ warm
; |
;  >  user variables pre-initialized from the dictionary
; |
; v cold

;--------------------------------------------------------------
;
;	FENCE
;
fencelfa	.word $adde
		.byt (fence-*-1)|bit7
		.asc "FENC","E"|bit7
fence		jsr uservar
		.byt userfence-userarea

;--------------------------------------------------------------
;
;	DP
;
dplfa		.word $adde
		.byt (dp-*-1)|bit7
		.asc "D","P"|bit7
dp		jsr uservar
		.byt userdp-userarea

;--------------------------------------------------------------
;
;	VOC-LINK
;
voclinklfa	.word $adde
		.byt (voclink-*-1)|bit7
		.asc "VOC-LIN","K"|bit7
voclink		jsr uservar
		.byt uservoclink-userarea

;--------------------------------------------------------------
;
;	VIEW?
;
viewqlfa	.word $adde
		.byt (viewq-*-1)|bit7
		.asc "VIEW","?"|bit7
viewq		jsr uservar
		.byt userviewquery-userarea

;--------------------------------------------------------------
;
;	MLMON   ( -- addr )
;
; The address of a variable to store the location of the ML monitor.
; COLD sets this from the contents of BRKVECTOR at $0092, then
; points BRKVECTOR to SW16.  The MON primitive sets BRKVECTOR
; back to its original state before exiting to TIM (or TIM's
; replacement e.g. Micromon).  Exiting the ML monitor with
; "G" will reestablish Sweet16 as the BRK instruction target.
;
mlmonlfa	.word $adde
		.byt (mlmon-*-1)|bit7
		.asc "MLMO","N"|bit7
mlmon		jsr uservar
		.byt usermlmon-userarea

; ^ cold
; |
;  >  user variables pre-initialized from the dictionary
; |
; v soft
;
; user variables beyond this point are not pre-initialized from the dictionary
;

;--------------------------------------------------------------
;
;	BLK   ( -- addr )
;
; * 83 interpreter
;
; The address of a variable containing the number of the mass
; storage block being interpreted as the input stream.  If the
; value of BLK is zero the input stream is taken from the text
; input buffer.  {{0..the number of blocks available -1}}
; -1 = cassette tape 1 ~
; -2 = cassette tape 2 ~
blklfa		.word $adde
		.byt (blk-*-1)|bit7
		.asc "BL","K"|bit7
blk		jsr uservar
		.byt usercold-userarea

;--------------------------------------------------------------
;
;	>IN   ( -- addr )
;
; * 83 interpreter
;
; Leaves the address of the user variable >IN which contains the
; number of bytes from the beginning of the input stream at any
; particular moment during interpretation.
; The address of a user variable which contains the present
; character offset within the input stream.  See: WORD
toinlfa		.word $adde
		.byt (toin-*-1)|bit7
		.asc ">I","N"|bit7
toin		jsr uservar
		.byt usercold-userarea+2

;--------------------------------------------------------------
;
;	#OUT
;
numoutlfa	.word $adde
		.byt (numout-*-1)|bit7
		.asc "#OU","T"|bit7
numout		jsr uservar
		.byt usercold-userarea+4

;--------------------------------------------------------------
;
;	SCR
;
scrlfa		.word $adde
		.byt (scr-*-1)|bit7
		.asc "SC","R"|bit7
scr		jsr uservar
		.byt usercold-userarea+6

;--------------------------------------------------------------
;
;	OFFSET
;
offsetlfa	.word $adde
		.byt (offset-*-1)|bit7
		.asc "OFFSE","T"|bit7
offset		jsr uservar
		.byt usercold-userarea+8

;--------------------------------------------------------------
;
;	CONTEXT
;
contextlfa	.word $adde
		.byt (context-*-1)|bit7
		.asc "CONTEX","T"|bit7
context		jsr uservar
		.byt usercold-userarea+10

;--------------------------------------------------------------
;
;	CURRENT
;
currentlfa	.word $adde
		.byt (current-*-1)|bit7
		.asc "CURREN","T"|bit7
current		jsr uservar
		.byt usercold-userarea+12

;--------------------------------------------------------------
;
;	STATE
;
; * 83 compiler
;
statelfa	.word $adde
		.byt (state-*-1)|bit7
		.asc "STAT","E"|bit7
state		jsr uservar
		.byt usercold-userarea+14

;--------------------------------------------------------------
;
;	BASE
;
; * 83 interpreter
;
baselfa		.word $adde
		.byt (base-*-1)|bit7
		.asc "BAS","E"|bit7
base		jsr uservar
		.byt usercold-userarea+16

;--------------------------------------------------------------
;
;	DPL
;
dpllfa		.word $adde
		.byt (dpl-*-1)|bit7
		.asc "DP","L"|bit7
dpl		jsr uservar
		.byt usercold-userarea+18

;--------------------------------------------------------------
;
;	SPAN   ( -- addr )
;
; * 83 interpreter
;
; Returns the address of the user variable that
; contains the count of characters received and
; stored by the most recent execution of EXPECT .
span		jsr uservar
		.byt usercold-userarea+20

;--------------------------------------------------------------
;
;	CSP
;
csplfa		.word $adde
		.byt (csp-*-1)|bit7
		.asc "CS","P"|bit7
csp		jsr uservar
		.byt usercold-userarea+22

;--------------------------------------------------------------
;
;	R#
;
rsharplfa	.word $adde
		.byt (rsharp-*-1)|bit7
		.asc "R","#"|bit7
rsharp		jsr uservar
		.byt usercold-userarea+24

;--------------------------------------------------------------
;
;	HLD
;
hldlfa		.word $adde
		.byt (hld-*-1)|bit7
		.asc "HL","D"|bit7
hld		jsr uservar
		.byt usercold-userarea+26

;--------------------------------------------------------------
;
;	DONE?
;
doneqlfa	.word $adde
		.byt (doneq-*-1)|bit7
		.asc "DONE","?"|bit7
doneq		jsr uservar
		.byt usercold-userarea+28

;--------------------------------------------------------------
;
;	#TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}  See:  "input stream"
numtiblfa	.word $adde
		.byt (numtib-*-1)|bit7
		.asc "#TI","B"|bit7
numtib		jsr uservar
		.byt usercold-userarea+30

;--------------------------------------------------------------
;
;	#LINE
;
numlinelfa	.word $adde
		.byt (numline-*-1)|bit7
		.asc "#LIN","E"|bit7
numline		jsr uservar
		.byt usercold-userarea+32

;--------------------------------------------------------------
;
;	-1   ( -- -1 )
;
minusonelfa	.word $adde
		.byt (minusone-*-1)|bit7
		.asc "-","1"|bit7
minusone	jmp true

;--------------------------------------------------------------
;
;	0   ( -- 0 )
;
zerolfa		.word $adde
		.byt (zero-*-1)|bit7
		.asc "0"|bit7
zero		jmp false

;--------------------------------------------------------------
;
;	1   ( -- 1 )
;
onelfa		.word $adde
		.byt (one-*-1)|bit7
		.asc "1"|bit7
one		jsr doconst
		.word 1

;--------------------------------------------------------------
;
;	2   ( -- 2 )
;
twolfa		.word $adde
		.byt (two-*-1)|bit7
		.asc "2"|bit7
two		jsr doconst
		.word 2

;--------------------------------------------------------------
;
;	3   ( -- 3 )
;
threelfa	.word $adde
		.byt (three-*-1)|bit7
		.asc "3"|bit7
three		jsr doconst
		.word 3

;--------------------------------------------------------------
;
;	BL   ( -- n )
;
bllfa		.word $adde
		.byt (bl-*-1)|bit7
		.asc "B","L"|bit7
bl		jsr doconst
		.word $20

;--------------------------------------------------------------
;
;	C/L   ( -- n )
;
cperllfa	.word $adde
		.byt (cperl-*-1)|bit7
		.asc "C/","L"|bit7
cperl		jsr doconst
		.word 64

;--------------------------------------------------------------
;
;	FIRST   ( -- addr )
;
;~ fix this to read actual top of memory
firstlfa	.word $adde
		.byt (first-*-1)|bit7
		.asc "FIRS","T"|bit7
first		jsr doconst
		.word $7000

;--------------------------------------------------------------
;
;	LIMIT   ( -- addr )
;
;~ fix this to read actual top of memory
limitlfa	.word $adde
		.byt (limit-*-1)|bit7
		.asc "LIMI","T"|bit7
limit		jsr doconst
		.word $8000

;--------------------------------------------------------------
;
;	#BUF   ( -- n )
;
numbuflfa	.word $adde
		.byt (numbuf-*-1)|bit7
		.asc "#BU","F"|bit7
numbuf		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	#BCQ   ( -- n )
;
numbcqlfa	.word $adde
		.byt (numbcq-*-1)|bit7
		.asc "#BC","Q"|bit7
numbcq		jsr doconst
		.word 32

;--------------------------------------------------------------
;
;	B/BUF   ( -- n )
;
bperbuflfa	.word $adde
		.byt (bperbuf-*-1)|bit7
		.asc "B/BU","F"|bit7
bperbuf		jsr doconst
		.word 1024

;--------------------------------------------------------------
;
;	B/SCR   ( -- n )
;
bperscrlfa	.word $adde
		.byt (bperscr-*-1)|bit7
		.asc "B/SC","R"|bit7
bperscr		jsr doconst
		.word 4

;--------------------------------------------------------------
;
;	TIB   ( -- addr )
;
; * 83 interpreter
;
tiblfa		.word $adde
		.byt (tib-*-1)|bit7
		.asc "TI","B"|bit7
tib		jsr doconst
		.word $0100

;--------------------------------------------------------------
;
;	TRUE   ( -- -1 )
;
truelfa		.word $adde
		.byt (true-*-1)|bit7
		.asc "TRU","E"|bit7
true		lda #$ff
		tay
		jmp pushya

;--------------------------------------------------------------
;
;	FALSE   ( -- 0 )
;
falselfa	.word $adde
		.byt (false-*-1)|bit7
		.asc "FALS","E"|bit7
false		lda #0
		tay
		jmp pushya

;--------------------------------------------------------------
;
;	0=
;
; * 83 nucleus
;
zeqlfa		.word $adde
		.byt (zeq-*-1)|bit7
		.asc "0","="|bit7
zeq		ldy #$ff
		lda tos
		ora tos+1
		beq zeq01
		iny
zeq01		tya
		jmp put

;--------------------------------------------------------------
;
;	0<
;
; * 83 nucleus
;
zltlfa		.word $adde
		.byt (zlt-*-1)|bit7
		.asc "0","<"|bit7
zlt		ldy #0
		bit tos+1
		bpl zlt01
		dey
zlt01		tya
		jmp put

;--------------------------------------------------------------
;
;	0<>
;
znelfa		.word $adde
		.byt (zne-*-1)|bit7
		.asc "0<",">"|bit7
zne		lda tos
		ora tos+1
		beq zne01
		lda #$ff
zne01		tay
		jmp put

;--------------------------------------------------------------
;
;	1+
;
; * 83 nucleus
;
onepluslfa	.word $adde
		.byt (oneplus-*-1)|bit7
		.asc "1","+"|bit7
oneplus		inc tos
		bne oneplus01
		inc tos+1
oneplus01	jmp next

;--------------------------------------------------------------

;
;	1-
;
; * 83 nucleus
;
oneminuslfa	.word $adde
		.byt (oneminus-*-1)|bit7
		.asc "1","-"|bit7
oneminus	lda tos
		bne oneminus01
		dec tos+1
oneminus01	dec tos
		jmp next

;--------------------------------------------------------------
;
;	2+
;
; * 83 nucleus
;
twopluslfa	.word $adde
		.byt (twoplus-*-1)|bit7
		.asc "2","+"|bit7
twoplus		clc
		lda tos
		adc #2
		sta tos
		bcc twoplus01
		inc tos+1
twoplus01	jmp next

;--------------------------------------------------------------
;
;	2-
;
; * 83 nucleus
;
twominuslfa	.word $adde
		.byt (twominus-*-1)|bit7
		.asc "2","-"|bit7
twominus	sec
		lda tos
		sbc #2
		sta tos
		bcs twominus01
		dec tos+1
twominus01	jmp next

;--------------------------------------------------------------
;
;	2/
;
; * 83 nucleus
;
twoslashlfa	.word $adde
		.byt (twoslash-*-1)|bit7
		.asc "2","/"|bit7
twoslash	lsr tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	2*
;
twostarlfa	.word $adde
		.byt (twostar-*-1)|bit7
		.asc "2","*"|bit7
twostar		asl tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	HERE
;
; * 83 interpreter
;
herelfa		.word $adde
		.byt (here-*-1)|bit7
		.asc "HER","E"|bit7
here		ldy #(userdp-userarea)
		lda (up),y
		pha
		iny
		lda (up),y
		tay
		pla
		jmp pushya

;--------------------------------------------------------------
;
;	ALLOT
;
; * 83 compiler
;
allotlfa	.word $adde
		.byt (_allot-*-1)|bit7
		.asc "ALLO","T"|bit7
_allot
#include "enter.i65"
		.word dp
#include "page.i65"
		.word plusstore
		.word exit

;--------------------------------------------------------------
;
;	,
;
; * 83 compiler
;
commalfa	.word $adde
		.byt (_comma-*-1)|bit7
		.asc ","|bit7
_comma
#include "enter.i65"
		.word here
#include "page.i65"
		.word store
#include "page.i65"
		.word two
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	C,
;
ccommalfa	.word $adde
		.byt (_ccomma-*-1)|bit7
		.asc "C",","|bit7
_ccomma
#include "enter.i65"
		.word here
#include "page.i65"
		.word cstore
#include "page.i65"
		.word one
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	-
;
; * 83 nucleus
;
; 09/15/10 cah
minuslfa	.word $adde
		.byt (minus-*-1)|bit7
		.asc "-"|bit7
minus		jsr donegate
		jmp plus

;--------------------------------------------------------------
;
;	=   ( n1 n2 -- flag )
;
; * 83 nucleus
;
eqlfa		.word $adde
		.byt (eq-*-1)|bit7
		.asc "="|bit7
eq		ldy #0
		lda tos
		cmp stackl,x
		bne cmpout
		lda tos+1
		cmp stackh,x
		bne cmpout
		dey
cmpout		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	U<
;
; * 83 nucleus
;
;09/16/10 cah
ultlfa		.word $adde
		.byt (ult-*-1)|bit7
		.asc "U","<"|bit7
ult		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
		bcs cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	<   ( n1 n2 -- flag )
;
; * 83 nucleus
;
ltlfa		.word $adde
		.byt (lt-*-1)|bit7
		.asc "<"|bit7
lt		ldy #0
		lda stackl,x
		cmp tos
		lda stackh,x
		sbc tos+1
sgntst		bvc lt01
		eor #bit7
lt01		bpl cmpout
		dey
		bmi cmpout

;--------------------------------------------------------------
;
;	>   ( n1 n2 -- flag )
;
; * 83 nucleus
;
; V is the exclusive or of the carrys out of bits 6 and 7 - Bogax
gtlfa		.word $adde
		.byt (gt-*-1)|bit7
		.asc ">"|bit7
gt		ldy #0
		lda tos
		cmp stackl,x
		lda tos+1
		sbc stackh,x
		jmp sgntst

;--------------------------------------------------------------
;
;	ROT   ( a b c -- b c a )
;
; * 83 nucleus
;
rotlfa		.word $adde
		.byt (rot-*-1)|bit7
		.asc "RO","T"|bit7
rot		ldy stackh+1,x
		lda stackh,x
		sta stackh+1,x
		lda tos+1
		sta stackh,x
		sty tos+1
		ldy stackl+1,x
		lda stackl,x
		sta stackl+1,x
		lda tos
		sta stackl,x
		sty tos
		jmp next

;--------------------------------------------------------------
;
;	LROT   ( a b c -- c a b )
;
lrotlfa		.word $adde
		.byt (lrot-*-1)|bit7
		.asc "LRO","T"|bit7
lrot		ldy tos+1	; c
		lda stackh,x
		sta tos+1	; b -> tos
		lda stackh+1,x
		sta stackh,x	; a -> 2os
		sty stackh+1,x	; c -> 3os
		ldy tos
		lda stackl,x
		sta tos
		lda stackl+1,x
		sta stackl,x
		sty stackl+1,x
		jmp next

;--------------------------------------------------------------
;
;	SPACE
;
; * 83 device
;
spacelfa	.word $adde
		.byt (_space-*-1)|bit7
		.asc "SPAC","E"|bit7
_space
#include "enter.i65"
		.word bl
#include "page.i65"
		.word emit
		.word exit

;--------------------------------------------------------------
;
;	?DUP   ( 0 -- 0 | n -- n n )
;
; * 83 nucleus
;
; DUP if top of stack is nonzero
qduplfa		.word $adde
		.byt (qdup-*-1)|bit7
		.asc "?DU","P"|bit7
qdup		lda tos
		ora tos+1
		beq qdup01
		lda tos
		ldy tos+1
		jmp pushya
qdup01		jmp next

;--------------------------------------------------------------
;
;	TRAVERSE   ( addr n -- addr )
;
; * dictionary
;
; scan forward (1) or backward (-1) for the next negative byte
; returns the address of the opposite side of this name field
;
;" : TRAVERSE	( addr n -- addr )
;"	SWAP
;"	BEGIN
;"		OVER +  127  OVER C@  <
;"	UNTIL
;"	SWAP DROP ;
traverselfa	.word $adde
		.byt (_traverse-*-1)|bit7
		.asc "TRAVERS","E"|bit7
_traverse
#include "enter.i65"
		.word swap
#include "page.i65"
traverse01	.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $7f
#include "pad.i65"
		.word over
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word traverse01
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	LATEST   ( -- NFA )
;
; Leaves the name field address of the top-most word in the
; CURRENT vocabulary.
latestlfa	.word $adde
		.byt (_latest-*-1)|bit7
		.asc "LATES","T"|bit7
_latest
#include "enter.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word fetch
		.word exit

;--------------------------------------------------------------
;
;	FORTH-83
;
; * 83 interpreter
;
; ~ make sure it's really Forth-83 compliant before making this word available
;
forth83lfa	.word $adde
		.byt (forth83-*-1)|bit7
		.asc "FORTH-8","3"|bit7
forth83		jmp next

; ~ better to follow ANS-Forth standard for this group?
;--------------------------------------------------------------
;
;	>BODY   ( cfa -- pfa )
;
; * 83 interpreter
;
; convert the compilation address (CFA) to the address of the parameter field.
tobodylfa	.word $adde
		.byt (_tobody-*-1)|bit7
		.asc ">BOD","Y"|bit7
_tobody
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	>NAME   ( CFA -- NFA )
;
; returns the NFA of a given word
;
tonamelfa	.word $adde
		.byt (_toname-*-1)|bit7
		.asc ">NAM","E"|bit7
_toname
#include "enter.i65"
		.word oneminus
#include "page.i65"
		.word minusone
#include "page.i65"
		.word _traverse
		.word exit

;--------------------------------------------------------------
;
;	>LINK   ( CFA -- LFA )
;
; returns the LFA of a given word
;
tolinklfa	.word $adde
		.byt (_tolink-*-1)|bit7
		.asc ">LIN","K"|bit7
_tolink
#include "enter.i65"
		.word _toname
#include "page.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	BODY>   ( PFA -- CFA )
;
bodyfromlfa	.word $adde			; ~ Blazin
		.byt (_bodyfrom-*-1)|bit7
		.asc "BODY",">"|bit7
_bodyfrom
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	NAME>   ( nfa -- cfa )
;
namefromlfa	.word $adde
		.byt (_namefrom-*-1)|bit7
		.asc "NAME",">"|bit7
_namefrom
#include "enter.i65"
		.word one
#include "page.i65"
		.word _traverse
#include "page.i65"
		.word oneplus
		.word exit

;--------------------------------------------------------------
;
;	LINK>   ( lfa -- cfa )
;
linkfromlfa	.word $adde
		.byt (_linkfrom-*-1)|bit7
		.asc "LINK",">"|bit7
_linkfrom
#include "enter.i65"
		.word twoplus
#include "page.i65"
		.word _namefrom
		.word exit

;--------------------------------------------------------------
;
;	N>LINK   ( nfa -- lfa )
;
ntolinklfa	.word $adde
		.byt (_ntolink-*-1)|bit7
		.asc "N>LIN","K"|bit7
_ntolink
#include "enter.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	L>NAME   ( lfa -- nfa )
;
linktonamelfa	.word $adde
		.byt (_linktoname-*-1)|bit7
		.asc "L>NAM","E"|bit7
_linktoname
#include "enter.i65"
		.word twoplus
		.word exit

;--------------------------------------------------------------
;
;	!CSP
;
storecsplfa	.word $adde
		.byt (_storecsp-*-1)|bit7
		.asc "!CS","P"|bit7
_storecsp
#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	WHERE
;
wherelfa	.word $adde
		.byt (_where-*-1)|bit7
		.asc "WHER","E"|bit7
_where
#include "enter.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word where03
#include "page.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word scr
#include "page.i65"
		.word store
#include "page.i65"
		.word cr
#include "page.i65"
		.word cr
#include "page.i65"
#if (((*&$ff)+3+5)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt where01-*-1
		.asc	"SCR# "
			;12345
where01
#include "page.i65"
		.word dup
#include "page.i65"
		.word _dot
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word _min
#include "page.i65"
		.word cperl
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word dup
#include "page.i65"
#if (((*&$ff)+3+6)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt where02-*-1
		.asc	"LINE# "
			;123456
where02
#include "page.i65"
		.word _dot
#include "page.i65"
		.word cperl
#include "page.i65"
		.word star
#include "page.i65"
		.word rot
#include "page.i65"
		.word _block
#include "page.i65"
		.word plus
#include "page.i65"
		.word cr
#include "page.i65"
		.word cr
#include "page.i65"
		.word cperl
#include "page.i65"
		.word _dashtrailing
#include "page.i65"
		.word type
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word gt
#include "page.i65"
		.word plus
#include "page.i65"
		.word branch
		.word where04
#include "page.i65"
where03		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
where04		.word cr
#include "page.i65"
		.word here
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word minus
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word minus
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
where05		.word clit
		.byt 94		;'^'
#include "pad.i65"
		.word emit
#include "page.i65"
		.word ploop
		.word where05
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	(ABORT")
;
; * outer interpreter headerless
;
;pabortqlfa	.word $adde
;		.byt (_pabortq-*-1)|bit7
;		.asc "(ABORT",'"',")"|bit7
_pabortq
#include "enter.i65"
		.word qbranch
		.word pabortq01
#include "page.i65"
		.word cmdoff
#include "page.i65"
		.word _where
#include "page.i65"
		.word cr
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word twoplus		; ~ why did I need this?
#include "page.i65"
		.word count
#include "page.i65"
		.word type
#include "page.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
#include "page.i65"
		.word branch
		.word pabortq02
#include "page.i65"
pabortq01	.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word tor
pabortq02	.word exit

;--------------------------------------------------------------
;
;	,$
;
commadollarlfa	.word $adde
		.byt (_commadollar-*-1)|bit7
		.asc ",","$"|bit7
_commadollar
#include "enter.i65"
		.word swap
#include "page.i65"
		.word over
#include "page.i65"
		.word here
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word cstore
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	ABORT"
;
; * 83 compiler
;
; ~ handle page boundary crossings
abortqlfa	.word $adde
		.byt (_abortq-*-1)|bit7
		.asc "ABORT",'"'|bit7
_abortq
#include "enter.i65"
		.word _compile
		.word _pabortq
#include "page.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	?COMP
;
qcomplfa	.word $adde
		.byt (_qcomp-*-1)|bit7
		.asc "?COM","P"|bit7
_qcomp
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
#if (((*&$ff)+3+35)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qcomp01-*-1
		.asc	"COMPILATION ONLY, USE IN DEFINITION"
			;123456789.123456789.123456789.12345
qcomp01		.word exit

;--------------------------------------------------------------
;
;	?FIND
;
qfindlfa	.word $adde
		.byt (_qfind-*-1)|bit7
		.asc "?FIN","D"|bit7
_qfind
#include "enter.i65"
#if (((*&$ff)+3+27)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qfind01-*-1
		.asc	"NOT IN CURRENT SEARCH ORDER"
			;123456789.123456789.1234567
qfind01		.word exit

;--------------------------------------------------------------
;
;	?PAIRS
;
qpairslfa	.word $adde
		.byt (_qpairs-*-1)|bit7
		.asc "?PAIR","S"|bit7
_qpairs
#include "enter.i65"
		.word minus
#include "page.i65"
#if (((*&$ff)+3+23)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qpairs01-*-1
		.asc	"CONDITIONALS NOT PAIRED"
			;123456789.123456789.123
qpairs01	.word exit

;--------------------------------------------------------------
;
;	?CSP
;
qcsplfa		.word $adde
		.byt (_qcsp-*-1)|bit7
		.asc "?CS","P"|bit7
_qcsp
#include "enter.i65"
		.word spfetch
#include "page.i65"
		.word csp
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
#if (((*&$ff)+3+23)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt qcsp01-*-1
		.asc	"DEFINITION NOT FINISHED"
			;123456789.123456789.123
qcsp01		.word exit

;--------------------------------------------------------------
;
;	?CHAR
;
qcharlfa	.word $adde
		.byt (_qchar-*-1)|bit7
		.asc "?CHA","R"|bit7
_qchar
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _tickstream
#include "page.i65"
		.word over
#include "page.i65"
		.word swap
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word scan
#include "page.i65"
		.word drop
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word tor
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word toin
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word qchar02
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word cr
#include "page.i65"
		.word emit
#include "page.i65"
#if (((*&$ff)+3+9)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt qchar01-*-1
		.asc	" MISSING "
			;123456789
qchar01		.word _abort
#include "pad.i65"
qchar02		.word rfrom
#include "page.i65"
		.word drop
		.word exit


;--------------------------------------------------------------
;
;	COMPILE
;
; * 83 compiler
;
compilelfa	.word $adde
		.byt (_compile-*-1)|bit7
		.asc "COMPIL","E"|bit7

_compile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word tor
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	[
;
; * 83 compiler
;
lbracketlfa	.word $adde
		.byt (_lbracket-*-1)|bit7
		.asc "["|bit7
_lbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	]
;
; * 83 compiler
;
rbracketlfa	.word $adde
		.byt (_rbracket-*-1)|bit7
		.asc "]"|bit7
_rbracket
#include "enter.i65"
		.word state
#include "page.i65"
		.word on
#include "page.i65"
rbracket01	.word qstack
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word dup
#include "page.i65"
		.word qbranch
		.word rbracket03
#include "pad.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word rbracket02
#include "pad.i65"
		.word _comma
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket02	.word execute
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket03	.word drop
#include "page.i65"
		.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word rbracket04
#include "pad.i65"
		.word _dliteral
#include "page.i65"
		.word branch
		.word rbracket05
#include "pad.i65"
rbracket04	.word drop
#include "page.i65"
		.word _literal
#include "page.i65"
rbracket05	.word true
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word rbracket01
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	SMUDGE
;
smudgelfa	.word $adde
		.byt (_smudge-*-1)|bit7
		.asc "SMUDG","E"|bit7
_smudge
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt bit5	; $20
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	HEX
;
hexlfa	.word $adde
		.byt (_hex-*-1)|bit7
		.asc "HE","X"|bit7
_hex
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DECIMAL
;
; * 83 interpreter
;
decimallfa	.word $adde
		.byt (_decimal-*-1)|bit7
		.asc "DECIMA","L"|bit7
_decimal
#include "enter.i65"
		.word clit
		.byt 10
#include "pad.i65"
		.word base
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(;CODE)
;
;psemilfa	.word $adde
;		.byt (_psemi-*-1)|bit7
;		.asc "(;CODE",")"|bit7
_psemi
#include "enter.i65"
		.word rfrom
#include "page.i65"
		.word _latest
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DOES>
;
; * 83 compiler
;
doeslfa		.word $adde
		.byt (_does-*-1)|bit7
		.asc "DOES",">"|bit7
_does
#include "enter.i65"
		.word _qcsp
#include "page.i65"
		.word _compile
		.word _psemi
#include "pad.i65"
		.word clit
		.byt $20	; jsr instruction
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word _compile	; ~ fix paging here
		.word dodoes
#include "pad.i65"
		.word exit
; I've got a pretzel in my brain!
dodoes		pla
		sta n
		pla
		sta n+1
		pla
		sta n+2
		pla
		sta n+3
		lda ip+1
		pha
		lda ip
		pha
		ldy n
		bne dodoes01
		dec n+1
dodoes01	dey
		sty ip
		lda n+1
		sta ip+1
		ldy n+3
		inc n+2
		bne dodoes02
		iny
dodoes02	lda n+2
		jmp pushya

;--------------------------------------------------------------
;
;	-TRAILING
;
; * 83 interpreter
;
dashtrailinglfa	.word $adde
		.byt (_dashtrailing-*-1)|bit7
		.asc "-TRAILIN","G"|bit7
_dashtrailing
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
dashtrailing01	.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word pqleave
		.word dashtrailing02
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word ploop
		.word dashtrailing01
dashtrailing02	.word exit

;--------------------------------------------------------------
;
;	(.")
;
; * headerless
;
;pdotqlfa	.word $adde
;		.byt (_pdotq-*-1)|bit7
;		.asc "(.",'"',")"|bit7
_pdotq
#include "enter.i65"
		.word rfetch		; address of _pdotq within secondary
#include "page.i65"
		.word twoplus		; address of counted string following
#include "page.i65"
		.word count
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
					; ~ check for $xxFF bug here
#include "page.i65"
		.word tor
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	COUNT   ( addr1 -- addr2 n+ )
;
; * 83 nucleus
;
; Leaves the address, addr2 and the character
; count +n of text beginning at addr1.
; addr2 is addr1+1 and n1 is the length of the
; counted string at addr1.  The byte at addr1 con-
; tains the byte count +n.  Range of +n is
; {0...255}.
countlfa	.word $adde
		.byt (count-*-1)|bit7
		.asc "COUN","T"|bit7
count		ldy #0
		lda (tos),y
		inc tos
		bne count01
		inc tos+1
count01		jmp pushya

;--------------------------------------------------------------
;
;	TYPE   ( addr count -- )
;
; * 83 device
;
typelfa		.word $adde
		.byt (type-*-1)|bit7
		.asc "TYP","E"|bit7
type		ldy #1
		jsr setup
		clc
		lda tos
		adc outputted
		sta outputted
		lda tos+1
		adc outputted+1
		sta outputted+1
type01		cpy tos
		bne type02
		dec tos+1
		bpl type02
		jmp pops
type02		lda (n),y
		jsr CHROUT
		iny
		bne type01
		inc n+1
		bne type01

;--------------------------------------------------------------
;
;	."   ( -- )
;
; * 83 compiler
;
dotqlfa		.word $adde
		.byt (_dotq-*-1)|bit7
		.asc ".",'"'|bit7
_dotq
#include "enter.i65"
		.word _compile
		.word _pdotq
#include "pad.i65"
		.word clit
		.asc '"'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word _commadollar
		.word exit

;--------------------------------------------------------------
;
;	.(
;
; * 83 interpreter
;
dotplfa		.word $adde
		.byt (_dotp-*-1)|bit7
		.asc ".","("|bit7
_dotp
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word type 
		.word exit

;--------------------------------------------------------------
;
;	EXPECT   ( addr +n -- )
;
; * 83 device
;
; Stores up to +n characters into memory begin-
; ning at addr.
; Receive characters and store each into memory.
; The transfer begins at addr proceeding towards
; higher addresses one byte per character until
; either "return" is received or until +n charac-
; ters have been transfered.  No more than +n
; characters will be stored.  The "return" is not
; stored into memory.  No characters are received
; or transfered if +n is zero.  All characters
; actually received and stored into memory will
; be displayed, with the "return" displaying as a
; space.

expectlfa	.word $adde
		.byt (expect-*-1)|bit7
		.asc "EXPEC","T"|bit7
expect		jmp expectvector
expectvector	ldy #1
		jsr setup
		sty inputted+1
		stx storex
		dey
expect01	iny
		cpy tos
		bcs expect02
		jsr CHRIN
		cmp #$0d
		beq expect02
		sta (n),y
		bne expect01
expect02	sty inputted		; ~ direct uarea ref breaks multitasking
		ldx storex
		jmp pops

;--------------------------------------------------------------
;
;	QUERY
;
querylfa	.word $adde
		.byt (_query-*-1)|bit7
		.asc "QUER","Y"|bit7
_query
#include "enter.i65"
		.word tib
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word expect
#include "page.i65"
		.word span
#include "page.i65"
		.word fetch
#include "page.i65"
		.word numtib
#include "page.i65"
		.word store
#include "page.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word toin
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	" "
;
;spacenplfa	.word $adde
;		.byt (_spacenp-*-1)|bit7|bit6
;		.asc " "|bit7
;_spacenp
;#include "enter.i65"
;		.word doneq
;#include "page.i65"
;		.word on
;		.word exit

;--------------------------------------------------------------
;
;	QUIT?
;
quitqlfa	.word $adde
		.byt (_quitq-*-1)|bit7
		.asc "QUIT","?"|bit7
_quitq
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word doneq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word orx
#include "page.i65"
		.word doneq
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	ERASE
;
; 09/15/10 cah
eraselfa	.word $adde
		.byt (_erase-*-1)|bit7
		.asc "ERAS","E"|bit7
_erase
#include "enter.i65"
		.word zero
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	BLANK
;
blanklfa	.word $adde
		.byt (_blank-*-1)|bit7
		.asc "BLAN","K"|bit7
_blank
#include "enter.i65"
		.word bl
#include "page.i65"
		.word fill
		.word exit

;--------------------------------------------------------------
;
;	HOLD
;
; * 83 interpreter
;
holdlfa		.word $adde
		.byt (_hold-*-1)|bit7
		.asc "HOL","D"|bit7
_hold
#include "enter.i65"
		.word true
#include "page.i65"
		.word hld
#include "page.i65"
		.word plusstore
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word cstore
		.word exit

;--------------------------------------------------------------
;
;	PAD
;
; * 83 interpreter
;
padlfa		.word $adde
		.byt (_pad-*-1)|bit7
		.asc "PA","D"|bit7
_pad
#include "enter.i65"
		.word here
#include "page.i65"
		.word clit
		.byt 80
#include "pad.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	'STREAM   ( -- addr size )
;
;" : 'stream
;	blk @ ?dup
;	if	block b/buf
;	else	tib #tib @
;	then
;	>in @ over min >r swap r@ + swap r> - ;
tickstreamlfa	.word $adde
		.byt (_tickstream-*-1)|bit7
		.asc "'STREA","M"|bit7
_tickstream
#include "enter.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup		; ( 0 | blk blk )
#include "page.i65"
		.word qbranch		; if
		.word tickstream01
#include "page.i65"
		.word _block		; ( addr )
#include "page.i65"
		.word bperbuf		; ( addr b/buf )
#include "page.i65"
		.word branch		; else
		.word tickstream02
#include "page.i65"
tickstream01	.word tib		; ( tib )
#include "page.i65"
		.word numtib
#include "page.i65"
		.word fetch		; ( tib #tib )
#include "page.i65"			; then
tickstream02	.word toin		; ( buf size >in )
#include "page.i65"
		.word fetch		; ( buf size offset )
#include "page.i65"
		.word over		; ( buf size offset size )
#include "page.i65"
		.word _min		; ( buf size offset )
#include "page.i65"
		.word tor		; ( buf size )
#include "page.i65"
		.word swap		; ( size buf )
#include "page.i65"
		.word rfetch		; ( size buf offset )
#include "page.i65"
		.word plus		; ( size addr )
#include "page.i65"
		.word swap		; ( addr size )
#include "page.i65"
		.word rfrom		; ( addr size offset )
#include "page.i65"
		.word minus		; ( addr remaining )
		.word exit

;		.word to6502
;		ldy #2
;		jsr setup
;		brk
;		.byt ldd  | TOS		; >in @
;		.byt cpr  | N0		; #tib or b/buf
;		.byt bm,  <(tickstream03-*-2)
;		.byt ld   | N0
;tickstream03	.byt st   | N2		; smaller of (#tib or b/buf, >in)
;		.byt ld   | N1		; tib
;		.byt add  | N2		; cursor position
;		.byt st   | TOS
;		.byt ld   | N0
;		.byt sub  | N2		; bytes remaining
;		.byt push		; ( addr remaining )
;		.byt rtn
;		jmp exit
;#include "toforth.i65"
;		.word exit

;--------------------------------------------------------------
;
;	WORD   ( char -- addr )
;
; * 83 interpreter
;
; Generates a counted string by non-destructively accepting
; characters from the input stream until the delimiting
; character char is encountered or the input stream is
; exhausted.  Leading delimiters are ignored.  The entire
; character string is stored in memory beginning at addr as a
; sequence of bytes.  The string is followed by a blank which
; is not included in the count.  The first byte of the string
; is the number of characters {0..255}.  If the string is
; longer than 255 characters, the count is unspecified.  If
; the input stream is already exhausted as WORD is called,
; then a zero length character string will result.
;
; If the delimiter is not found the value of >IN is the size
; of the input stream.  If the delimiter is found >IN is
; adjusted to indicate the offset to the character following
; the delimiter.  #TIB is unmodified. 		; ( 0100 0104 0107 0009 ) 
;
; The counted string returned by WORD may reside in the "free"
; dictionary area at HERE or above.  Note that the text
;"interpreter may also use this area.  See: "input stream"
;
; fig high level
;" : word   ( c -- addr )
;	blk @  if  blk @ block  else  tib @  then
;	>in @ + swap enclose here 34 blank >in +!
;	over - >r r@ here c! + here 1+ r> cmove ;
;
; blazin' high level
;" : 'stream
;	blk @ ?dup			; ( 0 | blk )
;	if  block b/buf
;	else  tib #tib @
;	then				; ( addr size )
;	>in @				; ( addr size pointer )
;	over min			; ( addr pointer )
;	>r swap				
;	r@ + swap
;	r> - ;
;" : skip
;
;" : scan
;
;" : word   ( c -- nfa )
;	>r				; ( -- ) r( c )
;	'stream
;	over swap
;	r@ skip
;	over swap
;	r> scan
;	drop over over swap -
;	>r
;	rot - 1+
;	>in +!
;	r> here
;	over over c!
;	1+ swap cmove
;	here dup count +
;	bl swap c! ;
wordlfa		.word $adde
		.byt (_word-*-1)|bit7
		.asc "WOR","D"|bit7
_word					; ( char )
#include "enter.i65"
		.word tor		; ( )
#include "page.i65"
		.word _tickstream	; ( addr size )
#include "page.i65"
		.word over		; ( addr size addr )
#include "page.i65"
		.word swap		; ( addr addr size )
#include "page.i65"
		.word rfetch		; ( addr addr size char )
#include "page.i65"
		.word skip		; ( addr addr2 size )
#include "page.i65"
		.word over		; ( addr addr2 size addr2 )
#include "page.i65"
		.word swap		; ( addr addr2 addr2 size )
#include "page.i65"
		.word rfrom		; ( addr addr2 addr2 size char )
#include "page.i65" 
		.word scan		; ( addr addr2 addr3 size )
#include "page.i65"
		.word drop		; ( addr addr2 addr3 )
#include "page.i65"
		.word _twodup		; ( addr addr2 addr3 addr2 addr3 )
#include "page.i65"
		.word swap		; ( addr addr2 addr3 addr3 addr2 )
#include "page.i65"
		.word minus		; ( addr addr2 addr3 wordsize )
#include "page.i65"
		.word tor		; ( addr addr2 addr3 )
#include "page.i65"
		.word rot		; ( addr2 addr3 addr )
#include "page.i65"
		.word minus		; ( addr2 offset )
#include "page.i65"
		.word oneplus		; ( addr2 offset )
#include "page.i65"
		.word toin		; ( addr2 offset toin )
#include "page.i65"
		.word plusstore		; ( addr2 )
#include "page.i65"
		.word rfrom		; ( addr2 size )
#include "page.i65"
		.word here		; ( addr2 size here )
#include "page.i65"
		.word _twodup		; ( addr2 size here size here )
#include "page.i65"
		.word cstore		; ( addr2 size here )
#include "page.i65"
		.word oneplus		; ( addr2 size here+1 )
#include "page.i65"
		.word swap		; ( addr2 here+1 size )
#include "page.i65"
		.word cmove		; ( )
#include "page.i65"
		.word here		; ( here )
#include "page.i65"			; the following may be unnecessary ~
		.word bl		; ( here bl )
#include "page.i65"
		.word over		; ( here bl here )
#include "page.i65"
		.word count		; ( here bl here+1 size )
#include "page.i65"
		.word plus		; ( here bl here+size+1 )
#include "page.i65"
		.word cstore		; ( here )
		.word exit

;--------------------------------------------------------------
;
;	(PUNCT?)
;
;ppunctqlfa	.word $adde
;		.byt (_ppunctq-*-1)|bit7
;		.asc "(PUNCT?",")"|bit7
_ppunctq
#include "enter.i65"
		.word clit
		.byt '.'
#include "pad.i65"
		.word eq
		.word exit

;--------------------------------------------------------------
;
;	PUNCT?
;
punctqlfa	.word $adde
		.byt (_punctq-*-1)|bit7
		.asc "PUNCT","?"|bit7
_punctq
#include "enter.i65"
		.word _ppunctq
		.word exit


;--------------------------------------------------------------
;
;	CONVERT
;
; * 83 interpreter
;
convertlfa	.word $adde
		.byt (_convert-*-1)|bit7
		.asc "CONVER","T"|bit7
_convert
#include "enter.i65"
convert01	.word oneplus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word convert03
#include "page.i65"
		.word swap
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word drop
#include "page.i65"
		.word rot
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word umstar
#include "page.i65"
		.word dplus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word convert02
#include "page.i65"
		.word one
#include "page.i65"
		.word dpl
#include "page.i65"
		.word plusstore
#include "page.i65"
convert02	.word rfrom
#include "page.i65"
		.word branch
		.word convert01
#include "page.i65"
convert03	.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	NUMBER    ( addr -- d )
;
; Convert the count and character string at addr, to a signed
; 32-bit integer, using the value of BASE .  If numeric
; conversion is not possible, an error condition exists.  The
; string may contain a preceding minus sign.
numberlfa	.word $adde
		.byt (_number-*-1)|bit7
		.asc "NUMBE","R"|bit7
_number
#include "enter.i65"
		.word true
#include "page.i65"
		.word over
#include "page.i65"
		.word count
#include "page.i65"
		.word over
#include "page.i65"
		.word plus
#include "page.i65"
		.word swap
#include "page.i65"
		.word pqdo
		.word number03
#include "pad.i65"
number01	.word i
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word digit
#include "page.i65"
		.word qbranch
		.word number02
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word pleave
		.word number03
#include "page.i65"
number02	.word ploop
		.word number01
#include "page.i65"
number03	.word _qfind
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word rot
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word clit
		.byt '-'
#include "pad.i65"
		.word eq
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word minus
#include "page.i65"
		.word dpl
#include "page.i65"
		.word on
#include "page.i65"
number04	.word _convert
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word _punctq
#include "page.i65"
		.word qbranch
		.word number05
#include "page.i65"
		.word dpl
#include "page.i65"
		.word off
#include "page.i65"
		.word branch
		.word number04
#include "page.i65"
number05	.word cfetch
#include "page.i65"
		.word bl
#include "page.i65"
		.word ne
#include "page.i65"
		.word _qfind
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word qbranch
		.word number06
#include "page.i65"
		.word dnegate
number06	.word exit

;--------------------------------------------------------------
;
;	TRYCHAIN   ( name-2 vocabptr -- addr flag )
;
;": trychain ( name vocabulary -- addr flag )
;	@ @ ?dup			( name-2 head head | name-2 0 )
;	if	(find)			( addr flag ; result of vocab search )
;	else	dup 2+ dhash		( name-2 hash1 hash2 )
;		bloom@			( name-2 hash1 flag )
;		if	dhash@ (find)	( lfa flag ; result of FORTH search )
;		else	drop false	( name-2 false ; bloom filter skip )
;		then
;	then ;
;
;trychainlfa	.word $adde
;		.byt (_trychain-*-1)|bit7
;		.asc "TRYCHAI","N"|bit7
_trychain
#include "enter.i65"
		.word fetch		; ( name-2 vocabulary )
#include "page.i65"
		.word fetch		; ( name-2 LFA|0 )
#include "page.i65"
		.word qdup		; ( name-2 LFA LFA | name-2 false )
#include "page.i65"
		.word qbranch
		.word trychain01
#include "pad.i65"			; ( name-2 LFA )
		.word pfind		; ( addr flag )
#include "page.i65"
		.word branch
		.word trychain03
#include "pad.i65"
trychain01	.word dup		; ( name-2 name-2 )
#include "page.i65"
		.word twoplus		; ( name-2 name )
#include "page.i65"
		.word dhash		; ( name-2 hash1 hash2 )
#include "page.i65"
		.word bloomfetch	; ( name-2 hash1 flag )
#include "page.i65"
		.word qbranch
		.word trychain02
#include "pad.i65"			; ( name-2 hash1 )
		.word dhashfetch	; ( name-2 LFA )
#include "page.i65"
		.word pfind		; ( addr flag )
#include "page.i65"
		.word branch
		.word trychain03
#include "pad.i65"			; ( name-2 hash1 )
trychain02	.word drop
#include "page.i65"			; ( name-2 )
		.word twoplus
#include "page.i65"
		.word false		; ( here false )
#include "page.i65"
trychain03	.word exit		; ( addr flag )

;--------------------------------------------------------------
;
;	FIND   ( addr1 -- addr2 n )
;
; * 83 interpreter
;
; addr1 is the address of a counted string.  The string
; contains a word name to be located in the currently active
; search order.  If the word is not found, addr2 is the string
; address addr1, and n is zero.  If the word is found, addr2
; is the compilation address and n is set to one of two non-
; zero values.  If the word found has the immediate attribute,
; n is set to one.  If the word is non-immediate, n is set to
; minus one (true).
;
;": find  ( name -- addr flag )
;	2- context trychain		( addr -1|1 | name false )
;	?dup 0=				( addr -1|1 false | name true )
;	if	current			( name current )
;		dup @ context @ <>	( name current flag )
;		if	trychain	( addr flag )
;		else	drop 2+ false	( name 0 )
;		then
;	then ;
;
findlfa		.word $adde
		.byt (_find-*-1)|bit7
		.asc "FIN","D"|bit7
_find
#include "enter.i65"			; ( name )
		.word twominus		; ( name-2 ) adjust to look like LFA
#include "page.i65"
		.word context		; ( name-2 context )
#include "page.i65"
		.word _trychain
#include "page.i65"
		.word qdup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word find02
#include "pad.i65"
		.word current
#include "page.i65"
		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word context
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ne
#include "page.i65"
		.word qbranch
		.word find01
#include "pad.i65"
		.word _trychain
#include "page.i65"
		.word branch
		.word find02
#include "pad.i65"
find01		.word drop
#include "page.i65"
		.word false
#include "page.i65"
find02		.word exit

;--------------------------------------------------------------
;
;	EXISTS?
;
existsqlfa	.word $adde
		.byt (_existsq-*-1)|bit7
		.asc "EXISTS","?"|bit7
_existsq
#include "enter.i65"
		.word bl		; ( c )
#include "page.i65"
		.word _word		; ( nfa )
#include "page.i65"
		.word _find		; ( nfa true | here false )
		.word exit

;--------------------------------------------------------------
;
;	ID.
;
iddotlfa	.word $adde
		.byt (_iddot-*-1)|bit7
		.asc "ID","."|bit7
_iddot
#include "enter.i65"
		.word _pad
#include "page.i65"
		.word clit
		.byt 32
#include "pad.i65"
		.word clit
		.asc '*'
#include "pad.i65"
		.word fill
#include "page.i65"
		.word dup
#include "page.i65"
		.word _namefrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _pad
#include "page.i65"
		.word swap
#include "page.i65"
		.word cmove
#include "page.i65"
		.word _pad
#include "page.i65"
		.word count
#include "page.i65"
		.word clit
		.byt $1f		; ~ shouldn't this use WIDTH?
#include "pad.i65"
		.word andx
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	CREATE
;
; * 83 compiler
;
;" ~ this 'CREATE' from Blazin' is um... kinda "busy."  Refactor
;" : create <bcq here width @ 2+ 2+ view?
;"	@ + + u< (abort") dictionary full exists?
;"	over (lit) 6017 = (abort") name required
;"	warning @ and ?branch 41 >name cr
;"	18 emit id. 146 emit (.") already exists
;"	branch 4 drop here dup c@
;"	over 2+ view? @ + dup >r swap 1+ cmove>
;"	r> dup c@ width @ min 1+ 2dup + 255
;"	and 255 = ?branch 25 2dup swap
;"	dup 1+ rot cmove> 234 c, swap 1+
;"	swap 2+ view? @ + allot dup 128 toggle
;"	here 1- 128 toggle latest over
;"	2- ! view? @ ?branch 14 blk @ over 2-
;"	2- ! 2 allot current @ ! (;code)
;".C:1b0b	18		CLC
;".C:1b0c	A5 87		LDA $87
;".C:1b0e	69 02		ADC #$02
;".C:1b10	48		PHA
;".C:1b11	98		TYA
;".C:1b12	65 88		ADC $88
;".C:1b14	4C 4A 08	JMP $084A
;
createlfa	.word $adde
		.byt (_create-*-1)|bit7
		.asc "CREAT","E"|bit7
_create
#include "enter.i65"
		.word _ltbcq
#include "page.i65"
		.word here
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word plus
#include "page.i65"
		.word ult
#include "page.i65"
#if (((*&$ff)+3+15)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt create01-*-1
		.asc	"DICTIONARY FULL"
			;123456789.12345
create01
#include "page.i65"
		.word _existsq
#include "page.i65"
		.word over
#include "page.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+13)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt create02-*-1
		.asc	"NAME REQUIRED"
			;123456789.123
create02
#include "page.i65"
		.word warning
#include "page.i65"
		.word fetch
#include "page.i65"
		.word andx
#include "page.i65"
		.word qbranch
		.word create04
#include "page.i65"
		.word _toname
#include "page.i65"
		.word cr
#include "page.i65"
		.word clit
		.byt $12	; rvs
#include "pad.i65"
		.word emit
#include "page.i65"
		.word _iddot
#include "page.i65"
		.word clit
		.byt $92	; off
#include "pad.i65"
		.word emit
#include "page.i65"
#if (((*&$ff)+3+15)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt create03-*-1
		.asc	" ALREADY EXISTS "
			;1234567869.12345
create03
#include "page.i65"
		.word branch
		.word create05
#include "page.i65"
create04	.word drop
#include "page.i65"
create05	.word here
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word cfetch
#include "page.i65"
		.word width
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _min
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word plus
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word andx
#include "page.i65"
		.word clit
		.byt $ff
#include "pad.i65"
		.word eq
#include "page.i65"

		.word qbranch
		.word create06
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word swap
#include "page.i65"
		.word dup
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word rot
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word clit
		.byt $ea
#include "pad.i65"
		.word _ccomma
#include "page.i65"
		.word swap
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
create06	.word twoplus
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word _allot
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word here
#include "page.i65"
		.word oneminus
#include "page.i65"
		.word clit
		.byt $80
#include "pad.i65"
		.word toggle
#include "page.i65"
		.word _latest
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word viewq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word create07
#include "page.i65"
		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
create07	.word two
#include "page.i65"
		.word _allot
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word store
		.word _psemi
docreate	pla
		clc
		adc #1
		sta n
		pla
		tay
		bcc docreate01
		iny
docreate01	lda n
		jmp pushya

;--------------------------------------------------------------
;
;	[COMPILE]
;
; * 83 compiler
;
bcompilelfa	.word $adde
		.byt (_bcompile-*-1)|bit7
		.asc "[COMPILE","]"|bit7
_bcompile
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _tick
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	LITERAL
;
; * 83 compiler
;
literallfa	.word $adde
		.byt (_literal-*-1)|bit7
		.asc "LITERA","L"|bit7
_literal
#include "enter.i65"
		.word dup
#include "page.i65"
		.word plit
		.word 256
#include "pad.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word literal01
#include "page.i65"
		.word _compile
		.word clit
#include "page.i65"
		.word _ccomma
#include "page.i65"
		.word branch
		.word literal02
#include "page.i65"
literal01	.word _compile
		.word plit
#include "page.i65"
		.word _comma
literal02	.word exit

;--------------------------------------------------------------
;
;	DLITERAL
;
dliterallfa	.word $adde
		.byt (_dliteral-*-1)|bit7
		.asc "DLITERA","L"|bit7
_dliteral
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _literal
#include "page.i65"
		.word _literal
		.word exit

;--------------------------------------------------------------
;
;	?STACK
;
; inspect data stack pointer for sanity, halt with a message if trouble
; a hybrid primitive that jumps up to high-level Forth to invoke ABORT"
qstacklfa	.word $adde
		.byt (qstack-*-1)|bit7
		.asc "?STAC","K"|bit7
qstack		txa
		bmi qstack01	; stack overflow
		ldy #usersp0-userarea
		cmp (up),y
		bcc qstack03	; things are just fine
		beq qstack03	; SP@ = bos, not a problem either
		ldy #>(qstackempty-2)	; stack underflow error
		lda #<(qstackempty-2)
		bcs qstack02	; bra
qstack01	ldy #>(qstackfull-2)	; stack overflow error
		lda #<(qstackfull-2)
qstack02	sty ip+1
		sta ip
qstack03	jmp next
#if (((*&$ff)+3+12)=$ff)
	.byt $ea,$ea,$ea,$ea
#endif
qstackempty	.word _pabortq		; qstack might transfer control here
		.byt qstackfull-*-1	; no need for an exit because we're
		.asc	"STACK EMPTY "	; not coming back from ABORT"
			;123456789.12
#if (((*&$ff)+3+15)=$ff)
	.byt $ea,$ea,$ea,$ea
#endif
qstackfull	.word _pabortq
		.byt qstack04-*-1
		.asc	"STACK OVERFLOW "
			;123456789.12345
qstack04

;--------------------------------------------------------------
;
;	INTERPRET
;
;
;": interpret   ( )
;	begin	?stack
;		exists?
;		if	link>
;			execute
;		else	number dpl @ 1+ 0=
;			if	drop
;			then
;		then
;		false
;		quit?
;	again ;
;
interpretlfa	.word $adde
		.byt (_interpret-*-1)|bit7
		.asc "INTERPRE","T"|bit7
_interpret
#include "enter.i65"
interpret01	.word qstack		; ( )
#include "page.i65"
		.word _existsq		; ( addr flag )
#include "page.i65"
		.word qbranch
		.word interpret02
#include "page.i65"
		.word _linkfrom
#include "page.i65"
		.word execute
#include "page.i65"
		.word branch
		.word interpret03
#include "page.i65"
interpret02	.word _number
#include "page.i65"
		.word dpl
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word interpret03
#include "page.i65"
		.word drop
#include "page.i65"
interpret03	.word false
#include "page.i65"
		.word _quitq
#include "page.i65"
		.word qbranch
		.word interpret01
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	IMMEDIATE
;
; * 83 compiler
;
immediatelfa	.word $adde
		.byt (_immediate-*-1)|bit7
		.asc "IMMEDIAT","E"|bit7
_immediate
#include "enter.i65"
		.word _latest
#include "page.i65"
		.word clit
		.byt $40
#include "pad.i65"
		.word toggle
		.word exit

;--------------------------------------------------------------
;
;	VOCABULARY
;
; * 83 compiler
;
; see FD-V05N3 p. 5

vocabularylfa	.word $adde
		.byt (_vocabulary-*-1)|bit7
		.asc "VOCABULAR","Y"|bit7
_vocabulary
#include "enter.i65"
		.word _create
#include "page.i65"
		.word current
#include "page.i65"
		.word fetch
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word _comma
#include "page.i65"
		.word plit
		.word $a081
#include "pad.i65"
		.word _comma
#include "page.i65"
		.word here
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _comma
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
		.word _psemi
vocabdoes	jsr dodoes
		.word context
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	FORTH
;
; * 83 interpreter
;
; ~ maybe put a zero instead of ntop, to flag the special handling?
; ntop doesn't seem very useful, at least here
; when all is over, said and done with, the PFA of FORTH (aka FORTH+3)
; should be stored in user variable CONTEXT
forthlfa	.word $adde
		.byt (forth-*-1)|bit7
		.asc "FORT","H"|bit7
forth		jsr vocabdoes
		.word 0			; flag as root vocabulary
		.word $a081		; some magic number?
lastvoc		.word 0			; link to next vocabulary, 0 for last

;--------------------------------------------------------------
;
;	DEFINITIONS
;
; * 83 interpreter
;
definitionslfa	.word $adde
		.byt (_definitions-*-1)|bit7
		.asc "DEFINITION","S"|bit7
_definitions
#include "enter.i65"
		.word context
#include "page.i65"
		.word fetch
#include "page.i65"
		.word current
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	(
;
; * 83 interpreter
;
lparenlfa	.word $adde
		.byt (_lparen-*-1)|bit7
		.asc "("|bit7
_lparen
#include "enter.i65"
		.word clit
		.asc ')'
#include "pad.i65"
		.word _qchar
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	RUN
;
runlfa		.word $adde
		.byt (_run-*-1)|bit7
		.asc "RU","N"|bit7
_run
#include "enter.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word run01
#include "page.i65"
		.word _rbracket
#include "page.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word not
#include "page.i65"
		.word qbranch
		.word run02
#include "page.i65"
		.word _interpret
#include "page.i65"
		.word branch
		.word run02
#include "page.i65"
run01		.word _interpret
run02		.word exit


;--------------------------------------------------------------
;
;	ABORT
;
; * 83 interpreter
;
abortlfa	.word $adde
		.byt (_abort-*-1)|bit7
		.asc "ABOR","T"|bit7
_abort
#include "enter.i65"
		.word spstore
#include "page.i65"
		.word _quit
		.word exit	; make the decompiler happy

;--------------------------------------------------------------
;
;	STARTUP
;
startuplfa	.word $adde
		.byt (startup-*-1)|bit7
		.asc "STARTU","P"|bit7
startup		jsr docreate
		.word _abort

;--------------------------------------------------------------
;
;	COLD
;
;cold
;Cold start
;print a welcome message
;reset top of the dictionary
;reset data and return stack
coldlfa		.word $adde
		.byt (cold-*-1)|bit7
		.asc "COL","D"|bit7
xyzzy
cold		sei
;~debug - leave patterns to make things easier in the debugger
	ldy #<next
	lda #$3e
d000	sta $FFFF,y
	dey
	bne d000

	ldy #bos-1
d001	lda #$bb
	sta stackl,y
	lda #$cc
	sta stackh,y
	dey
	bpl d001

	lda #$dd
	ldy #31
d002	sta R0L,y
	dey
	bpl d002

	lda #$ba
	sta tos+1
	lda #$ab
	sta tos
;~debug
; copy NEXT code to zeropage
		ldy #zpend-zpnext
cold01		lda zpnext-1,y
		sta next-1,y
		dey
		bne cold01

		lda #<warmvector
		sta NMIVEC
		lda #>warmvector
		sta NMIVEC+1			; ~ test with NMI switch

		ldy #usercold-userarea-1
		bne warm01

warm		lda #>warm05
		sta w1+1
		lda #<warm05
		sta w1

		ldy #userwarm-userarea-1

warm01		lda userup
		sta up
		lda userup+1
		sta up+1
warm02		lda userarea,y
		sta (up),y
		dey
		bpl warm02
		cld
		cli
		jsr CLRCHN
		jsr CLALL

		lda #>(w1-2)
		sta ip+1
		lda #<(w1-2)
		sta ip
#include "toforth.i65"
warm03		.word rpstore		; and we're off
#include "page.i65"
		.word spstore
#include "page.i65"
		.word plit
		.word SW16
#include "pad.i65"
		.word plit
		.word BRKVEC
#include "pad.i65"
		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word mlmon
#include "page.i65"
		.word store
#include "pad.i65"
		.word store		; set up Sweet-16
#include "page.i65"
#if (((*&$ff)+3+$ee)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt warm04-*-1
		.byt CLRSCR
.byt 236,239,17,157,157,234,32,41,17,157,157,157,234,247,17,157,157,252
.byt 32,32,145,145,145
.byt 236,239,251,17,157,157,157,234,17,157,234,247,17,157,157
.byt 252,247,254,145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 236,239,239,251,17,157,157,157,234,17,157,234,17,157,252,32,32
.byt 145,145,145
.byt 239,239,17,157,157,234,17,157,234,17,157
.byt 247,247,145,145,145
.byt 236,17,157,234,17,157,234,17,157,252,247,247,254
.byt 145,145,145
		.asc "6502 FORTH FOR THE"
.byt 17,17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
.byt 157,157,157
		.asc "COMMODORE PET 2001"
.byt 17,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157
		.asc "......... ... ...."

		.byt $0d,$0d
		.asc "HTTP:"
		.byt 47,47
		.asc "CHITSELB.COM 2010"
		.byt $0d,$0d
warm04
		.word _rethread
#include "page.i65"
warm05		.word _emptybuffers
#include "page.i65"
		.word _decimal
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#if (((*&$ff)+3+19)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt warm06-*-1
		.asc	$0d,"WELCOME TO PETTIL!"
			   ;123456789.123456789
warm06
#include "page.i65"
		.word startup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word execute
		.word exit

;--------------------------------------------------------------
;
;	QUIT
;
; * 83 interpreter outer
;
quitlfa		.word $adde
		.byt (_quit-*-1)|bit7
		.asc "QUI","T"|bit7
_quit
#include "enter.i65"
		.word blk
#include "page.i65"
		.word off
#include "page.i65"
		.word _lbracket
#include "page.i65"
quit01		.word rpstore
#include "page.i65"
		.word cr
#include "page.i65"
		.word _query
#include "page.i65"
		.word _interpret
#include "page.i65"
		.word state
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word quit02
#include "page.i65"
#if (((*&$ff)+3+2)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt (quit02-*-1)
		.asc	"OK"
			;12
quit02
#include "page.i65"
		.word branch
		.word quit01

;--------------------------------------------------------------
;
;	S>D
;
stodlfa		.word $adde
		.byt (_stod-*-1)|bit7
		.asc "S>","D"|bit7
_stod
#include "enter.i65"
		.word dup
#include "page.i65"
		.word zlt
		.word exit

;--------------------------------------------------------------
;
;	ABS   ( n -- +n )
;
; * 83 nucleus
;
abslfa		.word $adde
		.byt (abs-*-1)|bit7
		.asc "AB","S"|bit7
abs		lda tos+1
		bpl abs01
		jmp negate
abs01		jmp next

;--------------------------------------------------------------
;
;	DABS
;
dabslfa		.word $adde
		.byt (dabs-*-1)|bit7
		.asc "DAB","S"|bit7
dabs		lda tos+1
		bpl abs01
		jmp dnegate

;--------------------------------------------------------------
;
;	MIN
;
; * 83 nucleus
;
minlfa		.word $adde
		.byt (_min-*-1)|bit7
		.asc "MI","N"|bit7
_min
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word gt
#include "page.i65"
		.word qbranch
		.word min01
#include "pad.i65"
		.word swap
#include "page.i65"
min01		.word drop
		.word exit

;--------------------------------------------------------------
;
;	MAX
;
; * 83 nucleus
;
maxlfa	.word $adde
		.byt (_max-*-1)|bit7
		.asc "MA","X"|bit7
_max
#include "enter.i65"
		.word _twodup
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word max01
#include "pad.i65"
		.word swap
#include "page.i65"
max01		.word drop
		.word exit

;--------------------------------------------------------------
;
;	M*   ( n1 n2 -- d )
;
; multiply two signed words, leaving the double product on the stack
mstarlfa	.word $adde
		.byt (mstar-*-1)|bit7
		.asc "M","*"|bit7
mstar		jsr mult
		jmp next
mult		lda stackl,x
		sta n+4
		lda stackh,x
		sta n+5
		eor tos+1
		php			; we only care about the sign bit
		bit tos+1
		bpl mult01
		jsr donegate
mult01		bit n+5
		bpl mult02
		sec
		lda #0
		sbc n+4
		sta n+4
		lda #0
		sbc n+5
		sta n+5
mult02		jsr multiply
		lda n+1
		sta stackh,x
		lda n
		sta stackl,x
		lda n+3
		sta tos+1
		lda n+2
		sta tos
		plp
		bpl mult03
		jmp dodnegate
mult03		rts

;--------------------------------------------------------------
;
;	M/
;
mslashlfa	.word $adde
		.byt (mslash-*-1)|bit7
		.asc "M","/"|bit7
mslash
		jsr domslash
		jmp next
domslash	cpx #$6f
		bcc domslash02
domslash01	ldx #bos
	;	sty stack,x
	;	sty stack+1,x
		tya
		rts
domslash02;	lda stack,x
	;	ora stack+1,x
		beq domslash01
	;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+1,x
	;	eor stack+3,x
		pha
	;	lda stack+1,x
		pha
		bpl domslash03
		jsr donegate
domslash03;	lda stack+3,x
		bpl domslash04
		inx
		inx
		jsr dnegate
		dex
		dex
domslash04	jsr modulo
		pla
		bpl domslash05
		jsr remult
domslash05	pla
		bpl domslash07
		jsr donegate
	;	lda stack+2,x
	;	ora stack+3,x
		beq domslash07
	;	lda stack,x
		bne domslash06
	;	dec stack+1,x
domslash06;	dec stack,x
		jsr remult
		clc
		pla
	;	adc stack+2,x
	;	sta stack+2,x
		pla
	;	adc stack+3,x
	;	sta stack+3,x
		rts
domslash07	pla
		pla
		rts
remult		inx
		inx
		jsr donegate
		dex
		dex
		rts

;--------------------------------------------------------------
;
;	*   ( n1 n2 -- n1*n2 )
;
; * 83 nucleus
;
; multiply two signed words
starlfa		.word $adde
		.byt (star-*-1)|bit7
		.asc "*"|bit7
star		jsr mult
		jmp pops

;--------------------------------------------------------------
;
;	/MOD
;
; * 83 nucleus
;
slashmodlfa	.word $adde
		.byt (slashmod-*-1)|bit7
		.asc "/MO","D"|bit7
slashmod	jsr doslashmod
		jmp next
doslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	lda stack+3,x
		bpl doslashmod01
		dey
doslashmod01;	sty stack,x
	;	sty stack+1,x
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		ldy #0
		jmp domslash

;--------------------------------------------------------------
;
;	/
;
; * 83 nucleus
;
slashlfa	.word $adde
		.byt (slash-*-1)|bit7
		.asc "/"|bit7
slash		jsr doslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pops

;--------------------------------------------------------------
;
;	MOD
;
; * 83 nucleus
;
modlfa		.word $adde
		.byt (mod-*-1)|bit7
		.asc "MO","D"|bit7
mod		jsr doslashmod
		jmp pops

;--------------------------------------------------------------
;
;	*/MOD
;
; * 83 nucleus
;
starslashmodlfa	.word $adde
		.byt (starslashmod-*-1)|bit7
		.asc "*/MO","D"|bit7
starslashmod	jsr dostarslashmod
		jmp next
dostarslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
		inx
		inx
		jsr mult
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		jmp domslash

;--------------------------------------------------------------
;
;	*/
;
; * 83 nucleus
;
starslashlfa	.word $adde
		.byt (starslash-*-1)|bit7
		.asc "*","/"|bit7
starslash	jsr dostarslashmod
	;	lda stack,x
	;	sta stack+2,x
	;	lda stack+1,x
	;	sta stack+3,x
		jmp pops

;--------------------------------------------------------------
;
;	M/MOD
;
mslashmodlfa	.word $adde
		.byt (mslashmod-*-1)|bit7
		.asc "M/MO","D"|bit7
mslashmod	jsr domslashmod
		jmp next
domslashmod;	lda stack+1,x
		pha
	;	lda stack,x
		pha
	;	sty stack,x
	;	sty stack+1,x
		dex
		dex
		pla
		tay
	;	sta stack,x
		pla
	;	sta stack+1,x
		pha
		tya
		pha
		ldy #0
		jsr modulo
	;	lda stack+1,x
		sta n+1
	;	lda stack,x
		tay
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		lda n+1
		pha
		tya
		pha
		ldy #0
		jsr modulo
		dex
		dex
		pla
	;	sta stack,x
		pla
	;	sta stack+1,x
		rts

;--------------------------------------------------------------
;
;	<BCQ
;
ltbcqlfa	.word $adde
		.byt (_ltbcq-*-1)|bit7
		.asc "<BC","Q"|bit7
_ltbcq
#include "enter.i65"
		.word first
#include "page.i65"
		.word numbcq
#include "page.i65"
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	BCQ>
;
bcqtolfa	.word $adde
		.byt (_bcqto-*-1)|bit7
		.asc "BCQ",">"|bit7
_bcqto
#include "enter.i65"
		.word first
#include "page.i65"
		.word twominus
		.word exit

;--------------------------------------------------------------
;
;	>BCQ
;
tobcqlfa	.word $adde
		.byt (_tobcq-*-1)|bit7
		.asc ">BC","Q"|bit7
_tobcq
#include "enter.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word plus
		.word exit

;--------------------------------------------------------------
;
;	LATEST?
;
latestqlfa	.word $adde
		.byt (_latestq-*-1)|bit7
		.asc "LATEST","?"|bit7
_latestq
#include "enter.i65"
		.word offset
#include "page.i65"
		.word fetch
#include "page.i65"
		.word plus
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word latestq01
#include "pad.i65"
		.word drop
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word false
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word drop
latestq01	.word exit

;--------------------------------------------------------------
;
;	ABSENT?
;
absentqlfa	.word $adde
		.byt (_absentq-*-1)|bit7
		.asc "ABSENT","?"|bit7
_absentq
#include "enter.i65"
		.word _latestq
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word store
#include "page.i65"
		.word true
#include "page.i65"
		.word swap
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
absentq01	.word _twodup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word absentq02
#include "pad.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word cmove
#include "page.i65"
		.word dup
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word rot
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word minus
#include "page.i65"
		.word cmovegt
#include "page.i65"
		.word drop
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word false
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word pleave
		.word absentq03
#include "pad.i65"
absentq02	.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word ploop
		.word absentq01
#include "pad.i65"
absentq03	.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
		.word exit

;--------------------------------------------------------------
;
;	UPDATE
;
; * 83 device
;
updatelfa	.word $adde
		.byt (_update-*-1)|bit7
		.asc "UPDAT","E"|bit7
_update
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word on
		.word exit

;--------------------------------------------------------------
;
;	DR0
;
drzerolfa	.word $adde
		.byt (_drzero-*-1)|bit7
		.asc "DR","0"|bit7
_drzero
#include "enter.i65"
		.word offset
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	DR1
;
dronelfa	.word $adde
		.byt (_drone-*-1)|bit7
		.asc "DR","1"|bit7
_drone
#include "enter.i65"
		.word plit
		.word 166
#include "pad.i65"
		.word offset
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	DISCARD
;
discardlfa	.word $adde
		.byt (_discard-*-1)|bit7
		.asc "DISCAR","D"|bit7
_discard
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
		.word exit

;--------------------------------------------------------------
;
;	MISSING
;
missinglfa	.word $adde
		.byt (_missing-*-1)|bit7
		.asc "MISSIN","G"|bit7
_missing
#include "enter.i65"
		.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word missing01
#include "pad.i65"
		.word _bcqto
#include "page.i65"
		.word dup
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word minus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zero
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word off
#include "page.i65"
missing01	.word _bcqto
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word store
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"

		.word star
#include "page.i65"
		.word cmovegt
		.word exit

;--------------------------------------------------------------
;
;	BUFFER
;
; * 83 device
;
bufferlfa	.word $adde
		.byt (_buffer-*-1)|bit7
		.asc "BUFFE","R"|bit7
_buffer
#include "enter.i65"
		.word _absentq
#include "page.i65"
		.word qbranch
		.word buffer01
#include "pad.i65"
		.word drop
#include "page.i65"
		.word _missing
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
buffer01	.word exit

;--------------------------------------------------------------
;
;	BLOCK   ( u -- addr )
;
; * 83 device
;
; addr is the address of the assigned buffer of the first byte
; of block u.  If the block occupying that buffer is not block
; u and has been UPDATEed it is transferred to mass storage
; before assigning the buffer.  If block u is not already in
; memory, it is transferred from mass storage into an assigned
; block buffer.  A block may not be assigned to more than one
; buffer.  If u is not an available block number, an error
; condition exists.  Only data within the last buffer
; referenced by BLOCK or BUFFER is valid.  The contents of a
; block buffer must not be changed unless the change may be
; transferred to mass storage.
blocklfa	.word $adde
		.byt (_block-*-1)|bit7
		.asc "BLOC","K"|bit7
_block
#include "enter.i65"
		.word _absentq
#include "page.i65"
		.word qbranch
		.word block01
#include "pad.i65"
		.word drop
#include "page.i65"
		.word _missing
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word swap
#include "page.i65"
		.word fetch
#include "page.i65"
		.word one
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
block01		.word exit

;--------------------------------------------------------------
;
;	EMPTY-BUFFERS   ( -- )
;
; 09/16/10 cah
emptybufferslfa	.word $adde
		.byt (_emptybuffers-*-1)|bit7
		.asc "EMPTY-BUFFER","S"|bit7
_emptybuffers
#include "enter.i65"
		.word first
#include "page.i65"
		.word limit
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _erase
#include "page.i65"
		.word _ltbcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word _erase
#include "page.i65"
		.word first
#include "page.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
emptybuffers01	.word plit
		.word -1
#include "pad.i65"
		.word over
#include "page.i65"
		.word store
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word store
#include "page.i65"
		.word swap
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word plus
#include "page.i65"
		.word swap
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word ploop
		.word emptybuffers01
#include "pad.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	SAVE-BUFFERS   ( -- )
;
; * 83 device
;
; The contents of all block buffers marked as UPDATEed are
; written to their corresponding mass storage blocks.  All
; buffers are marked as no longer being modified, but may
; remain assigned.
savebufferslfa	.word $adde
		.byt (_savebuffers-*-1)|bit7
		.asc "SAVE-BUFFER","S"|bit7
_savebuffers
#include "enter.i65"
		.word one
#include "page.i65"
		.word _tobcq
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
savebuffers01	.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word qbranch
		.word savebuffers03
#include "pad.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word savebuffers02
#include "pad.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word fetch
#include "page.i65"
		.word over
#include "page.i65"
		.word fetch
#include "page.i65"
		.word zero
#include "page.i65"
		.word _rslashw
#include "page.i65"
		.word dup
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word off
#include "page.i65"
savebuffers02	.word clit
		.byt 6
#include "pad.i65"
		.word plus
#include "page.i65"
savebuffers03	.word ploop
		.word savebuffers01
#include "pad.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	FLUSH
;
; * 83 device
;
flushlfa	.word $adde
		.byt (_flush-*-1)|bit7
		.asc "FLUS","H"|bit7
_flush
#include "enter.i65"
		.word _savebuffers
#include "page.i65"
		.word _emptybuffers
		.word exit

;--------------------------------------------------------------
;
;	LOAD
;
; * 83 interpreter
;
loadlfa		.word $adde
		.byt (_load-*-1)|bit7
		.asc "LOA","D"|bit7
_load
#include "enter.i65"
		.word qdup
#include "page.i65"
		.word zeq
#if (((*&$ff)+3+17)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt load01-*-1
		.asc	"CAN'T LOAD SCR# 0"
			;123456789.1234567
load01		.word blk
#include "page.i65"
		.word fetch
#include "page.i65"
		.word tor
#include "page.i65"
		.word toin
#include "page.i65"
		.word fetch
#include "page.i65"
		.word tor
#include "page.i65"
		.word toin
#include "page.i65"
		.word off
#include "page.i65"
		.word blk
#include "page.i65"
		.word store
#include "page.i65"
		.word _run
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word toin
#include "page.i65"
		.word store
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word blk
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	>DISC
;
todisclfa	.word $adde
		.byt (todisc-*-1)|bit7
		.asc ">DIS","C"|bit7
todisc		lda curindev
		sta n+6
		lda curoutdev
		sta n+7
	;	stx storex
		tsx
		stx n+4
		jsr CLRCHN
	;	ldx storex
	;	lsr stack,x
		bcs todisc01
		jsr todisc12
		ldx #<ldr1
		lda #>ldr1
		jsr todisc03
		jmp todisc02
todisc01	ldx #<ldr0
		lda #>ldr0
		jsr todisc03
		jsr todisc05
todisc02	lda #0
		pha
		ldx n+6
		jsr CHKIN
		ldx n+7
		jsr CHKOUT
		pla
		ldx n+4
		txs
	;	ldx storex
	;	sta stack+8,x
	;	sta stack+9,x
		inx
		inx
		inx
		inx
		jmp poptwo
todisc03	stx n
		sta n+1
		ldx #15
		jsr CHKOUT
		ldx n
		lda n+1
		jsr todisc14
	;	ldx storex
	;	lda stack+2,x
		jsr todisc07
		lda #','
		jsr CHROUT
	;	lda stack+4,x
		jsr todisc07
		lda #','
		jsr CHROUT
	;	lda stack+6,x
		jsr todisc07
		lda #$0d
		jsr CHROUT
		jsr CLRCHN
		jmp todisc09
todisc04	ldx #15
		jsr CHKOUT
		ldx #<discstring
		lda #>discstring
		jsr todisc14
		jsr CLRCHN
		jmp todisc09
todisc05;	ldx storex
	;	lda stack+8,x
		sta n+2
	;	lda stack+9,x
		sta n+3
		jsr todisc04
		ldx #$0d
		jsr CHKIN
		ldy #0
todisc06	jsr GETIN
		sta (n+2),y
		iny
		bne todisc06
		jsr CLRCHN
		jmp todisc09
todisc07	ldy #$ff
		sec
todisc08	iny
		sbc #10
		bcs todisc08
		adc #10
		pha
		tya
		ora #'0'
		jsr CHROUT
		pla
		ora #'0'
		jmp CHROUT
todisc09	ldx #15
		jsr CHKIN
		ldy #$ff
todisc10	iny
		jsr GETIN
		sta inbuf+1,y
		cmp #$0d
		bne todisc10
		sty inbuf
		jsr CLRCHN
		lda inbuf+1
		cmp #'0'
		bne todisc11
		rts
todisc11	lda #$ff
	;	jmp l150
todisc12;	ldx storex
	;	lda stack+8,x
		sta n+2
	;	lda stack+9,x
		sta n+3
		jsr todisc04
		ldx #$0d
		jsr CHKOUT
		ldy #0
todisc13	lda (n+2),y
		jsr CHROUT
		iny
		bne todisc13
		jsr CLRCHN
		jmp todisc09
todisc14	stx n
		sta n+1
		ldy #0
todisc15	lda (n),y
		cmp #0
		beq todisc16
		jsr CHROUT
		iny
		bne todisc15
todisc16	rts
discstring	.asc "B-P13,0"
		.byt $0d
		.byt 0
ldr0		.asc "U1:13,"
		.byt 0
ldr1		.asc "U2:13,"
		.byt 0

;--------------------------------------------------------------
;
;	(R/W)
;
;prslashwlfa	.word $adde
;		.byt (_prslashw-*-1)|bit7
;		.asc "(R/W",")"|bit7
_prslashw
#include "enter.i65"
		.word _qdisc
#include "page.i65"
		.word _tns
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
prslashw01	.word clit
		.byt 5
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
prslashw02	.word clit
		.byt 4
#include "pad.i65"
		.word pick
#include "page.i65"
		.word ploop
		.word prslashw02
#include "pad.i65"
		.word todisc
#include "page.i65"
		.word qbranch
		.word prslashw03
#include "pad.i65"
		.word _dotderr
#include "page.i65"
prslashw03	.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word tor
#include "page.i65"
		.word plit
		.word $0100	; rstack

#include "pad.i65"
		.word plus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word two
#include "page.i65"
		.word pick
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
		.word rfrom
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word ploop
		.word prslashw01
#include "pad.i65"
		.word twodrop
#include "page.i65"
		.word twodrop
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	R/W
;
rslashwlfa	.word $adde
		.byt (_rslashw-*-1)|bit7
		.asc "R/","W"|bit7
_rslashw
#include "enter.i65"
		.word _prslashw
		.word exit

;--------------------------------------------------------------
;
;	T&S
;
;1541 Track Number Sectors
;1-17 0-20
;18-24 0-18
;25-30 0-17
;31-35 0-16
;track 18 = DIR/BAM
;
;1581 80 tracks, 40 sectors, tracks 40-41 = DIR/BAM
;
;tnslfa		.word $adde
;		.byt (_tns-*-1)|bit7
;		.asc "T&","S"|bit7
_tns
#include "enter.i65"
		.word tor
#include "page.i65"
		.word plit
		.word 332	 ;~	max disc size
#include "pad.i65"
		.word over
#include "page.i65"
		.word ult
#include "page.i65"
#if (((*&$ff)+3+22)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt tns01-*-1
		.asc	"SCREEN DOES NOT EXIST "
			;123456789.123456789.12
#include "pad.i65"
tns01		.word clit
		.byt 166
#include "pad.i65"
		.word slashmod
#include "page.i65"
		.word tor
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 88
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word tns02
#include "pad.i65"
		.word clit
		.byt 21
#include "pad.i65"
		.word one
#include "page.i65"
		.word tor
#include "page.i65"
		.word branch
		.word tns06
#include "pad.i65"
tns02		.word dup
#include "page.i65"
		.word clit
		.byt 92
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word tns03
#include "pad.i65"
		.word twoplus
#include "page.i65"
		.word clit
		.byt 21
#include "pad.i65"
		.word one
#include "page.i65"
		.word tor
#include "page.i65"
		.word branch
		.word tns06
#include "pad.i65"
tns03		.word dup
#include "page.i65"
		.word clit
		.byt 120
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word tns04
#include "pad.i65"
		.word clit
		.byt 92
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 19
#include "pad.i65"
		.word clit
		.byt 19
#include "pad.i65"
		.word tor
#include "page.i65"
		.word branch
		.word tns06
#include "pad.i65"
tns04		.word dup
#include "page.i65"
		.word clit
		.byt 146
#include "pad.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word tns05
#include "pad.i65"
		.word clit
		.byt 120
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 18
#include "pad.i65"
		.word clit
		.byt 25
#include "pad.i65"
		.word tor
#include "page.i65"
		.word branch
		.word tns06
#include "pad.i65"
tns05		.word clit
		.byt 146
#include "pad.i65"
		.word minus
#include "page.i65"
		.word clit
		.byt 17
#include "pad.i65"
		.word clit
		.byt 31
#include "pad.i65"
		.word tor
#include "page.i65"
tns06		.word rot
#include "page.i65"
		.word rot
#include "page.i65"
		.word dup
#include "page.i65"
		.word two
#include "page.i65"
		.word mod
#include "page.i65"
		.word swap
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word twostar
#include "page.i65"
		.word twostar
#include "page.i65"
		.word plus
#include "page.i65"
		.word two
#include "page.i65"
		.word pick
#include "page.i65"
		.word slashmod
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word plus
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word rfrom
		.word exit

;--------------------------------------------------------------
;
;	(OPEN)
;
;popenlfa	.word $adde
;		.byt (popen-*-1)|bit7
;		.asc "(OPEN",")"|bit7
popen	;	stx storex
	;	lda stack,x
		pha
	;	ldy stack+3,x
	;	lda stack+2,x
		tax
		pla
	;	jsr SETNAM
	;	ldx storex
	;	ldy stack+4,x
	;	lda stack+8,x
		pha
	;	lda stack+6,x
		tax
		pla
	;	jsr SETLFS
		jsr OPEN
		bcs popen02
	;	jsr READST
		and #$80
		beq popen01
		lda #5
		.byt $2c	; bit xxxx instruction
popen01		lda #0
popen02		pha
	;	lda storex
		clc
		adc #10
		tax
		pla
		jmp pushya

;--------------------------------------------------------------
;
;	CLOSE
;
closelfa	.word $adde
		.byt (close-*-1)|bit7
		.asc "CLOS","E"|bit7
close		stx n
		;lda stack,x
		jsr close
		ldx n
		jmp pops

;--------------------------------------------------------------
;
;	(CMDIN)
;
;pcmdinlfa	.word $adde
;		.byt (pcmdin-*-1)|bit7
;		.asc "(CMDIN",")"|bit7
pcmdin		.word *+2
		stx n+7
	;	lda stack,x
		tax
		jsr CHKIN
		bcs pcmdout01
		bcc pcmdout02
pcmdin01	ldx n+7
		lda #0
		inx
		inx
		jmp pushya

;--------------------------------------------------------------
;
;	(CMDOUT)
;
;pcmdoutlfa	.word $adde
;		.byt (pcmdout-*-1)|bit7
;		.asc "(CMDOUT",")"|bit7
pcmdout		stx n+7
	;	lda stack,x
		tax
		jsr CHKOUT
		bcc pcmdout02
pcmdout01	pha
		jsr CLRCHN
		pla
		ldx n+7
		inx
		inx
		jmp pushya
pcmdout02;	jsr READST
		and #$80
		beq pcmdin01
		lda #5
		bne pcmdout01

;--------------------------------------------------------------
;
;	CMDOFF
;
cmdofflfa	.word $adde
		.byt (cmdoff-*-1)|bit7
		.asc "CMDOF","F"|bit7
cmdoff		stx storex
		jsr CLRCHN
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	STATUS
;
statuslfa	.word $adde
		.byt (_status-*-1)|bit7
		.asc "STATU","S"|bit7
_status
#include "enter.i65"
		.word plit
		.word 144
#include "pad.i65"
		.word cfetch
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	(?DISC)
;
;pqdisclfa	.word $adde
;		.byt (_pqdisc-*-1)|bit7
;		.asc "(?DISC",")"|bit7
_pqdisc
#include "enter.i65"

;--------------------------------------------------------------
;
;	IOERR
;
ioerrlfa	.word $adde
		.byt (_ioerr-*-1)|bit7
		.asc "IOER","R"|bit7
_ioerr
#include "enter.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word ioerr09
#include "page.i65"
		.word dup
#include "page.i65"
		.word one
#include "page.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+19)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr01-*-1
		.asc	"TOO MANY OPEN FILES"
			;123456789.123456789
ioerr01
#include "page.i65"
		.word dup
#include "page.i65"
		.word two
#include "page.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+17)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr02-*-1
		.asc	"FILE ALREADY OPEN"
			;123456789.1234567
ioerr02
#include "page.i65"
		.word dup
#include "page.i65"
		.word three
#include "page.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+13)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr03-*-1
		.asc	"FILE NOT OPEN"
			;123456789.123
ioerr03
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+14)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr04-*-1
		.asc	"FILE NOT FOUND"
			;123456789.1234
ioerr04
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 5
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+18)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr05-*-1
		.asc	"DEVICE NOT PRESENT"
			;123456789.12345678
ioerr05
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+14)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr06-*-1
		.asc	"NOT INPUT FILE"
			;123456789.1234
ioerr06
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 7
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+15)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr07-*-1
		.asc	"NOT OUTPUT FILE"
			;123456789.12345
ioerr07
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+17)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr08-*-1
		.asc	"MISSING FILE NAME"
			;123456789.1234567
ioerr08
#include "page.i65"
		.word dup
#include "page.i65"
		.word clit
		.byt 9
#include "pad.i65"
		.word eq
#include "page.i65"
#if (((*&$ff)+3+21)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt ioerr09-*-1
		.asc	"ILLEGAL DEVICE NUMBER"
			;123456789.123456789.1
ioerr09		.word exit


;--------------------------------------------------------------
;
;	.DERR
;
dotderrlfa	.word $adde
		.byt (_dotderr-*-1)|bit7
		.asc ".DER","R"|bit7
_dotderr
#include "enter.i65"
		.word cmdoff
#include "page.i65"
#if (((*&$ff)+3+12)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt dotderr01-*-1
		.asc	"DISK ERROR: "
			;123456789.12
dotderr01	.word plit
		.word inbuf
#include "pad.i65"
		.word count
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	MOUNT
;
mountlfa	.word $adde
		.byt (_mount-*-1)|bit7
		.asc "MOUN","T"|bit7
_mount
#include "enter.i65"
		.word clit
		.byt 13
#include "pad.i65"
		.word close
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word close
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word popen
#include "page.i65"
		.word _ioerr
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word pcmdout
#include "page.i65"
		.word _ioerr
#include "page.i65"
#if (((*&$ff)+3+2)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt mount01-*-1
		.asc	"I1"
			;12
mount01		.word cmdoff
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word pcmdout
#include "page.i65"
		.word _ioerr
#include "page.i65"
#if (((*&$ff)+3+2)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt mount02-*-1
		.asc	"I0"
			;12
mount02		.word cmdoff
#include "page.i65"
		.word clit
		.byt 13
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word plit
		.word 10253	; ~
#include "pad.i65"
		.word one
#include "page.i65"
		.word popen
#include "page.i65"
		.word _ioerr
#include "page.i65"
		.word _qdisc
		.word exit

;--------------------------------------------------------------
;
;	?DISC
;
qdisclfa	.word $adde
		.byt (_qdisc-*-1)|bit7
		.asc "?DIS","C"|bit7
_qdisc
#include "enter.i65"
		.word _pqdisc
#include "page.i65"
		.word qbranch
		.word qdisc01
#include "pad.i65"
		.word _dotderr
#include "page.i65"
		.word _abort
qdisc01		.word exit

;--------------------------------------------------------------
;
;	'
;
; * 83 interpreter
;
ticklfa		.word $adde
		.byt (_tick-*-1)|bit7
		.asc "'"|bit7
_tick
#include "enter.i65"
		.word _existsq
#include "page.i65"
		.word zeq
#include "page.i65"
		.word _qfind
		.word exit

;--------------------------------------------------------------
;
;	[']
;
; * 83 compiler
;
brticklfa	.word $adde
		.byt (_brtick-*-1)|bit7
		.asc "['","]"|bit7
_brtick
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word _tick
#include "page.i65"
		.word _literal
		.word exit


;--------------------------------------------------------------
;
;	?>MARK
;
;qtomarklfa	.word $adde
;		.byt (_qtomark-*-1)|bit7
;		.asc "?>MAR","K"|bit7
_qtomark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word here
#include "page.i65"
		.word swap
#include "page.i65"
		.word _comma
		.word exit

;--------------------------------------------------------------
;
;	?<MARK
;
;qfrommarklfa	.word $adde
;		.byt (_qfrommark-*-1)|bit7
;		.asc "?<MAR","K"|bit7
_qfrommark
#include "enter.i65"
		.word _qcomp
#include "page.i65"
		.word here
#include "page.i65"
		.word zero
		.word exit

;--------------------------------------------------------------
;
;	?>RESOLVE
;
;qtoresolvelfa	.word $adde
;		.byt (_qtoresolve-*-1)|bit7
;		.asc "?>RESOLV","E"|bit7
_qtoresolve
#include "enter.i65"
qtoresolve01	.word qdup
#include "page.i65"
		.word qbranch
		.word qtoresolve02
#include "page.i65"
		.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word here
#include "page.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word qtoresolve01
qtoresolve02	.word exit

;--------------------------------------------------------------
;
;	?<RESOLVE
;
;qltresolvelfa	.word $adde
;		.byt (_qltresolve-*-1)|bit7
;		.asc "?<RESOLV","E"|bit7
_qltresolve
#include "enter.i65"
		.word swap
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	ADD>MARK
;
;addtomarklfa	.word $adde
;		.byt (_addtomark-*-1)|bit7
;		.asc "ADD>MAR","K"|bit7
_addtomark
#include "enter.i65"
		.word true
#include "page.i65"
		.word tor
#include "page.i65"
addtomark01	.word one
#include "page.i65"
		.word roll
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word tor
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word addtomark01
		.word drop
#include "page.i65"
		.word _qtomark
#include "page.i65"
addtomark02	.word rfrom
#include "page.i65"
		.word dup
#include "page.i65"
		.word true
#include "page.i65"
		.word eq
#include "page.i65"
		.word qbranch
		.word addtomark02
#include "page.i65"
		.word drop
		.word exit

;--------------------------------------------------------------
;
;	BEGIN
;
; * 83 compiler
;
beginlfa	.word $adde
		.byt (_begin-*-1)|bit7
		.asc "BEGI","N"|bit7
_begin
#include "enter.i65"
		.word _qfrommark
#include "page.i65"
		.word one
		.word exit

;--------------------------------------------------------------
;
;	THEN
;
; * 83 compiler
;
thenlfa		.word $adde
		.byt (_then-*-1)|bit7
		.asc "THE","N"|bit7
_then
#include "enter.i65"
		.word abs
#include "page.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word _qtoresolve
		.word exit

;--------------------------------------------------------------
;
;	DO
;
; * 83 compiler
;
dolfa		.word $adde
		.byt (_do-*-1)|bit7
		.asc "D","O"|bit7
_do
#include "enter.i65"
		.word _compile
#include "page.i65"
		.word pdo
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	?DO
;
qdolfa		.word $adde
		.byt (_qdo-*-1)|bit7
		.asc "?D","O"|bit7
_qdo
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word pqdo
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word _qfrommark
#include "page.i65"
		.word drop
#include "page.i65"
		.word swap
#include "page.i65"
		.word three
		.word exit

;--------------------------------------------------------------
;
;	LOOP
;
; * 83 compiler
;
looplfa		.word $adde
		.byt (_loop-*-1)|bit7
		.asc "LOO","P"|bit7
_loop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word ploop
#include "pad.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	+LOOP
;
; * 83 compiler
;
pluslooplfa	.word $adde
		.byt (_plusloop-*-1)|bit7
		.asc "+LOO","P"|bit7
_plusloop
#include "enter.i65"
		.word three
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word pploop
#include "pad.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	LEAVE
;
; * 83 compiler
;
leavelfa	.word $adde
		.byt (_leave-*-1)|bit7
		.asc "LEAV","E"|bit7
_leave
#include "enter.i65"
		.word _compile
		.word pleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	?LEAVE
;
qleavelfa	.word $adde
		.byt (_qleave-*-1)|bit7
		.asc "?LEAV","E"|bit7
_qleave
#include "enter.i65"
		.word _compile
		.word pqleave
#include "page.i65"
		.word three
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	UNTIL
;
; * 83 compiler
;
untillfa	.word $adde
		.byt (_until-*-1)|bit7
		.asc "UNTI","L"|bit7
_until
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word qbranch
#include "page.i65"
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	AGAIN
;
againlfa	.word $adde
		.byt (_again-*-1)|bit7
		.asc "AGAI","N"|bit7
_again
#include "enter.i65"
		.word one
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word _qltresolve
		.word exit

;--------------------------------------------------------------
;
;	REPEAT
;
; * 83 compiler
;
repeatlfa	.word $adde
		.byt (_repeat-*-1)|bit7
		.asc "REPEA","T"|bit7
_repeat
#include "enter.i65"
		.word _again
		.word exit

;--------------------------------------------------------------
;
;	IF
;
; * 83 compiler
;
iflfa		.word $adde
		.byt (_if-*-1)|bit7
		.asc "I","F"|bit7
_if
#include "enter.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word _compile
		.word qbranch
		.word _qtomark
#include "page.i65"
		.word two
		.word exit

;--------------------------------------------------------------
;
;	ELSE
;
; * 83 compiler
;
elselfa		.word $adde
		.byt (_else-*-1)|bit7
		.asc "ELS","E"|bit7
_else
#include "enter.i65"
		.word two
#include "page.i65"
		.word _qpairs
#include "page.i65"
		.word _compile
		.word branch
		.word swap
#include "page.i65"
		.word _qtomark
#include "page.i65"
		.word swap
#include "page.i65"
		.word _qtoresolve
#include "page.i65"
		.word zero
#include "page.i65"
		.word plit
		.word -2
#include "pad.i65"
		.word exit

;--------------------------------------------------------------
;
;	WHILE
;
; * 83 compiler
;
whilelfa	.word $adde
		.byt (_while-*-1)|bit7
		.asc "WHIL","E"|bit7
_while
#include "enter.i65"
		.word _compile
		.word qbranch
		.word one
#include "page.i65"
		.word _addtomark
		.word exit

;--------------------------------------------------------------
;
;	SPACES
;
; * 83 device
;
spaceslfa	.word $adde
		.byt (_spaces-*-1)|bit7
		.asc "SPACE","S"|bit7
_spaces
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _max
#include "page.i65"
		.word zero
#include "page.i65"
		.word pqdo
		.word spaces02
spaces01	.word _space
#include "page.i65"
		.word ploop
		.word spaces01
spaces02	.word exit

;--------------------------------------------------------------
;
;	<#
;
; * 83 interpreter
;
ltsharplfa	.word $adde
		.byt (_ltsharp-*-1)|bit7
		.asc "<","#"|bit7
_ltsharp
#include "enter.i65"
		.word _pad
#include "page.i65"
		.word hld
#include "page.i65"
		.word store
		.word exit

;--------------------------------------------------------------
;
;	#>
;
; * 83 interpreter
;
sharpgtlfa	.word $adde
		.byt (_sharpgt-*-1)|bit7
		.asc "#",">"|bit7
_sharpgt
#include "enter.i65"
		.word twodrop
#include "page.i65"
		.word hld
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _pad
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
		.word exit

;--------------------------------------------------------------
;
;	SIGN
;
; * 83 interpreter
;
signlfa		.word $adde
		.byt (_sign-*-1)|bit7
		.asc "SIG","N"|bit7
_sign
#include "enter.i65"
		.word zlt
#include "page.i65"
		.word qbranch
		.word *+7
		.word clit
		.byt '-'
#include "pad.i65"
		.word _hold
		.word exit

;--------------------------------------------------------------
;
;	#
;
; * 83 interpreter
;
sharplfa	.word $adde
		.byt (_sharp-*-1)|bit7
		.asc "#"|bit7
_sharp
#include "enter.i65"
		.word base
#include "page.i65"
		.word fetch
#include "page.i65"
		.word mslashmod
#include "page.i65"
		.word rot
#include "page.i65"
		.word clit
		.byt 9
#include "pad.i65"
		.word over
#include "page.i65"
		.word lt
#include "page.i65"
		.word qbranch
		.word sharp01
		.word clit
		.byt 7
#include "pad.i65"
		.word plus
#include "page.i65"
sharp01		.word clit
		.byt '0'
#include "pad.i65"
		.word plus
#include "page.i65"
		.word _hold
		.word exit

;--------------------------------------------------------------
;
;	#S
;
; * 83 interpreter
;
sharpslfa	.word $adde
		.byt (_sharps-*-1)|bit7
		.asc "#","S"|bit7
_sharps
#include "enter.i65"
		.word _sharp
#include "page.i65"
		.word _twodup
#include "page.i65"
		.word orx
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word *-10
		.word exit

;--------------------------------------------------------------
;
;	(U.)
;
;pudotlfa	.word $adde
;		.byt (_pudot-*-1)|bit7
;		.asc "(U.",")"|bit7
_pudot
#include "enter.i65"
		.word zero
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	U.
;
; * 83 interpreter
;
udotlfa		.word $adde
		.byt (_udot-*-1)|bit7
		.asc "U","."|bit7
_udot
#include "enter.i65"
		.word _pudot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	U.R
;
udotrlfa	.word $adde
		.byt (_udotr-*-1)|bit7
		.asc "U.","R"|bit7
_udotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pudot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(.)
;
;pdotlfa		.word $adde
;		.byt (_pdot-*-1)|bit7
;		.asc "(.",")"|bit7
_pdot
#include "enter.i65"
		.word dup
#include "page.i65"
		.word abs
#include "page.i65"
		.word zero
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word rot
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	.
;
; * 83 interpreter
;
dotlfa		.word $adde
		.byt (_dot-*-1)|bit7
		.asc "."|bit7
_dot
#include "enter.i65"
		.word _pdot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	.R
;
dotrlfa		.word $adde
		.byt (_dotr-*-1)|bit7
		.asc ".","R"|bit7
_dotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pdot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(UD.)
;
;puddotlfa	.word $adde
;		.byt (_puddot-*-1)|bit7
;		.asc "(UD.",")"|bit7
_puddot
#include "enter.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	UD.
;
uddotlfa	.word $adde
		.byt (_uddot-*-1)|bit7
		.asc "UD","."|bit7
_uddot
#include "enter.i65"
		.word _puddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	UD.R
;
uddotrlfa	.word $adde
		.byt (_uddotr-*-1)|bit7
		.asc "UD.","R"|bit7
_uddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _puddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	(D.)
;
;pdddotlfa	.word $adde
;		.byt (_pddot-*-1)|bit7
;		.asc "(D.",")"|bit7
_pddot
#include "enter.i65"
		.word dup
#include "page.i65"
		.word tor
#include "page.i65"
		.word dabs
#include "page.i65"
		.word _ltsharp
#include "page.i65"
		.word _sharps
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word _sign
#include "page.i65"
		.word _sharpgt
		.word exit

;--------------------------------------------------------------
;
;	D.
;
ddotlfa		.word $adde
		.byt (_ddot-*-1)|bit7
		.asc "D","."|bit7
_ddot
#include "enter.i65"
		.word _pddot
#include "page.i65"
		.word type
#include "page.i65"
		.word _space
		.word exit

;--------------------------------------------------------------
;
;	D.R
;
ddotrlfa	.word $adde
		.byt (_ddotr-*-1)|bit7
		.asc "D.","R"|bit7
_ddotr
#include "enter.i65"
		.word tor
#include "page.i65"
		.word _pddot
#include "page.i65"
		.word rfrom
#include "page.i65"
		.word over
#include "page.i65"
		.word minus
#include "page.i65"
		.word _spaces
#include "page.i65"
		.word type
		.word exit

;--------------------------------------------------------------
;
;	?
;
questionlfa	.word $adde
		.byt (_question-*-1)|bit7
		.asc "?"|bit7
_question
#include "enter.i65"
		.word fetch
#include "page.i65"
		.word _dot
		.word exit

;--------------------------------------------------------------
;
;	PICK   ( an ... a3 a2 a1 n -- an ... a3 a2 a1 an )
;
; * 83 nucleus
;
; 0 pick = same as dup
; 1 pick = same as over
picklfa		.word $adde
		.byt (pick-*-1)|bit7
		.asc "PIC","K"|bit7
pick		stx storex
		ldx tos
		lda stackl,x
		sta tos
		lda stackh,x
		sta tos+1
		ldx storex
		jmp next

;--------------------------------------------------------------
;
;	ROLL   ( an ... a3 a2 a1 n -- an-1 ... a3 a2 a1 an )
;
; * 83 nucleus
;
; remove the nth stack element (excluding n itself) to TOS, dropping n
;
; 2 roll = rot
; 1 roll = swap
; 0 roll has no effect
;
rolllfa		.word $adde
		.byt (roll-*-1)|bit7
		.asc "ROL","L"|bit7
roll		stx n
		txa
		clc
		adc tos
		tax
		lda stackh,x
		sta tos+1
		lda stackl,x
		sta tos
roll01		cpx n
		beq roll02
		lda stackh+$ff,x
		sta stackh,x
		lda stackl+$ff,x	; ~ probably not work!
		sta stackl,x
		dex
		bne roll01
roll02		inx
		jmp next

;--------------------------------------------------------------
;
;	DEPTH
;
; * 83 nucleus
;
depthlfa	.word $adde
		.byt (depth-*-1)|bit7
		.asc "DEPT","H"|bit7
depth		stx n
		lda #<bos
		sec
		sbc n
		ldy #0
		jmp pushya

;--------------------------------------------------------------
;
;	2DROP
;
twodroplfa	.word $adde
		.byt (twodrop-*-1)|bit7
		.asc "2DRO","P"|bit7
twodrop		jmp poptwo

;--------------------------------------------------------------
;
;	2DUP   ( n1 n2 -- n1 n2 n1 n2 )
;
twoduplfa	.word $adde
		.byt (_twodup-*-1)|bit7
		.asc "2DU","P"|bit7
_twodup
#include "enter.i65"
		.word over
#include "page.i65"
		.word over
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	2OVER   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
;
twooverlfa	.word $adde
		.byt (twoover-*-1)|bit7
		.asc "2OVE","R"|bit7
twoover		dex
		dex
		lda tos+1
		sta stackh+2,x
		lda tos
		sta stackl+2,x
		lda stackh+4,x
		sta stackh+1,x
		lda stackl+4,x
		sta stackl+1,x
		lda stackh+3,x
		sta tos+1
		lda stackl+3,x
		sta tos
		jmp next

;--------------------------------------------------------------
;
;	2ROT   ( lo3 hi3 lo2 hi2 lo1 hi1 -- lo2 hi2 lo1 hi1 lo3 hi3 )
;
; hi1 is stored in TOS, the rest in stackl/stackh ... stack+4
tworotlfa	.word $adde
		.byt (tworot-*-1)|bit7
		.asc "2RO","T"|bit7
tworot		ldy stackh+4,x
		lda stackh+2,x
		sta stackh+4,x
		lda stackh,x
		sta stackh+2,x
		sty stackh,x
		ldy stackl+4,x
		lda stackl+2,x
		sta stackl+4,x
		lda stackl,x
		sta stackl+2,x
		sty stackl,x		; done moving lo words
		ldy stackh+3,x
		lda stackh+1,x
		sta stackh+3,x
		lda tos+1
		sta stackh+1,x
		sty tos+1
		ldy stackl+3,x
		lda stackl+1,x
		sta stackl+3,x
		lda tos
		sta stackl+1,x
		sty tos			; done moving hi words
		jmp next

;--------------------------------------------------------------
;
;	2SWAP   ( hi2 lo2 hi1 lo1 -- hi1 lo1 hi2 lo2 )
;
twoswaplfa	.word $adde
		.byt (twoswap-*-1)|bit7
		.asc "2SWA","P"|bit7
twoswap		ldy tos+1
		lda stackh+1,x
		sta tos+1
		sty stackh+1,x
		ldy tos
		lda stackl+1,x
		sta tos
		sty stackl+1,x
		ldy stackh,x
		lda stackh+2,x
		sta stackh,x
		sty stackh+2,x
		ldy stackl,x
		lda stackl+2,x
		sta stackl,x
		sty stackl+2,x
		jmp next

;--------------------------------------------------------------
;
;	2!   ( hi lo addr -- )
;
twostorelfa	.word $adde
		.byt (twostore-*-1)|bit7
		.asc "2","!"|bit7
twostore	ldy #0
twostore01	lda stackh,x
		sta (tos),y
		iny
		lda stackl,x
		sta (tos),y
		iny
		inx
		cpy #4
		bne twostore01
		jmp pops

;--------------------------------------------------------------
;
;	2@   ( addr -- hi lo )
;
twofetchlfa	.word $adde
		.byt (twofetch-*-1)|bit7
		.asc "2","@"|bit7
twofetch	ldy #3
		dex
		lda (tos),y
		sta stackh,x
		dey
		lda (tos),y
		sta stackl,x
		dey
		lda (tos),y
		sta n
		dey
		lda (tos),y
		ldy n
		jmp put

;--------------------------------------------------------------
;
;	2CONSTANT
;
twoconstlfa	.word $adde
		.byt (_twoconst-*-1)|bit7
		.asc "2CONSTAN","T"|bit7
_twoconst
#include "enter.i65"
		.word _create
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _comma
#include "page.i65"
		.word _psemi
		jsr dodoes
#include "page.i65"
		.word twofetch
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	2VARIABLE
;
twovariablelfa	.word $adde
		.byt (_twovariable-*-1)|bit7
		.asc "2VARIABL","E"|bit7
_twovariable
#include "enter.i65"
		.word _create
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word _allot
		.word exit

;--------------------------------------------------------------
;
;	D-
;
dminuslfa	.word $adde
		.byt (dminus-*-1)|bit7
		.asc "D","-"|bit7
dminus	;	jsr dnegate
		jmp dplus+2

;--------------------------------------------------------------
;
;	D0=   ( hi lo -- flag )
;
dzeqlfa		.word $adde
		.byt (dzeq-*-1)|bit7
		.asc "D0","="|bit7
dzeq		ldy #0
		lda tos
		ora tos+1
		ora stackl,x
		ora stackh,x
		bne *+3
		dey
		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	D=   ( hi2 lo2 hi1 lo1 -- flag )
;
deqlfa		.word $adde
		.byt (deq-*-1)|bit7
		.asc "D","="|bit7
deq		ldy #0
		lda tos
		eor stackl+1,x
		bne deq01
		lda tos+1
		eor stackh+1,x
		bne deq01
		lda stackl,x
		eor stackl+2,x
		bne deq01
		lda stackh,x
		eor stackh+2,x
		bne deq01
		dey
deq01		inx
		inx
		inx
		tya
		jmp put

;--------------------------------------------------------------
;
;	DU<
;
dultlfa		.word $adde
		.byt (dult-*-1)|bit7
		.asc "DU","<"|bit7
dult		jsr dcmp
		bcs dult01
		dey
dult01	;	sty stack+6,x
	;	sty stack+7,x
		inx
		inx
		jmp poptwo

;--------------------------------------------------------------
;
;	D2/   ( hi lo -- hi/2 lo/2 )
;
dtwoslashlfa	.word $adde
		.byt (dtwoslash-*-1)|bit7
		.asc "D2","/"|bit7
dtwoslash	lsr stackh,x
		ror stackl,x
		ror tos+1
		ror tos
		jmp next

;--------------------------------------------------------------
;
;	D2*   ( hi lo -- hi*2 lo*2 )
;
dtwostarlfa	.word $adde
		.byt (dtwostar-*-1)|bit7
		.asc "D2","*"|bit7
dtwostar	asl stackl,x
		rol stackh,x
		rol tos
		rol tos+1
		jmp next

;--------------------------------------------------------------
;
;	D>
;
dgtlfa		.word $adde
		.byt (_dgt-*-1)|bit7
		.asc "D",">"|bit7
_dgt
#include "enter.i65"
		.word twoswap
#include "page.i65"
		.word dlt
		.word exit

;--------------------------------------------------------------
;
;	DMIN
;
dminlfa		.word $adde
		.byt (_dmin-*-1)|bit7
		.asc "DMI","N"|bit7
_dmin
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word _dgt
#include "page.i65"
		.word qbranch
		.word *+4
#include "page.i65"
		.word twoswap
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	DMAX
;
dmaxlfa		.word $adde
		.byt (_dmax-*-1)|bit7
		.asc "DMA","X"|bit7
_dmax
#include "enter.i65"
		.word twoover
#include "page.i65"
		.word twoover
#include "page.i65"
		.word dlt
#include "page.i65"
		.word qbranch
		.word *+4
#include "pad.i65"
		.word twoswap
#include "page.i65"
		.word twodrop
		.word exit

;--------------------------------------------------------------
;
;	CONFIGURE
;
configurelfa	.word $adde
		.byt (_configure-*-1)|bit7
		.asc "CONFIGUR","E"|bit7
_configure
#include "enter.i65"
		.word limit
#include "page.i65"
		.word bperbuf
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word star
#include "page.i65"
		.word minus
#include "page.i65"
		.word plit
		.word $fee		; ~
#include "pad.i65"
		.word store
#include "page.i65"
		.word numbuf
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 6
#include "pad.i65"
		.word star
#include "page.i65"
		.word twoplus
#include "page.i65"
		.word plit
		.word $1010		; ~
#include "pad.i65"
		.word store
		.word cold

;--------------------------------------------------------------
;
;	FREEZE
;
; ~ what does this do?
freezelfa	.word $adde
		.byt (_freeze-*-1)|bit7
		.asc "FREEZ","E"|bit7
_freeze
#include "enter.i65"
		.word plit
		.word forth+3
#include "pad.i65"
		.word fetch
#include "page.i65"
		.word clit
		.byt 4
#include "pad.i65"
		.word _plusorigin
#include "page.i65"
		.word store
#include "page.i65"
		.word width
#include "page.i65"
		.word clit
		.byt 12
#include "pad.i65"
		.word _plusorigin
#include "page.i65"
		.word clit
		.byt 12
#include "pad.i65"
		.word cmove
		.word exit

;--------------------------------------------------------------
;
;	(BSAVE)
;
;pbsavelfa	.word $adde
;		.byt (pbsave-*-1)|bit7
;		.asc "(BSAVE",")"|bit7
pbsave		ldy #3
		jsr setup
		stx tos
		lda #<basic+1
		ldx #>basic+1
		tay
		;jsr SETLFS
		lda n
		ldx n+2
		ldy n+3
		;jsr SETNAM
		ldx n+4
		ldy n+5
		lda #$82
		jsr SAVE
		ldx tos
		jmp next

;--------------------------------------------------------------
;
;	SAVE-FORTH
;
saveforthlfa	.word $adde
		.byt (_saveforth-*-1)|bit7
		.asc "SAVE-FORT","H"|bit7
_saveforth
#include "enter.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word _freeze
#include "page.i65"
		.word cr
#if (((*&$ff)+3+10)=$ff)
	.word next
	.word next
#endif
		.word _pdotq
		.byt saveforth01-*-1
		.asc	"FILENAME? "
			;123456789.
saveforth01	.word _pad
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word clit
		.byt 18
#include "pad.i65"
		.word expect
#include "page.i65"
		.word span
#include "page.i65"
		.word fetch
#include "page.i65"
		.word _pad
#include "page.i65"
		.word cstore
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word clit
		.byt 8
#include "pad.i65"
		.word over
#include "page.i65"
		.word zero
#include "page.i65"
		.word zero
#include "page.i65"
		.word popen
#include "page.i65"
		.word drop
#include "page.i65"
		.word plit
		.word basic+1
#include "pad.i65"
		.word here
#include "page.i65"
		.word oneplus
#include "page.i65"
		.word _pad
#include "page.i65"
		.word count
#include "page.i65"
		.word pbsave
#include "page.i65"
		.word _qdisc
#include "page.i65"
		.word clit
		.byt 15
#include "pad.i65"
		.word close
		.word exit

;--------------------------------------------------------------
;
;	BRINGOUTYERDEAD   ( addr -- deadlfa|0 )
;
; scans forward in memory returning the address of the next $DE $AD
; in memory that is followed by a name
;" http://www.youtube.com/watch?v=grbSQ6O6kbs
;
; sweet16 saved 37 bytes vs. 6502
boydlfa		.word $adde
		.byt (boyd-*-1)|bit7
		.asc "BRINGOUTYERDEA","D"|bit7
boyd		brk
		.byt set  | R10
		.word $de
		.byt set  | R11
		.word $adde
		.byt set  | N0
		.word userdp-userarea
		.byt ld   | UP
		.byt add  | N0
		.byt st   | N0
		.byt ldd  | N0
		.byt st   | N0		; here
		.byt ldd  | N0
		.byt popd | N0		; restore N0
		.byt st   | N1
		.byt ld   | R11
		.byt std  | N0		; here+2 -> N0
		.byt rtn
boyd01		brk
		.byt ldi  | TOS
		.byt cpr  | R10
		.byt bnz, <(boyd01-*-1)
		.byt dcr  | TOS
		.byt ldd  | TOS
		.byt cpr  | R11
		.byt bz,  <(boyd02-*-2)
		.byt dcr  | TOS
		.byt br,  <(boyd01-*-1)
boyd02		.byt ld   | TOS
		.byt cpr  | N0		; TOS=here+2?
		.byt bnz, <(boyd03-*-2)
		.byt sub  | ACC
		.byt st   | TOS
		.byt br,  <(boyd06-*-2)
boyd03		.byt rtn		; TOS points to probable NFA
		ldy #0
		lda (tos),y
		bpl boyd01		; NFA length must be negative
		and #$1f
		tay
		lda (tos),y
		bpl boyd01		; last NFA byte must be negative
boyd04		dey
		beq boyd05
		lda (tos),y
		bpl boyd04
		bmi boyd01		; middle NFA bytes must be positive
boyd05		brk
		.byt popd | TOS		; point at the LFA
boyd06		.byt popd | N0		; back up the pointer
		.byt ld   | N1
		.byt std  | N0		; restore previous contents of here
		.byt rtn
		jmp next

;--------------------------------------------------------------
;
;	DHASH	( nfa -- hash1 hash2 )
;
; input is NFA or address of a counted string. Output is two hashcodes
;
;dhashlfa	.word $adde
;		.byt (dhash-*-1)|bit7
;		.asc "DHAS","H"|bit7
dhash		stx storex
		ldy #0
		lda (tos),y
		and #$3f		; turn off 7 and 6, not 5 (smudge)
		sta n			; seed hash1 with length
		sty n+1			; seed hash2 with 0
		tay
		iny		;	hash2	hash1
dhash01		dey				;[2]
		beq dhash02			;[2]
		lda (tos),y			;[5]
		sec				;[2]
		sbc #$20			;[2]
		and #(power2-pearson-1)		;[2]
		tax				;[2]
		lda n				;[3]
		eor pearson,x			;[4]
		sta n				;[3]
		lda (tos),y		;[5]
		and #$7f		;[2]
		clc			;[2]
		adc #$FF-('9')		;[2]
		adc #'9'-'0'+1		;[2]
		bcc dhash01			;[3]  [12]hash2 [27]hash1	
		adc n+1			; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
		sta n+1			; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1 
		jmp dhash01		; 2drop 2dup 2over 2rot 2swap 2! 2@
					; 2constant 2variable d0= d2/ d2* 
dhash02		lda n
		lsr
		lsr
		lsr
		lsr			; - - - - [ 7 6 5 4 ]
		eor n			; 7 6 5 4 [ 3 2 1 0 ]
		and #$0f		; - - - - [4bit hash]
		;jsr debug
		sta tos
		sty tos+1
		lda n+1		; sum of all digits 0..9	
		ldx storex
		jmp pushya

;~debug hex dump the byte in A
debug	pha
	pha
	and #$0f
	jsr print
	pla
	lsr
	lsr
	lsr
	lsr
	;jsr print
	pla
dbout	rts
print	sed
	cmp #10
	adc #'0'
	cld
	jmp CHROUT

;--------------------------------------------------------------
;
;	DHASH@   ( hashkey -- LFA )
;
; retrieve the head of this hash thread
;
;dhashfetchlfa	.word $adde
;		.byt (dhashfetch-*-1)|bit7
;		.asc "DHASH","@"|bit7
dhashfetch	brk
		.byt set  | ACC
		.word lfalist
		.byt add  | TOS
		.byt add  | TOS
		.byt st   | TOS
		.byt ldd  | TOS
		.byt st   | TOS
		.byt rtn
		jmp next


;--------------------------------------------------------------
;
;	BLOOM!   ( hash -- )
;
; set the bit in the dictionary's bloom filter
;
; hash is an 8-bit hash code indexing a 256-bit bitfield
;bloomstorelfa	.word $adde
;		.byt (bloomstore-*-1)|bit7
;		.asc "BLOOM","!"|bit7
bloomstore	lda tos			; set bloom filter bit for hash2
		and #7
		tay
		lda power2,y
		sta n
		lda tos
		lsr
		lsr
		lsr
		and #(bloom2x-bloom2-1)	; don't write outside filter area
		tay
		lda n
		ora bloom2,y
		sta bloom2,y
		jmp pops

;--------------------------------------------------------------
;
;	BLOOM@   ( hash -- flag )
;
; test a bit in the filter
; hash indexes a single bit in the bloom2 filter
; false = it can't be in there (bit was clear)
; true = it might be in there (bit was set)
;bloomfetchlfa	.word $adde
;		.byt (bloomfetch-*-1)|bit7
;		.asc "BLOOM","@"|bit7
bloomfetch	lda tos			; read bloom filter bit for hash2
		and #7
		tay
		lda power2,y
		sta n
		lda tos
		lsr
		lsr
		lsr
		and #(bloom2x-bloom2-1)	; don't read outside filter area
		tay
		lda bloom2,y
		ldy #0
		and n
		beq bloomfetch01
		dey
bloomfetch01	tya
		jmp put

;--------------------------------------------------------------
;
;	DHASH!   ( LFAnew hash1 -- )
;
; links the current LFA onto the top of this hash' thread
;
; When we're done, the word whose LFAnew is on the stack will become
; the new top of this hash thread, and the new word's LFA will link
; to the previous top of the chain.
;
; sweet16 saved 51 bytes vs. 6502
;dhashstorelfa	.word $adde
;		.byt (dhashstore-*-1)|bit7
;		.asc "DHASH","!"|bit7
dhashstore	ldy #1
		jsr setup		; LFAnew -> N0
		brk
		.byt set  | R11
		.word lfalist
		.byt sub  | ACC
		.byt st   | N2		; 0 -> N2
		.byt ld   | R11
		.byt add  | TOS
		.byt add  | TOS
		.byt st   | R11		; R11+hash1*2 -> R11
		.byt ldd  | R11
		.byt popd | R11		; back up the pointer
		.byt bnz, <(dhashstore01-*-2)
		.byt set  | ACC
		.word rootlfa
		.byt std  | R11
		.byt popd | R11
dhashstore01	.byt st   | N1		; head -> N1
		.byt rtn
		ldy #2
		lda (n),y
		and #$1f
		sta n+7			; length of name being inserted
dhashstore02	lda (n+2),y
		and #$1f
		sta n+6
		lda n+7
		cmp n+6			; compare lengths
		bcc dhashstore05
		bne dhashstore04
		;sec
		adc #1
		tay			; last char in names
dhashstore03	lda (n),y
		eor (n+2),y
		asl			; compare char ignoring bit7
		bne dhashstore04
		dey
		cpy #2
		bne dhashstore03	; stop at first char
		dey
		brk
		.byt set  | ACC
		.word $adde
		.byt std  | N1
		.byt rtn
dhashstore04	brk
		.byt ld   | N1
		.byt st   | N2		; keep track of where we've just been
		.byt ldd  | N1
		.byt st   | N1		; (N1) -> N1
		.byt rtn
		ldy #2
		bne dhashstore02
dhashstore05	brk
		.byt ld   | N2
		.byt bnz, <(dhashstore06-*-2)
		.byt ld   | R11		; empty list, insert at the head
		.byt st   | N2		; head -> N2
dhashstore06	.byt ld   | N0
		.byt std  | N2		; N0 -> (N2)
		.byt ld   | N1
		.byt std  | N0		; N1 -> (N0)
		.byt rtn
		jmp pops		; toss the hash

;--------------------------------------------------------------
;
;	RETHREAD   ( -- )
;
; When the system is first loaded, all LFAs contain $DE $AD.
; The reason for this is twofold.  PETTIL uses a hash-threaded
; dictionary, and calculating the hash values and link fields
; by hand would be an extremely cumbersome activity for the programmer.
; More importantly, FORGET might wipe away words that are linked in
; this fashion and break the link chains.  So when FORGET is invoked,
; first it performs UNTHREAD (to mark all LFAs as DEAD) then it moves
; the dictionary pointer (DP) to where it belongs, then it does RETHREAD
;
; This word builds the LFA field in every word up to this point.
; It also marks the last word in the core dictionary.
; links all LFAs
;" : rethread   ( -- )
;	lfalist 40 erase
;	0 +origin
;	begin	bringoutyerdead
;		?dup
;	while	dup dup 2+
;		dhash
;		bloom!
;		dhash!
;	until ;
;
;rethreadlfa	.word $adde
;		.byt (_rethread-*-1)|bit7
;		.asc "RETHREA","D"|bit7
_rethread
#include "enterx.i65"
		.word plit
		.word lfalist
#include "pad.i65"
		.word clit
		.byt <(bloom2x-lfalist)		; clear list head
#include "pad.i65"
		.word _erase
#include "page.i65"
		.word zero
#include "page.i65"
		.word _plusorigin
#include "page.i65"
rethread01	.word boyd		; begin boyd ?dup while ... repeat
#include "page.i65"
		.word qdup
#include "page.i65"
		.word qbranch
		.word rethread02
#include "page.i65"
		.word dup		; ( lfa lfa )
#include "page.i65"
		.word dup		; ( lfa lfa lfa )
#include "page.i65"
		.word twoplus		; ( lfa lfa nfa )
#include "page.i65"
		.word dhash		; ( lfa lfa hash1 hash23 )
#include "page.i65"
		.word bloomstore	; ( lfa lfa hash1 )
#include "page.i65"
		.word dhashstore	; ( lfa )
#include "page.i65"
		.word branch
		.word rethread01
#include "pad.i65"
rethread02	.word exit

;--------------------------------------------------------------
;
;	UNTHREAD   ( -- )
;
; iterate through all LFAs and reset them to $DEAD
;
;" : unthread
;	16 0 do				( )
;		i dhash@		( lfa1 )
;		begin
;			dup		( lfa1 lfa1 )
;			@		( lfa1 lfa2 )
;			?dup		( lfa1 lfa2 true | lfa1 false )
;		while			( lfa1 lfa2 )
;			$dead		( lfa1 lfa2 $dead )
;			rot		( lfa2 $dead lfa1 )
;~ dup 2- ( nfa ) dup c@ ( nfa len ) $80 or ( nfa len ) swap c! ( )
;			!		( lfa2 )
;		repeat
;					( lfa )
;		drop			( )
;	loop
;
;unthreadlfa	.word $adde
;		.byt (_unthread-*-1)|bit7
;		.asc "UNTHREA","D"|bit7
_unthread
#include "enter.i65"
		.word clit
		.byt 16
#include "pad.i65"
		.word zero
#include "page.i65"
		.word pdo
#include "page.i65"
unthread01	.word i
#include "page.i65"
		.word dhashfetch
#include "page.i65"
unthread02	.word dup
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qbranch
		.word unthread03
#include "pad.i65"
		.word plit
		.word $adde
#include "pad.i65"
		.word rot
#include "page.i65"
		.word store
#include "page.i65"
		.word branch
		.word unthread02
#include "page.i65"
unthread03	.word drop
#include "page.i65"
		.word zero
#include "page.i65"
		.word i
#include "page.i65"
		.word dhashstore
#include "page.i65"
		.word ploop
		.word unthread01
#include "page.i65"
		.word exit

;--------------------------------------------------------------
;
;	FORGET
;
; * 83 interpreter
;
; unthread, move DP, then rethread
; don't forget to rechain vocabularies!
forgetlfa	.word $adde
ntop		.byt (_forget-*-1)|bit7
		.asc "FORGE","T"|bit7
_forget
#include "enter.i65"
		.word _tick
#include "page.i65"
		.word _toname
		.word dup
#include "page.i65"
		.word fence
#include "page.i65"
		.word fetch
#include "page.i65"
		.word ult
#if (((*&$ff)+3+23)=$ff)
	.word next
	.word next
#endif
		.word _pabortq
		.byt forget01-*-1
		.asc	"IN PROTECTED DICTIONARY"
			;123456789.123456789.123
forget01	.word tor
#include "page.i65"
		.word voclink
#include "page.i65"
		.word fetch
#include "page.i65"
forget02	.word rfetch
#include "page.i65"
		.word over
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word forget03
#include "page.i65"
		.word forth
#include "page.i65"
		.word _definitions
#include "page.i65"
		.word fetch
#include "page.i65"
		.word branch
		.word forget02
#include "page.i65"
forget03	.word dup
#include "page.i65"
		.word voclink
#include "page.i65"
		.word store
#include "page.i65"
forget04	.word dup
#include "page.i65"
		.word twominus
#include "page.i65"
forget05	.word _ntolink
#include "page.i65"
		.word fetch
#include "page.i65"
		.word dup
#include "page.i65"
		.word rfetch
#include "page.i65"
		.word ult
#include "page.i65"
		.word qbranch
		.word forget05
#include "pad.i65"
		.word over
#include "page.i65"
		.word twominus
#include "page.i65"
		.word twominus
#include "page.i65"
		.word store
#include "page.i65"
		.word fetch
#include "page.i65"
		.word qdup
#include "page.i65"
		.word zeq
#include "page.i65"
		.word qbranch
		.word forget04
#include "pad.i65"
		.word rfrom
#include "page.i65"
		.word dp
#include "page.i65"
		.word store
		.word exit

forgetfence

;==============================================================

;--------------------------------------------------------------
;
;	THRU
;
thrulfa		.word $adde
		.byt (_thru-*-1)|bit7
		.asc "THR","U"|bit7
_thru
#include "enter.i65"
		.word oneplus
#include "page.i65"
		.word swap
#include "page.i65"
		.word pdo
#include "page.i65"
thru01		.word i
#include "page.i65"
		.word _udot
#include "page.i65"
		.word i
#include "page.i65"
		.word _load
#include "page.i65"
		.word qterminal
#include "page.i65"
		.word pqleave
		.word thru02
#include "pad.i65"
		.word ploop
		.word thru01
#include "pad.i65"
thru02		.word exit

;foolfa		.word $adde
;		.byt (_foo-*-1)|bit7
;		.asc "FO","O"|bit7
_foo
#include "enterx.i65"
		.word exit
;barlfa		.word $adde
;		.byt (_bar-*-1)|bit7
;		.asc "BA","R"|bit7
_bar
#include "enterx.i65"
		.word exit

endofile

; words that use psemi
;"	:		jsr	enter
;	constant	jsr	doconst
;	user		jsr	uservar
;	does>		jsr	dodoes
;	create		jsr	docreate
;	vocabulary	jsr	vocabdoes
;
; words that might page
; 	page
;	plit
;	clit
;	branch
;	pdotq
;
; from the forth-83 standards doc
;"http://forth.sourceforge.net/standard/fst83/FORTH-83.PRN
;
;	Nucleus layer
;
;		!  *  */  */MOD  +  +!  -  /  /MOD  0<  0=  0>  1+  1-  2+
;		2-  2/  <  =  >  >R  ?DUP  @  ABS  AND  C!  C@  CMOVE
;		CMOVE>  COUNT  D+  D<  DEPTH  DNEGATE  DROP  DUP  EXECUTE
;		EXIT  FILL  I  J  MAX  MIN  MOD  NEGATE  NOT  OR  OVER  PICK
;		R>  R@  ROLL  ROT  SWAP  U<  UM*  UM/MOD  XOR
;
;
;	Device layer
;
;		BLOCK  BUFFER  CR  EMIT  EXPECT  FLUSH  KEY  SAVE-BUFFERS
;		SPACE  SPACES  TYPE  UPDATE
;
;
;	Interpreter layer
;
;		#  #>  #S  #TIB  '  (  -TRAILING  .  .(  <#  >BODY  >IN
;		ABORT  BASE  BLK  CONVERT  DECIMAL  DEFINITIONS  FIND
;		FORGET  FORTH  FORTH-83  HERE  HOLD  LOAD  PAD  QUIT  SIGN
;		SPAN  TIB  U.  WORD
;
;
;	Compiler layer
;
;"		+LOOP  ,  ."  :  ;  ABORT"  ALLOT  BEGIN  COMPILE  CONSTANT
;		CREATE  DO  DOES>  ELSE  IF  IMMEDIATE  LEAVE  LITERAL  LOOP
;		REPEAT  STATE  THEN  UNTIL  VARIABLE  VOCABULARY  WHILE  [
;		[']  [COMPILE]  ]
; The fig-Forth, F79, F83, and ANS standards have quite a
; variance of words.  There are 229
; defined words for fig-FORTH, 236 defined words for F79, and 255 defined
; words for F83.
